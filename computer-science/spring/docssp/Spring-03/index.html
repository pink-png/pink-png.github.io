<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="死肥宅" href="https://pink-png.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="死肥宅" href="https://pink-png.github.io/atom.xml"><link rel="alternate" type="application/json" title="死肥宅" href="https://pink-png.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="Spring"><link rel="canonical" href="https://pink-png.github.io/computer-science/spring/docssp/Spring-03/"><title>Step.3 - Spring基础 - Spring - 计算机科学 | Yume Shoka = 死肥宅 = 肥宅快乐水</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">Step.3</h1><div class="meta"><span class="item" title="创建时间：2020-03-13 09:30:48"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2020-03-13T09:30:48+08:00">2020-03-13</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Yume Shoka</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://cdn.cdnjson.com/tva4.sinaimg.cn/large/6833939bly1giciusoyjnj219g0u0x56.jpg"></li><li class="item" data-background-image="https://cdn.cdnjson.com/tva4.sinaimg.cn/large/6833939bly1giclg5ms2rj20zk0m8u0x.jpg"></li><li class="item" data-background-image="https://cdn.cdnjson.com/tva4.sinaimg.cn/large/6833939bly1gicit31ffoj20zk0m8naf.jpg"></li><li class="item" data-background-image="https://cdn.cdnjson.com/tva4.sinaimg.cn/large/6833939bly1gipexe4oykj20zk0m87ji.jpg"></li><li class="item" data-background-image="https://cdn.cdnjson.com/tva4.sinaimg.cn/large/6833939bly1giciuv0socj20zk0m8qes.jpg"></li><li class="item" data-background-image="https://cdn.cdnjson.com/tva4.sinaimg.cn/large/6833939bly1gipevarprfj20zk0m8npd.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-science/" itemprop="item" rel="index" title="分类于 计算机科学"><span itemprop="name">计算机科学</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-science/spring/" itemprop="item" rel="index" title="分类于 Spring"><span itemprop="name">Spring</span></a><meta itemprop="position" content="2"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-science/spring/Spring%E5%9F%BA%E7%A1%80/" itemprop="item" rel="index" title="分类于 Spring基础"><span itemprop="name">Spring基础</span></a><meta itemprop="position" content="3"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://pink-png.github.io/computer-science/spring/docssp/Spring-03/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="sanxin98"><meta itemprop="description" content="肥宅快乐水, 编程 & 生活"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="死肥宅"></span><div class="body md" itemprop="articleBody"><h1 id="Spring-03"><a href="#Spring-03" class="headerlink" title="Spring-03"></a>Spring-03</h1><h2 id="1-AOP"><a href="#1-AOP" class="headerlink" title="1. AOP"></a>1. AOP</h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h3><p>​ AOP为Aspect Oriented Programming的缩写，意为：面向切面编程。他是一种可以在不修改原来的核心代码的情况下给程序动态统一进行增强的一种技术。</p><p>​	<strong>SpringAOP: 批量对Spring容器中bean的方法做增强，并且这种增强不会与原来方法中的代码耦合。</strong></p><h3 id="1-2-快速入门"><a href="#1-2-快速入门" class="headerlink" title="1.2 快速入门"></a>1.2 快速入门</h3><h4 id="1-2-1-需求"><a href="#1-2-1-需求" class="headerlink" title="1.2.1 需求"></a>1.2.1 需求</h4><p>​	要求让_08_SpringAOP模块中service包下所有类的所有方法在调用前都输出：方法被调用了。</p><h4 id="1-2-2-准备工作"><a href="#1-2-2-准备工作" class="headerlink" title="1.2.2 准备工作"></a>1.2.2 准备工作</h4><h5 id="①添加依赖"><a href="#①添加依赖" class="headerlink" title="①添加依赖"></a>①添加依赖</h5><p>需要添加SpringIOC相关依赖和AOP相关依赖。</p><pre><code class="xml">        &lt;!--SpringIOC相关依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--AOP相关依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
            &lt;version&gt;1.8.13&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre><h5 id="②相关bean要注入容器中"><a href="#②相关bean要注入容器中" class="headerlink" title="②相关bean要注入容器中"></a>②相关bean要注入容器中</h5><p>开启组件扫描</p><pre><code class="xml">&lt;context:component-scan base-package=&quot;com.sangeng&quot;&gt;&lt;/context:component-scan&gt;
</code></pre><p>加@Service注解</p><pre><code class="java">@Service
public class PhoneService &#123;

    public void deleteAll()&#123;
        System.out.println(&quot;PhoneService中deleteAll的核心代码&quot;);
    &#125;
&#125;
</code></pre><pre><code class="java">@Service
public class UserService &#123;


    public void deleteAll()&#123;
        System.out.println(&quot;UserService中deleteAll的核心代码&quot;);
    &#125;
&#125;
</code></pre><h4 id="1-2-3-实现AOP"><a href="#1-2-3-实现AOP" class="headerlink" title="1.2.3 实现AOP"></a>1.2.3 实现AOP</h4><h5 id="①开启AOP注解支持"><a href="#①开启AOP注解支持" class="headerlink" title="①开启AOP注解支持"></a>①开启AOP注解支持</h5><p>使用<strong>aop:aspectj-autoproxy</strong>标签</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;!--开启组件扫描--&gt;
    &lt;context:component-scan base-package=&quot;com.sangeng&quot;&gt;&lt;/context:component-scan&gt;
    &lt;!--开启aop注解支持--&gt;
    &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;

&lt;/beans&gt;
</code></pre><h5 id="②创建切面类"><a href="#②创建切面类" class="headerlink" title="②创建切面类"></a>②创建切面类</h5><p>创建一个类，在类上加上@Component和@Aspect</p><p>使用@Pointcut注解来指定要被增强的方法</p><p>使用@Before注解来给我们的增强代码所在的方法进行标识，并且指定了增强代码是在被增强方法执行之前执行的。</p><pre><code class="java">@Component
@Aspect
public class MyAspect &#123;

//    用Pointcut注解中的属性来指定对哪些方法进行增强
    @Pointcut(&quot;execution(* com.sangeng.service.*.*(..))&quot;)
    public void pt()&#123;&#125;

    /*
        用@Before注解来指定该方法中是增强的代码，并且是在被增强方法执行前执行的
        @Before的属性写上加了@Pointcut注解的方法: 方法名()
    */
    @Before(&quot;pt()&quot;)
    public void methodbefore()&#123;
        System.out.println(&quot;方法被调用了&quot;);
    &#125;

&#125;
</code></pre><h4 id="1-2-4-测试"><a href="#1-2-4-测试" class="headerlink" title="1.2.4 测试"></a>1.2.4 测试</h4><pre><code class="java">    public static void main(String[] args) &#123;
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        PhoneService phoneService = applicationContext.getBean(PhoneService.class);
        UserService userService = applicationContext.getBean(UserService.class);
        phoneService.deleteAll();

    &#125;
</code></pre><h3 id="1-3-AOP核心概念"><a href="#1-3-AOP核心概念" class="headerlink" title="1.3 AOP核心概念"></a>1.3 AOP核心概念</h3><ul><li><p>Joinpoint（连接点）：所谓连接点是指那些可以被增强到的点。在spring中,这些点指的是方法，因为spring只支持方法类型的连接点</p></li><li><p><strong>Pointcut（切入点）：所谓切入点是指被增强的连接点（方法）</strong></p></li><li><p><strong>Advice（通知&#x2F; 增强）：所谓通知是指具体增强的代码</strong></p></li><li><p>Target（目标对象）：被增强的对象就是目标对象</p></li><li><p><strong>Aspect（切面）：是切入点和通知（引介）的结合</strong></p></li><li><p>Proxy （代理）：一个类被 AOP 增强后，就产生一个结果代理类</p></li></ul><h3 id="1-4-切点确定"><a href="#1-4-切点确定" class="headerlink" title="1.4 切点确定"></a>1.4 切点确定</h3><h4 id="1-4-1-切点表达式"><a href="#1-4-1-切点表达式" class="headerlink" title="1.4.1 切点表达式"></a>1.4.1 切点表达式</h4><p>​ 可以使用切点表达式来表示要对哪些方法进行增强。</p><p>写法：<strong>execution([修饰符] 返回值类型 包名.类名.方法名(参数))</strong></p><ul><li>访问修饰符可以省略，大部分情况下省略</li><li>返回值类型、包名、类名、方法名可以使用星号* 代表任意</li><li>包名与类名之间一个点 . 代表当前包下的类，两个点 .. 表示当前包及其子包下的类</li><li>参数列表可以使用两个点 .. 表示任意个数，任意类型的参数列表</li></ul><p>例如：</p><pre><code class="java">execution(* com.sangeng.service.*.*(..))   表示com.sangeng.service包下任意类，方法名任意，参数列表任意，返回值类型任意
   
execution(* com.sangeng.service..*.*(..))   表示com.sangeng.service包及其子包下任意类，方法名任意，参数列表任意，返回值类型任意
    
execution(* com.sangeng.service.*.*())     表示com.sangeng.service包下任意类，方法名任意，要求方法不能有参数，返回值类型任意
    
execution(* com.sangeng.service.*.delete*(..))     表示com.sangeng.service包下任意类，要求方法不能有参数，返回值类型任意,方法名要求已delete开头
</code></pre><h4 id="1-4-2-切点函数-annotation"><a href="#1-4-2-切点函数-annotation" class="headerlink" title="1.4.2 切点函数@annotation"></a>1.4.2 切点函数@annotation</h4><p>​	我们也可以在要增强的方法上加上注解。然后使用@annotation来表示对加了什么注解的方法进行增强。</p><p>写法：**@annotation(注解的全类名)**</p><p>例如：</p><p>定义注解如下</p><pre><code class="java">@Target(&#123;ElementType.METHOD&#125;)//该注解可以加在方法上
@Retention(RetentionPolicy.RUNTIME)
public @interface InvokeLog &#123;
&#125;
</code></pre><p>给需要增强的方法增加注解</p><pre><code class="java">@Service
public class PhoneService &#123;

    @InvokeLog  
    public void deleteAll()&#123;
        System.out.println(&quot;PhoneService中deleteAll的核心代码&quot;);
    &#125;
&#125;
</code></pre><p>切面类中使用@annotation来确定要增强的方法</p><pre><code class="java">@Component
@Aspect
public class MyAspect &#123;

//    用Pointcut注解中的属性来指定对哪些方法进行增强
    @Pointcut(&quot;@annotation(com.sangeng.aspect.InvokeLog)&quot;)
    public void pt()&#123;&#125;

    /*
        用@Before注解来指定该方法中是增强的代码，并且是在被增强方法执行前执行的
        @Before的属性写上加了@Pointcut注解的方法: 方法名()
    */
    @Before(&quot;pt()&quot;)
    public void methodbefore()&#123;
        System.out.println(&quot;方法被调用了&quot;);
    &#125;
&#125;
</code></pre><h3 id="1-5-通知分类"><a href="#1-5-通知分类" class="headerlink" title="1.5 通知分类"></a>1.5 通知分类</h3><ul><li><p>@Before：前置通知,在目标方法执行前执行</p></li><li><p>@AfterReturning： 返回后通知，在目标方法执行后执行，如果出现异常不会执行</p></li><li><p>@After：后置通知，在目标方法之后执行，无论是否出现异常都会执行</p></li><li><p>@AfterThrowing：异常通知，在目标方法抛出异常后执行</p></li><li><p><strong>@Around：环绕通知，围绕着目标方法执行</strong></p></li></ul><p>理解不同通知执行时机。（<strong>下面的伪代码是用来理解单个通知的执行时机的，不能用来理解多个通知情况下的执行顺序。如果需要配置多个通知我们会选择使用Around通知，更加的清晰并且好用</strong>）</p><pre><code class="java">    public Object test() &#123;
        before();//@Before 前置通知
        try &#123;
            Object ret = 目标方法();//目标方法调用
            afterReturing();//@AfterReturning 返回后通知
        &#125; catch (Throwable throwable) &#123;
            throwable.printStackTrace();
            afterThrowing();//@AfterThrowing 异常通知通知
        &#125;finally &#123;
            after();//@After 后置通知
        &#125;
        return ret;
    &#125;
</code></pre><p>环绕通知非常特殊，它可以对目标方法进行全方位的增强。</p><p>例如：</p><pre><code class="java">      @Around(&quot;pt()&quot;)
    public void around(ProceedingJoinPoint pjp)&#123;
        System.out.println(&quot;目标方法前&quot;);
        try &#123;
            pjp.proceed();//目标方法执行
            System.out.println(&quot;目标方法后&quot;);
        &#125; catch (Throwable throwable) &#123;
            throwable.printStackTrace();
            System.out.println(&quot;目标方法出现异常&quot;);
        &#125;finally &#123;
            System.out.println(&quot;finally中进行增强&quot;);
        &#125;
    &#125;
</code></pre><h3 id="1-6-获取被增强方法相关信息"><a href="#1-6-获取被增强方法相关信息" class="headerlink" title="1.6 获取被增强方法相关信息"></a>1.6 获取被增强方法相关信息</h3><p>​	我们实际对方法进行增强时往往还需要获取到被增强代码的相关信息，比如方法名，参数，返回值，异常对象等。</p><p>​	我们可以在除了环绕通知外的所有通知方法中增加一个<strong>JoinPoint类型</strong>的参数。这个参数封装了被增强方法的相关信息。<strong>我们可以通过这个参数获取到除了异常对象和返回值之外的所有信息。</strong></p><p>例如：</p><pre><code class="java">    @Before(&quot;pt()&quot;)
    public void methodbefore(JoinPoint jp)&#123;
        Object[] args = jp.getArgs();//方法调用时传入的参数
        Object target = jp.getTarget();//被代理对象
        MethodSignature signature = (MethodSignature) jp.getSignature();//获取被被增强方法签名封装的对象
        System.out.println(&quot;Before方法被调用了&quot;);
    &#125;
</code></pre><p>案例：</p><p>需求：要求让所有service包下类的所有方法被调用前都输出全类名，方法名，以及调用时传入的参数</p><pre><code class="java">@Component
@Aspect
public class PrintLogAspect &#123;

    //对哪些方法增强
    @Pointcut(&quot;execution(* com.sangeng.service..*.*(..))&quot;)
    public void pt()&#123;&#125;

    //怎么增强
    @Before(&quot;pt()&quot;)
    public void printLog(JoinPoint joinPoint)&#123;
        //输出 被增强的方法所在的类名 方法名 调用时传入的参数   joinPoint.getSignature().getName()  joinPoint.getArgs()
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        //类名
        String className = signature.getDeclaringTypeName();
        //方法名
        String methodName = signature.getName();
        //调用时传入的参数
        Object[] args = joinPoint.getArgs();

        System.out.println(className+&quot;==&quot;+methodName+&quot;======&quot;+ Arrays.toString(args));
    &#125;
&#125;
</code></pre><p>​	如果需要<strong>获取被增强方法中的异常对象或者返回值</strong>则需要在方法参数上增加一个对应类型的参数，并且使用注解的属性进行配置。这样Spring会把你想获取的数据赋值给对应的方法参数。</p><p>例如：</p><pre><code class="java">    @AfterReturning(value = &quot;pt()&quot;,returning = &quot;ret&quot;)//使用returning属性指定了把目标方法返回值赋值给下面方法的参数ret
    public void AfterReturning(JoinPoint jp,Object ret)&#123;
        System.out.println(&quot;AfterReturning方法被调用了&quot;);
    &#125;
</code></pre><pre><code class="java">    @AfterThrowing(value = &quot;pt()&quot;,throwing = &quot;t&quot;)//使用throwing属性指定了把出现的异常对象赋值给下面方法的参数t
    public void AfterThrowing(JoinPoint jp,Throwable t)&#123;
        System.out.println(&quot;AfterReturning方法被调用了&quot;);
    &#125;
</code></pre><p>​	相信你肯定觉得上面的获取方式特别的麻烦难以理解。就可以使用下面这种万能的方法。</p><p>​	直接在环绕通知方法中增加一个<strong>ProceedingJoinPoint类型</strong>的参数。这个参数封装了被增强方法的相关信息。</p><p>该参数的proceed()方法被调用相当于被增强方法被执行，调用后的返回值就相当于被增强方法的返回值。</p><p>例如：</p><pre><code class="java">    @Around(value = &quot;pt()&quot;)
    public Object around(ProceedingJoinPoint pjp) &#123;
        Object[] args = pjp.getArgs();//方法调用时传入的参数
        Object target = pjp.getTarget();//被代理对象
        MethodSignature signature = (MethodSignature) pjp.getSignature();//获取被被增强方法签名封装的对象
        Object ret = null;
        try &#123;
            ret = pjp.proceed();//ret就是目标方法执行后的返回值
        &#125; catch (Throwable throwable) &#123;
            throwable.printStackTrace();//throwable就是出现异常时的异常对象
        &#125;
        return ret;
    &#125;
</code></pre><h3 id="1-7-AOP应用案例"><a href="#1-7-AOP应用案例" class="headerlink" title="1.7 AOP应用案例"></a>1.7 AOP应用案例</h3><h4 id="1-7-1-需求"><a href="#1-7-1-需求" class="headerlink" title="1.7.1 需求"></a>1.7.1 需求</h4><p>现有AI核心功能代码如下：</p><pre><code class="java">public class AIController &#123;
    //AI自动回答
    public String getAnswer(String question)&#123;
        //AI核心代码 价值10个亿
        String str = question.replace(&quot;吗&quot;, &quot;&quot;);
        str = str.replace(&quot;？&quot;,&quot;!&quot;);
        return str;
    &#125;

    //AI算命
    public String fortuneTelling(String name)&#123;
        //AI算命核心代码
        String[] strs = &#123;&quot;女犯伤官把夫克，旱地莲花栽不活，不是吃上两家饭，也要刷上三家锅。&quot;,&quot;一朵鲜花头上戴，一年四季也不开，一心想要花开时，采花之人没到来。&quot;,&quot;此命生来脾气暴，上来一阵双脚跳，对你脾气啥都好，经常与人吵和闹。&quot;&#125;;
        int index = name.hashCode() % 3;

        return strs[index];
    &#125;
&#125;
</code></pre><p>​ 现在为了保证数据的安全性，要求调用方法时fortuneTelling传入的姓名是经过加密的。我们需要对传入的参数进行解密后才能使用。并且要对该方法的返回值进行加密后返回。</p><p>​ <strong>PS:后期也可能让其他方法进行相应的加密处理。</strong></p><p>字符串加密解密直接使用下面的工具类即可：</p><pre><code class="java">import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import java.security.SecureRandom;

public class CryptUtil &#123;
    private static final String AES = &quot;AES&quot;;

    private static int keysizeAES = 128;

    private static String charset = &quot;utf-8&quot;;

    public static String parseByte2HexStr(final byte buf[]) &#123;
        final StringBuffer sb = new StringBuffer();
        for (int i = 0; i &lt; buf.length; i++) &#123;
            String hex = Integer.toHexString(buf[i] &amp; 0xFF);
            if (hex.length() == 1) &#123;
                hex = &#39;0&#39; + hex;
            &#125;
            sb.append(hex.toUpperCase());
        &#125;
        return sb.toString();
    &#125;

    public static byte[] parseHexStr2Byte(final String hexStr) &#123;
        if (hexStr.length() &lt; 1)
            return null;
        final byte[] result = new byte[hexStr.length() / 2];
        for (int i = 0;i&lt; hexStr.length()/2; i++) &#123;
            int high = Integer.parseInt(hexStr.substring(i * 2, i * 2 + 1), 16);
            int low = Integer.parseInt(hexStr.substring(i * 2 + 1, i * 2 + 2), 16);
            result[i] = (byte) (high * 16 + low);
        &#125;
        return result;
    &#125;

    private static String keyGeneratorES(final String res, final String algorithm, final String key, final Integer keysize, final Boolean bEncode) &#123;
        try &#123;
            final KeyGenerator g = KeyGenerator.getInstance(algorithm);
            if (keysize == 0) &#123;
                byte[] keyBytes = charset == null ? key.getBytes() : key.getBytes(charset);
                g.init(new SecureRandom(keyBytes));
            &#125; else if (key == null) &#123;
                g.init(keysize);
            &#125; else &#123;
                byte[] keyBytes = charset == null ? key.getBytes() : key.getBytes(charset);
                SecureRandom random = SecureRandom.getInstance(&quot;SHA1PRNG&quot;);
                random.setSeed(keyBytes);
                g.init(keysize, random);
            &#125;
            final SecretKey sk = g.generateKey();
            final SecretKeySpec sks = new SecretKeySpec(sk.getEncoded(), algorithm);
            final Cipher cipher = Cipher.getInstance(algorithm);
            if (bEncode) &#123;
                cipher.init(Cipher.ENCRYPT_MODE, sks);
                final byte[] resBytes = charset == null? res.getBytes() : res.getBytes(charset);
                return parseByte2HexStr(cipher.doFinal(resBytes));
            &#125; else &#123;
                cipher.init(Cipher.DECRYPT_MODE, sks);
                return new String(cipher.doFinal(parseHexStr2Byte(res)));
            &#125;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
        return null;
    &#125;

    public static String AESencode(final String res) &#123;
        return keyGeneratorES(res, AES, &quot;aA11*-%&quot;, keysizeAES, true);
    &#125;

    public static String AESdecode(final String res) &#123;
        return keyGeneratorES(res, AES, &quot;aA11*-%&quot;, keysizeAES, false);
    &#125;

    public static void main(String[] args) &#123;
        System.out.println(
                &quot;加密后:&quot; + AESencode(&quot;将要加密的明文&quot;)
        );
        System.out.println(
                &quot;解密后:&quot; + AESdecode(&quot;730CAE52D85B372FB161B39D0A908B8CC6EF6DA2F7D4E595D35402134C3E18AB&quot;)
        );
    &#125;
&#125;
</code></pre><h4 id="1-7-2-实现"><a href="#1-7-2-实现" class="headerlink" title="1.7.2  实现"></a>1.7.2 实现</h4><h5 id="①导入依赖"><a href="#①导入依赖" class="headerlink" title="①导入依赖"></a>①导入依赖</h5><pre><code class="xml">        &lt;!--SpringIOC相关依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--AOP相关依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
            &lt;version&gt;1.8.13&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre><h5 id="②开启AOP注解支持"><a href="#②开启AOP注解支持" class="headerlink" title="②开启AOP注解支持"></a>②开启AOP注解支持</h5><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;


    &lt;!--配置组件扫描--&gt;
    &lt;context:component-scan base-package=&quot;com.sangeng&quot;&gt;&lt;/context:component-scan&gt;
    &lt;!--启动AOP注解支持--&gt;
    &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;
&lt;/beans&gt;
</code></pre><p>③自定义注解</p><pre><code class="java">package com.sangeng.aspect;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Crypt &#123;

&#125;
</code></pre><p>④在目标方法上增加注解</p><p><strong>注意：目标对象一定要记得注入Spring容器中</strong></p><pre><code class="java">@Controller
public class AIController &#123;
    //....

    //AI算命
    @Crypt
    public String fortuneTelling(String name)&#123;
        System.out.println(name);
              //AI算命核心代码
        String[] strs = &#123;&quot;女犯伤官把夫克，旱地莲花栽不活，不是吃上两家饭，也要刷上三家锅。&quot;,&quot;一朵鲜花头上戴，一年四季也不开，一心想要花开时，采花之人没到来。&quot;,&quot;此命生来脾气暴，上来一阵双脚跳，对你脾气啥都好，经常与人吵和闹。&quot;&#125;;
        int index = name.hashCode() % 3;

        return strs[index];
    &#125;
&#125;
</code></pre><h5 id="⑤定义切面类"><a href="#⑤定义切面类" class="headerlink" title="⑤定义切面类"></a>⑤定义切面类</h5><pre><code class="java">package com.sangeng.aspect;

import com.sangeng.util.CryptUtil;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.stereotype.Component;

@Component
@Aspect
public class CryptAspect &#123;

    //确定切点
    @Pointcut(&quot;@annotation(com.sangeng.aspect.Crypt)&quot;)
    public void pt()&#123;

    &#125;

    //定义通知
    @Around(&quot;pt()&quot;)
    public Object crypt(ProceedingJoinPoint pjp) &#123;
        //获取去目标方法调用时的参数
        Object[] args = pjp.getArgs();
        //对参数进行解密  解密后传入目标方法执行
        String arg = (String) args[0];
        String s = CryptUtil.AESdecode(arg);//解密
        args[0] = s;
        Object proceed = null;
        String ret = null;
        try &#123;
            proceed = pjp.proceed(args);//目标方法调用
            //目标方法执行后需要获取到返回值
            ret = (String) proceed;
            //对返回值加密后进行真正的返回
            ret = CryptUtil.AESencode(ret);
        &#125; catch (Throwable throwable) &#123;
            throwable.printStackTrace();
        &#125;
        return ret;
    &#125;

&#125;
</code></pre><h3 id="1-8-xml配置AOP"><a href="#1-8-xml配置AOP" class="headerlink" title="1.8 xml配置AOP"></a>1.8 xml配置AOP</h3><h4 id="①定义切面类"><a href="#①定义切面类" class="headerlink" title="①定义切面类"></a>①定义切面类</h4><pre><code class="java">public class MyAspect &#123;


    public void before(JoinPoint joinPoint)&#123;
        System.out.println(&quot;before&quot;);
    &#125;

//    @AfterReturning(value = &quot;pt()&quot;,returning = &quot;ret&quot;)
    public void afterReturning(JoinPoint joinPoint,Object ret)&#123;
        System.out.println(&quot;afterReturning:&quot;+ret);
    &#125;
//    @After(&quot;pt()&quot;)
    public void after(JoinPoint joinPoint)&#123;
        System.out.println(&quot;after&quot;);
    &#125;

//    @AfterThrowing(value = &quot;pt()&quot;,throwing = &quot;e&quot;)
    public void afterThrowing(JoinPoint joinPoint,Throwable e)&#123;
        String message = e.getMessage();
        System.out.println(&quot;afterThrowing:&quot;+message);
    &#125;

    public Object around(ProceedingJoinPoint pjp)&#123;
        //获取参数
        Object[] args = pjp.getArgs();
        MethodSignature signature = (MethodSignature) pjp.getSignature();
        Object target = pjp.getTarget();
        Object ret = null;
        try &#123;
            ret = pjp.proceed();//目标方法的执行
            //ret就是被增强方法的返回值
            System.out.println(ret);
        &#125; catch (Throwable throwable) &#123;
            throwable.printStackTrace();
            System.out.println(throwable.getMessage());
        &#125;
//        System.out.println(pjp);
        return ret;
    &#125;
&#125;
</code></pre><h4 id="②目标类和切面类注入容器"><a href="#②目标类和切面类注入容器" class="headerlink" title="②目标类和切面类注入容器"></a>②目标类和切面类注入容器</h4><p>在切面类和目标类上加是对应的注解。注入如果是使用注解的方式注入容器要记得开启组件扫描。</p><p>当然你也可以在xml中使用bean标签的方式注入容器。</p><pre><code class="java">@Component//把切面类注入容器
public class MyAspect &#123;
    //..。省略无关代码
&#125;
</code></pre><pre><code class="java">@Service//把目标类注入容器
public class UserService &#123;
    //..。省略无关代码
&#125;
</code></pre><h4 id="③配置AOP"><a href="#③配置AOP" class="headerlink" title="③配置AOP"></a>③配置AOP</h4><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;

    &lt;!--开启组件扫描--&gt;
    &lt;context:component-scan base-package=&quot;com.sangeng&quot;&gt;&lt;/context:component-scan&gt;

    &lt;!--配置AOP--&gt;
    &lt;aop:config&gt;
        &lt;!--定义切点--&gt;
        &lt;aop:pointcut id=&quot;pt1&quot; expression=&quot;execution(* com.sangeng.service..*.*(..))&quot;&gt;&lt;/aop:pointcut&gt;
        &lt;aop:pointcut id=&quot;pt2&quot; expression=&quot;@annotation(com.sangeng.aspect.InvokeLog)&quot;&gt;&lt;/aop:pointcut&gt;
        &lt;!--配置切面--&gt;
        &lt;aop:aspect ref=&quot;myAspect&quot;&gt;
            &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:before&gt;
            &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:after&gt;
            &lt;aop:after-returning method=&quot;afterReturning&quot; pointcut-ref=&quot;pt1&quot; returning=&quot;ret&quot;&gt;&lt;/aop:after-returning&gt;
            &lt;aop:after-throwing method=&quot;afterThrowing&quot; pointcut-ref=&quot;pt2&quot; throwing=&quot;e&quot;&gt;&lt;/aop:after-throwing&gt;
        &lt;/aop:aspect&gt;
    &lt;/aop:config&gt;
&lt;/beans&gt;
</code></pre><h3 id="1-9-多切面顺序问题"><a href="#1-9-多切面顺序问题" class="headerlink" title="1.9 多切面顺序问题"></a>1.9 多切面顺序问题</h3><p>​	在实际项目中我们可能会存在配置了多个切面的情况。这种情况下我们很可能需要控制切面的顺序。</p><p>​	我们在默认情况下Spring有它自己的排序规则。（按照类名排序）</p><p>​	默认排序规则往往不符合我们的要求，我们需要进行特殊控制。</p><p>​	如果是注解方式配置的AOP可以在切面类上加**@Order注解<strong>来控制顺序。</strong>@Order中的属性越小优先级越高。**</p><p>​	如果是XML方式配置的AOP,可以通过调整<strong>配置顺序</strong>来控制。</p><p>例如：</p><p>下面这种配置方式就会先使用CryptAspect里面的增强，在使用APrintLogAspect里的增强</p><pre><code class="java">@Component
@Aspect
@Order(2)
public class APrintLogAspect &#123;
    //省略无关代码
&#125;
@Component
@Aspect
@Order(1)
public class CryptAspect &#123;
    //省略无关代码
&#125;
</code></pre><h3 id="1-10-AOP原理-动态代理"><a href="#1-10-AOP原理-动态代理" class="headerlink" title="1.10 AOP原理-动态代理"></a>1.10 AOP原理-动态代理</h3><p>​	实际上Spring的AOP其实底层就是使用动态代理来完成的。并且使用了两种动态代理分别是JDK的动态代理和Cglib动态代理。</p><p>​	所以我们接下去来学习下这两种动态代理，理解下它们的不同点。</p><h4 id="1-10-1-JDK动态代理"><a href="#1-10-1-JDK动态代理" class="headerlink" title="1.10.1 JDK动态代理"></a>1.10.1 JDK动态代理</h4><p>​	JDK的动态代理使用的java.lang.reflect.Proxy这个类来进行实现的。要求被代理（被增强）的类需要实现了接口。并且JDK动态代理也只能对接口中的方法进行增强。</p><pre><code class="java">public static void main(String[] args) &#123;
        AIControllerImpl aiController = new AIControllerImpl();
        //使用动态代理增强getAnswer方法
        //1.JDK动态代理
        //获取类加载器
        ClassLoader cl = Demo.class.getClassLoader();
        //被代理类所实现接口的字节码对象数组
        Class&lt;?&gt;[] interfaces = AIControllerImpl.class.getInterfaces();
        AIController proxy = (AIController) Proxy.newProxyInstance(cl, interfaces, new InvocationHandler() &#123;
            //使用代理对象的方法时 会调用到invoke
                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;
                //proxy   是代理对象
                //method 是当前被调用的方法封装的Method对象
                //args   是调用方法时传入的参数
                //调用被代理对象的对应方法
                //判断 当前调用的是否是getAnswer方法
                if(method.getName().equals(&quot;getAnswer&quot;))&#123;
                    System.out.println(&quot;增强&quot;);
                &#125;
                Object ret = method.invoke(aiController, args);
                return ret;
            &#125;
        &#125;);
        String answer = proxy.getAnswer(&quot;三连了吗？&quot;);
        System.out.println(answer);
    &#125;
</code></pre><h4 id="1-10-2-Cglib动态代理"><a href="#1-10-2-Cglib动态代理" class="headerlink" title="1.10.2 Cglib动态代理"></a>1.10.2 Cglib动态代理</h4><p>​	使用的是org.springframework.cglib.proxy.Enhancer类进行实现的。</p><pre><code class="java">public class CglibDemo &#123;
    public static void main(String[] args) &#123;
        Enhancer enhancer = new Enhancer();
        //设置父类的字节码对象
        enhancer.setSuperclass(AIControllerImpl.class);
        enhancer.setCallback(new MethodInterceptor() &#123;
            //使用代理对象执行方法是都会调用到intercept方法
            @Override
            public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;
                //判断当前调用的方法是不是getAnswer方法 如果是进行增强
                if (&quot;getAnswer&quot;.equals(method.getName()))&#123;
                    System.out.println(&quot;被增强了&quot;);
                &#125;
                //调用父类中对应的方法
                Object ret = methodProxy.invokeSuper(o, objects);
                return ret;
            &#125;
        &#125;);
        //生成代理对象
        AIControllerImpl proxy = (AIControllerImpl) enhancer.create();
//        System.out.println(proxy.getAnswer(&quot;你好吗？&quot;));
        System.out.println(proxy.fortuneTelling(&quot;你好吗？&quot;));
    &#125;
&#125;
</code></pre><h4 id="1-10-3-总结"><a href="#1-10-3-总结" class="headerlink" title="1.10.3 总结"></a>1.10.3 总结</h4><p>​	JDK动态代理要求被代理（被增强）的类必须要实现接口，生成的代理对象相当于是被代理对象的兄弟。</p><p>​	Cglib的动态代理不要求被代理（被增强）的类要实现接口，生成的代理对象相当于被代理对象的子类对象。</p><p>​	<strong>Spring的AOP默认情况下优先使用的是JDK的动态代理，如果使用不了JDK的动态代理才会使用Cglib的动态代理。</strong></p><h3 id="1-11-切换默认动态代理方式"><a href="#1-11-切换默认动态代理方式" class="headerlink" title="1.11 切换默认动态代理方式"></a>1.11 切换默认动态代理方式</h3><p>​	有的时候我们需要修改AOP的代理方式。</p><p>​	我们可以使用以下方式修改：</p><p>如果我们是采用注解方式配置AOP的话：</p><p>设置aop:aspectj-autoproxy标签的proxy-target-class属性为true，代理方式就会修改成Cglib</p><pre><code class="xml">&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;
</code></pre><p>如果我们是采用xml方式配置AOP的话：</p><p>设置aop:config标签的proxy-target-class属性为true,代理方式就会修改成Cglib</p><pre><code class="xml">&lt;aop:config proxy-target-class=&quot;true&quot;&gt;
&lt;/aop:config&gt;
</code></pre><div class="tags"><a href="/tags/Spring/" rel="tag"><i class="ic i-tag"></i> Spring</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-07-07 15:28:23" itemprop="dateModified" datetime="2023-07-07T15:28:23+08:00">2023-07-07</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="sanxin98 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="sanxin98 支付宝"><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>sanxin98 <i class="ic i-at"><em>@</em></i>死肥宅</li><li class="link"><strong>本文链接：</strong> <a href="https://pink-png.github.io/computer-science/spring/docssp/Spring-03/" title="Step.3">https://pink-png.github.io/computer-science/spring/docssp/Spring-03/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/computer-science/spring/docssp/Spring-04/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;cdn.cdnjson.com&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipex2cdtbj20zk0m8x6p.jpg" title="Step.4"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> Spring基础</span><h3>Step.4</h3></a></div><div class="item right"><a href="/computer-science/spring/docssp/Spring-02/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;cdn.cdnjson.com&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclxp31goj20zk0m8qv5.jpg" title="Step.2"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> Spring基础</span><h3>Step.2</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring-03"><span class="toc-number">1.</span> <span class="toc-text">Spring-03</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-AOP"><span class="toc-number">1.1.</span> <span class="toc-text">1. AOP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1 概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 快速入门</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-%E9%9C%80%E6%B1%82"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">1.2.1 需求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">1.2.2 准备工作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96"><span class="toc-number">1.1.2.2.1.</span> <span class="toc-text">①添加依赖</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1%E7%9B%B8%E5%85%B3bean%E8%A6%81%E6%B3%A8%E5%85%A5%E5%AE%B9%E5%99%A8%E4%B8%AD"><span class="toc-number">1.1.2.2.2.</span> <span class="toc-text">②相关bean要注入容器中</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-3-%E5%AE%9E%E7%8E%B0AOP"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">1.2.3 实现AOP</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0%E5%BC%80%E5%90%AFAOP%E6%B3%A8%E8%A7%A3%E6%94%AF%E6%8C%81"><span class="toc-number">1.1.2.3.1.</span> <span class="toc-text">①开启AOP注解支持</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1%E5%88%9B%E5%BB%BA%E5%88%87%E9%9D%A2%E7%B1%BB"><span class="toc-number">1.1.2.3.2.</span> <span class="toc-text">②创建切面类</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-4-%E6%B5%8B%E8%AF%95"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">1.2.4 测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-AOP%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3 AOP核心概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E5%88%87%E7%82%B9%E7%A1%AE%E5%AE%9A"><span class="toc-number">1.1.4.</span> <span class="toc-text">1.4 切点确定</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-1-%E5%88%87%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">1.4.1 切点表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-2-%E5%88%87%E7%82%B9%E5%87%BD%E6%95%B0-annotation"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">1.4.2 切点函数@annotation</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E9%80%9A%E7%9F%A5%E5%88%86%E7%B1%BB"><span class="toc-number">1.1.5.</span> <span class="toc-text">1.5 通知分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-%E8%8E%B7%E5%8F%96%E8%A2%AB%E5%A2%9E%E5%BC%BA%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF"><span class="toc-number">1.1.6.</span> <span class="toc-text">1.6 获取被增强方法相关信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-AOP%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="toc-number">1.1.7.</span> <span class="toc-text">1.7 AOP应用案例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-1-%E9%9C%80%E6%B1%82"><span class="toc-number">1.1.7.1.</span> <span class="toc-text">1.7.1 需求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-2-%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.1.7.2.</span> <span class="toc-text">1.7.2 实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0%E5%AF%BC%E5%85%A5%E4%BE%9D%E8%B5%96"><span class="toc-number">1.1.7.2.1.</span> <span class="toc-text">①导入依赖</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1%E5%BC%80%E5%90%AFAOP%E6%B3%A8%E8%A7%A3%E6%94%AF%E6%8C%81"><span class="toc-number">1.1.7.2.2.</span> <span class="toc-text">②开启AOP注解支持</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A4%E5%AE%9A%E4%B9%89%E5%88%87%E9%9D%A2%E7%B1%BB"><span class="toc-number">1.1.7.2.3.</span> <span class="toc-text">⑤定义切面类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-xml%E9%85%8D%E7%BD%AEAOP"><span class="toc-number">1.1.8.</span> <span class="toc-text">1.8 xml配置AOP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%AE%9A%E4%B9%89%E5%88%87%E9%9D%A2%E7%B1%BB"><span class="toc-number">1.1.8.1.</span> <span class="toc-text">①定义切面类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E7%9B%AE%E6%A0%87%E7%B1%BB%E5%92%8C%E5%88%87%E9%9D%A2%E7%B1%BB%E6%B3%A8%E5%85%A5%E5%AE%B9%E5%99%A8"><span class="toc-number">1.1.8.2.</span> <span class="toc-text">②目标类和切面类注入容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E9%85%8D%E7%BD%AEAOP"><span class="toc-number">1.1.8.3.</span> <span class="toc-text">③配置AOP</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-9-%E5%A4%9A%E5%88%87%E9%9D%A2%E9%A1%BA%E5%BA%8F%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.9.</span> <span class="toc-text">1.9 多切面顺序问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-10-AOP%E5%8E%9F%E7%90%86-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">1.1.10.</span> <span class="toc-text">1.10 AOP原理-动态代理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-10-1-JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">1.1.10.1.</span> <span class="toc-text">1.10.1 JDK动态代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-10-2-Cglib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">1.1.10.2.</span> <span class="toc-text">1.10.2 Cglib动态代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-10-3-%E6%80%BB%E7%BB%93"><span class="toc-number">1.1.10.3.</span> <span class="toc-text">1.10.3 总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-11-%E5%88%87%E6%8D%A2%E9%BB%98%E8%AE%A4%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.11.</span> <span class="toc-text">1.11 切换默认动态代理方式</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/computer-science/spring/docssp/Spring-01/" rel="bookmark" title="Step.1">Step.1</a></li><li><a href="/computer-science/spring/docssp/Spring-02/" rel="bookmark" title="Step.2">Step.2</a></li><li class="active"><a href="/computer-science/spring/docssp/Spring-03/" rel="bookmark" title="Step.3">Step.3</a></li><li><a href="/computer-science/spring/docssp/Spring-04/" rel="bookmark" title="Step.4">Step.4</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="sanxin98" data-src="/images/avatar.jpg"><p class="name" itemprop="name">sanxin98</p><div class="description" itemprop="description">编程 & 生活</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">93</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">37</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">27</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BpbmstcG5n" title="https:&#x2F;&#x2F;github.com&#x2F;pink-png"><i class="ic i-github"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/computer-science/spring/docssp/Spring-04/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/computer-science/spring/docssp/Spring-02/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" title="分类于 前端开发">前端开发</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E8%B7%A8%E5%9F%9F/" title="分类于 跨域">跨域</a></div><span><a href="/Web-Integration/%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" title="跨域解决方案">跨域解决方案</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" title="分类于 前端开发">前端开发</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Javascript/" title="分类于 Javascript">Javascript</a></div><span><a href="/js-base/%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96/" title="数组扁平化">数组扁平化</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" title="分类于 前端开发">前端开发</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E6%B5%8F%E8%A7%88%E5%99%A8/" title="分类于 浏览器">浏览器</a></div><span><a href="/Web-Integration/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/" title="浏览器渲染原理以及优化思路">浏览器渲染原理以及优化思路</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/vueyuanma/" title="分类于 Vue">Vue</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/vueyuanma/dosc/" title="分类于 vue2.x源码">vue2.x源码</a></div><span><a href="/computer-science/vueyuanma/dosc/13%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3v-model%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96%E4%BA%86%E5%90%97/" title="Step.13 你真的了解v-model的语法糖了吗">Step.13 你真的了解v-model的语法糖了吗</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" title="分类于 前端开发">前端开发</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Javascript/" title="分类于 Javascript">Javascript</a></div><span><a href="/js-base/js%E6%B5%85%E8%B0%88call%E5%92%8Capply%E5%92%8Cbind/" title="浅谈call和apply和bind">浅谈call和apply和bind</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/Mybatis/" title="分类于 Mybatis">Mybatis</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/Mybatis/Mybatis%E5%9F%BA%E7%A1%80/" title="分类于 Mybatis基础">Mybatis基础</a></div><span><a href="/computer-science/Mybatis/doscmp/Mybatis-02/" title="Step.2">Step.2</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" title="分类于 前端开发">前端开发</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Javascript/" title="分类于 Javascript">Javascript</a></div><span><a href="/js-base/js%E6%B5%85%E8%B0%88%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%BB%A5%E5%8F%8A%E5%8F%98%E9%87%8F%E4%BB%A5%E5%8F%8A%E9%97%AD%E5%8C%85/" title="js浅谈作用域 - 变量 - 闭包">js浅谈作用域 - 变量 - 闭包</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" title="分类于 前端开发">前端开发</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/" title="分类于 网络请求">网络请求</a></div><span><a href="/front-end/ajax%E3%80%81axios%E3%80%81fetch%E5%8C%BA%E5%88%AB/" title="ajax、axios、fetch区别">ajax、axios、fetch区别</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/Mybatis/" title="分类于 Mybatis">Mybatis</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/Mybatis/Mybatis%E5%9F%BA%E7%A1%80/" title="分类于 Mybatis基础">Mybatis基础</a></div><span><a href="/computer-science/Mybatis/doscmp/Mybatis-01/" title="Step.1">Step.1</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" title="分类于 前端开发">前端开发</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" title="分类于 前端性能优化">前端性能优化</a></div><span><a href="/performance-optimization/Vue%E9%A6%96%E5%B1%8F%E4%BC%98%E5%8C%96/" title="vue首屏优化">vue首屏优化</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">sanxin98 @ Yume Shoka</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"computer-science/spring/docssp/Spring-03/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:{placeholder:"1. 提问前请先仔细阅读本文档⚡\n2. 页面显示问题💥，请提供控制台截图📸或者您的测试网址\n3. 其他任何报错💣，请提供详细描述和截图📸，祝食用愉快💪"},fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>