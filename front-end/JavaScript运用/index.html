<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="死肥宅" href="http://yoursite.com/rss.xml"><link rel="alternate" type="application/atom+xml" title="死肥宅" href="http://yoursite.com/atom.xml"><link rel="alternate" type="application/json" title="死肥宅" href="http://yoursite.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="Javascript"><link rel="canonical" href="http://yoursite.com/front-end/JavaScript%E8%BF%90%E7%94%A8/"><title>js运用 - Javascript - 前端开发 | Yume Shoka = 死肥宅 = 肥宅快乐水</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">js运用</h1><div class="meta"><span class="item" title="创建时间：2021-06-25 16:43:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2021-06-25T16:43:00+08:00">2021-06-25</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Yume Shoka</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gipeuibk9fj20zk0m8ay2.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gipewkhf1zj20zk0m81kx.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gipeybxm1pj20zk0m8niv.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giclg5ms2rj20zk0m8u0x.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giclxxcb6rj20zk0m8b29.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giclj61ylzj20zk0m8b29.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" itemprop="item" rel="index" title="分类于 前端开发"><span itemprop="name">前端开发</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Javascript/" itemprop="item" rel="index" title="分类于 Javascript"><span itemprop="name">Javascript</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://yoursite.com/front-end/JavaScript%E8%BF%90%E7%94%A8/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Yn"><meta itemprop="description" content="肥宅快乐水, 双马尾の罪"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="死肥宅"></span><div class="body md" itemprop="articleBody"><h1 id="一：什么是JavaScript"><a href="#一：什么是JavaScript" class="headerlink" title="一：什么是JavaScript"></a>一：什么是JavaScript</h1><h2 id="1-发展历史"><a href="#1-发展历史" class="headerlink" title="1.发展历史"></a>1.发展历史</h2><pre><code class="javascript">1995年 JavaScript 1.0 问世 它的主要用途是代替 Perl 等服务器端语言处理输入验证
1997年 javascript 1.1 作为提案被提交给欧洲计算机制造商协会（Ecma）TC39 委员会他们花了数月时间打造出 ECMA-262
1998年 国际标准化组织（ISO）和国际电工委员会（IEC）也将 ECMAScript 采纳为标准  自此以后，各家浏览器均以 ECMAScript 作为自己 JavaScript 实现的依据，虽然具体实现各有不同。
</code></pre><h2 id="2-javascript的构成"><a href="#2-javascript的构成" class="headerlink" title="2.javascript的构成"></a>2.javascript的构成</h2><pre><code class="javascript">1.核心（ECMAScript）    
2.文档对象模型（DOM）
3.浏览器对象模型（BOM）
</code></pre><h1 id="一：数据类型以及相应的操作"><a href="#一：数据类型以及相应的操作" class="headerlink" title="一：数据类型以及相应的操作"></a>一：数据类型以及相应的操作</h1><h5 id="2：关于Array处理数据的方法总结"><a href="#2：关于Array处理数据的方法总结" class="headerlink" title="2：关于Array处理数据的方法总结"></a>2：关于Array处理数据的方法总结</h5><pre><code class="javascript">//敲重点1：创建数组的方式有2种，一种是构造函数的方式 一个是字面量的方式，最好使用字面量的方式
//因为不管Array或者String本身也是构造函数
        Array = String;
        let aa = new Array(1,2,3,4,5);
        console.log(aa);  //string

        let bb = [1,2,3,4];
        console.log(bb); //[1,2,3,4]

----------------------------------------------------------

//敲重点2：ECMAScript的数组每个槽位可以存储任意类型的数据，而且ECMAScript数组也是动态大小的，会随着数据的添加自动增长
        let arr = [1,&#39;1&#39;,[1,2,3,4],&#123;obj1:11,obj2:[1,2,3,4]&#125;];

------------------------------------------------------------
        
//敲重点3：数组排列位置
//使用for循环打乱位数组置
        var Arr = [4, 1, 67, 12, 45, 121, 3];
        function randArr(arr) &#123;
            for (var i = 0; i &lt; arr.length; i++) &#123;
                var iRand = parseInt(arr.length * Math.random());
                var temp = arr[i];
                arr[i] = arr[iRand];
                arr[iRand] = temp;
            &#125;
            return arr;
        &#125;

//使用sort方法错误打乱位数组置
        arr.sort(function () &#123;
            return (0.5 - Math.random());
        &#125;);


//reverse()方法是倒序交换位置 会改变原来的数组
        let newarr = arr.reverse()
          console.log(newarr === arr)  //true


//利用sort()对数组对象某个值进行升序排序
        let arr = [&#123; &#39;a&#39;: 1, &#39;b&#39;: 2 &#125;, &#123; &#39;a&#39;: 466, &#39;b&#39;: 2 &#125;, &#123; &#39;a&#39;: 623, &#39;b&#39;: 2 &#125;, &#123; &#39;a&#39;: 7, &#39;b&#39;: 2 &#125;, &#123; &#39;a&#39;: 67, &#39;b&#39;: 2 &#125;]

        function creatCompare(propertyName) &#123; //根据哪个属性值排序
            return function (obj1, obj2) &#123;
                //对象两两比较
                let value1 = obj1[propertyName];
                let value2 = obj2[propertyName];
                if (value1 &lt; value2) &#123;
                    return -1
                &#125; else if (value1 &gt; value2) &#123;
                    return 1
                &#125; else &#123;
                    return 0
                &#125;
            &#125;
        &#125;

        let newarr = arr.sort(creatCompare(&#39;a&#39;))
        console.log(newarr)
---------------------------------------------------------------

//敲重点4：数组的转换方法
//数组转成字符串
        let color = [&#39;green&#39;,&#39;red&#39;,&#39;pink&#39;]
        console.log(color.join())  // green,red,pink
        console.log(color.join(&#39;,&#39;)) // green,red,pink
        console.log(color.join(&#39;|&#39;))  // green|red|pink

//以下这种方法只能转成以逗号分隔的字符串
        let colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; 
        alert(colors.toString()); // red,blue,green
        alert(colors.valueOf()); // red,blue,green
        alert(colors); // red,blue,green		
//扩展：字符串转数组
        console.log(color.join(&#39;|&#39;).split(&#39;|&#39;)) //[&#39;green&#39;,&#39;red&#39;,&#39;pink&#39;]

----------------------------------------------------------------

//敲重点5：栈方法
        let arr = [1,2,3,4];
        arr.push(5); //向数组末尾添加5
        let poparr = arr.pop();   //取得数组末尾的值，并且删除
        console.log(arr);  //[1,2,3,4]

----------------------------------------------------------------

//敲重点6：队列方法
           let arr = [1,2,3,4];
           let shiftarr = arr.shift(); //删除数组第一项并取得
           arr.unshift(1); //向数组第一项添加
           console.log(arr); // [1,2,3,4]

------------------------------------------------------------

//敲重点7：数组相关的操作方法
        let arr = [1,2,3,4,5]
        
//拼接2个数组  返回一个新的数组,不改变原来的数组
        let zenarr = arr.concat(6,7,8)
        console.log(zenarr) // [1, 2, 3, 4, 5, 6, 7, 8]
        
//concat方法不传参数对数组进行第一层的深拷贝
        let arr = [1,2,3];
        let newarr = arr.concat()
        

//数组截取    遵循左包，右不包
        console.log(arr.slice(1))  //[2,3,4]
        console.log(arr.slice(2))   //[3,4]
        console.log(arr.slice(2,4)) //[3,4] 

//slice方法不传参数对数组进行第一层深拷贝
        let arr = [1,2,3,4]
        let slicearr = arr.slice()
        console.log(slicearr) //返回跟原来一样的新数组   [1,2,3,4]

------------------------------------------------------------


//敲重点8：数组增删改
    
        let arr = [1,2,3,4]

//删除    
        arr.splice(1,1) //传入2个参数，第一个数数组开始位置，第二个是删除的数量
        console.log(arr)   //[1,3,4] 

//插入
        arr.splice(1,0,2) //传入3个参数  第一个参数是开始位置，第二个是要删除的数量，要插入的元素   
        console.log(arr) //[1,2,3,4]

//替换
        arr.splice(3,0,4,5,6)  //方法同插入  ，在序列为3的位置后面，删除0个，添加 4，5，6
        console.log(arr) //[1, 2, 3, 4, 5, 6, 4]

--------------------------------------------------------------

//敲重点9：搜索和位置方法
        
//indexOf从索为0开始搜索   
//lastIndexOf从最后一项开始搜索
        let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];
        alert(numbers.indexOf(4)); // 3
        alert(numbers.lastIndexOf(4)); // 5
        alert(numbers.includes(4)); // true
        alert(numbers.indexOf(4, 4)); // 5
        alert(numbers.lastIndexOf(4, 4)); // 3
        alert(numbers.includes(4, 7)); // false
        let person = &#123; name: &quot;Nicholas&quot; &#125;;
        let people = [&#123; name: &quot;Nicholas&quot; &#125;];
        let morePeople = [person];
        alert(people.indexOf(person)); // -1
        alert(morePeople.indexOf(person)); // 0
        alert(people.includes(person)); // false
        alert(morePeople.includes(person)); // true


//使用includes()方法判断数组里有无某数据  
          function test(fruit) &#123;
            const redFruits = [&#39;apple&#39;, &#39;strawberry&#39;, &#39;cherry&#39;, &#39;cranberries&#39;];
            if (redFruits.includes(fruit)) &#123;
                console.log(&#39;存在&#39;);
            &#125;else&#123;
                console.log(&#39;不存在&#39;)
            &#125;
        &#125;

--------------------------------------------------------------

//敲重点10：断言函数的运用
//找到匹配项后，这两个方法都不再继续搜索。 
//可以说是查询判断里性能最好的方法
        const people = [
            &#123;
                name: &quot;Matt&quot;,
                age: 27
            &#125;,
            &#123;
                name: &quot;Nicholas&quot;,
                age: 29
            &#125;
        ];
        alert(people.find((element, index, array) =&gt; element.age &lt; 28));
        // &#123;name: &quot;Matt&quot;, age: 27&#125;
        alert(people.findIndex((element, index, array) =&gt; element.age &lt; 28));
        // 0


//其实也可以当做循环使用
        const evens = [2, 4, 6];

        evens.find((element, index, array) =&gt; &#123;
            console.log(element);
            console.log(index); 
            console.log(array);
            return element === 4;
        &#125;);
// 2
// 0
// [2, 4, 6]
// 4
// 1
// [2, 4, 6]

--------------------------------------------------------------

//敲重点11：迭代方法
every()：对数组每一项都运行传入的函数，如果对每一项函数都返回 true，则这个方法返回 true。
filter()：对数组每一项都运行传入的函数，函数返回 true 的项会组成数组之后返回。
forEach()：对数组每一项都运行传入的函数，没有返回值。
map()：对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组。
some()：对数组每一项都运行传入的函数，如果有一项函数返回 true，则这个方法返回 true。
这些方法都不改变调用它们的数组。

//map方法每次要主动定义返回项
            let newobjarr =  objarr.map((item)=&gt;&#123;
                item.a += 1;
                item.b += 1;
                return &#123;a:item.a,b:item.b&#125;

            &#125;)     
            console.log(newobjarr)

//敲重点12：归并方法
reduce()
        

        //每一项都加1
        let arr = [1,1,2,3,4,5]
        const res = arr.reduce(function(prev,cur)&#123;
            return [...prev,cur + 1]
        &#125;,[])




        //数组求和
        const text = [&#123;
            id: 1,
            sex: 0
        &#125;, &#123;
            id: 2,
            sex: 1
        &#125;, &#123;
            id: 3,
            sex: 1
        &#125;]

        const res = text.reduce(function (prev, cur, index, array) &#123;
            return prev + cur.id
        &#125;, 0)


        // 计算数组每个元素出现的次数
        const arr = [1, 1, 2, 3, 4]
        const rescount = arr.reduce(function (prev, cur, index, array) &#123;
            if (cur in prev) &#123;
                prev[cur]++
            &#125; else &#123;
                prev[cur] = 1
            &#125;
            return prev
        &#125;, &#123;&#125;)
        
        //取出最大值
         const res = arr.reduce(function(prev,cur)&#123;
           return prev &lt;= cur ? prev = cur : prev = prev
        &#125;,0)


        //数组去重
        const res = arr.reduce(function(prev,cur)&#123;
            return !prev.includes(cur) ? [...prev,cur] : prev
        &#125;,[])


        // 将二维数组转化为一维
        const arrer = [[0, 1], [2, 3], [4, 5]]
        const arrerres = arrer.reduce(function (prev, cur) &#123;
            return prev.concat(cur)
        &#125;, [])


        // 将多维数组转化为一维
        let arr = [[0, 1], [2, 3], [4, [5, 6, 7]]]
        const newArr = function (arr) &#123;
            return arr.reduce((pre, cur) =&gt; pre.concat(Array.isArray(cur) ? newArr(cur) : cur), [])
        &#125;

reduceRight()




//12.某些方法调用用会修改自身的数组?
  push
  pop
  shift
  unshift
  splice
  sort
  reverse
</code></pre><h5 id="3：关于String包装类型处理数据的总结"><a href="#3：关于String包装类型处理数据的总结" class="headerlink" title="3：关于String包装类型处理数据的总结"></a>3：关于String包装类型处理数据的总结</h5><pre><code class="javascript">
        let mseesage = new String(&#39;hello&#39;)
        console.log(mseesage.length)  //返回字符串的长度  5
        console.log(mseesage.charAt(0))  //返回某个索引值  h
        console.log(mseesage.charCodeAt(0))  //字符编码  h的字符编码是108

3.1
// 字符串拼接  不改变原来的字符串， 返回一个新的字符串
        let o = &#39;hello&#39;
        let result = stringvalue.concat(&#39;world&#39;) //可以接受多个参数，用逗号分开

        console.log(result)  //  hello world
        console.log(stringvalue) //hello  

// 采用 加号 +  实现快速拼接
        let a = &#39;hello&#39;
        let b = a + &#39;world&#39;
        console.log(a)  // hello
        console.log(b) //hello world 

3.2
//字符串提取
        let stringvalue = &#39;hello world&#39;
        console.log(stringValue.slice(3)); // &quot;lo world&quot;
        console.log(stringValue.substring(3)); // &quot;lo world&quot;
        console.log(stringValue.substr(3)); // &quot;lo world&quot;
        console.log(stringValue.slice(3, 7)); // &quot;lo w&quot;
        console.log(stringValue.substring(3, 7)); // &quot;lo w&quot;
        console.log(stringValue.substr(3, 7)); // &quot;lo worl&quot; 

//clice 单个参数是 左不包后面全要 (]        2个参数是 左不包，后包  (]
//substring 单个参数是 左不包后面全要 (]         2个参数是 左包，后包   []
//substr 单个参数是 左包后面全要  []           2个参数是 左包，第二个参数是截取个数  []

3.3
//字符串位置方法
        let stringvalue = &#39;hello world&#39;
        console.log(stringvalue.indexOf(&quot;o&quot;)) // 4
        console.log(stringvalue.lastIndexOf(&quot;o&quot;)) // 7 
//indexOd和lastIndexOf的区别就是前者是从前面开始寻找，后者是从后面开始寻找

//传入第二个参数的时候，
        console.log(stringValue.indexOf(&quot;o&quot;, 6)); // 7
        console.log(stringValue.lastIndexOf(&quot;o&quot;, 6)); // 4 
//第二个参数代表从哪个序列开始寻找


//寻找某段字符串里的某个字符，并全部记录它的序列位置
        let stringValue = &quot;Lorem ipsum dolor sit amet, consectetur adipisicing elit&quot;;
        let positions = new Array();
        let pos = stringValue.indexOf(&quot;e&quot;); 

        while(pos &gt; -1)&#123; 
            positions.push(pos)
            pos = stringValue.indexOf(&#39;e&#39;, pos + 1)
        &#125;
        console.log(positions)  // [3,24,32,35,52]

3.4
//查看字符串里是否包含某个 字符串 或者字符
//有三种方法可以判断  
        let message = &quot;foobarbaz&quot;;
        console.log(message.startsWith(&quot;foo&quot;)); // true
        console.log(message.startsWith(&quot;bar&quot;)); // false
        console.log(message.endsWith(&quot;baz&quot;)); // true
        console.log(message.endsWith(&quot;bar&quot;)); // false
        console.log(message.includes(&quot;bar&quot;)); // true
        console.log(message.includes(&quot;qux&quot;)); // false 

//startsWith()检查开始于索引 0 的匹配项 
//endsWith()检查开始于索引(string.length - substring.length)的匹配项
//includes()检查整个字符串

//基本就是使用includes就完事了

3.5
//trim() 删除2边空格    原字符串不受到影响 返回一个新的字符串
        let stringValue = &quot; hello world &quot;;
        let trimmedStringValue = stringValue.trim();
        console.log(stringValue); // &quot; hello world &quot;
        console.log(trimmedStringValue); // &quot;hello world&quot; 

//扩展：
//trimLeft()和 trimRight()方法分别用于从字符串开始和末尾清理空格符。


3.6
//repeat()  复制多次字符串 原字符串不受影响  返回一个新的字符串
        let stringvalue = &#39;ha&#39;
        console.log(stringvalue.repeat(12).concat(&#39; yyyy&#39;)) 
// hahahahahahahahahahahaha yyyy


3.7
 //padStart()和 padEnd()方法会复制字符串，如果小于指定长度，则在相应一边填充字符，直至
//满足长度条件。这两个方法的第一个参数是长度，第二个参数是可选的填充字符串，默认为空格


3.8
// 字符串迭代与解构简单的运用，原理参考js高程
        let arr = []
        let str = &#39;asddd&#39;
        arr = [...str]
        console.log(arr)  //[&quot;a&quot;, &quot;s&quot;, &quot;d&quot;, &quot;d&quot;, &quot;d&quot;]

3.9
        //字符串大小转换
        let stringValue = &quot;hello world&quot;;
        console.log(stringValue.toLocaleUpperCase()); // &quot;HELLO WORLD&quot;
        console.log(stringValue.toUpperCase()); // &quot;HELLO WORLD&quot;
        console.log(stringValue.toLocaleLowerCase()); // &quot;hello world&quot;
        console.log(stringValue.toLowerCase()); // &quot;hello world&quot; 
/*原来就有的是 toUpperCase 和 toLowerCase ，但是在很多地区，地区特定的方法与通用的方法是一样的。但在少数语言中（如土耳其语），Unicode 大小写转换需应用特殊规则，要使用地区特定的方法才能实现正确转换。*/

//推荐使用 toLocaleUpperCase 和 toLocaleLowerCase

//记忆方法是一个是Up是向上 就是放大

3.10
//字符串替换  简单用法   
        let text = &quot;cat, bat, sat, fat&quot;;
        let result = text.replace(&quot;at&quot;, &quot;ond&quot;);
        console.log(result); // &quot;cond, bat, sat, fat&quot;  
            //配合正则表达式的高级用法
        result = text.replace(/a t/g, &quot;ond&quot;);
        console.log(result); // &quot;cond, bond, sond, fond&quot; 

3.11
//计算输入的字符个数
         getByteLen(val) &#123;
              var len = 0
              for (var i = 0; i &lt; val.length; i++) &#123;
                var a = val.charAt(i)
                if (a.match(/[^\x00-\xff]/gi) != null) &#123;
                  len += 2
                &#125; else &#123;
                  len += 1
                &#125;
              &#125;
              return len
            &#125;

3.12
        
//实现方法为将字符串按某个字符切割成若干个字符串，并以数组形式返回
        var s = &quot;abc,abcd,aaa&quot;;
        ss = s.split(&quot;,&quot;);// 在每个逗号(,)处进行分解  [&quot;abc&quot;, &quot;abcd&quot;, &quot;aaa&quot;]
        var s1 = &quot;helloworld&quot;;
        ss1 = s1.split(&#39;&#39;);  //[&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;, &quot;w&quot;, &quot;o&quot;, &quot;r&quot;, &quot;l&quot;, &quot;d&quot;]
</code></pre><h5 id="4：关于Number包装类型的处理"><a href="#4：关于Number包装类型的处理" class="headerlink" title="4：关于Number包装类型的处理"></a>4：关于Number包装类型的处理</h5><pre><code class="javascript">    
        let num1 = new Number(10.4545)
        let num2 = new Number(10)
        console.log(num1.toFixed(2)) //10.45  //表示返回2位小数,采用4舍5入
        console.log(num2.toFixed(2)) //10.00 
</code></pre><h5 id="5：关于Date时间处理"><a href="#5：关于Date时间处理" class="headerlink" title="5：关于Date时间处理"></a>5：关于Date时间处理</h5><pre><code class="javascript">// 创建时间类
        let time = new Date()   
        console.log(time)  // Sat Nov 14 2020 15:51:41 GMT+0800 (中国标准时间)
        console.log(Date.parse(new Date())) //使用Date.parse这个方法可以将其转化成 13位的时间戳
    

// 填入时间戳，得出天/时/分
        function DateDifference(faultDate, completeTime) &#123;
          // let d1 = new Date(faultDate);
          // let d2 = new Date(completeTime);
          var stime = new Date(faultDate).getTime();
          var etime = new Date(completeTime).getTime();
          var usedTime = etime - stime;  //两个时间戳相差的毫秒数
          var days = Math.floor(usedTime / (24 * 3600 * 1000));
          //计算出小时数
          var leave1 = usedTime % (24 * 3600 * 1000);    //计算天数后剩余的毫秒数
          var hours = Math.floor(leave1 / (3600 * 1000));
          //计算相差分钟数
          var leave2 = leave1 % (3600 * 1000);        //计算小时数后剩余的毫秒数
          var minutes = Math.floor(leave2 / (60 * 1000));
          var time = days + &quot;天&quot; + hours + &quot;时&quot; + minutes + &quot;分&quot;;
          //   var time = days;
          return time;
        &#125;
// 使用方法
        console.log( DateDifference(1597800343,1697900343) )


//时间戳转时间格式
        getdate() &#123;
           var now = new Date(),
           y = now.getFullYear(),
           m = now.getMonth() + 1,
           d = now.getDate()
           return y + &#39;-&#39; + (m &lt; 10 ? &#39;0&#39; + m : m) + &#39;-&#39; + (d &lt; 10 ? &#39;0&#39; + d : d) + &#39; &#39; +                             now.toTimeString().substr(0, 8)
         &#125;

</code></pre><h5 id="6：关于Math内置对象的处理"><a href="#6：关于Math内置对象的处理" class="headerlink" title="6：关于Math内置对象的处理"></a>6：关于Math内置对象的处理</h5><pre><code class="javascript">
2.1：
//Math对象属性  例如 Math.E  (自然对数的基数 e 的值)

2.2：	
//最大最小值
         let max = Math.max(3, 6, 5, 7)
         let min = Math.min(3, 4, 1, 5)

         console.log(max)  //7
         console.log(min)  //1 

//可以传入数组
        let values = [1, 2, 3, 4, 5, 6, 7, 8];
        let maxarr = Math.max(...values); 
        console.log(maxarr)

2.3：
        //舍入方法
        console.log(Math.ceil(25.9)); // 26
        console.log(Math.ceil(25.5)); // 26
        console.log(Math.ceil(25.1)); // 26
        console.log(Math.round(25.9)); // 26
        console.log(Math.round(25.5)); // 26
        console.log(Math.round(25.1)); // 25
        console.log(Math.fround(0.4)); // 0.4000000059604645
        console.log(Math.fround(0.5)); // 0.5
        console.log(Math.fround(25.9)); // 25.899999618530273
        console.log(Math.floor(25.9)); // 25
        console.log(Math.floor(25.5)); // 25
        console.log(Math.floor(25.1)); // 25 

//Math.ceil()方法始终向上舍入为最接近的整数
//Math.floor()方法始终向下舍入为最接近的整数
//Math.round()方法执行四舍五入
//Math.fround()方法返回数值最接近的单精度（32 位）浮点值表示


2.4
// 随机数
         let round = Math.random()  
//返回一个 0-1 范围内的随机数（0.9356889462950324），其中包含0但是不包含1

2.4.1
//返回一个 [a,b]中的随机数
        let bb = Math.round(Math.random()*b + a)
</code></pre><h5 id="7：数据类型检测"><a href="#7：数据类型检测" class="headerlink" title="7：数据类型检测"></a>7：数据类型检测</h5><pre><code class="javascript">(1)typeof  (2)instanceof  (3)constructor  (4)Object.prototype.toString.call()

1：在`JavaScript`里使用`typeof`判断数据类型，只能区分**基本类型**，即：`number`、`string`、`undefined`、`boolean`、`object`。

2：对于`null`、`array`、`function`、`object`来说，使用`typeof`都会统一返回`object`字符串。

3：要想区分对象、数组、函数、单纯使用`typeof`是不行的。在JS中，可以通过`Object.prototype.toString.call()`方法，判断某个对象之属于哪种内置类型。分为`null`、`string`、`boolean`、`number`、`undefined`、`array`、`function`、`object`、`date`、`math`。

4：constructor 本来是用于标识对象类型的。

5：一般认为 instanceof 操作符是确定对象类型 更可靠的方式。


    let obj = &#123;&#125;
    let num1 = 1
    console.log(typeof obj)   //object
    console.log(obj instanceof Object)  //true
    console.log(obj.constructor) //ƒ Object() &#123; [native code] &#125;
    console.log( Object.prototype.toString.call(1)) // [object Number]
    console.log(Object.prototype.toString.call(obj)) // [object Object]
</code></pre><h5 id="8：深浅拷贝"><a href="#8：深浅拷贝" class="headerlink" title="8：深浅拷贝"></a>8：深浅拷贝</h5><p>1：深浅拷贝的区别</p><p>首先要知道一点的就是，JavaScript的数据类型的分为基本数据类型和引用类型，</p><p>对于基本数据类型的拷贝，并没有深浅拷贝的区别，我们所说的深浅拷贝都是对于<strong>引用数据类型</strong>而言的</p><p><strong>浅拷贝的概念</strong></p><p>浅拷贝的意思就是只复制引用，而未复制真正的值。</p><pre><code class="javascript">       // 定义一个数组
       let arr = [1,2,3,4,5]
       // 定义一个对象
       let obj = &#123;a:&#39;a&#39;,b:&#39;b&#39;,c:[1,2,3,4,5],d:&#123;dd:&#39;dd&#39;&#125;&#125;
    
       //赋值这个数组给另一个变量
       let clonearr = arr
       //赋值这个数组给另一个对象
       let cloneobj = obj 

        // 打印一下拷贝的数据，嗯，是个原本来的一样的
       console.log(clonearr) // [1,2,3,4,5]
       console.log(cloneobj) // &#123;a:&#39;a&#39;,b:&#39;b&#39;,c:Array[3],d:&#123;dd:&#39;dd&#39;&#125;&#125;
    
        // 这个时候操作来了，我们给这个克隆的数组添加数据 克隆的对象也修改数据
        clonearr.push(6)
        cloneobj.a = &#123;aa:&#39;aa&#39;&#125;

        //打印2个数组   发现arr是和修改过的clonearr是一样的
        console.log(arr)  // [1,2,3,4,5,6]
        console.log(clonearr) // [1,2,3,4,5,6]

        //打印2个对象   发现obj是和修改过的cloneobj是一样的
        console.log(obj); // &#123;a:&#123;aa:&#39;aa&#39;&#125;,b:&#39;b&#39;,c:Array[3],d:&#123;dd:&#39;dd&#39;&#125;&#125;
        console.log(cloneobj); // &#123;a:&#123;aa:&#39;aa&#39;&#125;,b:&#39;b&#39;,c:Array[3],d:&#123;dd:&#39;dd&#39;&#125;&#125;
 
</code></pre><h6 id="1：深拷贝有哪些方式？"><a href="#1：深拷贝有哪些方式？" class="headerlink" title="1：深拷贝有哪些方式？"></a>1：深拷贝有哪些方式？</h6><pre><code class="javascript">深拷贝就是对目标的完全拷贝，不像浅拷贝那样只是复制了一层引用，就连值也都复制了。

只要进行了深拷贝，它们老死不相往来，谁也不会影响谁。

目前实现深拷贝的方法不多，主要是两种：

1. 利用 `JSON` 对象中的 `parse` 和 `stringify`
2. 利用递归来实现每一层都重新创建对象并赋值

`JSON.stringify` 是将一个 `JavaScript` 值转成一个 `JSON` 字符串。

`JSON.parse` 是将一个 `JSON` 字符串转成一个 `JavaScript` 值或对象。
</code></pre><p><strong>使用JSON.stringify(obj)的缺点</strong></p><pre><code class="javascript">   确实是深拷贝，也很方便。但是，这个方法只能适用于一些简单的情况。比如下面这样的一个对象就不适用：   
const obj = &#123;
          name:&#39;gsq&#39;,
          hello:function()&#123;
              console.log(&#39;gsq&#39;);
          &#125;
      &#125;

      const cloneobj = JSON.parse(JSON.stringify(obj))

      console.log(obj) // &#123;name: &quot;gsq&quot;, hello: ƒ&#125;
      console.log(cloneobj) //  &#123;name: &quot;gsq&quot;&#125;
</code></pre><p><strong>注意</strong>：使用 JSON.parse(JSON.stringify(obj)) 进行深拷贝 对 <code>undefined</code>、<code>function</code>、<code>symbol</code> 会在转换过程中被忽略。。。</p><p><strong>递归的方法</strong></p><p>递归的思想就很简单了，就是对每一层的数据都实现一次 <code>创建对象-&gt;对象赋值</code> 的操作，简单粗暴上代码：</p><p><strong>这种方式就不存在<code>undefined</code>、<code>function</code>、<code>symbol</code> 被忽略了</strong></p><pre><code class="javascript">function deepClone(source)&#123;
  const targetObj = source.constructor === Array ? [] : &#123;&#125;; // 判断复制的目标是数组还是对象
  for(let keys in source)&#123; // 遍历目标
    if(source.hasOwnProperty(keys))&#123;
      if(source[keys] &amp;&amp; typeof source[keys] === &#39;object&#39;)&#123; // 如果值是对象，就递归一下
        targetObj[keys] = source[keys].constructor === Array ? [] : &#123;&#125;;
        targetObj[keys] = deepClone(source[keys]);
      &#125;else&#123; // 如果不是，就直接赋值
        targetObj[keys] = source[keys];
      &#125;
    &#125; 
  &#125;
  return targetObj;
&#125;
</code></pre><h6 id="2：浅拷贝有哪些方式"><a href="#2：浅拷贝有哪些方式" class="headerlink" title="2：浅拷贝有哪些方式"></a>2：浅拷贝有哪些方式</h6><p>1：concat</p><pre><code class="javascript">        const arr = [1,2,3,4,5];
        const clonearr = arr.concat();
console.log(arr === clonearr)  // false
</code></pre><p>2：slice</p><pre><code class="javascript">    let arr1 = [1,2,3,4]
    let arr2 = arr1.slice()
console.log(arr1 === arr2) //false
</code></pre><p>3：es6之 <code>Object.assign()</code></p><pre><code class="javascript">    let obj = &#123;&#39;a&#39; : 1, &#39;b&#39; : 2&#125;
    let cloneobj = Object.assign(&#123;&#125;,obj)
console.log(obj === cloneobj) //false    
</code></pre><p>4：es6扩展运算符 …</p><pre><code class="javascript">        let arr = [1,2,3,4]
        let clonearr = [...arr]
console.log(arr === clonearr) //false
</code></pre><p>5：es6 from方法</p><pre><code class="javascript">        const a1 = [1, 2, 3, 4];
        const a2 = Array.from(a1); 
console.log(a1 === a2) //false
</code></pre><p>6：使用map方法</p><pre><code class="javascript">        const arr = [1,2,3,4]
        let clonearr = arr.map(item =&gt; item)
console.log(arr === clonearr)
</code></pre><p>7：自定义函数浅拷贝</p><pre><code class="javascript">function shallowClone(source) &#123;
  const targetObj = source.constructor === Array ? [] : &#123;&#125;; // 判断复制的目标是数组还是对象
  for (let keys in source) &#123; // 遍历目标
    if (source.hasOwnProperty(keys)) &#123;
      targetObj[keys] = source[keys];
    &#125;
  &#125;
  return targetObj;
&#125;
</code></pre><p><strong>总结</strong>：</p><ol><li>赋值运算符 <code>=</code> 实现的是浅拷贝，只拷贝对象的引用值；</li><li>JavaScript 中数组和对象自带的拷贝方法都是“首层深拷贝”；</li><li><code>JSON.stringify</code> 实现的是深拷贝，但是对目标对象有要求，转化的值不能是<code>function</code>，<code>undefined</code>，<code>symbol</code> ；</li><li>若想真正意义上的深拷贝，请递归。</li></ol><h1 id="二：作用域以及变量"><a href="#二：作用域以及变量" class="headerlink" title="二：作用域以及变量"></a>二：作用域以及变量</h1><h5 id="2：变量声明提升"><a href="#2：变量声明提升" class="headerlink" title="2：变量声明提升"></a>2：变量声明提升</h5><p><strong>只有var会存在变量提升</strong></p><pre><code class="javascript">       var a = 1;
       var b = 2;
       var c = 4;
       a = b = c ;  //相当于  a = c    b = c
       console.log(a) //4
       console.log(b) //4
       console.log(c) //4
       console.log(a = b = c) //4
</code></pre><pre><code class="javascript">        var foo = 1;
        function bar() &#123;
            if (!foo) &#123;
                var foo = 10;
            &#125;
            alert(foo);
        &#125;
         bar();   //输出什么?

解析过程：
        //1:首先会预解析 ：注意函数比变量优先级高
        function bar()&#123;
            var foo;   //这里此时foo没有被赋值 是undefined
            if(!foo) &#123; //!undefined == true
                var foo; 
                foo = 10
            &#125;  //到这里后foo被赋值为10
            alert(foo)
        &#125;
        var foo;
        foo = 1;
        bar()  // 10
</code></pre><pre><code class="javascript">        var num = 123;
        function f1(num) &#123;
            console.log(num); 
        &#125;
        function f2() &#123;
            var num = 456;
            f1(num);
        &#125;
        f2();

解析过程：
        //1:首先会预解析 ：注意函数比变量优先级高
        function f1(num)&#123;
            console.log(num)
        &#125;
        function f2()&#123;  //执行f2函数
            var num; //声明num
            num = 456; //赋值456
            f1(num) //执行f1函数 。传入num的值456 ，打印456
        &#125;

        var num;
        num = 123;
        f2()
</code></pre><pre><code class="javascript">        function fn()&#123;
           var a = 1, b = 1, c = 1;
         &#125;
         fn();
         console.log(c); 
         console.log(b);
         console.log(a); 

解析过程：
        //  1:预解析
        function fn()&#123;
            var a,b,c;
            a = 1, b = 1, c = 1;
        &#125;
        // 执行fn函数  因为作用域链是从里往外查询
        // 分别输出cba 直接在c这一行报错
        // 原因:
        //js是解释型语言，执行一行解释一行，发现报错就停止执行
        //因为作用域链是从里往外查询 此时输出cba的环境已经是最大的windows环境了
</code></pre><pre><code class="javascript">        function fn1()&#123;
           var a = b = c = 1;
         &#125;
         fn1();
         console.log(c); 
         console.log(b); 
         console.log(a); 

解析过程：
         //1:预解析
         function fn1()&#123;
             var a = 1;
             b = 1;  
             c = 1; 
         &#125;  //对于局部函数变量里面没有声明var的变量  都是全局变量
         console.log(c);  //1 
         console.log(b);  //1
         console.log(a);  // Uncaught ReferenceError: a is not defined
</code></pre><pre><code class="javascript">        var a = 1;
        function fn()&#123;
            var a = 2;
            function fnSon(a)&#123;
                a = 3;
                console.log(a); 
            &#125;
            fnSon();
            console.log(a);  
        &#125;
        console.log(a);  
        fn();
        console.log(a); 

解析过程：
        //预解析
        function fn()&#123;
            function fnSon(a)&#123;
                a = 3; //a没有定义var是全局变量
                console.log(a) //直接得到当前作用域的值 3
            &#125;
            var a; //跟fnSon函数同一作用预的变量a
            a = 2; //a赋值2
            fnSon(); //此时fnSon并未传入参数a ,直接执行fnSon 
            console.log(a) //得到当前作用域的值 2
        &#125;
        var a;
        a = 1;
        console.log(a) //直接得到全局变量 1
        fn(); //执行fn函数 
        console.log(a)  //
</code></pre><pre><code class="javascript">        var a ;
        function a()&#123;
            console.log(&#39;呵呵&#39;)
            function a()&#123;
                a = 4;
                console.log(&#39;哈哈&#39;)
            &#125;
            a();
            console.log(a);
        &#125;
        a();
        console.log(a);

解析过程:
        //预解析
        function a()&#123;
            console.log(&#39;呵呵&#39;) //注意啦:  打印不存在变量提升
            function a()&#123;
                a = 4; //全局变量a
                console.log(&#39;哈哈&#39;)  //哈哈
            &#125;
            a() 
            console.log(a) // 取得当前同级作用域的 4 
        &#125;
        var a;
        a()
        console.log(a) //函数a //此时函数a取代了 a 函数
</code></pre><pre><code class="javascript">        var value = &#39;hello&#39;;
        function show() &#123;
            alert(value);
            if (!value) &#123;
                var value = &#39;function&#39;;
            &#125;
            alert(value);
        &#125;
        show() 


解析过程：
        // 预解析
        var value;
        value = &#39;hello&#39;
        function show() &#123;
            var value;  //undefined
            alert(value) 
            if(!value)&#123;  //!undnefined  = true
                value = &#39;function&#39; 
            &#125;
            alert(value)       
        &#125;
        show()  //此处调用函数依次弹出 &quot;undefined&quot;, &quot;function&quot;
</code></pre><h5 id="3：作用域链"><a href="#3：作用域链" class="headerlink" title="3：作用域链"></a>3：作用域链</h5><p>作用域分为<strong>全局作用域</strong>和<strong>函数作用域</strong></p><table><thead><tr><th>作用域</th><th>意义</th></tr></thead><tbody><tr><td>函数作用域</td><td>在固定的代码片段才能被访问</td></tr><tr><td>全局作用域</td><td>代码在程序的任何地方都能被访问，window 对象的内置属性都拥有全局作用域。</td></tr></tbody></table><pre><code class="javascript">        var a = 10, b = 20;  //全局作用域
        function fn() &#123;
            var a = 100, c = 300; //fn作用域
            console.log(a);
            function bar() &#123;  
                var a = 1000, d = 4000  //bar作用域
                console.log(a);
            &#125;
        &#125;
        bar()

作用域特点：
作用域有上下级关系，上下级关系的确定就看函数是在哪个作用域下创建的。如上，fn作用域下创建了bar函数，那么“fn作用域”就是“bar作用域”的上级。   

作用域用处：
作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。

变量取值：
到创建 这个变量 的函数的作用域中取值
</code></pre><p>作用域链</p><pre><code class="javascript">        var x = 10;

        function fn() &#123;
            console.log(x);
        &#125;

        function show(f) &#123;
            var x = 20;
            (function () &#123;
                f();    // 10
            &#125;)()
        &#125;

        show(fn);
1：一般情况下，变量取值到 创建 这个变量 的函数的作用域中取值。
    
2：但是如果在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链。
</code></pre><h5 id="4：闭包（closure）"><a href="#4：闭包（closure）" class="headerlink" title="4：闭包（closure）"></a>4：闭包（closure）</h5><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>特点</td><td>1：外部访问函数内部变成可能（我们知道作用域链，是只能里面一层一层访问到外面，但是，外部不能访问内部）2：局部变量常驻在内存中 3：可以避免使用全局变量，防止全局变量污染 4：缺点是会造成内存泄漏（有一块内存空间长期被占用，而不被释放）</td></tr><tr><td>概念</td><td><strong>闭包函数：</strong>声明在一个函数中的函数，叫做闭包函数。<strong>闭包：</strong>内部函数总是可以访问其所在的外部函数中声明的参数和变量，即使在其外部函数被返回（寿命终结）了之后。</td></tr></tbody></table><p>闭包的创建</p><pre><code class="javascript">example 1
        function funA() &#123;
            var a = 10;  // funA的活动对象之中;
            return function () &#123;   //匿名函数的活动对象;
                alert(a);
            &#125;
        &#125;
        var b = funA();
        b();  //10
</code></pre><pre><code class="javascript">example 2
        function outerFn() &#123;
            var i = 0;
            function innerFn() &#123;
                i++;
                console.log(i);
            &#125;
            return innerFn;
        &#125;
        var inner = outerFn();  //每次外部函数执行的时候,都会开辟一块内存空间,外部函数的地址不同，都会重新创建一个新的地址
        inner();
        inner();
        inner();
        var inner2 = outerFn();
        inner2();
        inner2();
        inner2();   //1 2 3 1 2 3
</code></pre><pre><code class="javascript">example 3
        var i = 0;
        function outerFn() &#123;
            function innnerFn() &#123;
                i++;
                console.log(i);
            &#125;
            return innnerFn;
        &#125;
        var inner1 = outerFn();
        var inner2 = outerFn();
        inner1();
        inner2();      //同一个地址变量每调用一次  i+1 
        inner1();
        inner2();     //1 2 3 4
</code></pre><pre><code class="javascript">example 4
        function fn() &#123;
            var a = 3;
            return function () &#123;
                return ++a;
            &#125;
        &#125;
        alert(fn()());  //4   
        alert(fn()());  //4 
    //并没有创建地址变量去保存
</code></pre><pre><code class="javascript">example 5
        function outerFn() &#123;
            var i = 0;
            function innnerFn() &#123;
                i++;
                console.log(i);
            &#125;
            return innnerFn;
        &#125;
        var inner1 = outerFn();
        var inner2 = outerFn();
        inner1();
        inner2();
        inner1();
        inner2();    //1 1 2 2
</code></pre><pre><code class="javascript">example 6
        (function () &#123;   //自调用函数
            var m = 0;
            function getM() &#123; return m; &#125; 
            function seta(val) &#123; m = val; &#125; 
            window.g = getM;  //window是最高级的对象  添加windows下一个g的一个键值  值为 getM
            window.f = seta; 
        &#125;)();
        f(100);
        console.info(g());   //100  闭包找到的是同一地址中父级函数中对应变量最终的值
</code></pre><pre><code class="javascript">example 7
        function a() &#123;
            var i = 0;
            function b() &#123; alert(++i); &#125;
            return b;
        &#125;
        var c = a();   //函数的赋值是引用类型的
        c();      //1 
        c();      //2
</code></pre><pre><code class="javascript">example 8
        function f() &#123;
            var count = 0;
            return function () &#123;
                count++;
                console.info(count);
            &#125;
        &#125;
        var t1 = f();
        t1();     //1 
        t1();     //2 
        t1();     //3 
</code></pre><pre><code class="javascript">example 9
        var add = function (x) &#123;
            var sum = 1;
            var tmp = function (x) &#123;
                sum = sum + x;
                return tmp;
            &#125;
            tmp.toString = function () &#123;
                return sum;
            &#125;
            return tmp;
        &#125;
        alert(add(1)(2)(3));     //6
</code></pre><pre><code class="javascript">example 10
        var lis = document.getElementsByTagName(&quot;li&quot;);
        for (var i = 0; i &lt; lis.length; i++) &#123;
            (function (i) &#123;
                lis[i].onclick = function () &#123;
                    console.log(i);
                &#125;;
            &#125;)(i);       //事件处理函数中闭包的写法
        &#125;
</code></pre><pre><code class="javascript">example 11
        function m1() &#123;
            var x = 1;
            return function () &#123;
                console.log(++x);
            &#125;
        &#125;

        m1()();   //2
        m1()();   //2
        m1()();   //2

        var m2 = m1();
        m2();   //2
        m2();   //3
        m2();   //4
   //一个是有变量地址的，一个是没有的 ，有的才会保存
</code></pre><pre><code class="javascript">example 12
        var fn = (function () &#123;
            var i = 10;
            function fn() &#123;
                console.log(++i);
            &#125;
            return fn;
        &#125;)()
        fn();   //11
        fn();   //12
</code></pre><pre><code class="javascript">example 13
        function love1() &#123;
            var num = 223;
            var me1 = function () &#123;
                console.log(num);
            &#125;
            num++;
            return me1;
        &#125;
        var loveme1 = love1();
        loveme1();   //输出224
预解析：
        function love1() &#123;
            var num;
            var me1;
            me1 = function()&#123;
                console.log(num)
            &#125;
            num = 233
            num ++;
            return me1;
        &#125;
        var loveme1 = love1();
        loveme1();   //输出224
</code></pre><pre><code class="javascript">example 14
        function fun(n, o) &#123;
            console.log(o);
            return &#123;
                fun: function (m) &#123;
                    return fun(m, n);
                &#125;
            &#125;;
        &#125;
        var a = fun(0);  //undefined
        a.fun(1);  //0  
        a.fun(2);  //0  
        a.fun(3);  //0  
        var b = fun(0).fun(1).fun(2).fun(3);   //undefined  0  1  2
        var c = fun(0).fun(1);
        c.fun(2);
        c.fun(3);  //undefined  0  1  1
</code></pre><pre><code class="javascript">example 15
        function fn() &#123;
            var arr = [];
            for (var i = 0; i &lt; 5; i++) &#123;
                arr[i] = function () &#123;
                    return i;
                &#125;
            &#125;
            return arr;
        &#125;
        var list = fn();
        for (var i = 0, len = list.length; i &lt; len; i++) &#123;
            console.log(list[i]());
        &#125;  //5 5 5 5 5
</code></pre><pre><code class="javascript">example 16
        function fn() &#123;
            var arr = [];
            for (var i = 0; i &lt; 5; i++) &#123;
                arr[i] = (function (i) &#123;
                    return function () &#123;
                        return i;
                    &#125;;
                &#125;)(i);
            &#125;
            return arr;
        &#125;
        var list = fn();
        for (var i = 0, len = list.length; i &lt; len; i++) &#123;
            console.log(list[i]());
        &#125;  //0 1 2 3 4
</code></pre><h1 id="三：JavaScript创建对象"><a href="#三：JavaScript创建对象" class="headerlink" title="三：JavaScript创建对象"></a>三：JavaScript创建对象</h1><h5 id="1：js创建对象的几种方式的优缺点"><a href="#1：js创建对象的几种方式的优缺点" class="headerlink" title="1：js创建对象的几种方式的优缺点"></a>1：js创建对象的几种方式的优缺点</h5><pre><code class="javascript">1:工厂模式
        function createPerson(name, age, job) &#123;
            let o = new Object();
            o.name = name;
            o.age = age;
            o.job = job;
            o.sayName = function () &#123;
                console.log(this.name);
            &#125;;
            return o;
        &#125;
        let person1 = createPerson(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);
        let person2 = createPerson(&quot;Greg&quot;, 27, &quot;Doctor&quot;);
        console.log(person1.isPrototypeOf == person2.isPrototypeOf); //true

//敲重点一：
这里，函数 createPerson()接收 3 个参数，根据这几个参数构建了一个包含 Person 信息的对象。
可以用不同的参数多次调用这个函数，每次都会返回包含 3 个属性和 1 个方法的对象。这种工厂模式虽
然可以解决创建多个类似对象的问题，但没有解决对象标识问题（即新创建的对象是什么类型）。
</code></pre><pre><code class="javascript">2:构造函数模式
        function Person(name, age, job) &#123;
            this.name = name;
            this.age = age;
            this.job = job;
            this.sayName = function () &#123;
                console.log(this.name);
            &#125;;
        &#125;
        let person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);
        let person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);
        person1.sayName(); // Nicholas
        person2.sayName(); // Greg 
        console.log(person1.isPrototypeOf == person2.isPrototypeOf) //true
        console.log(person1.sayName == person2.sayName);  //false    

//敲重点一：
实际上，Person()内部的代码跟 createPerson()基本是一样的，只是有如下区别。
1: 没有显式地创建对象没有 return
2: 属性和方法直接赋值给了 this
3: 没有 return

//敲重点二：
构造函数名称的首字母都是要大写的，非构造函数则以小写字母开头。
有助于在 ECMAScript 中区分构造函数和普通函数。毕竟 ECMAScript 的构造函数就是能创建对象的函数。

//敲重点三：
要创建 Person 的实例，应使用 new 操作符。以这种方式调用构造函数会执行如下操作。
1: 在内存中创建一个新对象。
2: 这个新对象内部的[[Prototype]]特性被赋值为构造函数的 prototype 属性。
3: 构造函数内部的 this 被赋值为这个新对象（即 this 指向新对象）。
4: 执行构造函数内部的代码（给新对象添加属性）。
5: 如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。

//敲重点四：
person1 和 person2 分别保存着 Person 的不同实例。这两个对象都有一个 constructor 属性指向 Person，
console.log(person1.constructor == Person); // true
console.log(person2.constructor == Person); // true 
constructor 本来是用于标识对象类型的。不过，一般认为 instanceof 操作符是确定对象类型
更可靠的方式。前面例子中的每个对象都是 Object 的实例，同时也是 Person 的实例，如下面调用
instanceof 操作符的结果所示：
console.log(person1 instanceof Object); // true
console.log(person1 instanceof Person); // true
console.log(person2 instanceof Object); // true
console.log(person2 instanceof Person); // true 
定义自定义构造函数可以确保实例被标识为特定类型，相比于工厂模式，这是一个很大的好处。在
这个例子中，person1 和 person2 之所以也被认为是 Object 的实例，是因为所有自定义对象都继承自 Object

//敲重点五：
构造函数不一定要写成函数声明的形式。赋值给变量的函数表达式也可以表示构造函数：
        let Person = function (name, age, job) &#123;
            this.name = name;
            this.age = age;
            this.job = job;
            this.sayName = function () &#123;
                console.log(this.name);
            &#125;;
        &#125;
let person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);
let person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);
person1.sayName(); // Nicholas
person2.sayName(); // Greg
console.log(person1 instanceof Object); // true
console.log(person1 instanceof Person); // true
console.log(person2 instanceof Object); // true
console.log(person2 instanceof Person); // true 

//敲重点六：
在实例化时，如果不想传参数，那么构造函数后面的括号可加可不加。只要有 new 操作符，就可以调用相应的构造函数：
        function Person() &#123;
            this.name = &quot;Jake&quot;;
            this.sayName = function () &#123;
                console.log(this.name);
            &#125;;
        &#125;
        let person1 = new Person();
        let person2 = new Person;

        person1.sayName(); // Jake
        person2.sayName(); // Jake
        console.log(person1 instanceof Object); // true
        console.log(person1 instanceof Person); // true
        console.log(person2 instanceof Object); // true
        console.log(person2 instanceof Person); // true

//敲重点七： 构造函数也是函数
构造函数与普通函数唯一的区别就是调用方式不同。除此之外，构造函数也是函数。并没有把某个
函数定义为构造函数的特殊语法。任何函数只要使用 new 操作符调用就是构造函数，而不使用 new 操
作符调用的函数就是普通函数。比如，前面的例子中定义的 Person()可以像下面这样调用：

为啥都是大写，因为这样可以区别于普通的函数，一目了然的就知道这是构造函数


//敲重点八：构造函数的问题（优化构造函数）
构造函数虽然有用，但也不是没有问题。构造函数的主要问题在于，其定义的方法会在每个实例上
都创建一遍。因此对前面的例子而言，person1 和 person2 都有名为 sayName()的方法，但这两个方
法不是同一个 Function 实例。我们知道，ECMAScript 中的函数是对象，因此每次定义函数时，都会
初始化一个对象

逻辑上讲，这个构造函数实际上是这样的：
 function Person(name, age, job) &#123;
            this.name = name;
            this.age = age;
            this.job = job;
            this.sayName = new Function(&quot;console.log(this.name)&quot;); // 逻辑等价
        &#125;
这样理解这个构造函数可以更清楚地知道，每个 Person 实例都会有自己的 Function 实例用于显
示 name 属性。当然了，以这种方式创建函数会带来不同的作用域链和标识符解析。但创建新 Function
实例的机制是一样的。因此不同实例上的函数虽然同名却不相等，如下所示：
console.log(person1.sayName == person2.sayName); // false 

怎么优化呢?
    函数定义转移到构造函数外部
        function Person(name, age, job) &#123;
            this.name = name;
            this.age = age;
            this.job = job;
            this.sayName = sayName;
        &#125;
        function sayName() &#123;
            console.log(this.name);
        &#125;
        let person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);
        let person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);
        person1.sayName(); // Nicholas
        person2.sayName(); // Greg 
    
在这里，sayName()被定义在了构造函数外部。在构造函数内部，sayName 属性等于全局 sayName()函数。因为这一次 sayName 属性中包含的只是一个指向外部函数的指针，所以 person1 和 person2共享了定义在全局作用域上的 sayName()函数。这样虽然解决了相同逻辑的函数重复定义的问题，但全局作用域也因此被搞乱了，因为那个函数实际上只能在一个对象上调用。如果这个对象需要多个方法，那么就要在全局作用域中定义多个函数。这会导致自定义类型引用的代码不能很好地聚集一起。这个新问题可以通过原型模式来解决。
</code></pre><h5 id="2：原型模式创建对象（重点部分单独分离出来）"><a href="#2：原型模式创建对象（重点部分单独分离出来）" class="headerlink" title="2：原型模式创建对象（重点部分单独分离出来）"></a>2：原型模式创建对象（重点部分单独分离出来）</h5><pre><code class="javascript">//敲重点一：为啥出现原型模式创建对象?
这样虽然解决了相同逻辑的函数重复定义的问题，但全局作用域也因此被搞乱了，因为那个函数实际上只能在一个对象上调用。如果这个对象需要多个方法，那么就要在全局作用域中定义多个函数。这会导致自定义类型引用的代码不能很好地聚集一起。这个新问题可以通过原型模式来解决。

        function Person() &#123; &#125;
        //也可以使用函数表达式的方式创建对象
        //  let Person = function() &#123;&#125;; 
    
        Person.prototype.name = &quot;Nicholas&quot;;
        Person.prototype.age = 29;
        Person.prototype.job = &quot;Software Engineer&quot;;
        Person.prototype.sayName = function () &#123;
            console.log(this.name);
        &#125;;
        let person1 = new Person();
        person1.sayName(); // &quot;Nicholas&quot;
        let person2 = new Person();
        person2.sayName(); // &quot;Nicholas&quot;
        console.log(person1.sayName == person2.sayName); // true
这里，所有属性和 sayName()方法都直接添加到了 Person 的 prototype 属性上，构造函数体中什么也没有。但这样定义之后，调用构造函数创建的新对象仍然拥有相应的属性和方法。与构造函数模式不同，使用这种原型模式定义的属性和方法是由所有实例共享的。因此 person1 和 person2 访问的都是相同的属性和相同的 sayName()函数。要理解这个过程，就必须理解 ECMAScript 中原型的本质。 



//敲重点二：理解原型
无论何时，只要创建一个函数，就会按照特定的规则为这个函数创建一个 prototype 属性（指向原型对象）。默认情况下，所有原型对象自动获得一个名为 constructor 的属性，指回与之关联的构造函数。对前面的例子而言，Person.prototype.constructor 指向 Person。然后，因构造函数而异，可能会给原型对象添加其他属性和方法。

在自定义构造函数时，原型对象默认只会获得 constructor 属性，其他的所有方法都继承自Object。每次调用构造函数创建一个新实例，这个实例的内部[[Prototype]]指针就会被赋值为构造函数的原型对象。脚本中没有访问这个[[Prototype]]特性的标准方式，但 Firefox、Safari 和 Chrome会在每个对象上暴露__proto__属性，通过这个属性可以访问对象的原型。在其他实现中，这个特性完全被隐藏了。关键在于理解这一点：实例与构造函数原型之间有直接的联系，但实例与构造函数之间没有。

1:构造函数可以是函数表达式, 也可以是函数声明
2:声明之后，构造函数就有了一个 与之关联的原型对象
3:如前所述，构造函数有一个 prototype 属性 引用其原型对象，而这个原型对象也有一个 constructor 属性，引用这个构造函数 换句话说，两者循环引用
4: 正常的原型链都会终止于 Object 的原型对象,Object 原型的原型是 null
5:构造函数、原型对象和实例是 3 个完全不同的对象
6:实例通过__proto__链接到原型对象 它实际上指向隐藏特性[[Prototype]] 构造函数通过 prototype 属性链接到原型对象 实例与构造函数没有直接联系，与原型对象有直接联系
7: 同一个构造函数创建的两个实例 共享同一个原型对象：


//敲重点三：相关API
1：
使用 isPrototypeOf()方法确定两个对象之间的这种关系
本质上，isPrototypeOf()会在传入参数的[[Prototype]]指向调用它的对象时返回 true
//说白了就是判断当前的实例对象是不是指向当前的原型
console.log(Person.prototype.isPrototypeOf(person1)); // true
console.log(Person.prototype.isPrototypeOf(person2)); // true 

2：
ECMAScript的Object 类型有一个方法叫 Object.getPrototypeOf()，返回参数的内部特性[[Prototype]]的值 
//说白了，就是获取当前实例的原型对象
console.log(Object.getPrototypeOf(person1) == Person.prototype); // true
console.log(Object.getPrototypeOf(person1).name); // &quot;Nicholas&quot;

3:
Object 类型还有一个 setPrototypeOf()方法，可以向实例的私有特性[[Prototype]]写入一
个新值。这样就可以重写一个对象的原型继承关系
        let biped = &#123;
            numLegs: 2
        &#125;;
        let person = &#123;
            name: &#39;Matt&#39;
        &#125;;
        Object.setPrototypeOf(person, biped);
        console.log(person.name); // Matt
        console.log(person.numLegs); // 2
        console.log(Object.getPrototypeOf(person) === biped); // true
//但是不建议这样做，会严重影响性能

4:
为避免使用 Object.setPrototypeOf()可能造成的性能下降，可以通过 Object.create()来创建一个新对象，同时为其指定原型
        let biped = &#123;
            numLegs: 2
        &#125;;
        let person = Object.create(biped);
        person.name = &#39;Matt&#39;;
        console.log(person.name); // Matt
        console.log(person.numLegs); // 2
        console.log(Object.getPrototypeOf(person) === biped); // true


//敲重点四：原型层级
说白了就是 构造函数创造出来的实例 访问属性或者方法 会先从构造函数里面寻找，如果找不到会到原型里面找
</code></pre><h1 id="四：JavaScript继承"><a href="#四：JavaScript继承" class="headerlink" title="四：JavaScript继承"></a>四：JavaScript继承</h1><h5 id="1：原型链"><a href="#1：原型链" class="headerlink" title="1：原型链"></a>1：原型链</h5><pre><code class="javascript">//敲重点一： 什么是原型链
原型链是ECMAScript的主要继承方式

其基本思想就是通过原型继承多个引用
类型的属性和方法。重温一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型有一个属性指回构造函数，而实例有一个内部指针指向原型。如果原型是另一个类型的实例呢？那就意味着这个原型本身有一个内部指针指向另一个原型，相应地另一个原型也有一个指针指向另一个构造函数。这样就在实例和原型之间构造了一条原型链。这就是原型链的基本构想。
</code></pre><h5 id="1：js如何实现继承-ES6类的原理"><a href="#1：js如何实现继承-ES6类的原理" class="headerlink" title="1：js如何实现继承(ES6类的原理)"></a>1：js如何实现继承(ES6类的原理)</h5><pre><code class="javascript">原型链继承

盗用构造函数继承

组合继承

原型式继承

寄生式继承

寄生组合继承
</code></pre><h5 id="2：ES6类"><a href="#2：ES6类" class="headerlink" title="2：ES6类"></a>2：ES6类</h5><pre><code class="javascript">//敲重点一： 为什么出现类的概念
因为通过原型链和构造函数虽然能是实现继承，各种继承策略都有自己的问题，也有相应的妥协 但是代码也显得非常冗长和混乱。   

为解决这些问题，ECMAScript 6 新引入的 class 关键字具有正式定义类的能力。类（class）是ECMAScript 中新的基础性语法糖结构。虽然 ECMAScript 6 类表面上看起来可以支持正式的面向对象编程，但实际上它背后使用的仍然是原型和构造函数的概念

//敲重点二： 怎么定义一个类
class Person &#123;&#125;  //类声明
或者
const Animal = class &#123;&#125;;  //类表达式

与函数表达式类似，类表达式在它们被求值前也不能引用。
与函数定义不同的是，虽然函数声明可以提升，但类定义不能

//敲重点三：类可以由哪些构成
构造函数方法、实例方法、获取函数、设置函数和静态类方法
1.构造函数方法 constructor ，每当创建实例的时候都会执行
2.实例方法  就是定义在原型上的方法，是每个实例都共享的
3.静态方法  直接用类点静态方法调用，（注意，实例是不能调用的）
静态方法很适合返回实例工厂
        class Person &#123;
            constructor(age) &#123;
                this.age_ = age;
            &#125;
            sayAge() &#123;
                console.log(this.age_);
            &#125;
            static create() &#123;
                // 使用随机年龄创建并返回一个 Person 实例
                return new Person(Math.floor(Math.random() * 100));
            &#125;
        &#125;
        console.log(Person.create()); // Person &#123; age_: ... &#125;

//敲重点四：继承
ES6 类支持单继承。使用 extends 关键字，就可以继承任何拥有[[Construct]]和原型的对象。很大程度上，这意味着不仅可以继承一个类，也可以继承普通的构造函数（保持向后兼容）
</code></pre><h1 id="五：new，this"><a href="#五：new，this" class="headerlink" title="五：new，this"></a>五：new，this</h1><h5 id="1：new操作符具体干了什么"><a href="#1：new操作符具体干了什么" class="headerlink" title="1：new操作符具体干了什么"></a>1：new操作符具体干了什么</h5><pre><code class="javascript">1：在内存中创建一个新对象
2：这个对象内部的[[Prototype]]特性被赋值为构造函数的protopype属性
3：构造函数的内部的this被赋值为这个新对象（即this指向新对象）
4：执行构造函数内部的代码（给新对象添加属性）
5：如果构造函数返回非空对象，则返回该对象；否则返回刚创建的新对象
</code></pre><h5 id="2：new的模拟实现"><a href="#2：new的模拟实现" class="headerlink" title="2：new的模拟实现"></a>2：new的模拟实现</h5><h5 id="3：this对象的理解"><a href="#3：this对象的理解" class="headerlink" title="3：this对象的理解"></a>3：this对象的理解</h5><h1 id="六：call-x2F-apply-x2F-bind"><a href="#六：call-x2F-apply-x2F-bind" class="headerlink" title="六：call&#x2F;apply&#x2F;bind"></a>六：call&#x2F;apply&#x2F;bind</h1><h5 id="1：call-x2F-apply-x2F-bind"><a href="#1：call-x2F-apply-x2F-bind" class="headerlink" title="1：call&#x2F;apply&#x2F;bind"></a>1：call&#x2F;apply&#x2F;bind</h5><h5 id="2：call和apply的模拟实现"><a href="#2：call和apply的模拟实现" class="headerlink" title="2：call和apply的模拟实现"></a>2：call和apply的模拟实现</h5><h5 id="3：bind的模拟实现"><a href="#3：bind的模拟实现" class="headerlink" title="3：bind的模拟实现"></a>3：bind的模拟实现</h5><h1 id="七：事件"><a href="#七：事件" class="headerlink" title="七：事件"></a>七：事件</h1><h5 id="1：事件流"><a href="#1：事件流" class="headerlink" title="1：事件流"></a>1：事件流</h5><h5 id="2：事件的三个阶段"><a href="#2：事件的三个阶段" class="headerlink" title="2：事件的三个阶段"></a>2：事件的三个阶段</h5><h5 id="3：事件的代理有何委托"><a href="#3：事件的代理有何委托" class="headerlink" title="3：事件的代理有何委托"></a>3：事件的代理有何委托</h5><h5 id="4：如何派发事件"><a href="#4：如何派发事件" class="headerlink" title="4：如何派发事件"></a>4：如何派发事件</h5><h1 id="八：event-loop"><a href="#八：event-loop" class="headerlink" title="八：event loop"></a>八：event loop</h1><h5 id="1：进程和线程"><a href="#1：进程和线程" class="headerlink" title="1：进程和线程"></a>1：进程和线程</h5><h5 id="2：执行栈"><a href="#2：执行栈" class="headerlink" title="2：执行栈"></a>2：执行栈</h5><h5 id="3：为什么js是单线程，而不是多线程"><a href="#3：为什么js是单线程，而不是多线程" class="headerlink" title="3：为什么js是单线程，而不是多线程"></a>3：为什么js是单线程，而不是多线程</h5><h5 id="4：宏任务-x2F-微任务"><a href="#4：宏任务-x2F-微任务" class="headerlink" title="4：宏任务&#x2F;微任务"></a>4：宏任务&#x2F;微任务</h5><h5 id="5-浏览器与Node事件（有何区别）"><a href="#5-浏览器与Node事件（有何区别）" class="headerlink" title="5:浏览器与Node事件（有何区别）"></a>5:浏览器与Node事件（有何区别）</h5><h1 id="十：浏览器缓存机制"><a href="#十：浏览器缓存机制" class="headerlink" title="十：浏览器缓存机制"></a>十：浏览器缓存机制</h1><h5 id="1：缓存位置"><a href="#1：缓存位置" class="headerlink" title="1：缓存位置"></a>1：缓存位置</h5><pre><code class="javascript">## webStorage

1. 存储内容大小一般支持5MB左右（不同浏览器可能还不一样）

2. 浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制。

3. 相关API：

   1. ```xxxxxStorage.setItem(&#39;key&#39;, &#39;value&#39;);```
                      该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值。

   2. ```xxxxxStorage.getItem(&#39;person&#39;);```

      ​		该方法接受一个键名作为参数，返回键名对应的值。

   3. ```xxxxxStorage.removeItem(&#39;key&#39;);```

      ​		该方法接受一个键名作为参数，并把该键名从存储中删除。

   4. ``` xxxxxStorage.clear()```

      ​		该方法会清空存储中的所有数据。

4. 备注：

   1. SessionStorage存储的内容会随着浏览器窗口关闭而消失。
   2. LocalStorage存储的内容，需要手动清除才会消失。
   3. ```xxxxxStorage.getItem(xxx)```如果xxx对应的value获取不到，那么getItem的返回值是null。
   4. ```JSON.parse(null)```的结果依然是null。
</code></pre><h5 id="2：缓存策略（强缓存，协商缓存）"><a href="#2：缓存策略（强缓存，协商缓存）" class="headerlink" title="2：缓存策略（强缓存，协商缓存）"></a>2：缓存策略（强缓存，协商缓存）</h5><h1 id="十一：浏览器渲染原理"><a href="#十一：浏览器渲染原理" class="headerlink" title="十一：浏览器渲染原理"></a>十一：浏览器渲染原理</h1><h5 id="1：渲染过程"><a href="#1：渲染过程" class="headerlink" title="1：渲染过程"></a>1：渲染过程</h5><h5 id="2：阻塞过程"><a href="#2：阻塞过程" class="headerlink" title="2：阻塞过程"></a>2：阻塞过程</h5><h5 id="3：重绘和汇流（重排）"><a href="#3：重绘和汇流（重排）" class="headerlink" title="3：重绘和汇流（重排）"></a>3：重绘和汇流（重排）</h5><h1 id="十二：进阶知识"><a href="#十二：进阶知识" class="headerlink" title="十二：进阶知识"></a>十二：进阶知识</h1><h5 id="1：函数式编程"><a href="#1：函数式编程" class="headerlink" title="1：函数式编程"></a>1：函数式编程</h5><h5 id="2：HTML5-Web-Worker"><a href="#2：HTML5-Web-Worker" class="headerlink" title="2：HTML5 Web Worker"></a>2：HTML5 Web Worker</h5><h5 id="3：Service-Worker"><a href="#3：Service-Worker" class="headerlink" title="3：Service Worker"></a>3：Service Worker</h5><h1 id="十三：ECMAScript"><a href="#十三：ECMAScript" class="headerlink" title="十三：ECMAScript"></a>十三：ECMAScript</h1><h2 id="一：es5基础-es5是从ECMAScript从第一版到现在比较完善的一版"><a href="#一：es5基础-es5是从ECMAScript从第一版到现在比较完善的一版" class="headerlink" title="一：es5基础(es5是从ECMAScript从第一版到现在比较完善的一版)"></a>一：es5基础(es5是从ECMAScript从第一版到现在比较完善的一版)</h2><h3 id="1：变量-var"><a href="#1：变量-var" class="headerlink" title="1：变量 var"></a>1：变量 var</h3><pre><code class="javascript">1.var声明的作用域
    //该变量将在函数退出时被销毁
    function test() &#123; 
         var message = &quot;hi&quot;; // 局部变量
    &#125; 
    test(); 
    console.log(message); // 出错！
    
    //去掉之前的 var 操作符之后，message 就变成了全局变量
    function test() &#123; 
         message = &quot;hi&quot;; // 全局变量
    &#125; 
    test(); 
    console.log(message); // &quot;hi&quot;


2.逗号分隔符定义多个变量
    var name = &#39;hi&#39;,
        age = 18,
        height = 1.8
    
3.var声明提升
    function foo() &#123; 
         console.log(age); 
         var age = 26; 
    &#125; 
    foo(); // undefined 

上面的代码等价于
    function foo() &#123; 
         var age; 
         console.log(age); 
         age = 26; 
    &#125; 
    foo(); // undefined

</code></pre><h3 id="2：JavaScript-ES5-数据类型"><a href="#2：JavaScript-ES5-数据类型" class="headerlink" title="2：JavaScript(ES5)数据类型"></a>2：JavaScript(ES5)数据类型</h3><pre><code class="javascript">数据类型：`Undefined`、`Null`、`Boolean`、`String`、`Number`、`Symbol （ES6新出的）`、`Object`
引用类型：Object可以细分为：`基本引用类型`,`集合引用类型`
基本引用类型：`Date`,`RegExp`,`原始包装类型(Boolean,Number,String)`,`单例内置对象(Global,Math)`
集合引用类型：`Object`,`Array`,`定型数组`,`Map`,`WeakMap`,`Set`,`WeakSet`
</code></pre><h3 id="3：数据类型的检测"><a href="#3：数据类型的检测" class="headerlink" title="3：数据类型的检测"></a>3：数据类型的检测</h3><pre><code class="javascript">`为什么要有数据类型的检测?`
只有 7 种数据类型似乎不足以表示全部数据。但 ECMAScript 的数据类型很灵活，一种数据类型可以当作多种数据类型来使用


`有哪些检测方法?`
(1)typeof
(2)instanceof(主要用于判断是那种对象类型)
(3)constructor  
(4)Object.prototype.toString.call()

1：在`JavaScript`里使用`typeof`判断数据类型，即：`number`、`string`、`undefined`、`boolean`。

2：对于`null`、`array`、`function`、`object`来说，使用`typeof`都会统一返回`object`字符串。

3：要想区分对象、数组、函数、单纯使用`typeof`是不行的。在JS中，可以通过`Object.prototype.toString.call()`方法，判断某个对象之属于哪种内置类型。分为`null`、`string`、`boolean`、`number`、`undefined`、`array`、`function`、`object`、`date`、`math`。

4：constructor 本来是用于标识对象类型的。

5：一般认为 instanceof 操作符是确定对象类型 更可靠的方式。


    let obj = &#123;&#125;
    let num1 = 1
    console.log(typeof obj)   //object
    console.log(obj instanceof Object)  //true
    console.log(obj.constructor) //ƒ Object() &#123; [native code] &#125;
    console.log( Object.prototype.toString.call(1)) // [object Number]
    console.log(Object.prototype.toString.call(obj)) // [object Object]
</code></pre><h2 id="二：es6新增的特性"><a href="#二：es6新增的特性" class="headerlink" title="二：es6新增的特性"></a>二：es6新增的特性</h2><h3 id="1：变量-let"><a href="#1：变量-let" class="headerlink" title="1：变量 let"></a>1：变量 let</h3><pre><code class="javascript">1.只能在块作用域里面生效
    if (true) &#123; 
         var name = &#39;Matt&#39;; 
         console.log(name); // Matt 
    &#125; 
    console.log(name); // Matt

    if (true) &#123; 
         let age = 26; 
         console.log(age); // 26 
    &#125; 
    console.log(age); // ReferenceError: age 没有定义

2.不能重复定义同一个变量
    var name; 
    var name; 

    let age; 
    let age; // SyntaxError；标识符 age 已经声明过了

3.暂时性死区
    // name 会被提升
    console.log(name); // undefined 
    var name = &#39;Matt&#39;; 

    // age 不会被提升
    console.log(age); // ReferenceError：age 没有定义
    let age = 26; 

4.全局声明
    // 与 var 关键字不同，使用 let 在全局作用域中声明的变量不会成为 window 对象的属性

    var name = &#39;Matt&#39;; 
    console.log(window.name); // &#39;Matt&#39; 

    let age = 26; 
    console.log(window.age); // undefined
    
5.for 循环中的 let声明
    // 在 let出现之前，for 循环定义的迭代变量会渗透到循环体外部：
        for (var i = 0; i &lt; 5; ++i) &#123; 
             // 循环逻辑 
        &#125; 
    console.log(i); // 5
    
    // 改成使用 let之后，这个问题就消失了，因为迭代变量的作用域仅限于 for 循环块内部：
        for (let i = 0; i &lt; 5; ++i) &#123; 
             // 循环逻辑
        &#125; 
    console.log(i); // ReferenceError: i 没有定义
</code></pre><h3 id="2：变量-const"><a href="#2：变量-const" class="headerlink" title="2：变量 const"></a>2：变量 const</h3><pre><code class="javascript">1.声明变量时必须同时初始化变量，如果是常量且不能修改,如果是对象则可以修改
2.不允许重复声明
3.声明的作用域也是块
4.不能用 const 来声明迭代变量（因为迭代变量会自增）
</code></pre><h3 id="3：解构赋值"><a href="#3：解构赋值" class="headerlink" title="3：解构赋值"></a>3：解构赋值</h3><pre><code class="javascript">1.分为数组解构和对象解构，项目中从接口获取的数据可以解构为自己需要的数据，也常用于交换变量值
2.这里面引入了rest参数，用来获取函数的多余参数，这样就不需要使用arguments对象。
</code></pre><h3 id="4：模板字符串-主要是针对变量"><a href="#4：模板字符串-主要是针对变量" class="headerlink" title="4：模板字符串(主要是针对变量)"></a>4：模板字符串(主要是针对变量)</h3><pre><code class="javascript">&#123;
    let name = &#39;list&#39;;
    let info = &#39;hello world&#39;;
    let m = `i am $&#123;name&#125;,$&#123;info&#125;`;
&#125;
</code></pre><h3 id="5：数组新增的方法"><a href="#5：数组新增的方法" class="headerlink" title="5：数组新增的方法"></a>5：数组新增的方法</h3><pre><code class="javascript">1.Array.from()：遍历数组元素，用于将类数组结构转换为数组实例
2.Array.of()：用于将一组参数转换为数组实例
3.Array.fill()：替换元素
4.Array.keys()：返回一个数组，返回的是数组的下标
5.Array.values()：返回一个数组，返回的是数组中的值
6.Array.entries()：返回下标和值
7.Array.copyWithin(起始位置,从第几个数据读取,截止位置)
8.Array.find()：找出第一个符合条件的数组成员
9.Array.findIndex()：找出第一个符合条件的数组成员的下标
</code></pre><h3 id="6：字符串新增的方法"><a href="#6：字符串新增的方法" class="headerlink" title="6：字符串新增的方法"></a>6：字符串新增的方法</h3><pre><code class="javascript">1.String.includes(value)：是否包含value值，是的话返回true
</code></pre><h3 id="7：函数新增的方法"><a href="#7：函数新增的方法" class="headerlink" title="7：函数新增的方法"></a>7：函数新增的方法</h3><pre><code class="javascript">1.扩展运算符：…[1,2,3] //1,2,3 把数组拆分成了三个值
2.箭头函数：
箭头函数是普通函数的简写，可以更优雅的定义一个函数，和普通函数相比，有以下几点差异：
（1）函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。
（2）不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。
（3）不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。
（4）不可以使用 new 命令，因为：
没有自己的 this，无法调用 call，apply。
没有 prototype 属性 ，而 new 命令在执行时需要将构造函数的 prototype 赋值给新的对象的 proto
</code></pre><h3 id="8：对象新增的方法"><a href="#8：对象新增的方法" class="headerlink" title="8：对象新增的方法"></a>8：对象新增的方法</h3><pre><code class="javascript">1.Object.is(value1,value2)：判断两个参数是否相等
2.Object.assign(value1,value2)：浅拷贝，拷贝出来的结果是 [value1,value2]（value1和value2都是对象）
3.扩展运算符：&#123;a,b,…c&#125;=&#123;a:’a’,b:’b’,c:’c’,d:’d’&#125;→c=&#123;c:’c’,d:’d’&#125;
4.for…in循环遍历对象自身的和继承的可枚举属性
5.Object.keys(obj)：返回一个数组，返回的是数组成员的下标
6.Object.getOwnPropertySymbols(obj)：返回的是Symbol定义的值
7.Object.ownKeys(obj)：可以拿到所有的值，包括Symbol定义的和非Symbol定义的
</code></pre><h3 id="9：Symbol用法"><a href="#9：Symbol用法" class="headerlink" title="9：Symbol用法"></a>9：Symbol用法</h3><pre><code class="javascript">1.这是ES6新增的数据类型，表示独一无二的值

&#123;
let a1 = Symbol.for(‘a1’)
//后面再对a1赋值也是无效的，a1的值依旧是’a1’
&#125;
</code></pre><h3 id="10：Set-Map数据结构"><a href="#10：Set-Map数据结构" class="headerlink" title="10：Set-Map数据结构"></a>10：Set-Map数据结构</h3><pre><code class="javascript">1.Set本身是一个构造函数，类似于数组，但是里面的值都是唯一的，没有重复的值，所以可以用Set去重

&#123;
    let array = [1,1,2,2,6,5];
    let set = new Set(array);
    console.log(set);  //[1,2,6,5]
&#125;
&#123;
    //接下里介绍几个方法
    let arr = [&#39;add&#39;,&#39;delete&#39;,&#39;clear&#39;,&#39;has&#39;];
    let list = new Set(arr);
    list.has(&#39;add&#39;) //判断是否有该值
    list.delete(&#39;add&#39;);	//、删除该值
    list.clear(); //清空
&#125;


2.Map数据结构类似于对象，也是键值对的集合，但是键的范围不局限与字符
&#123;
    let map = new Map();
    let arr = [&#39;123&#39;];
    map.set(arr,456);
    map.get(arr);  //456
&#125;

</code></pre><h3 id="11：Proxy"><a href="#11：Proxy" class="headerlink" title="11：Proxy"></a>11：Proxy</h3><pre><code class="javascript">1.Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。

2.Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，
因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，
用在这里表示由它来“代理”某些操作，可以译为“代理器”。

var proxy = new Proxy(target, handler);

优点：通过代理，条件与对象本身隔绝，后续代码维护、健壮都很强
</code></pre><h3 id="12：Class的基本用法"><a href="#12：Class的基本用法" class="headerlink" title="12：Class的基本用法"></a>12：Class的基本用法</h3><pre><code class="javascript">1.class其实是对function的简化 class的声明

//基本定义和生成实例
class Parent&#123;
    constructor(name)&#123;
        this.name = name;
    &#125;
&#125;
let parent = new Parent(&#39;xiaomao&#39;)
//继承
class Child extends Parent&#123;
    //子类怎么去覆盖父类,this一定要放在super后面
    constructor(name = &#39;child&#39;)&#123;
        super(name);   //若super()，则所有参数都是父类的
        this.type = &#39;child&#39;;   //子类增加的属性
    &#125;
&#125;
</code></pre><h3 id="13：Promise"><a href="#13：Promise" class="headerlink" title="13：Promise"></a>13：Promise</h3><pre><code class="javascript">promise实际上解决jquery的ajax回调地域(解决层层嵌套),只是异步编程的一种解决方案
new promise(function(resolve,reject) &#123;
        resolve(&#39;...&#39;)
    &#125; ).then(function(value) &#123;
        console.log(value)
    &#125;).catch(function(error)&#123;
    console.log(error)
&#125;)
</code></pre><h5 id="1：什么是promise"><a href="#1：什么是promise" class="headerlink" title="1：什么是promise"></a>1：什么是promise</h5><p>Promise 是异步编程的一种解决方案： 从语法上讲，promise是一个对象，从它可以获取异步操作的消息；从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。 promise有三种状态：**pending(等待态)，fulfiled(成功态)，rejected(失败态)**；状态一旦改变，就不会再变。创造promise实例后，它会立即执行</p><h5 id="2：promise用来解决什么问题"><a href="#2：promise用来解决什么问题" class="headerlink" title="2：promise用来解决什么问题"></a>2：promise用来解决什么问题</h5><pre><code class="javascript">// 当参数a大于10且参数fn2是一个方法时 执行fn2
     function fn1(a, fn2)&#123;
        if(a &gt; 10 &amp;&amp; fn2 instanceof Function)&#123;
            fn2()
        &#125;
     &#125;

     fn1(12, ()=&gt;&#123;
         console.log(&#39;this is callback&#39;)
     &#125;)
一般来说我们会碰到的回调嵌套都不会很多，一般就一到两级，但是某些情况下，回调嵌套很多时，代码就会非常繁琐，会给我们的编程带来很多的麻烦，这种情况俗称——回调地狱。

主要用来解决：
1：回调地狱，代码难以维护，常常第一个的函数输出的是第二个函数的输入的这种现象
2：promise可以支持多个并发的请求，获取并发请求中的请求
3：promise可以解决异步问题，本身不能说promise是异步的
</code></pre><h5 id="3：promise的基础用法"><a href="#3：promise的基础用法" class="headerlink" title="3：promise的基础用法"></a>3：promise的基础用法</h5><pre><code class="javascript">1： Promise是一个构造函数，自己身上有all、reject、resolve这几个眼熟的方法，原型上有then、catch等同样很眼熟的方法。

      let p = new Promise((resolve, reject) =&gt; &#123;
          //执行异步操作
          setTimeout(() =&gt; &#123;
              console.log(&#39;执行完成&#39;)
              resolve(&#39;我是成功！！&#39;)
          &#125;, 2000);
      &#125;)
上段代码会直接执行 2秒后输出 &#39;执行完成&#39;

Promise的构造函数接收一个参数：函数，并且这个函数需要传入两个参数：
resolve：异步操作执行成功后的回调函数
reject：异步操作执行失败后的回调函数

2：then 链式操作的用法  
从表面上看，Promise只是能够简化层层回调的写法，而实质上，Promise的精髓是“状态”，用维护状态、传递状态的方式来使得回调函数能够及时调用，它比传递callback函数要简单、灵活的多。所以使用Promise的正确场景是这样的：
      p.then((data) =&gt; &#123;
          console.log(data)
      &#125;)

3：reject的用法 
把Promise的状态置为rejected，这样我们在then中就能捕捉到，然后执行“失败”情况的回调。看下面的代码。
      let p = new Promise((resolve, reject) =&gt; &#123;
          //执行异步操作
          setTimeout(() =&gt; &#123;
              let num = Math.ceil(Math.random()*10) //生成1 - 10的随机数
               if(num &lt;= 5)&#123;
                   resolve(num)
               &#125;else&#123;
                   reject(&#39;数字是大于5的&#39;)
               &#125;
          &#125;, 1000);
      &#125;)

      p.then((data) =&gt; &#123;
          console.log(&#39;resolve&#39;,data)
      &#125;,(err) =&gt; &#123;
          console.log(&#39;rejeced&#39;,err)
      &#125;)
产生以一个随机数，如果大于5就会使用reject  错误(err)输出&#39;数字是大于5&#39;

4：catch的用法 (前面的代码有错误可以报出来，不要promise是无法执行下来的)
我们知道Promise对象除了then方法，还有一个catch方法，它是做什么用的呢？其实它和then的第二个参数一样，用来指定reject的回调。用法是这样：
      let p = new Promise((resolve, reject) =&gt; &#123;
          //执行异步操作
          setTimeout(() =&gt; &#123;
              let num = Math.ceil(Math.random()*10) //生成1 - 10的随机数
               if(num &lt;= 5)&#123;
                   resolve(num)
               &#125;else&#123;
                   reject(&#39;数字是大于5的&#39;)
               &#125;
          &#125;, 1000);
      &#125;)

      p.then((data) =&gt; &#123;
          console.log(&#39;resolve&#39;,data)  // 假设随机数是 3  那么输出 resolve 为 3
          console.log(aaaa)  //aaaa是没有被定义的
      &#125;,(err) =&gt; &#123;
          console.log(&#39;rejeced&#39;,err)
      &#125;).catch((err) =&gt; &#123;
          console.log(&#39;rejeced&#39;,err)  //  这里报错 ： rejeced ReferenceError: aaaa is not defined
      &#125;)
在resolve的回调中，我们console.log(somedata);而aaaa这个变量是没有被定义的。如果我们不用Promise，代码运行到这里就直接在控制台报错了，不往下运行了。
</code></pre><h5 id="4：all的用法"><a href="#4：all的用法" class="headerlink" title="4：all的用法"></a>4：all的用法</h5><pre><code class="javascript">1:
all的用法：谁跑的慢，以谁为准执行回调。all接收一个数组参数，里面的值最终都算返回Promise对象

2:
Promise的all方法提供了并行执行异步操作的能力，并且在所有异步操作执行完后才执行回调。看下面的例子：

        let promise1 = new Promise((resolve, reject) =&gt; &#123;
            setTimeout(() =&gt; &#123;
                var num = Math.ceil(Math.random() * 10); //生成1-10的随机数
                if (num &lt;= 5) &#123;
                    resolve(num);
                &#125;
                else &#123;
                    reject(&#39;数字太大了1&#39;);
                &#125;
            &#125;)
        &#125;)
        let promise2 = new Promise((resolve, reject) =&gt; &#123;
            setTimeout(() =&gt; &#123;
                var num = Math.ceil(Math.random() * 10); //生成1-10的随机数
                if (num &lt;= 5) &#123;
                    resolve(num);
                &#125;
                else &#123;
                    reject(&#39;数字太大了2&#39;);
                &#125;
            &#125;)
        &#125;)
        let promise3 = new Promise((resolve, reject) =&gt; &#123;
            setTimeout(() =&gt; &#123;
                var num = Math.ceil(Math.random() * 10); //生成1-10的随机数
                if (num &lt;= 5) &#123;
                    resolve(num);
                &#125;
                else &#123;
                    reject(&#39;数字太大了3&#39;);
                &#125;
            &#125;)
        &#125;)

        let p = Promise.all([promise1, promise2, promise3])

        p.then(function (res) &#123;
            //三个都成功则成功 res返回 [p1,p2,p3] 结果的数组
            console.log(res)
        &#125;, function (err) &#123;
            //只要有失败，则失败  err 返回在哪个promise失败的回调
            console.log(err)
        &#125;)

有了all，你就可以并行执行多个异步操作，并且在一个回调中处理所有的返回数据，是不是很酷？有一个场景是很适合用这个的，一些游戏类的素材比较多的应用，打开网页时，预先加载需要用到的各种资源如图片、flash以及各种静态文件。所有的都加载完后，我们再进行页面的初始化。
</code></pre><h5 id="5：race的用法"><a href="#5：race的用法" class="headerlink" title="5：race的用法"></a>5：race的用法</h5><pre><code class="javascript">1:race的用法：谁跑的快，以谁为准执行回调

2：race的使用场景：比如我们可以用race给某个异步请求设置超时时间，并且在超时后执行相应的操作，代码如下

        //请求某个图片资源
        function requestImg() &#123;
            var p = new Promise((resolve, reject) =&gt; &#123;
                var img = new Image();
                img.onload = function () &#123;
                    resolve(img);
                &#125;
                img.src = &#39;图片的路径&#39;;
            &#125;);
            return p;
        &#125;
        //延时函数，用于给请求计时
        function timeout() &#123;
            var p = new Promise((resolve, reject) =&gt; &#123;
                setTimeout(() =&gt; &#123;
                    reject(&#39;图片请求超时&#39;);
                &#125;, 5000);
            &#125;);
            return p;
        &#125;
        Promise.race([requestImg(), timeout()]).then((data) =&gt; &#123;
            console.log(data);
        &#125;).catch((err) =&gt; &#123;
            console.log(err);
        &#125;);

requestImg函数会异步请求一张图片，我把地址写为&quot;图片的路径&quot;，所以肯定是无法成功请求到的。timeout函数是一个延时5秒的异步操作。我们把这两个返回Promise对象的函数放进race，于是他俩就会赛跑，如果5秒之内图片请求成功了，那么遍进入then方法，执行正常的流程。如果5秒钟图片还未成功返回，那么timeout就跑赢了，则进入catch，报出“图片请求超时”的信息。
</code></pre><h5 id="6：手写一个promise"><a href="#6：手写一个promise" class="headerlink" title="6：手写一个promise"></a>6：手写一个promise</h5><h5 id="7：promise面试题"><a href="#7：promise面试题" class="headerlink" title="7：promise面试题"></a>7：promise面试题</h5><pre><code class="javascript">1.
const promise = new Promise((resolve, reject) =&gt; &#123;
  console.log(1)
  resolve()
  console.log(2)
&#125;)
promise.then(() =&gt; &#123;
  console.log(3)
&#125;)
console.log(4)


输出:  1 2 4 3
解释:  Promise构造函数是同步执行的,promsie.then 中的函数是异步执行的 
</code></pre><pre><code class="javascript">2.
const promise1 = new Promise((resolve, reject) =&gt; &#123;
  setTimeout(() =&gt; &#123;
    resolve(&#39;success&#39;)
  &#125;, 1000)
&#125;)
const promise2 = promise1.then(() =&gt; &#123;
  throw new Error(&#39;error!!!&#39;)
&#125;)

console.log(&#39;promise1&#39;, promise1)
console.log(&#39;promise2&#39;, promise2)

setTimeout(() =&gt; &#123;
  console.log(&#39;promise1&#39;, promise1)
  console.log(&#39;promise2&#39;, promise2)
&#125;, 2000)

输出:
promise1 Promise &#123; &lt;pending&gt; &#125;
promise2 Promise &#123; &lt;pending&gt; &#125;
(node:50928) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): Error: error!!!
(node:50928) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.
promise1 Promise &#123; &#39;success&#39; &#125;
promise2 Promise &#123;
  &lt;rejected&gt; Error: error!!!
    at promise.then (...)
    at &lt;anonymous&gt; &#125;

解释：promise 有 3 种状态：pending、fulfilled 或 rejected。状态改变只能是 pending-&gt;fulfilled 或者 pending-&gt;rejected，状态一旦改变则不能再变。上面 promise2 并不是 promise1，而是返回的一个新的 Promise 实例。

</code></pre><pre><code class="javascript">3.
const promise = new Promise((resolve, reject) =&gt; &#123;
  resolve(&#39;success1&#39;)
  reject(&#39;error&#39;)
  resolve(&#39;success2&#39;)
&#125;)

promise
  .then((res) =&gt; &#123;
    console.log(&#39;then: &#39;, res)
  &#125;)
  .catch((err) =&gt; &#123;
    console.log(&#39;catch: &#39;, err)
  &#125;)

输出: success1
解释：构造函数中的 resolve 或 reject 只有第一次执行有效，多次调用没有任何作用，呼应代码二结论：promise 状态一旦改变则不能再变。
</code></pre><pre><code class="javascript">4.
Promise.resolve(1)
  .then((res) =&gt; &#123;
    console.log(res)
    return 2
  &#125;)
  .catch((err) =&gt; &#123;
    return 3
  &#125;)
  .then((res) =&gt; &#123;
    console.log(res)
  &#125;)

输出:  1,2

解释：promise 可以链式调用。提起链式调用我们通常会想到通过 return this 实现，不过 Promise 并不是这样实现的。promise 每次调用 .then 或者 .catch 都会返回一个新的 promise，从而实现了链式调用。
</code></pre><pre><code class="javascript">5.
const promise = new Promise((resolve, reject) =&gt; &#123;
  setTimeout(() =&gt; &#123;
    console.log(&#39;once&#39;)
    resolve(&#39;success&#39;)
  &#125;, 1000)
&#125;)

const start = Date.now()
promise.then((res) =&gt; &#123;
  console.log(res, Date.now() - start)
&#125;)
promise.then((res) =&gt; &#123;
  console.log(res, Date.now() - start)
&#125;)

输出:
once
success 1005
success 1007

解释：promise 的 .then 或者 .catch 可以被调用多次，但这里 Promise 构造函数只执行一次。或者说 promise 内部状态一经改变，并且有了一个值，那么后续每次调用 .then 或者 .catch 都会直接拿到该值
</code></pre><pre><code class="javascript">6.
Promise.resolve()
  .then(() =&gt; &#123;
    return new Error(&#39;error!!!&#39;)
  &#125;)
  .then((res) =&gt; &#123;
    console.log(&#39;then: &#39;, res)
  &#125;)
  .catch((err) =&gt; &#123;
    console.log(&#39;catch: &#39;, err)
  &#125;)

输出:
then: Error: error!!!
    at Promise.resolve.then (...)
    at ...
                             
解释：.then 或者 .catch 中 return 一个 error 对象并不会抛出错误，所以不会被后续的 .catch 捕获，需要改成其中一种：                                                       
</code></pre><pre><code class="javascript">7.
const promise = Promise.resolve()
  .then(() =&gt; &#123;
    return promise
  &#125;)
promise.catch(console.error)

输出:
TypeError: Chaining cycle detected for promise #&lt;Promise&gt;
    at &lt;anonymous&gt;
    at process._tickCallback (internal/process/next_tick.js:188:7)
    at Function.Module.runMain (module.js:667:11)
    at startup (bootstrap_node.js:187:16)
    at bootstrap_node.js:607:3

解释：.then 或 .catch 返回的值不能是 promise 本身，否则会造成死循环。类似于：
process.nextTick(function tick () &#123;
  console.log(&#39;tick&#39;)
  process.nextTick(tick)
&#125;)
</code></pre><pre><code class="javascript">8.
Promise.resolve(1)
  .then(2)
  .then(Promise.resolve(3))
  .then(console.log)

输出: 1

解释：.then 或者 .catch 的参数期望是函数，传入非函数则会发生值穿透。
</code></pre><pre><code class="javascript">9.
Promise.resolve()
  .then(function success (res) &#123;
    throw new Error(&#39;error&#39;)
  &#125;, function fail1 (e) &#123;
    console.error(&#39;fail1: &#39;, e)
  &#125;)
  .catch(function fail2 (e) &#123;
    console.error(&#39;fail2: &#39;, e)
  &#125;)

输出:
fail2: Error: error
    at success (...)
    at ...
                
解释：.then 可以接收两个参数，第一个是处理成功的函数，第二个是处理错误的函数。.catch 是 .then 第二个参数的简便写法，但是它们用法上有一点需要注意：.then 的第二个处理错误的函数捕获不了第一个处理成功的函数抛出的错误，而后续的 .catch 可以捕获之前的错误。当然以下代码也可以：            
</code></pre><pre><code class="javascript">10.
process.nextTick(() =&gt; &#123;
  console.log(&#39;nextTick&#39;)
&#125;)
Promise.resolve()
  .then(() =&gt; &#123;
    console.log(&#39;then&#39;)
  &#125;)
setImmediate(() =&gt; &#123;
  console.log(&#39;setImmediate&#39;)
&#125;)
console.log(&#39;end&#39;)

输出:
end
nextTick
then
setImmediate

解释：process.nextTick 和 promise.then 都属于 microtask，而 setImmediate 属于 macrotask，在事件循环的 check 阶段执行。事件循环的每个阶段（macrotask）之间都会执行 microtask，事件循环的开始会先执行一次 microtask。
</code></pre><h3 id="14：Iterator和for…of循环"><a href="#14：Iterator和for…of循环" class="headerlink" title="14：Iterator和for…of循环"></a>14：Iterator和for…of循环</h3><pre><code class="javascript">遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。

Iterator 的作用有三个：
一是为各种数据结构，提供一个统一的、简便的访问接口；
二是使得数据结构的成员能够按某种次序排列；
三是 ES6 创造了一种新的遍历命令for…of循环，Iterator 接口主要供for…of消费
</code></pre><h3 id="15：Generator"><a href="#15：Generator" class="headerlink" title="15：Generator"></a>15：Generator</h3><pre><code class="javascript">Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。

Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。

执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。
返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。

形式上，Generator 函数是一个普通函数，但是有两个特征。
一是，function关键字与函数名之间有一个星号；
二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”

function* helloWorldGenerator() &#123;
  yield &#39;hello&#39;;
  yield &#39;world&#39;;
  return &#39;ending&#39;;
&#125;
var hw = helloWorldGenerator();

上面代码定义了一个 Generator 函数helloWorldGenerator，它内部有两个yield表达式（hello和world），即该函数有三个状态：hello，world 和 return 语句（结束执行）。

然后，Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。
不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，
也就是前面介绍的遍历器对象（Iterator Object）。
</code></pre><h3 id="16：Module体系"><a href="#16：Module体系" class="headerlink" title="16：Module体系"></a>16：Module体系</h3><pre><code class="javascript">
模块功能主要由两个命令构成：
export和import。
export命令用于规定模块的对外接口，
import命令用于输入其他模块提供的功能。
export default&#123;&#125;
为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到export default命令，为模块指定默认输出。

import animal from &#39;./content&#39;
export default &#39;a cat&#39;


import &#123;say.type&#125; from &#39;./content&#39;
import * as content from &#39;./content&#39;
</code></pre><h2 id="三：es7新增的特性"><a href="#三：es7新增的特性" class="headerlink" title="三：es7新增的特性"></a>三：es7新增的特性</h2><h3 id="1-数组新增的方法"><a href="#1-数组新增的方法" class="headerlink" title="1:数组新增的方法"></a>1:数组新增的方法</h3><pre><code class="javascript">1.Array.includes(value)：是否包含value值，是的话返回true
</code></pre><h1 id="十四：防抖和节流"><a href="#十四：防抖和节流" class="headerlink" title="十四：防抖和节流"></a>十四：防抖和节流</h1><pre><code class="javascript">防抖的定义:任务频繁触发的情况下，只有触发的间隔超过指定间隔，任务才执行。

案例:方式用户多次点击按钮，监听滚动条滚动,操纵一个小人让他有跳跃的动作，你狂点鼠标，小人狂跳，这就是最直观的抖动现象。

代码实现:
        function debounce(fn, delay) &#123;
            let timer;
            return function () &#123;
                let args = arguments;
                if (timer) &#123;
                    clearTimeout(timer);
                &#125;
                timer = setTimeout(() =&gt; &#123;
                    fn.call(this, args);
                &#125;, delay)
            &#125;
        &#125;
</code></pre><pre><code class="javascript">节流的定义:指定时间间隔只执行一次，执行频率不受操作频率影响，但会把所有的都执行完。

案例:节流就像排队，比如我们在车站候车，当听到检票进站的通知，不论你有多紧急，跑得多快，还是得跟着排队，一个个地过闸机口，你的通过速度不可能比闸机口开关的速度更快了。

代码实现:
        function throttle(fn, delay) &#123;
            let flag = true;
            return function () &#123;
                if (flag) &#123;
                    flag = false;
                &#125;
                timer = setTimeout(() =&gt; &#123;
                    fn();
                    flag = true;
                &#125;, delay)
            &#125;
        &#125;
</code></pre><div class="tags"><a href="/tags/Javascript/" rel="tag"><i class="ic i-tag"></i> Javascript</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-06-29 18:50:33" itemprop="dateModified" datetime="2023-06-29T18:50:33+08:00">2023-06-29</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Yn 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="Yn 支付宝"><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Yn <i class="ic i-at"><em>@</em></i>死肥宅</li><li class="link"><strong>本文链接：</strong> <a href="http://yoursite.com/front-end/JavaScript%E8%BF%90%E7%94%A8/" title="js运用">http://yoursite.com/front-end/JavaScript运用/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/front-end/Typescript/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gicit4jrvuj20zk0m8785.jpg" title="Typescript基础"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> Typescript</span><h3>Typescript基础</h3></a></div><div class="item right"><a href="/front-end/html+css%E9%9D%A2%E8%AF%95/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gicis3attqj20zk0m8k7l.jpg" title="css面试"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> css</span><h3>css面试</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AFJavaScript"><span class="toc-number">1.</span> <span class="toc-text">一：什么是JavaScript</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2"><span class="toc-number">1.1.</span> <span class="toc-text">1.发展历史</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-javascript%E7%9A%84%E6%9E%84%E6%88%90"><span class="toc-number">1.2.</span> <span class="toc-text">2.javascript的构成</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%BA%94%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">2.</span> <span class="toc-text">一：数据类型以及相应的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%9A%E5%85%B3%E4%BA%8EArray%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93"><span class="toc-number">2.0.0.0.1.</span> <span class="toc-text">2：关于Array处理数据的方法总结</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%9A%E5%85%B3%E4%BA%8EString%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E7%9A%84%E6%80%BB%E7%BB%93"><span class="toc-number">2.0.0.0.2.</span> <span class="toc-text">3：关于String包装类型处理数据的总结</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%EF%BC%9A%E5%85%B3%E4%BA%8ENumber%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">2.0.0.0.3.</span> <span class="toc-text">4：关于Number包装类型的处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%EF%BC%9A%E5%85%B3%E4%BA%8EDate%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86"><span class="toc-number">2.0.0.0.4.</span> <span class="toc-text">5：关于Date时间处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%EF%BC%9A%E5%85%B3%E4%BA%8EMath%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">2.0.0.0.5.</span> <span class="toc-text">6：关于Math内置对象的处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B"><span class="toc-number">2.0.0.0.6.</span> <span class="toc-text">7：数据类型检测</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8%EF%BC%9A%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">2.0.0.0.7.</span> <span class="toc-text">8：深浅拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%EF%BC%9A%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">2.0.0.0.7.1.</span> <span class="toc-text">1：深拷贝有哪些方式？</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%EF%BC%9A%E6%B5%85%E6%8B%B7%E8%B4%9D%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F"><span class="toc-number">2.0.0.0.7.2.</span> <span class="toc-text">2：浅拷贝有哪些方式</span></a></li></ol></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%EF%BC%9A%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%BB%A5%E5%8F%8A%E5%8F%98%E9%87%8F"><span class="toc-number">3.</span> <span class="toc-text">二：作用域以及变量</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%9A%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E6%8F%90%E5%8D%87"><span class="toc-number">3.0.0.0.1.</span> <span class="toc-text">2：变量声明提升</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%9A%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="toc-number">3.0.0.0.2.</span> <span class="toc-text">3：作用域链</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%EF%BC%9A%E9%97%AD%E5%8C%85%EF%BC%88closure%EF%BC%89"><span class="toc-number">3.0.0.0.3.</span> <span class="toc-text">4：闭包（closure）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%EF%BC%9AJavaScript%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.</span> <span class="toc-text">三：JavaScript创建对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%9Ajs%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">4.0.0.0.1.</span> <span class="toc-text">1：js创建对象的几种方式的优缺点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%9A%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%EF%BC%88%E9%87%8D%E7%82%B9%E9%83%A8%E5%88%86%E5%8D%95%E7%8B%AC%E5%88%86%E7%A6%BB%E5%87%BA%E6%9D%A5%EF%BC%89"><span class="toc-number">4.0.0.0.2.</span> <span class="toc-text">2：原型模式创建对象（重点部分单独分离出来）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%EF%BC%9AJavaScript%E7%BB%A7%E6%89%BF"><span class="toc-number">5.</span> <span class="toc-text">四：JavaScript继承</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%9A%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">5.0.0.0.1.</span> <span class="toc-text">1：原型链</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%9Ajs%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF-ES6%E7%B1%BB%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">5.0.0.0.2.</span> <span class="toc-text">1：js如何实现继承(ES6类的原理)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%9AES6%E7%B1%BB"><span class="toc-number">5.0.0.0.3.</span> <span class="toc-text">2：ES6类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%EF%BC%9Anew%EF%BC%8Cthis"><span class="toc-number">6.</span> <span class="toc-text">五：new，this</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%9Anew%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%85%B7%E4%BD%93%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">6.0.0.0.1.</span> <span class="toc-text">1：new操作符具体干了什么</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%9Anew%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.0.0.0.2.</span> <span class="toc-text">2：new的模拟实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%9Athis%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">6.0.0.0.3.</span> <span class="toc-text">3：this对象的理解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%EF%BC%9Acall-x2F-apply-x2F-bind"><span class="toc-number">7.</span> <span class="toc-text">六：call&#x2F;apply&#x2F;bind</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%9Acall-x2F-apply-x2F-bind"><span class="toc-number">7.0.0.0.1.</span> <span class="toc-text">1：call&#x2F;apply&#x2F;bind</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%9Acall%E5%92%8Capply%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.0.0.0.2.</span> <span class="toc-text">2：call和apply的模拟实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%9Abind%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.0.0.0.3.</span> <span class="toc-text">3：bind的模拟实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%EF%BC%9A%E4%BA%8B%E4%BB%B6"><span class="toc-number">8.</span> <span class="toc-text">七：事件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%9A%E4%BA%8B%E4%BB%B6%E6%B5%81"><span class="toc-number">8.0.0.0.1.</span> <span class="toc-text">1：事件流</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%9A%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5"><span class="toc-number">8.0.0.0.2.</span> <span class="toc-text">2：事件的三个阶段</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%9A%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BB%A3%E7%90%86%E6%9C%89%E4%BD%95%E5%A7%94%E6%89%98"><span class="toc-number">8.0.0.0.3.</span> <span class="toc-text">3：事件的代理有何委托</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%EF%BC%9A%E5%A6%82%E4%BD%95%E6%B4%BE%E5%8F%91%E4%BA%8B%E4%BB%B6"><span class="toc-number">8.0.0.0.4.</span> <span class="toc-text">4：如何派发事件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%EF%BC%9Aevent-loop"><span class="toc-number">9.</span> <span class="toc-text">八：event loop</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">9.0.0.0.1.</span> <span class="toc-text">1：进程和线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%9A%E6%89%A7%E8%A1%8C%E6%A0%88"><span class="toc-number">9.0.0.0.2.</span> <span class="toc-text">2：执行栈</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88js%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">9.0.0.0.3.</span> <span class="toc-text">3：为什么js是单线程，而不是多线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%EF%BC%9A%E5%AE%8F%E4%BB%BB%E5%8A%A1-x2F-%E5%BE%AE%E4%BB%BB%E5%8A%A1"><span class="toc-number">9.0.0.0.4.</span> <span class="toc-text">4：宏任务&#x2F;微任务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8ENode%E4%BA%8B%E4%BB%B6%EF%BC%88%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%89"><span class="toc-number">9.0.0.0.5.</span> <span class="toc-text">5:浏览器与Node事件（有何区别）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%EF%BC%9A%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="toc-number">10.</span> <span class="toc-text">十：浏览器缓存机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%9A%E7%BC%93%E5%AD%98%E4%BD%8D%E7%BD%AE"><span class="toc-number">10.0.0.0.1.</span> <span class="toc-text">1：缓存位置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%9A%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5%EF%BC%88%E5%BC%BA%E7%BC%93%E5%AD%98%EF%BC%8C%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%EF%BC%89"><span class="toc-number">10.0.0.0.2.</span> <span class="toc-text">2：缓存策略（强缓存，协商缓存）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%EF%BC%9A%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86"><span class="toc-number">11.</span> <span class="toc-text">十一：浏览器渲染原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%9A%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B"><span class="toc-number">11.0.0.0.1.</span> <span class="toc-text">1：渲染过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%9A%E9%98%BB%E5%A1%9E%E8%BF%87%E7%A8%8B"><span class="toc-number">11.0.0.0.2.</span> <span class="toc-text">2：阻塞过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%9A%E9%87%8D%E7%BB%98%E5%92%8C%E6%B1%87%E6%B5%81%EF%BC%88%E9%87%8D%E6%8E%92%EF%BC%89"><span class="toc-number">11.0.0.0.3.</span> <span class="toc-text">3：重绘和汇流（重排）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%EF%BC%9A%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86"><span class="toc-number">12.</span> <span class="toc-text">十二：进阶知识</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%9A%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">12.0.0.0.1.</span> <span class="toc-text">1：函数式编程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%9AHTML5-Web-Worker"><span class="toc-number">12.0.0.0.2.</span> <span class="toc-text">2：HTML5 Web Worker</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%9AService-Worker"><span class="toc-number">12.0.0.0.3.</span> <span class="toc-text">3：Service Worker</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%89%EF%BC%9AECMAScript"><span class="toc-number">13.</span> <span class="toc-text">十三：ECMAScript</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%EF%BC%9Aes5%E5%9F%BA%E7%A1%80-es5%E6%98%AF%E4%BB%8EECMAScript%E4%BB%8E%E7%AC%AC%E4%B8%80%E7%89%88%E5%88%B0%E7%8E%B0%E5%9C%A8%E6%AF%94%E8%BE%83%E5%AE%8C%E5%96%84%E7%9A%84%E4%B8%80%E7%89%88"><span class="toc-number">13.1.</span> <span class="toc-text">一：es5基础(es5是从ECMAScript从第一版到现在比较完善的一版)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%9A%E5%8F%98%E9%87%8F-var"><span class="toc-number">13.1.1.</span> <span class="toc-text">1：变量 var</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%9AJavaScript-ES5-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">13.1.2.</span> <span class="toc-text">2：JavaScript(ES5)数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%A3%80%E6%B5%8B"><span class="toc-number">13.1.3.</span> <span class="toc-text">3：数据类型的检测</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%EF%BC%9Aes6%E6%96%B0%E5%A2%9E%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">13.2.</span> <span class="toc-text">二：es6新增的特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%9A%E5%8F%98%E9%87%8F-let"><span class="toc-number">13.2.1.</span> <span class="toc-text">1：变量 let</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%9A%E5%8F%98%E9%87%8F-const"><span class="toc-number">13.2.2.</span> <span class="toc-text">2：变量 const</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%9A%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-number">13.2.3.</span> <span class="toc-text">3：解构赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%9A%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2-%E4%B8%BB%E8%A6%81%E6%98%AF%E9%92%88%E5%AF%B9%E5%8F%98%E9%87%8F"><span class="toc-number">13.2.4.</span> <span class="toc-text">4：模板字符串(主要是针对变量)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%EF%BC%9A%E6%95%B0%E7%BB%84%E6%96%B0%E5%A2%9E%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">13.2.5.</span> <span class="toc-text">5：数组新增的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B0%E5%A2%9E%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">13.2.6.</span> <span class="toc-text">6：字符串新增的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%EF%BC%9A%E5%87%BD%E6%95%B0%E6%96%B0%E5%A2%9E%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">13.2.7.</span> <span class="toc-text">7：函数新增的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%EF%BC%9A%E5%AF%B9%E8%B1%A1%E6%96%B0%E5%A2%9E%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">13.2.8.</span> <span class="toc-text">8：对象新增的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%EF%BC%9ASymbol%E7%94%A8%E6%B3%95"><span class="toc-number">13.2.9.</span> <span class="toc-text">9：Symbol用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%EF%BC%9ASet-Map%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">13.2.10.</span> <span class="toc-text">10：Set-Map数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%EF%BC%9AProxy"><span class="toc-number">13.2.11.</span> <span class="toc-text">11：Proxy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%EF%BC%9AClass%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">13.2.12.</span> <span class="toc-text">12：Class的基本用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%EF%BC%9APromise"><span class="toc-number">13.2.13.</span> <span class="toc-text">13：Promise</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AFpromise"><span class="toc-number">13.2.13.0.1.</span> <span class="toc-text">1：什么是promise</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%9Apromise%E7%94%A8%E6%9D%A5%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">13.2.13.0.2.</span> <span class="toc-text">2：promise用来解决什么问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%9Apromise%E7%9A%84%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95"><span class="toc-number">13.2.13.0.3.</span> <span class="toc-text">3：promise的基础用法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%EF%BC%9Aall%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">13.2.13.0.4.</span> <span class="toc-text">4：all的用法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%EF%BC%9Arace%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">13.2.13.0.5.</span> <span class="toc-text">5：race的用法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%EF%BC%9A%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AApromise"><span class="toc-number">13.2.13.0.6.</span> <span class="toc-text">6：手写一个promise</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7%EF%BC%9Apromise%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">13.2.13.0.7.</span> <span class="toc-text">7：promise面试题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14%EF%BC%9AIterator%E5%92%8Cfor%E2%80%A6of%E5%BE%AA%E7%8E%AF"><span class="toc-number">13.2.14.</span> <span class="toc-text">14：Iterator和for…of循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15%EF%BC%9AGenerator"><span class="toc-number">13.2.15.</span> <span class="toc-text">15：Generator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16%EF%BC%9AModule%E4%BD%93%E7%B3%BB"><span class="toc-number">13.2.16.</span> <span class="toc-text">16：Module体系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%EF%BC%9Aes7%E6%96%B0%E5%A2%9E%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">13.3.</span> <span class="toc-text">三：es7新增的特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E7%BB%84%E6%96%B0%E5%A2%9E%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">13.3.1.</span> <span class="toc-text">1:数组新增的方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E5%9B%9B%EF%BC%9A%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81"><span class="toc-number">14.</span> <span class="toc-text">十四：防抖和节流</span></a></li></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/front-end/JavaScript%E8%BF%90%E7%94%A8/" rel="bookmark" title="js运用">js运用</a></li><li><a href="/front-end/javascript%E9%9D%A2%E8%AF%95/" rel="bookmark" title="js面试">js面试</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Yn" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Yn</p><div class="description" itemprop="description">双马尾の罪</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">24</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">23</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">18</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BpbmstcG5n" title="https:&#x2F;&#x2F;github.com&#x2F;pink-png"><i class="ic i-github"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/front-end/Typescript/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/front-end/html+css%E9%9D%A2%E8%AF%95/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" title="分类于 前端开发">前端开发</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/uniapp/" title="分类于 uniapp">uniapp</a></div><span><a href="/front-end/uniapp/" title="uniapp基础原理">uniapp基础原理</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" title="分类于 前端开发">前端开发</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/React/" title="分类于 React">React</a></div><span><a href="/front-end/React/" title="React基础">React基础</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" title="分类于 前端开发">前端开发</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Javascript/" title="分类于 Javascript">Javascript</a></div><span><a href="/front-end/JavaScript%E8%BF%90%E7%94%A8/" title="js运用">js运用</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" title="分类于 前端开发">前端开发</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/css/" title="分类于 css">css</a></div><span><a href="/front-end/css%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AF%87/" title="css性能优化篇">css性能优化篇</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" title="分类于 前端开发">前端开发</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Typescript/" title="分类于 Typescript">Typescript</a></div><span><a href="/front-end/Typescript/" title="Typescript基础">Typescript基础</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" title="分类于 前端开发">前端开发</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/" title="分类于 前端工程化">前端工程化</a></div><span><a href="/front-end/webpack%E9%9D%A2%E8%AF%95/" title="webpack面试">webpack面试</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/" title="分类于 服务端开发">服务端开发</a> <i class="ic i-angle-right"></i> <a href="/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/java/" title="分类于 java">java</a> <i class="ic i-angle-right"></i> <a href="/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/java/hello-world/" title="分类于 hello world">hello world</a></div><span><a href="/rear-end/java/hello-world/" title="hello world">hello world</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a></div><span><a href="/suanfa/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="算法基础">算法基础</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" title="分类于 前端开发">前端开发</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Jquery/" title="分类于 Jquery">Jquery</a></div><span><a href="/front-end/Jquery/" title="Jquery基础">Jquery基础</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" title="分类于 前端开发">前端开发</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E8%B7%A8%E5%9F%9F/" title="分类于 跨域">跨域</a></div><span><a href="/front-end/%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" title="跨域解决方案">跨域解决方案</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Yn @ Yume Shoka</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"front-end/JavaScript运用/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>