<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="死肥宅" href="https://pink-png.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="死肥宅" href="https://pink-png.github.io/atom.xml"><link rel="alternate" type="application/json" title="死肥宅" href="https://pink-png.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="Javascript"><link rel="canonical" href="https://pink-png.github.io/js-base/promise/"><title>Promise - Javascript - 前端开发 | Yume Shoka = 死肥宅 = 肥宅快乐水</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">Promise</h1><div class="meta"><span class="item" title="创建时间：2021-06-25 16:43:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2021-06-25T16:43:00+08:00">2021-06-25</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Yume Shoka</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://cdn.cdnjson.com/tva3.sinaimg.cn/large/6833939bly1giclwrdwyaj20zk0m8are.jpg"></li><li class="item" data-background-image="https://cdn.cdnjson.com/tva3.sinaimg.cn/large/6833939bly1gipeuibk9fj20zk0m8ay2.jpg"></li><li class="item" data-background-image="https://cdn.cdnjson.com/tva3.sinaimg.cn/large/6833939bly1gicliwyw55j20zk0m8hdt.jpg"></li><li class="item" data-background-image="https://cdn.cdnjson.com/tva3.sinaimg.cn/large/6833939bly1gipewf5l51j20zk0m8b29.jpg"></li><li class="item" data-background-image="https://cdn.cdnjson.com/tva3.sinaimg.cn/large/6833939bly1gicitf0kl1j20zk0m87fe.jpg"></li><li class="item" data-background-image="https://cdn.cdnjson.com/tva3.sinaimg.cn/large/6833939bly1gicmnywqgpj20zk0m8dwx.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" itemprop="item" rel="index" title="分类于 前端开发"><span itemprop="name">前端开发</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Javascript/" itemprop="item" rel="index" title="分类于 Javascript"><span itemprop="name">Javascript</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://pink-png.github.io/js-base/promise/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="sanxin98"><meta itemprop="description" content="肥宅快乐水, 编程 & 生活"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="死肥宅"></span><div class="body md" itemprop="articleBody"><h1 id="什么是promise"><a href="#什么是promise" class="headerlink" title="什么是promise"></a>什么是promise</h1><p>Promise 是异步编程的一种解决方案： 从语法上讲，promise是一个对象，从它可以获取异步操作的消息；从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。 promise有三种状态：**pending(等待态)，fulfiled(成功态)，rejected(失败态)**；状态一旦改变，就不会再变。创造promise实例后，它会立即执行</p><h1 id="promise用来解决什么问题"><a href="#promise用来解决什么问题" class="headerlink" title="promise用来解决什么问题"></a>promise用来解决什么问题</h1><ol><li>回调地狱（Callback Hell）：在多个异步操作嵌套执行的情况下，使用传统的回调函数会导致代码结构混乱、可读性差，并且难以维护。Promise 可以通过链式调用的方式，使代码更加清晰易读，避免回调地狱的问题。</li><li>统一返回错误处理 catch</li><li>统一返回处理结果 then</li><li>并行异步操作的协调：有些场景下，需要同时执行多个异步操作，并在所有操作完成后进行进一步处理。Promise 提供了 Promise.all 方法，可以接收一个包含多个 Promise 对象的数组，并在所有 Promise 对象都成功解决后才返回结果，这样可以方便地协调并行异步操作。</li><li>多个异步操作的竞态条件控制：有时候需要多个异步操作并发执行，但只需要获取最先完成的结果。Promise 提供了 Promise.race 方法，可以接收一个包含多个 Promise 对象的数组，并在其中任何一个 Promise 对象首次解决或拒绝后即返回结果，方便控制竞态条件。</li></ol><h1 id="promise的基础用法"><a href="#promise的基础用法" class="headerlink" title="promise的基础用法"></a>promise的基础用法</h1><pre><code class="javascript">1： Promise是一个构造函数，自己身上有all、reject、resolve这几个眼熟的方法，原型上有then、catch等同样很眼熟的方法。

      let p = new Promise((resolve, reject) =&gt; &#123;
          //执行异步操作
          setTimeout(() =&gt; &#123;
              console.log(&#39;执行完成&#39;)
              resolve(&#39;我是成功！！&#39;)
          &#125;, 2000);
      &#125;)
上段代码会直接执行 2秒后输出 &#39;执行完成&#39;

Promise的构造函数接收一个参数：函数，并且这个函数需要传入两个参数：
resolve：异步操作执行成功后的回调函数
reject：异步操作执行失败后的回调函数

2：then 链式操作的用法  
从表面上看，Promise只是能够简化层层回调的写法，而实质上，Promise的精髓是“状态”，用维护状态、传递状态的方式来使得回调函数能够及时调用，它比传递callback函数要简单、灵活的多。所以使用Promise的正确场景是这样的：
      p.then((data) =&gt; &#123;
          console.log(data)
      &#125;)

3：reject的用法 
把Promise的状态置为rejected，这样我们在then中就能捕捉到，然后执行“失败”情况的回调。看下面的代码。
      let p = new Promise((resolve, reject) =&gt; &#123;
          //执行异步操作
          setTimeout(() =&gt; &#123;
              let num = Math.ceil(Math.random()*10) //生成1 - 10的随机数
               if(num &lt;= 5)&#123;
                   resolve(num)
               &#125;else&#123;
                   reject(&#39;数字是大于5的&#39;)
               &#125;
          &#125;, 1000);
      &#125;)

      p.then((data) =&gt; &#123;
          console.log(&#39;resolve&#39;,data)
      &#125;,(err) =&gt; &#123;
          console.log(&#39;rejeced&#39;,err)
      &#125;)
产生以一个随机数，如果大于5就会使用reject  错误(err)输出&#39;数字是大于5&#39;

4：catch的用法 (前面的代码有错误可以报出来，不要promise是无法执行下来的)
我们知道Promise对象除了then方法，还有一个catch方法，它是做什么用的呢？其实它和then的第二个参数一样，用来指定reject的回调。用法是这样：
      let p = new Promise((resolve, reject) =&gt; &#123;
          //执行异步操作
          setTimeout(() =&gt; &#123;
              let num = Math.ceil(Math.random()*10) //生成1 - 10的随机数
               if(num &lt;= 5)&#123;
                   resolve(num)
               &#125;else&#123;
                   reject(&#39;数字是大于5的&#39;)
               &#125;
          &#125;, 1000);
      &#125;)

      p.then((data) =&gt; &#123;
          console.log(&#39;resolve&#39;,data)  // 假设随机数是 3  那么输出 resolve 为 3
          console.log(aaaa)  //aaaa是没有被定义的
      &#125;,(err) =&gt; &#123;
          console.log(&#39;rejeced&#39;,err)
      &#125;).catch((err) =&gt; &#123;
          console.log(&#39;rejeced&#39;,err)  //  这里报错 ： rejeced ReferenceError: aaaa is not defined
      &#125;)
在resolve的回调中，我们console.log(somedata);而aaaa这个变量是没有被定义的。如果我们不用Promise，代码运行到这里就直接在控制台报错了，不往下运行了。
</code></pre><h1 id="all的用法"><a href="#all的用法" class="headerlink" title="all的用法"></a>all的用法</h1><pre><code class="javascript">1:
all的用法：谁跑的慢，以谁为准执行回调。all接收一个数组参数，里面的值最终都算返回Promise对象

2:
Promise的all方法提供了并行执行异步操作的能力，并且在所有异步操作执行完后才执行回调。看下面的例子：

        let promise1 = new Promise((resolve, reject) =&gt; &#123;
            setTimeout(() =&gt; &#123;
                var num = Math.ceil(Math.random() * 10); //生成1-10的随机数
                if (num &lt;= 5) &#123;
                    resolve(num);
                &#125;
                else &#123;
                    reject(&#39;数字太大了1&#39;);
                &#125;
            &#125;)
        &#125;)
        let promise2 = new Promise((resolve, reject) =&gt; &#123;
            setTimeout(() =&gt; &#123;
                var num = Math.ceil(Math.random() * 10); //生成1-10的随机数
                if (num &lt;= 5) &#123;
                    resolve(num);
                &#125;
                else &#123;
                    reject(&#39;数字太大了2&#39;);
                &#125;
            &#125;)
        &#125;)
        let promise3 = new Promise((resolve, reject) =&gt; &#123;
            setTimeout(() =&gt; &#123;
                var num = Math.ceil(Math.random() * 10); //生成1-10的随机数
                if (num &lt;= 5) &#123;
                    resolve(num);
                &#125;
                else &#123;
                    reject(&#39;数字太大了3&#39;);
                &#125;
            &#125;)
        &#125;)

        let p = Promise.all([promise1, promise2, promise3])

        p.then(function (res) &#123;
            //三个都成功则成功 res返回 [p1,p2,p3] 结果的数组
            console.log(res)
        &#125;, function (err) &#123;
            //只要有失败，则失败  err 返回在哪个promise失败的回调
            console.log(err)
        &#125;)

有了all，你就可以并行执行多个异步操作，并且在一个回调中处理所有的返回数据，是不是很酷？有一个场景是很适合用这个的，一些游戏类的素材比较多的应用，打开网页时，预先加载需要用到的各种资源如图片、flash以及各种静态文件。所有的都加载完后，我们再进行页面的初始化。
</code></pre><h1 id="race的用法"><a href="#race的用法" class="headerlink" title="race的用法"></a>race的用法</h1><pre><code class="javascript">1:race的用法：谁跑的快，以谁为准执行回调

2：race的使用场景：比如我们可以用race给某个异步请求设置超时时间，并且在超时后执行相应的操作，代码如下

        //请求某个图片资源
        function requestImg() &#123;
            var p = new Promise((resolve, reject) =&gt; &#123;
                var img = new Image();
                img.onload = function () &#123;
                    resolve(img);
                &#125;
                img.src = &#39;图片的路径&#39;;
            &#125;);
            return p;
        &#125;
        //延时函数，用于给请求计时
        function timeout() &#123;
            var p = new Promise((resolve, reject) =&gt; &#123;
                setTimeout(() =&gt; &#123;
                    reject(&#39;图片请求超时&#39;);
                &#125;, 5000);
            &#125;);
            return p;
        &#125;
        Promise.race([requestImg(), timeout()]).then((data) =&gt; &#123;
            console.log(data);
        &#125;).catch((err) =&gt; &#123;
            console.log(err);
        &#125;);

requestImg函数会异步请求一张图片，我把地址写为&quot;图片的路径&quot;，所以肯定是无法成功请求到的。timeout函数是一个延时5秒的异步操作。我们把这两个返回Promise对象的函数放进race，于是他俩就会赛跑，如果5秒之内图片请求成功了，那么遍进入then方法，执行正常的流程。如果5秒钟图片还未成功返回，那么timeout就跑赢了，则进入catch，报出“图片请求超时”的信息。
</code></pre><h1 id="promise-上有哪些方法"><a href="#promise-上有哪些方法" class="headerlink" title="promise 上有哪些方法"></a>promise 上有哪些方法</h1><ol><li><p>Promise.prototype.then(onFulfilled, onRejected)：添加对 Promise 成功或失败状态的处理函数。onFulfilled 是当 Promise 成功时执行的回调函数，onRejected 是当 Promise 失败时执行的回调函数。该方法返回一个新的 Promise 对象，可以通过链式调用 then 方法来实现对异步操作的连续处理。</p></li><li><p>Promise.prototype.catch(onRejected)：添加对 Promise 失败状态的处理函数。相当于调用 then(undefined, onRejected)。该方法也返回一个新的 Promise 对象。</p></li><li><p>Promise.prototype.finally(onFinally)：添加一个回调函数，在 Promise 执行结束后无论成功或失败都会执行该函数。可以用于清理工作或处理一些需要在最后执行的逻辑。该方法返回一个新的 Promise 对象。</p></li><li><p>Promise.resolve(value)：返回一个以给定值解析后的 Promise 对象。如果给定的值是一个 Promise 对象，则直接返回该对象，否则创建一个新的 Promise 对象并使用给定的值进行解析。</p></li><li><p>Promise.reject(reason)：返回一个以给定原因拒绝的 Promise 对象。</p></li><li><p>Promise.all(iterable)：接收一个可迭代对象（例如数组或类数组对象），并返回一个新的 Promise 对象。该 Promise 对象在所有输入的 Promise 对象都成功解析后才会成功解析，并将解析结果按顺序作为数组传递。如果其中任何一个 Promise 对象失败，则整个 Promise.all 操作会立即失败。</p></li><li><p>Promise.race(iterable)：接收一个可迭代对象，并返回一个新的 Promise 对象。该 Promise 对象在输入的 Promise 对象中有任何一个完成（无论成功或失败）时就会完成，并采用第一个完成的 Promise 的结果。</p></li><li><p>Promise.allSettled(iterable)：接收一个可迭代对象，并返回一个新的 Promise 对象。该 Promise 对象在所有输入的 Promise 对象都完成后才会完成，不管是成功还是失败，结果会作为数组传递给回调函数。</p></li><li><p>Promise.any(iterable)：接收一个可迭代对象，并返回一个新的 Promise 对象。该 Promise 对象在输入的 Promise 对象中有任何一个成功解析时就会成功解析，并采用第一个成功解析的 Promise 的结果。如果所有 Promise 都失败，则整个 Promise.any 操作会立即失败。</p></li></ol><h1 id="手写一个promise"><a href="#手写一个promise" class="headerlink" title="手写一个promise"></a>手写一个promise</h1><pre><code class="javascript">    // 三种状态
    const PENDING = &quot;pending&quot;;
    const RESOLVED = &quot;resolved&quot;;
    const REJECTED = &quot;rejected&quot;;
    // promise 接收⼀个函数参数，该函数会⽴即执⾏
    function MyPromise(fn) &#123;
        let _this = this;
        _this.currentState = PENDING;
        _this.value = undefined;
        // ⽤于保存 then 中的回调，只有当 promise
        // 状态为 pending 时才会缓存，并且每个实例⾄多缓存⼀个
        _this.resolvedCallbacks = [];
        _this.rejectedCallbacks = [];
        _this.resolve = function (value) &#123;
            if (value instanceof MyPromise) &#123;
                // 如果 value 是个 Promise，递归执⾏
                return value.then(_this.resolve, _this.reject)
            &#125;
            setTimeout(() =&gt; &#123; // 异步执⾏，保证执⾏顺序
                if (_this.currentState === PENDING) &#123;
                    _this.currentState = RESOLVED;
                    _this.value = value;
                    _this.resolvedCallbacks.forEach(cb =&gt; cb());
                &#125;
            &#125;)
        &#125;;
        _this.reject = function (reason) &#123;
            setTimeout(() =&gt; &#123; // 异步执⾏，保证执⾏顺序
                if (_this.currentState === PENDING) &#123;
                    _this.currentState = REJECTED;
                    _this.value = reason;
                    _this.rejectedCallbacks.forEach(cb =&gt; cb());
                &#125;
            &#125;)
        &#125;
        // ⽤于解决以下问题
        // new Promise(() =&gt; throw Error(&#39;error))
        try &#123;
            fn(_this.resolve, _this.reject);
        &#125; catch (e) &#123;
            _this.reject(e);
        &#125;
    &#125;

    MyPromise.prototype.then = function (onResolved, onRejected) &#123;
        var self = this;
        // 规范 2.2.7，then 必须返回⼀个新的 promise
        var promise2;
        // 规范 2.2.onResolved 和 onRejected 都为可选参数
        // 如果类型不是函数需要忽略，同时也实现了透传
        // Promise.resolve(4).then().then((value) =&gt; console.log(value))
        onResolved = typeof onResolved === &#39;function&#39; ? onResolved : v =&gt; v;
        onRejected = typeof onRejected === &#39;function&#39; ? onRejected : r =&gt; r
        if (self.currentState === RESOLVED) &#123;
            return (promise2 = new MyPromise(function (resolve, reject) &#123;
                // 规范 2.2.4，保证 onFulfilled，onRjected 异步执⾏
                // 所以⽤了 setTimeout 包裹下
                setTimeout(function () &#123;
                    try &#123;
                        var x = onResolved(self.value);
                        resolutionProcedure(promise2, x, resolve, reject);
                    &#125; catch (reason) &#123;
                        reject(reason);
                    &#125;
                &#125;);
            &#125;));
        &#125;
        if (self.currentState === REJECTED) &#123;
            return (promise2 = new MyPromise(function (resolve, reject) &#123;
                setTimeout(function () &#123;
                    // 异步执⾏onRejected
                    try &#123;
                        var x = onRejected(self.value);
                        resolutionProcedure(promise2, x, resolve, reject);
                    &#125; catch (reason) &#123;
                        reject(reason);
                    &#125;
                &#125;);
            &#125;));
        &#125;
        if (self.currentState === PENDING) &#123;
            return (promise2 = new MyPromise(function (resolve, reject) &#123;
                self.resolvedCallbacks.push(function () &#123;
                    // 考虑到可能会有报错，所以使⽤ try/catch 包裹
                    try &#123;
                        var x = onResolved(self.value);
                        resolutionProcedure(promise2, x, resolve, reject);
                    &#125; catch (r) &#123;
                        reject(r);
                    &#125;
                &#125;);
                self.rejectedCallbacks.push(function () &#123;
                    try &#123;
                        var x = onRejected(self.value);
                        resolutionProcedure(promise2, x, resolve, reject);
                    &#125; catch (r) &#123;
                        reject(r);
                    &#125;
                &#125;);
            &#125;));
        &#125;
    &#125;;
</code></pre><h1 id="promise经典案例加深理解"><a href="#promise经典案例加深理解" class="headerlink" title="promise经典案例加深理解"></a>promise经典案例加深理解</h1><pre><code class="javascript">1.
const promise = new Promise((resolve, reject) =&gt; &#123;
  console.log(1)
  resolve()
  console.log(2)
&#125;)
promise.then(() =&gt; &#123;
  console.log(3)
&#125;)
console.log(4)


输出:  1 2 4 3
解释:  Promise构造函数是同步执行的,promsie.then 中的函数是异步执行的 
</code></pre><pre><code class="javascript">2.
const promise1 = new Promise((resolve, reject) =&gt; &#123;
  setTimeout(() =&gt; &#123;
    resolve(&#39;success&#39;)
  &#125;, 1000)
&#125;)
const promise2 = promise1.then(() =&gt; &#123;
  throw new Error(&#39;error!!!&#39;)
&#125;)

console.log(&#39;promise1&#39;, promise1)
console.log(&#39;promise2&#39;, promise2)

setTimeout(() =&gt; &#123;
  console.log(&#39;promise1&#39;, promise1)
  console.log(&#39;promise2&#39;, promise2)
&#125;, 2000)

输出:
promise1 Promise &#123; &lt;pending&gt; &#125;
promise2 Promise &#123; &lt;pending&gt; &#125;
promise1 Promise &#123; &lt;fulfilled&gt;: &quot;success&quot; &#125;
promise2 Promise &#123; &lt;rejected&gt;: Error: error!!! at promise1.then (…) &#125;

解释：
创建 Promise promise1，1 秒后变为已兑现状态。
使用 then 方法将回调函数添加到 promise1 上并创建了 promise2。
在第一轮事件循环结束前，打印 promise1 和 promise2，它们都是待定状态。
在第二轮事件循环开始时，promise1 变为已兑现状态，promise2 变为已拒绝状态。
</code></pre><pre><code class="javascript">3.
const promise = new Promise((resolve, reject) =&gt; &#123;
  resolve(&#39;success1&#39;)
  reject(&#39;error&#39;)
  resolve(&#39;success2&#39;)
&#125;)

promise
  .then((res) =&gt; &#123;
    console.log(&#39;then: &#39;, res)
  &#125;)
  .catch((err) =&gt; &#123;
    console.log(&#39;catch: &#39;, err)
  &#125;)

输出: success1
解释：构造函数中的 resolve 或 reject 只有第一次执行有效，多次调用没有任何作用，呼应代码二结论：promise 状态一旦改变则不能再变。
</code></pre><pre><code class="javascript">4.
Promise.resolve(1)
  .then((res) =&gt; &#123;
    console.log(res)
    return 2
  &#125;)
  .catch((err) =&gt; &#123;
    return 3
  &#125;)
  .then((res) =&gt; &#123;
    console.log(res)
  &#125;)

输出:  1,2

解释：promise 可以链式调用。提起链式调用我们通常会想到通过 return this 实现，不过 Promise 并不是这样实现的。promise 每次调用 .then 或者 .catch 都会返回一个新的 promise，从而实现了链式调用。
</code></pre><pre><code class="javascript">5.
const promise = new Promise((resolve, reject) =&gt; &#123;
  setTimeout(() =&gt; &#123;
    console.log(&#39;once&#39;)
    resolve(&#39;success&#39;)
  &#125;, 1000)
&#125;)

const start = Date.now()
promise.then((res) =&gt; &#123;
  console.log(res, Date.now() - start)
&#125;)
promise.then((res) =&gt; &#123;
  console.log(res, Date.now() - start)
&#125;)

输出:
once
success 1000
success 1000

解释：promise 的 .then 或者 .catch 可以被调用多次，但这里 Promise 构造函数只执行一次。或者说 promise 内部状态一经改变，并且有了一个值，那么后续每次调用 .then 或者 .catch 都会直接拿到该值
</code></pre><pre><code class="javascript">6.
Promise.resolve()
  .then(() =&gt; &#123;
    return new Error(&#39;error!!!&#39;)
  &#125;)
  .then((res) =&gt; &#123;
    console.log(&#39;then: &#39;, res)
  &#125;)
  .catch((err) =&gt; &#123;
    console.log(&#39;catch: &#39;, err)
  &#125;)

输出:
then: Error: error!!!
    at Promise.resolve.then (...)
    at ...
                             
解释：.then 或者 .catch 中 return 一个 error 对象并不会抛出错误，所以不会被后续的 .catch 捕获，需要改成其中一种：                                                       
</code></pre><pre><code class="javascript">7.
const promise = Promise.resolve()
  .then(() =&gt; &#123;
    return promise
  &#125;)
promise.catch(console.error)

输出:
TypeError: Chaining cycle detected for promise #&lt;Promise&gt;
    at &lt;anonymous&gt;
    at process._tickCallback (internal/process/next_tick.js:188:7)
    at Function.Module.runMain (module.js:667:11)
    at startup (bootstrap_node.js:187:16)
    at bootstrap_node.js:607:3

解释：.then 或 .catch 返回的值不能是 promise 本身，否则会造成死循环。类似于：
process.nextTick(function tick () &#123;
  console.log(&#39;tick&#39;)
  process.nextTick(tick)
&#125;)
</code></pre><pre><code class="javascript">8.
Promise.resolve(1)
  .then(2)
  .then(Promise.resolve(3))
  .then(console.log)

输出: 1
解释：.then 或者 .catch 的参数期望是函数，传入非函数则会发生值穿透。
</code></pre><pre><code class="javascript">9.
Promise.resolve()
  .then(function success (res) &#123;
    throw new Error(&#39;error&#39;)
  &#125;, function fail1 (e) &#123;
    console.error(&#39;fail1: &#39;, e)
  &#125;)
  .catch(function fail2 (e) &#123;
    console.error(&#39;fail2: &#39;, e)
  &#125;)

输出:
fail2: Error: error
    at success (...)
    at ...
                
解释：.then 可以接收两个参数，第一个是处理成功的函数，第二个是处理错误的函数。.catch 是 .then 第二个参数的简便写法，但是它们用法上有一点需要注意：.then 的第二个处理错误的函数捕获不了第一个处理成功的函数抛出的错误，而后续的 .catch 可以捕获之前的错误。当然以下代码也可以：            
</code></pre><pre><code class="javascript">10.
process.nextTick(() =&gt; &#123;
  console.log(&#39;nextTick&#39;)
&#125;)
Promise.resolve()
  .then(() =&gt; &#123;
    console.log(&#39;then&#39;)
  &#125;)
setImmediate(() =&gt; &#123;
  console.log(&#39;setImmediate&#39;)
&#125;)
console.log(&#39;end&#39;)

输出:
end
nextTick
then
setImmediate

解释：process.nextTick 和 promise.then 都属于 microtask，而 setImmediate 属于 macrotask，在事件循环的 check 阶段执行。事件循环的每个阶段（macrotask）之间都会执行 microtask，事件循环的开始会先执行一次 microtask。
</code></pre><div class="tags"><a href="/tags/Javascript/" rel="tag"><i class="ic i-tag"></i> Javascript</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-07-21 09:05:37" itemprop="dateModified" datetime="2023-07-21T09:05:37+08:00">2023-07-21</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="sanxin98 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="sanxin98 支付宝"><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>sanxin98 <i class="ic i-at"><em>@</em></i>死肥宅</li><li class="link"><strong>本文链接：</strong> <a href="https://pink-png.github.io/js-base/promise/" title="Promise">https://pink-png.github.io/js-base/promise/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/js-base/%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;cdn.cdnjson.com&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclgi503lj20zk0m8hdt.jpg" title="数组扁平化"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> Javascript</span><h3>数组扁平化</h3></a></div><div class="item right"><a href="/js-base/js%E6%B5%85%E8%B0%88call%E5%92%8Capply%E5%92%8Cbind/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;cdn.cdnjson.com&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipex2cdtbj20zk0m8x6p.jpg" title="浅谈call和apply和bind"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> Javascript</span><h3>浅谈call和apply和bind</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFpromise"><span class="toc-number">1.</span> <span class="toc-text">什么是promise</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#promise%E7%94%A8%E6%9D%A5%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">promise用来解决什么问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#promise%E7%9A%84%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">promise的基础用法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#all%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">all的用法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#race%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">5.</span> <span class="toc-text">race的用法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#promise-%E4%B8%8A%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95"><span class="toc-number">6.</span> <span class="toc-text">promise 上有哪些方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AApromise"><span class="toc-number">7.</span> <span class="toc-text">手写一个promise</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#promise%E7%BB%8F%E5%85%B8%E6%A1%88%E4%BE%8B%E5%8A%A0%E6%B7%B1%E7%90%86%E8%A7%A3"><span class="toc-number">8.</span> <span class="toc-text">promise经典案例加深理解</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/js-base/js%E4%B8%AD%E7%9A%84%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/" rel="bookmark" title="js中的深浅拷贝">js中的深浅拷贝</a></li><li><a href="/js-base/event%20loop/" rel="bookmark" title="event loop">event loop</a></li><li><a href="/js-base/javascript%E9%9D%A2%E8%AF%95/" rel="bookmark" title="js面试">js面试</a></li><li><a href="/js-base/js%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%B5%81/" rel="bookmark" title="js中的事件">js中的事件</a></li><li><a href="/js-base/js%E5%85%B3%E4%BA%8EString%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E7%9A%84%E6%80%BB%E7%BB%93/" rel="bookmark" title="关于String包装类型处理数据的总结">关于String包装类型处理数据的总结</a></li><li><a href="/js-base/js%E5%85%B3%E4%BA%8EArray%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/" rel="bookmark" title="关于Array处理数据的方法总结">关于Array处理数据的方法总结</a></li><li><a href="/js-base/js%E5%8E%9F%E5%9E%8B%EF%BC%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/" rel="bookmark" title="js原型，原型链">js原型，原型链</a></li><li><a href="/js-base/js%E6%B5%85%E8%B0%88call%E5%92%8Capply%E5%92%8Cbind/" rel="bookmark" title="浅谈call和apply和bind">浅谈call和apply和bind</a></li><li class="active"><a href="/js-base/promise/" rel="bookmark" title="Promise">Promise</a></li><li><a href="/js-base/%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96/" rel="bookmark" title="数组扁平化">数组扁平化</a></li><li><a href="/js-base/jsES6-ES13%E6%96%B0%E5%A2%9E%E7%9A%84%E5%8A%9F%E8%83%BD/" rel="bookmark" title="ES6-ES13新增的特性">ES6-ES13新增的特性</a></li><li><a href="/js-base/js%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/" rel="bookmark" title="javascript全局函数和全局变量">javascript全局函数和全局变量</a></li><li><a href="/js-base/js%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F/" rel="bookmark" title="js创建对象的多种方式">js创建对象的多种方式</a></li><li><a href="/js-base/js%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/" rel="bookmark" title="js 实现异步编程">js 实现异步编程</a></li><li><a href="/js-base/js%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/" rel="bookmark" title="数组去重方法总结">数组去重方法总结</a></li><li><a href="/js-base/js%E6%B5%85%E8%B0%88new%20this/" rel="bookmark" title="浅谈js中new this 关键字">浅谈js中new this 关键字</a></li><li><a href="/js-base/js%E6%B5%85%E8%B0%88%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%BB%A5%E5%8F%8A%E5%8F%98%E9%87%8F%E4%BB%A5%E5%8F%8A%E9%97%AD%E5%8C%85/" rel="bookmark" title="js浅谈作用域 - 变量 - 闭包">js浅谈作用域 - 变量 - 闭包</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="sanxin98" data-src="/images/avatar.jpg"><p class="name" itemprop="name">sanxin98</p><div class="description" itemprop="description">编程 & 生活</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">92</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">36</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">26</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BpbmstcG5n" title="https:&#x2F;&#x2F;github.com&#x2F;pink-png"><i class="ic i-github"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/js-base/%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/js-base/js%E6%B5%85%E8%B0%88call%E5%92%8Capply%E5%92%8Cbind/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" title="分类于 前端开发">前端开发</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Bootstrap/" title="分类于 Bootstrap">Bootstrap</a></div><span><a href="/front-end/Bootstrap/" title="Bootstrap">Bootstrap</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" title="分类于 前端开发">前端开发</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Javascript/" title="分类于 Javascript">Javascript</a></div><span><a href="/js-base/js%E5%85%B3%E4%BA%8EArray%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/" title="关于Array处理数据的方法总结">关于Array处理数据的方法总结</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" title="分类于 前端开发">前端开发</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Uniapp/" title="分类于 Uniapp">Uniapp</a></div><span><a href="/front-end/%E8%AE%B0%E4%B8%80%E6%AC%A1vue%E8%BD%ACuniapp/" title="记一次vue转uniapp">记一次vue转uniapp</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" title="分类于 前端开发">前端开发</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/gulp/" title="分类于 gulp">gulp</a></div><span><a href="/front-end/gulp/" title="gulp">gulp</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/react0-1/" title="分类于 react">react</a></div><span><a href="/computer-science/react0-1/react%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/" title="step.1 react基础语法">step.1 react基础语法</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" title="分类于 前端开发">前端开发</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" title="分类于 前端性能优化">前端性能优化</a></div><span><a href="/performance-optimization/%E6%94%AF%E4%BB%98%E5%AE%9D%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/" title="支付宝小程序性能优化方案">支付宝小程序性能优化方案</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" title="分类于 前端开发">前端开发</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Javascript/" title="分类于 Javascript">Javascript</a></div><span><a href="/js-base/js%E5%85%B3%E4%BA%8EString%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E7%9A%84%E6%80%BB%E7%BB%93/" title="关于String包装类型处理数据的总结">关于String包装类型处理数据的总结</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" title="分类于 前端开发">前端开发</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Javascript/" title="分类于 Javascript">Javascript</a></div><span><a href="/js-base/js%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/" title="javascript全局函数和全局变量">javascript全局函数和全局变量</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" title="分类于 前端开发">前端开发</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" title="分类于 前端性能优化">前端性能优化</a></div><span><a href="/performance-optimization/css%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AF%87/" title="css性能优化篇">css性能优化篇</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" title="分类于 前端开发">前端开发</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/" title="分类于 前端工程化">前端工程化</a></div><span><a href="/front-end/webpack/" title="webpack">webpack</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">sanxin98 @ Yume Shoka</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"js-base/promise/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>