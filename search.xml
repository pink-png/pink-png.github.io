<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>前端调试技巧</title>
      <link href="/performance-optimization/%E5%89%8D%E7%AB%AF%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/"/>
      <url>/performance-optimization/%E5%89%8D%E7%AB%AF%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<pre><code class="javascript">1、网络 请求重新发送xhr 2、修改请求参数： 复制-&gt;以fetch格式复制3、复制JavaScript变量：右键复制object、将object存储为全局变量4、$0 输出选中的第一个元素5、截屏：Ctrl+shift+p screen6、同时展开多级节点 选中元素，按住alt再点击7、$_ 上一个输出结果8、Ctrl +shift +p switch切换主题9、$$()选中所有匹配元素10、debugger</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> 前端调试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git学习清单</title>
      <link href="/tool/git%E5%AD%A6%E4%B9%A0%E6%B8%85%E5%8D%95/"/>
      <url>/tool/git%E5%AD%A6%E4%B9%A0%E6%B8%85%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-初始化本地仓库-git-init"><a href="#1-初始化本地仓库-git-init" class="headerlink" title="1.初始化本地仓库  git init "></a>1.初始化本地仓库  git init <directory></h2><h2 id="2-克隆一个远程仓库-git-clone"><a href="#2-克隆一个远程仓库-git-clone" class="headerlink" title="2.克隆一个远程仓库  git clone "></a>2.克隆一个远程仓库  git clone <url></h2><h2 id="3-添加文件到暂存区-git-add-要添加当前目录中的所有文件，请使用-代替-代码如下：-git-add"><a href="#3-添加文件到暂存区-git-add-要添加当前目录中的所有文件，请使用-代替-代码如下：-git-add" class="headerlink" title="3.添加文件到暂存区 git add 要添加当前目录中的所有文件，请使用 . 代替,代码如下： git add ."></a>3.添加文件到暂存区 git add <file>要添加当前目录中的所有文件，请使用 . 代替,代码如下： git add .</h2><h2 id="4-提交更改-git-commit-m-““如果要添加对跟踪文件所做的所有更改并提交。-git-commit-a-m-““-orgit-commit-am-““"><a href="#4-提交更改-git-commit-m-““如果要添加对跟踪文件所做的所有更改并提交。-git-commit-a-m-““-orgit-commit-am-““" class="headerlink" title="4.提交更改 git commit -m ““如果要添加对跟踪文件所做的所有更改并提交。 git commit -a -m ““# orgit commit -am ““"></a>4.提交更改 git commit -m “<message>“如果要添加对跟踪文件所做的所有更改并提交。 git commit -a -m “<message>“# orgit commit -am “<message>“</h2><h2 id="5-从暂存区删除一个文件-git-reset"><a href="#5-从暂存区删除一个文件-git-reset" class="headerlink" title="5.从暂存区删除一个文件 git reset "></a>5.从暂存区删除一个文件 git reset <file></h2><h2 id="6-移动或重命名文件-git-mv"><a href="#6-移动或重命名文件-git-mv" class="headerlink" title="6.移动或重命名文件 git mv  "></a>6.移动或重命名文件 git mv <current path> <new path></h2><h2 id="7-从存储库中删除文件-git-rm-您也可以仅使用-–cached-标志将其从暂存区中删除-git-rm-–cached"><a href="#7-从存储库中删除文件-git-rm-您也可以仅使用-–cached-标志将其从暂存区中删除-git-rm-–cached" class="headerlink" title="7.从存储库中删除文件  git rm  您也可以仅使用 –cached 标志将其从暂存区中删除 git rm –cached "></a>7.从存储库中删除文件  git rm <file> 您也可以仅使用 –cached 标志将其从暂存区中删除 git rm –cached <file></h2><h1 id="基本-Git-概念"><a href="#基本-Git-概念" class="headerlink" title="基本 Git 概念"></a>基本 Git 概念</h1><h2 id="8-默认分支名称：main"><a href="#8-默认分支名称：main" class="headerlink" title="8.默认分支名称：main"></a>8.默认分支名称：main</h2><h2 id="9-默认远程名称：origin"><a href="#9-默认远程名称：origin" class="headerlink" title="9.默认远程名称：origin"></a>9.默认远程名称：origin</h2><h2 id="10-当前分支参考：HEAD"><a href="#10-当前分支参考：HEAD" class="headerlink" title="10.当前分支参考：HEAD"></a>10.当前分支参考：HEAD</h2><h2 id="11-HEAD-的父级：HEAD-或-HEAD-1"><a href="#11-HEAD-的父级：HEAD-或-HEAD-1" class="headerlink" title="11.HEAD 的父级：HEAD^ 或 HEAD~1"></a>11.HEAD 的父级：HEAD^ 或 HEAD~1</h2><h2 id="12-HEAD-的祖父母：HEAD-或-HEAD-2"><a href="#12-HEAD-的祖父母：HEAD-或-HEAD-2" class="headerlink" title="12.HEAD 的祖父母：HEAD^^ 或 HEAD~2"></a>12.HEAD 的祖父母：HEAD^^ 或 HEAD~2</h2><h2 id="13-显示分支-git-branch-有用的标志："><a href="#13-显示分支-git-branch-有用的标志：" class="headerlink" title="13.显示分支 git branch  有用的标志："></a>13.显示分支 git branch  有用的标志：</h2><p>-a：显示所有分支（本地和远程）</p><p>-r：显示远程分支</p><p>-v：显示最后一次提交的分支</p><h2 id="14-创建一个分支-git-branch-你可以创建一个分支并使用-checkout-命令切换到它。git-checkout-b"><a href="#14-创建一个分支-git-branch-你可以创建一个分支并使用-checkout-命令切换到它。git-checkout-b" class="headerlink" title="14.创建一个分支 git branch   你可以创建一个分支并使用 checkout 命令切换到它。git checkout -b "></a>14.创建一个分支 git branch <branch>  你可以创建一个分支并使用 checkout 命令切换到它。git checkout -b <branch></h2><h2 id="15-切换到一个分支-git-checkout"><a href="#15-切换到一个分支-git-checkout" class="headerlink" title="15.切换到一个分支 git checkout "></a>15.切换到一个分支 git checkout <branch></h2><h2 id="16-删除一个分支-git-branch-d-您还可以使用-D-标志强制删除分支。-git-branch-D"><a href="#16-删除一个分支-git-branch-d-您还可以使用-D-标志强制删除分支。-git-branch-D" class="headerlink" title="16.删除一个分支 git branch -d  您还可以使用 -D 标志强制删除分支。 git branch -D "></a>16.删除一个分支 git branch -d <branch> 您还可以使用 -D 标志强制删除分支。 git branch -D <branch></h2><h2 id="17-合并分支-git-merge-有用的标志："><a href="#17-合并分支-git-merge-有用的标志：" class="headerlink" title="17.合并分支 git merge  有用的标志："></a>17.合并分支 git merge <branch to merge into HEAD> 有用的标志：</h2><p>–no-ff：即使合并解析为快进，也创建合并提交</p><p>–squash：将指定分支中的所有提交压缩为单个提交</p><p>建议不要使用 –squash 标志，因为它会将所有提交压缩为单个提交，从而导致提交历史混乱。</p><h2 id="18-变基分支-变基是将一系列提交移动或组合到新的基本提交的过程。git-rebase"><a href="#18-变基分支-变基是将一系列提交移动或组合到新的基本提交的过程。git-rebase" class="headerlink" title="18.变基分支 变基是将一系列提交移动或组合到新的基本提交的过程。git rebase "></a>18.变基分支 变基是将一系列提交移动或组合到新的基本提交的过程。git rebase <branch to rebase from></h2><h2 id="19-查看之前的提交-git-checkout"><a href="#19-查看之前的提交-git-checkout" class="headerlink" title="19.查看之前的提交 git checkout "></a>19.查看之前的提交 git checkout <commit id></h2><h2 id="20-恢复提交-git-revert"><a href="#20-恢复提交-git-revert" class="headerlink" title="20.恢复提交 git revert "></a>20.恢复提交 git revert <commit id></h2><h2 id="21-重置提交-git-reset-您还可以添加-–hard-标志来删除所有更改，但请谨慎使用。-git-reset-–hard"><a href="#21-重置提交-git-reset-您还可以添加-–hard-标志来删除所有更改，但请谨慎使用。-git-reset-–hard" class="headerlink" title="21.重置提交 git reset  您还可以添加 –hard 标志来删除所有更改，但请谨慎使用。 git reset –hard "></a>21.重置提交 git reset <commit id> 您还可以添加 –hard 标志来删除所有更改，但请谨慎使用。 git reset –hard <commit id></h2><h2 id="22-查看存储库的状态-git-status"><a href="#22-查看存储库的状态-git-status" class="headerlink" title="22.查看存储库的状态 git status"></a>22.查看存储库的状态 git status</h2><h2 id="23-显示提交历史-git-log"><a href="#23-显示提交历史-git-log" class="headerlink" title="23.显示提交历史 git log"></a>23.显示提交历史 git log</h2><h2 id="24-显示对未暂存文件的更改-git-diff-您还可以使用-–staged-标志来显示对暂存文件的更改。-git-diff-–staged"><a href="#24-显示对未暂存文件的更改-git-diff-您还可以使用-–staged-标志来显示对暂存文件的更改。-git-diff-–staged" class="headerlink" title="24.显示对未暂存文件的更改 git diff\  您还可以使用 –staged 标志来显示对暂存文件的更改。 git diff –staged"></a>24.显示对未暂存文件的更改 git diff\  您还可以使用 –staged 标志来显示对暂存文件的更改。 git diff –staged</h2><h2 id="25-显示两次提交之间的变化-git-diff-lt-commit-id-01-gt-lt-commit-id-02-gt"><a href="#25-显示两次提交之间的变化-git-diff-lt-commit-id-01-gt-lt-commit-id-02-gt" class="headerlink" title="25.显示两次提交之间的变化 git diff &lt;commit id 01&gt; &lt;commit id 02&gt;"></a>25.显示两次提交之间的变化 git diff &lt;commit id 01&gt; &lt;commit id 02&gt;</h2><h2 id="26-存储更改-stash-允许您在不提交更改的情况下临时存储更改。-git-stash-您还可以将消息添加到存储中。-git-stash-save-““"><a href="#26-存储更改-stash-允许您在不提交更改的情况下临时存储更改。-git-stash-您还可以将消息添加到存储中。-git-stash-save-““" class="headerlink" title="26.存储更改 stash 允许您在不提交更改的情况下临时存储更改。 git stash  您还可以将消息添加到存储中。 git stash save ““"></a>26.存储更改 stash 允许您在不提交更改的情况下临时存储更改。 git stash  您还可以将消息添加到存储中。 git stash save “<message>“</h2><h2 id="27-列出存储-git-stash-list"><a href="#27-列出存储-git-stash-list" class="headerlink" title="27.列出存储 git stash list"></a>27.列出存储 git stash list</h2><h2 id="28-申请一个藏匿处-应用存储不会将其从存储列表中删除。-git-stash-apply-如果不指定，将应用最新的-stash（适用于所有类似的-stash-命令）-您还可以使用格式-stash-应用存储（适用于所有类似的存储命令）-git-stash-apply-stash-0"><a href="#28-申请一个藏匿处-应用存储不会将其从存储列表中删除。-git-stash-apply-如果不指定，将应用最新的-stash（适用于所有类似的-stash-命令）-您还可以使用格式-stash-应用存储（适用于所有类似的存储命令）-git-stash-apply-stash-0" class="headerlink" title="28.申请一个藏匿处 应用存储不会将其从存储列表中删除。 git stash apply  如果不指定，将应用最新的 stash（适用于所有类似的 stash 命令） 您还可以使用格式 stash@{} 应用存储（适用于所有类似的存储命令） git stash apply stash@{0}"></a>28.申请一个藏匿处 应用存储不会将其从存储列表中删除。 git stash apply <stash id> 如果不指定，将应用最新的 stash（适用于所有类似的 stash 命令） 您还可以使用格式 stash@{} 应用存储（适用于所有类似的存储命令） git stash apply stash@{0}</h2><h2 id="29-删除一个藏匿处-git-stash-drop"><a href="#29-删除一个藏匿处-git-stash-drop" class="headerlink" title="29.删除一个藏匿处 git stash drop "></a>29.删除一个藏匿处 git stash drop <stash id></h2><h2 id="30-删除所有藏匿处-git-stash-clear"><a href="#30-删除所有藏匿处-git-stash-clear" class="headerlink" title="30.删除所有藏匿处 git stash clear"></a>30.删除所有藏匿处 git stash clear</h2><h2 id="31-应用和删除存储-git-stash-pop"><a href="#31-应用和删除存储-git-stash-pop" class="headerlink" title="31.应用和删除存储 git stash pop "></a>31.应用和删除存储 git stash pop <stash id></h2><h2 id="32-显示存储中的更改-git-stash-show"><a href="#32-显示存储中的更改-git-stash-show" class="headerlink" title="32.显示存储中的更改 git stash show "></a>32.显示存储中的更改 git stash show <stash id></h2><h2 id="33-添加远程仓库-git-remote-add"><a href="#33-添加远程仓库-git-remote-add" class="headerlink" title="33.添加远程仓库 git remote add  "></a>33.添加远程仓库 git remote add <remote name> <url></h2><h2 id="34-显示远程仓库-git-remote-添加-v-标志以显示远程存储库的-URL。-git-remote-v"><a href="#34-显示远程仓库-git-remote-添加-v-标志以显示远程存储库的-URL。-git-remote-v" class="headerlink" title="34.显示远程仓库 git remote 添加 -v 标志以显示远程存储库的 URL。 git remote -v"></a>34.显示远程仓库 git remote 添加 -v 标志以显示远程存储库的 URL。 git remote -v</h2><h2 id="35-删除远程仓库-git-remote-remove"><a href="#35-删除远程仓库-git-remote-remove" class="headerlink" title="35.删除远程仓库 git remote remove "></a>35.删除远程仓库 git remote remove <remote name></h2><h2 id="36-重命名远程存储库-git-remote-rename"><a href="#36-重命名远程存储库-git-remote-rename" class="headerlink" title="36.重命名远程存储库 git remote rename  "></a>36.重命名远程存储库 git remote rename <old name> <new name></h2><h2 id="37-从远程存储库中获取更改-git-fetch"><a href="#37-从远程存储库中获取更改-git-fetch" class="headerlink" title="37.从远程存储库中获取更改 git fetch "></a>37.从远程存储库中获取更改 git fetch <remote name></h2><h2 id="38-从特定分支获取更改-git-fetch"><a href="#38-从特定分支获取更改-git-fetch" class="headerlink" title="38.从特定分支获取更改 git fetch  "></a>38.从特定分支获取更改 git fetch <remote name> <branch></h2><h2 id="39-从远程存储库中拉取更改-git-pull"><a href="#39-从远程存储库中拉取更改-git-pull" class="headerlink" title="39.从远程存储库中拉取更改 git pull  "></a>39.从远程存储库中拉取更改 git pull <remote name> <branch></h2><h2 id="40-将更改推送到远程存储库-git-push"><a href="#40-将更改推送到远程存储库-git-push" class="headerlink" title="40.将更改推送到远程存储库 git push "></a>40.将更改推送到远程存储库 git push <remote name></h2><h2 id="41-将更改推送到特定分支-git-push"><a href="#41-将更改推送到特定分支-git-push" class="headerlink" title="41.将更改推送到特定分支 git push  "></a>41.将更改推送到特定分支 git push <remote name> <branch></h2>]]></content>
      
      
      <categories>
          
          <category> 版本管理 </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 版本管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>下载</title>
      <link href="/tool/%E4%B8%8B%E8%BD%BD%E7%B1%BB/"/>
      <url>/tool/%E4%B8%8B%E8%BD%BD%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="xshell-下载地址"><a href="#xshell-下载地址" class="headerlink" title="xshell 下载地址"></a>xshell 下载地址</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cueHNoZWxsLmNvbS96aC9mcmVlLWZvci1ob21lLXNjaG9vbC8=">https://www.xshell.com/zh/free-for-home-school/</span> </p>]]></content>
      
      
      <categories>
          
          <category> 下载 </category>
          
          <category> xshell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xshell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6-ES13新增的特性</title>
      <link href="/js-base/jsES6-ES13%E6%96%B0%E5%A2%9E%E7%9A%84%E5%8A%9F%E8%83%BD/"/>
      <url>/js-base/jsES6-ES13%E6%96%B0%E5%A2%9E%E7%9A%84%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="ES6（ES2015）"><a href="#ES6（ES2015）" class="headerlink" title="ES6（ES2015）"></a>ES6（ES2015）</h1><pre><code class="text">块级作用域变量声明（let和const）箭头函数模板字面量解构赋值默认参数值扩展运算符和剩余参数类和模块化（class和import/export）Promise 对象迭代器和生成器（Iterator和Generator）新的集合类型（Map、Set、WeakMap、WeakSet）</code></pre><h1 id="ES7（ES2016）"><a href="#ES7（ES2016）" class="headerlink" title="ES7（ES2016）"></a>ES7（ES2016）</h1><pre><code class="text">Array.prototype.includes 方法指数操作符（**）</code></pre><h1 id="ES8-ES2017"><a href="#ES8-ES2017" class="headerlink" title="ES8 (ES2017)"></a>ES8 (ES2017)</h1><pre><code class="text">异步函数（async/await）Object.values 和 Object.entries 方法字符串填充方法（padStart和padEnd）</code></pre><h1 id="ES9-ES2018"><a href="#ES9-ES2018" class="headerlink" title="ES9 (ES2018)"></a>ES9 (ES2018)</h1><pre><code class="text">异步迭代器Promise.prototype.finally 方法Rest/Spread 属性</code></pre><h1 id="ES10-ES2019"><a href="#ES10-ES2019" class="headerlink" title="ES10 (ES2019)"></a>ES10 (ES2019)</h1><pre><code class="text">Array.prototype.flat 和 Array.prototype.flatMap 方法Optional Chaining （可选链操作符 ?.）空值合并运算符（??）</code></pre><h1 id="ES11-ES2020"><a href="#ES11-ES2020" class="headerlink" title="ES11 (ES2020)"></a>ES11 (ES2020)</h1><pre><code class="text">BigInt 类型动态导入（import()）可选的捕获绑定（Optional catch binding）Promise.allSettled 方法String.prototype.matchAll 方法全局对象 globalThis</code></pre><h1 id="ES12-ES2021"><a href="#ES12-ES2021" class="headerlink" title="ES12 (ES2021)"></a>ES12 (ES2021)</h1><pre><code class="text">逻辑赋值运算符（||=、&amp;&amp;=、??=）String.prototype.replaceAll 方法Promise.any 方法私有字段和方法（# 开头）数字分隔符（Number separator）</code></pre><h1 id="ES13-ES2022"><a href="#ES13-ES2022" class="headerlink" title="ES13 (ES2022)"></a>ES13 (ES2022)</h1><pre><code class="text">导入.meta对象字符串实例方法String.prototype.&#123;trimLeft, trimRight&#125;异步迭代器的for-await-of支持import()的顶级动态引入更宽松的模板字面量转义</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript全局函数和全局变量</title>
      <link href="/js-base/js%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/"/>
      <url>/js-base/js%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<ol><li>全局变量</li></ol><ul><li>Infinity 代表正的⽆穷⼤的数值。</li><li>NaN 指示某个值是不是数字值。</li><li>undefined 指示未定义的值。</li></ul><ol start="2"><li>全局函数</li></ol><ul><li>decodeURI() 解码某个编码的 URI 。</li><li>decodeURIComponent() 解码⼀个编码的 URI 组件。</li><li>encodeURI() 把字符串编码为 URI。</li><li>encodeURIComponent() 把字符串编码为 URI 组件。</li><li>escape() 对字符串进⾏编码。</li><li>eval() 计算 JavaScript 字符串，并把它作为脚本代码来执⾏。</li><li>isFinite() 检查某个值是否为有穷⼤的数。</li><li>isNaN() 检查某个值是否是数字。</li><li>Number() 把对象的值转换为数字。</li><li>parseFloat() 解析⼀个字符串并返回⼀个浮点数。</li><li>parseInt() 解析⼀个字符串并返回⼀个整数。</li><li>String() 把对象的值转换为字符串。</li><li>unescape() 对由 escape() 编码的字符串进⾏解码</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js创建对象的多种方式</title>
      <link href="/js-base/js%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
      <url>/js-base/js%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<pre><code class="javascript">1. 对象字面量（Object Literal）：使用对象字面量可以直接创建一个简单的对象。对象字面量使用花括号 &#123;&#125; 包裹，并在其中定义键值对。const person = &#123;  name: &#39;John&#39;,  age: 30,  sayHello: function() &#123;    console.log(&#39;Hello!&#39;);  &#125;&#125;;优点：简洁、直观，适合创建简单的对象。缺点：无法实现对象的复用，每次创建对象时都需要重新定义属性和方法。</code></pre><pre><code class="javascript">2. 构造函数（Constructor）：通过构造函数可以创建一个对象的实例。构造函数使用 new 操作符来调用，并在内部使用 this 关键字来引用新创建的对象。function Person(name, age) &#123;  this.name = name;  this.age = age;  this.sayHello = function() &#123;    console.log(&#39;Hello!&#39;);  &#125;;&#125;const person = new Person(&#39;John&#39;, 30);优点：可以通过 new 操作符创建对象的实例，适合创建多个相似的对象。缺点：每个对象实例都会拥有独立的方法，占用额外的内存空间。创建大量对象时可能造成内存浪费。</code></pre><pre><code class="javascript">3. 原型链继承（Prototype Chain Inheritance）：使用原型链可以实现对象的继承。可以通过给构造函数的原型对象添加属性和方法，使所有通过该构造函数创建的对象都可以共享这些属性和方法。function Person(name, age) &#123;  this.name = name;  this.age = age;&#125;Person.prototype.sayHello = function() &#123;  console.log(&#39;Hello!&#39;);&#125;;const person = new Person(&#39;John&#39;, 30);优点：可以实现对象的属性和方法的共享，减少内存占用。适合创建多个具有相同属性和方法的对象。缺点：所有实例共享原型对象上的属性和方法，如果对原型对象进行修改，会影响所有实例。不能传递参数给构造函数。</code></pre><pre><code class="javascript">4. ES6 的类（Class）：ES6 引入了类的概念，可以使用 class 关键字来定义一个类，并通过 new 操作符创建类的实例。class Person &#123;  constructor(name, age) &#123;    this.name = name;    this.age = age;  &#125;    sayHello() &#123;    console.log(&#39;Hello!&#39;);  &#125;&#125;const person = new Person(&#39;John&#39;, 30);优点：语法更加直观、易读，符合面向对象的编程习惯。支持继承、封装和多态等特性。缺点：在底层仍然使用原型链来实现，因此也存在原型链继承的一些问题，如共享方法造成的潜在风险。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js 实现异步编程</title>
      <link href="/js-base/js%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
      <url>/js-base/js%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<ol><li>回调函数（Callbacks）：在异步操作完成后，通过传递一个回调函数作为参数，在异步操作结束时调用该回调函数来处理结果。</li></ol><pre><code class="Javascript">function asyncOperation(callback) &#123;  // 模拟异步操作  setTimeout(function() &#123;    const result = &#39;Async operation completed&#39;;    callback(result);  &#125;, 1000);&#125;asyncOperation(function(result) &#123;  console.log(result);&#125;);优点：简单、容易理解缺点：不利于维护，代码耦合⾼</code></pre><ol start="2"><li>Promise：Promise 是一种在 ES6 中引入的异步编程模式。它代表一个异步操作最终的完成或失败，并提供了处理结果的方法。</li></ol><pre><code class="Javascript">function asyncOperation() &#123;  return new Promise(function(resolve, reject) &#123;    // 模拟异步操作    setTimeout(function() &#123;      const result = &#39;Async operation completed&#39;;      resolve(result); // 异步操作成功      // 或者使用 reject(new Error(&#39;Async operation failed&#39;)); 处理异步操作失败    &#125;, 1000);  &#125;);&#125;asyncOperation()  .then(function(result) &#123;    console.log(result);  &#125;)  .catch(function(error) &#123;    console.error(error);  &#125;);优点：可以利⽤then⽅法，进⾏链式写法；可以书写错误时的回调函数；缺点：编写和理解，相对⽐较难</code></pre><ol start="3"><li>async&#x2F;await：async&#x2F;await 是在 ES2017 中引入的异步编程语法糖，基于 Promise，让异步代码看起来像同步代码一样。</li></ol><pre><code class="Javascript">function asyncOperation() &#123;  return new Promise(function(resolve, reject) &#123;    // 模拟异步操作    setTimeout(function() &#123;      const result = &#39;Async operation completed&#39;;      resolve(result); // 异步操作成功      // 或者使用 reject(new Error(&#39;Async operation failed&#39;)); 处理异步操作失败    &#125;, 1000);  &#125;);&#125;async function processData() &#123;  try &#123;    const result = await asyncOperation();    console.log(result);  &#125; catch (error) &#123;    console.error(error);  &#125;&#125;processData();优点：内置执⾏器、更好的语义、更⼴的适⽤性、返回的是Promise、结构清晰。缺点：错误处理机制</code></pre><ol start="4"><li>事件监听（Event Listening）：事件监听是一种基于观察者模式的编程方式。通过注册事件监听器，当特定事件发生时，会触发相应的回调函数。</li></ol><pre><code class="Javascript">// 定义一个事件触发器const eventEmitter = new EventEmitter();// 注册事件监听器eventEmitter.on(&#39;event&#39;, function(data) &#123;  console.log(&#39;Event triggered:&#39;, data);&#125;);// 触发事件eventEmitter.emit(&#39;event&#39;, &#39;Some data&#39;);优点：容易理解，可以绑定多个事件，每个事件可以指定多个回调函数缺点：事件驱动型，流程不够清晰</code></pre><ol start="5"><li>发布&#x2F;订阅（Publish&#x2F;Subscribe）：发布&#x2F;订阅也是一种基于观察者模式的编程方式，其中发布者（发布消息的对象）和订阅者（接收消息的对象）之间是松耦合的关系。</li></ol><pre><code class="Javascript">// 创建一个发布者const publisher = new Publisher();// 创建一个订阅者并订阅消息const subscriber1 = new Subscriber(&#39;Subscriber 1&#39;);publisher.subscribe(subscriber1);// 创建另一个订阅者并订阅消息const subscriber2 = new Subscriber(&#39;Subscriber 2&#39;);publisher.subscribe(subscriber2);// 发布消息publisher.publish(&#39;Some message&#39;);类似于事件监听，但是可以通过‘消息中⼼ʼ，了解现在有多少发布者，多少订阅者</code></pre><ol start="5"><li>Generator函数</li></ol><pre><code class="javascript">function* myGeneratorFunction() &#123;  try &#123;    const result = yield new Promise((resolve, reject) =&gt; &#123;      setTimeout(() =&gt; &#123;        resolve(&#39;Async operation completed.&#39;);      &#125;, 2000);    &#125;);    console.log(result);  &#125; catch (error) &#123;    console.error(error);  &#125;&#125;function runGenerator(generator) &#123;  const iterator = generator();  function iterate(&#123; value, done &#125;) &#123;    if (done) &#123;      return;    &#125;    if (value instanceof Promise) &#123;      value.then(        (result) =&gt; &#123;          iterate(iterator.next(result));        &#125;,        (error) =&gt; &#123;          iterate(iterator.throw(error));        &#125;      );    &#125; else &#123;      iterate(iterator.next(value));    &#125;  &#125;  iterate(iterator.next());&#125;runGenerator(myGeneratorFunction);优点：函数体内外的数据交换、错误处理机制缺点：流程管理不⽅便</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组去重方法总结</title>
      <link href="/js-base/js%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/js-base/js%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="借助ES6提供的Set结构-new-Set-简单好用-强烈推荐"><a href="#借助ES6提供的Set结构-new-Set-简单好用-强烈推荐" class="headerlink" title="借助ES6提供的Set结构 new Set() 简单好用 强烈推荐"></a>借助ES6提供的Set结构 new Set() 简单好用 强烈推荐</h1><pre><code class="javascript">使用 Set 数据结构：将数组转换为 Set，然后再将 Set 转回数组。 var arr = [1,9,8,8,7,7];  function noRepeat(arr)&#123;    var newArr = [...new Set(arr)]; //利用了Set结构不能接收重复数据的特点    return newArr  &#125;  var arr2 = noRepeat(arr) </code></pre><h1 id="利用-filter-indexOf-去重"><a href="#利用-filter-indexOf-去重" class="headerlink" title="利用 filter() +  indexOf() 去重"></a>利用 filter() +  indexOf() 去重</h1><pre><code class="javascript">filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。item是当前元素的值，index是当前元素的索引值。indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。利用indexOf() 查询到数组的下标，看是否等于当前的下标，相等的话就返回，否则不返回值var arr = [&#39;apple&#39;,&#39;apps&#39;,&#39;pear&#39;,&#39;apple&#39;,&#39;orange&#39;,&#39;apps&#39;];    var newArr = arr.filter(function(item,index)&#123;     return arr.indexOf(item) === index;  // 因为indexOf 只能查找到第一个    &#125;);</code></pre><h1 id="利用for-循环-搭配-indexOf-去重"><a href="#利用for-循环-搭配-indexOf-去重" class="headerlink" title="利用for 循环 搭配 indexOf 去重"></a>利用for 循环 搭配 indexOf 去重</h1><pre><code class="javascript"> var arr = [1,9,8,8,7,7]; function noRepeat(arr) &#123;        var newArr=[];         for(var i=0;i&lt;arr.length;i++) &#123;          if(newArr.indexOf(arr[i]) === -1) &#123;             newArr.push(arr[i]);          &#125;        &#125;    return newArr  &#125;  var arr2 = noRepeat(arr);</code></pre><h1 id="将数组的每一个元素依次与其他元素做比较，发现重复元素，删除-比较繁琐-不推荐"><a href="#将数组的每一个元素依次与其他元素做比较，发现重复元素，删除-比较繁琐-不推荐" class="headerlink" title="将数组的每一个元素依次与其他元素做比较，发现重复元素，删除 比较繁琐 不推荐"></a>将数组的每一个元素依次与其他元素做比较，发现重复元素，删除 比较繁琐 不推荐</h1><pre><code class="javascript">var arr = [1,9,8,8,7,7]; function noRepeat(arr) &#123;        for(var i = 0; i &lt; arr.length-1; i++)&#123;            for(var j = i+1; j &lt; arr.length; j++)&#123;                if(arr[i]===arr[j])&#123;                    arr.splice(j,1);                    j--;                &#125;            &#125;        &#125;        return arr; &#125; var arr2 = noRepeat(arr);</code></pre><h1 id="借助新数组-通过-indexOf-方法判断当前元素在数组中的索引，如果与循环的下标相等则添加到新数组中"><a href="#借助新数组-通过-indexOf-方法判断当前元素在数组中的索引，如果与循环的下标相等则添加到新数组中" class="headerlink" title="借助新数组 通过 indexOf 方法判断当前元素在数组中的索引，如果与循环的下标相等则添加到新数组中"></a>借助新数组 通过 indexOf 方法判断当前元素在数组中的索引，如果与循环的下标相等则添加到新数组中</h1><pre><code class="javascript"> var arr = [1,9,8,8,7,7];    function noRepeat(arr) &#123;        var newArr = [];        for (var i = 0; i &lt; arr.length; i++) &#123;            if (arr.indexOf(arr[i]) == i) &#123;              newArr.push(arr[i]);            &#125;        &#125;        return newArr;    &#125;   var arr2 = noRepeat(arr); </code></pre><h1 id="利用双重for循环"><a href="#利用双重for循环" class="headerlink" title="利用双重for循环"></a>利用双重for循环</h1><pre><code class="javascript">var arr = [1,9,8,8,7,7];  function noRepeat(arr)&#123;   for (var i = 0; i &lt; arr.length; i++) &#123;       for (var j = 0; j &lt; arr.length; j++) &#123;           if (arr[i] == arr[j] &amp;&amp; i != j) &#123;              arr.splice(j, 1);            &#125;       &#125;    &#125;    return arr;&#125;var arr2  = noRepeat(arr);</code></pre><h1 id="利用includes实现数组去重"><a href="#利用includes实现数组去重" class="headerlink" title="利用includes实现数组去重"></a>利用includes实现数组去重</h1><pre><code class="javascript"> var arr = [1,9,8,8,7,7];    function noRepeat(arr) &#123;      let newArr = [];      for(i=0; i&lt;arr.length; i++)&#123;        if(!newArr.includes(arr[i]))&#123;            newArr.push(arr[i])        &#125;      &#125;     return newArr   &#125;</code></pre><h1 id="利⽤-reduce-includes"><a href="#利⽤-reduce-includes" class="headerlink" title="利⽤ reduce + includes"></a>利⽤ reduce + includes</h1><pre><code class="javascript">  const res = arr.reduce((prev, cur) =&gt; &#123;      if(!prev.includes(cur))&#123;          prev.push(cur)      &#125;      return prev  &#125;, [])  优化后 function unique(arr) &#123;    return arr.reduce((prev, cur) =&gt; prev.includes(cur) ? prev : [...prev, cur])  &#125;</code></pre><h1 id="利⽤Map数据结构去重"><a href="#利⽤Map数据结构去重" class="headerlink" title="利⽤Map数据结构去重"></a>利⽤Map数据结构去重</h1><pre><code class="javascript"> function arrayNonRepeatfy(arr) &#123;    let map = new Map();    let array = new Array(); // 数组⽤于返回结果    for (let i = 0; i &lt; arr.length; i++) &#123;        if (map.has(arr[i])) &#123; // 如果有该key值            map.set(arr[i], true);        &#125; else &#123;            map.set(arr[i], false); // 如果没有该key值            array.push(arr[i]);        &#125;    &#125;    return array;&#125;</code></pre><h1 id="利⽤递归去重"><a href="#利⽤递归去重" class="headerlink" title="利⽤递归去重"></a>利⽤递归去重</h1><pre><code class="javascript"> function unique(arr) &#123;      var array = arr;      var len = array.length;      array.sort(function (a, b) &#123; //排序后更加⽅便去重          return a - b;      &#125;)      function loop(index) &#123;          if (index &gt;= 1) &#123;              if (array[index] === array[index - 1]) &#123;                  array.splice(index, 1);              &#125;              loop(index - 1); //递归loop，然后数组去重          &#125;      &#125;      loop(len - 1);      return array;  &#125;</code></pre><h1 id="利⽤hasOwnProperty-filter"><a href="#利⽤hasOwnProperty-filter" class="headerlink" title="利⽤hasOwnProperty + filter"></a>利⽤hasOwnProperty + filter</h1><pre><code class="javascript">function unique(arr) &#123;    var obj = &#123;&#125;;    return arr.filter(function (item, index, arr) &#123;        return obj.hasOwnProperty(typeof item + item) ? false : (obj[typeof item + item] = true);    &#125;);&#125;</code></pre><h1 id="利⽤对象的属性不能相同的特点进⾏去重"><a href="#利⽤对象的属性不能相同的特点进⾏去重" class="headerlink" title="利⽤对象的属性不能相同的特点进⾏去重"></a>利⽤对象的属性不能相同的特点进⾏去重</h1><pre><code class="javascript">function unique(arr) &#123;      if (!Array.isArray(arr)) &#123;          console.log(&#39;type error!&#39;)          return      &#125;      var arrry = [];      var obj = &#123;&#125;;      for (var i = 0; i &lt; arr.length; i++) &#123;          if (!obj[arr[i]]) &#123;              arrry.push(arr[i])              obj[arr[i]] = 1          &#125; else &#123;              obj[arr[i]]++          &#125;      &#125;      return arrry;  &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈js中new this 关键字</title>
      <link href="/js-base/js%E6%B5%85%E8%B0%88new%20this/"/>
      <url>/js-base/js%E6%B5%85%E8%B0%88new%20this/</url>
      
        <content type="html"><![CDATA[<h1 id="new操作符具体干了什么"><a href="#new操作符具体干了什么" class="headerlink" title="new操作符具体干了什么"></a>new操作符具体干了什么</h1><pre><code class="text">1. 创建一个新的空对象。2. 将新对象的原型链（[[Prototype]]）链接到构造函数的 prototype 属性上，使新对象能够访问构造函数原型中定义的属性和方法。3. 将构造函数的作用域赋值给新对象，即将新对象的 this 绑定到构造函数上，使构造函数内部的代码能够访问和操作新对象的属性。4. 执行构造函数内部的代码，初始化新对象的属性和方法。5. 如果构造函数返回了一个非空对象，则返回该对象；否则，返回新创建的对象。</code></pre><h1 id="new的模拟实现"><a href="#new的模拟实现" class="headerlink" title="new的模拟实现"></a>new的模拟实现</h1><pre><code class="javascript">function myNew(constructor, ...args) &#123;  // 1. 在内存中创建一个新对象  const obj = &#123;&#125;;  // 2. 将新对象的原型设置为构造函数的 prototype 属性  Object.setPrototypeOf(obj, constructor.prototype);  // 3. 将构造函数内部的 this 绑定到新对象  const result = constructor.apply(obj, args);  // 4. 执行构造函数内部的代码后，如果返回非空对象则返回该对象，否则返回新对象  return result instanceof Object ? result : obj;&#125;</code></pre><p>上述代码中，myNew 函数接受构造函数和参数，模拟了 new 操作符的行为。它会创建一个新对象 obj，将该对象的原型设置为构造函数的 prototype 属性，然后将构造函数内部的 this 绑定到新对象 obj 上，最后根据构造函数的返回结果决定返回值。</p><p>需要注意的是，这只是一个简化的实现，并没有考虑 new 操作符的所有细节和复杂性，如原型链继承、构造函数返回非对象值时的处理等。在实际开发中，建议优先使用原生的 new 操作符。</p><h1 id="this-对象的理解"><a href="#this-对象的理解" class="headerlink" title="this 对象的理解"></a>this 对象的理解</h1><p>&#96;&#96;text<br>在 JavaScript 中，this 是一个特殊的关键字，它指向当前执行代码的上下文对象。具体来说，this 引用的是调用函数的对象，根据函数的调用方式不同，this 会有不同的值。</p><pre><code>```textthis 的值可以根据以下几种情况进行判断</code></pre><pre><code class="javascript">1. 作为普通函数调用：当函数作为独立函数调用时，this 的值指向全局对象（在浏览器中为 window）。function greet() &#123;  console.log(`Hello, $&#123;this.name&#125;`);&#125;const obj = &#123;  name: &#39;Alice&#39;,  sayHello: greet&#125;;greet(); // 输出：Hello, undefinedobj.sayHello(); // 输出：Hello, Alice</code></pre><pre><code class="javascript">2. 作为对象方法调用：当函数作为对象的方法调用时，this 的值指向调用该方法的对象。const person = &#123;  name: &#39;Alice&#39;,  sayHello() &#123;    console.log(`Hello, $&#123;this.name&#125;`);  &#125;&#125;;person.sayHello(); // 输出：Hello, Alice</code></pre><pre><code class="javascript">3. 作为构造函数调用：当函数被用作构造函数调用时（使用 new 关键字），this 的值指向新创建的对象。function Person(name) &#123;  this.name = name;  this.sayHello = function() &#123;    console.log(`Hello, $&#123;this.name&#125;`);  &#125;;&#125;const john = new Person(&#39;John&#39;);john.sayHello(); // 输出：Hello, John</code></pre><pre><code class="javascript">4. 使用 call、apply 或 bind 方法显式指定 this 的值。function greet(greeting) &#123;  console.log(`$&#123;greeting&#125;, $&#123;this.name&#125;`);&#125;const person = &#123;  name: &#39;Alice&#39;&#125;;greet.call(person, &#39;Hi&#39;); // 输出：Hi, Alicegreet.apply(person, [&#39;Hi&#39;]); // 输出：Hi, Aliceconst boundGreet = greet.bind(person);boundGreet(&#39;Hi&#39;); // 输出：Hi, Alice</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js浅谈作用域 - 变量 - 闭包</title>
      <link href="/js-base/js%E6%B5%85%E8%B0%88%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%BB%A5%E5%8F%8A%E5%8F%98%E9%87%8F%E4%BB%A5%E5%8F%8A%E9%97%AD%E5%8C%85/"/>
      <url>/js-base/js%E6%B5%85%E8%B0%88%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%BB%A5%E5%8F%8A%E5%8F%98%E9%87%8F%E4%BB%A5%E5%8F%8A%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是作用域"><a href="#什么是作用域" class="headerlink" title="什么是作用域"></a>什么是作用域</h1><pre><code class="text">在 JavaScript 中，作用域是指变量的可访问范围，它控制了变量在代码中的可见性和生命周期。JavaScript 有以下几种类型的作用域和变量：</code></pre><pre><code class="javascript">1. 全局作用域（Global Scope）：全局作用域是在代码中任何地方都能访问到的最外层作用域。在浏览器环境中，全局作用域通常指的是 window 对象。在全局作用域中声明的变量在整个程序中都是可访问的。 var globalVariable = &#39;I am a global variable&#39;;function foo() &#123;  console.log(globalVariable); // 输出：I am a global variable&#125;console.log(globalVariable); // 输出：I am a global variable</code></pre><pre><code class="javascript">2. 函数作用域（Function Scope）：函数作用域是在函数内部声明的变量所拥有的作用域。这意味着函数内部可以访问函数外部的变量，但函数外部无法访问函数内部的变量。function foo() &#123;  var functionVariable = &#39;I am a function variable&#39;;  console.log(functionVariable); // 输出：I am a function variable&#125;console.log(functionVariable); // 报错：functionVariable is not defined</code></pre><pre><code class="javascript">3. 块级作用域（Block Scope）：在 ES6（ECMAScript 2015）之前，JavaScript 只有全局作用域和函数作用域，没有块级作用域。块级作用域由一对花括号（&#123;&#125;）创建，在块级作用域内声明的变量只在该块级作用域内部可见。function foo() &#123;  if (true) &#123;    var blockVariable = &#39;I am a block variable&#39;;    let blockScopedVariable = &#39;I am a block-scoped variable&#39;;    console.log(blockVariable); // 输出：I am a block variable    console.log(blockScopedVariable); // 输出：I am a block-scoped variable  &#125;  console.log(blockVariable); // 输出：I am a block variable  console.log(blockScopedVariable); // 报错：blockScopedVariable is not defined&#125;</code></pre><pre><code class="javascript">4. 词法作用域（Lexical Scope）：JavaScript 使用的是词法作用域，也称为静态作用域。词法作用域是在代码编写时确定的，它基于变量在代码中的位置来确定其可访问范围，而不是运行时的调用栈。var globalVariable = &#39;I am a global variable&#39;;function foo() &#123;  var functionVariable = &#39;I am a function variable&#39;;  console.log(globalVariable); // 输出：I am a global variable  console.log(functionVariable); // 输出：I am a function variable&#125;foo();</code></pre><pre><code class="text">在 JavaScript 中，变量有三种声明方式：var、let 和 const。其中 var 声明的变量具有函数作用域或全局作用域，let 和 const 声明的变量具有块级作用域。请注意，函数声明本身也遵循词法作用域，可以在函数内部定义函数，并在函数内部访问和调用。这就是 JavaScript 中的闭包机制。</code></pre><h1 id="作用域的理解"><a href="#作用域的理解" class="headerlink" title="作用域的理解"></a>作用域的理解</h1><ol><li>作⽤域链的作⽤是保证执⾏环境⾥有权访问的变量和函数是有序的，作⽤域链的变量只能向上访问，变量访问到 window 对象即被终⽌，作⽤域链向下访问变量是不被允许的</li><li>简单的说，作⽤域就是变量与函数的可访问范围，即作⽤域控制着变量与函数的可⻅性和⽣命周期</li></ol><h1 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h1><ol><li><p>闭包就是能够读取其他函数内部变量的函数</p></li><li><p>闭包是指有权访问另⼀个函数作⽤域中变量的函数，创建闭包的最常⻅的⽅式就是在⼀个函数内创建另⼀个函数，通过另⼀个函数访问这个函数的局部变量,利⽤闭包可以突破作⽤链域</p></li><li><p>闭包的特性：<br>函数内再嵌套函数<br>内部函数可以引⽤外层的参数和变量<br>参数和变量不会被垃圾回收机制回收</p></li></ol><h1 id="闭包的理解"><a href="#闭包的理解" class="headerlink" title="闭包的理解"></a>闭包的理解</h1><ol><li>使⽤闭包主要是为了设计私有的⽅法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增⼤内存使⽤量，使⽤不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产⽣作⽤域的概念</li><li>闭包 的最⼤⽤处有两个，⼀个是可以读取函数内部的变量，另⼀个就是让这些变量始终保持在内存中</li><li>闭包的另⼀个⽤处，是封装对象的私有属性和私有⽅法</li><li>好处：能够实现封装和缓存等；</li><li>坏处：就是消耗内存、不正当使⽤会造成内存溢出的问题</li></ol><h1 id="使⽤闭包的注意点"><a href="#使⽤闭包的注意点" class="headerlink" title="使⽤闭包的注意点"></a>使⽤闭包的注意点</h1><ol><li>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很⼤，所以不能滥⽤闭包，否则会造成⽹⻚的性能问题，在IE中可能导致内存泄露</li><li>解决⽅法是，在退出函数之前，将不使⽤的局部变量全部删除</li></ol><pre><code class="javascript">function outer() &#123;  var outerVariable = &#39;I am an outer variable&#39;;  function inner() &#123;    console.log(outerVariable); // 闭包，内部函数可以访问外部函数的变量  &#125;  return inner;&#125;var closureFunction = outer(); closureFunction(); // 输出：I am an outer variable</code></pre><h1 id="什么情况下会造成内存泄漏"><a href="#什么情况下会造成内存泄漏" class="headerlink" title="什么情况下会造成内存泄漏"></a>什么情况下会造成内存泄漏</h1><ol><li>未及时释放闭包：如果闭包被保留在内存中，并且不再需要使用，但没有手动解除对闭包的引用，这将导致闭包及其所引用的变量无法被垃圾回收，从而造成内存泄漏。</li><li>循环引用：如果闭包持有对其他对象的引用，而这些对象又持有对闭包的引用，形成了循环引用，那么这些对象以及闭包本身都无法被垃圾回收，导致内存泄漏。</li><li>事件监听器未移除：当页面中的元素绑定了事件监听器，而这些监听器是在闭包中定义的，如果没有正确地解除对元素的引用，这会导致闭包无法释放，从而造成内存泄漏。</li><li>全局变量引用：如果闭包中引用了全局变量，即使函数执行结束，闭包仍然可以访问和持有对全局变量的引用，阻止了对全局变量的释放，导致内存泄漏。</li></ol><h1 id="为避免闭包导致的内存泄漏，可以采取以下措施："><a href="#为避免闭包导致的内存泄漏，可以采取以下措施：" class="headerlink" title="为避免闭包导致的内存泄漏，可以采取以下措施："></a>为避免闭包导致的内存泄漏，可以采取以下措施：</h1><ol><li>及时释放闭包：在不需要使用闭包时，手动解除对闭包的引用，让垃圾回收机制能够回收闭包及其引用的变量。</li><li>移除事件监听器：在不再需要使用的情况下，确保移除元素上的事件监听器，以免闭包继续持有对元素的引用。</li><li>避免不必要的全局变量：减少对全局作用域的依赖，限制闭包对全局变量的引用，使得相关变量能够在不需要时被回收。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><pre><code class="text">在上面的例子中，outer 函数返回了一个内部函数 inner，该内部函数引用了 outer 函数的变量 outerVariable。即使 outer 函数执行完毕后，inner 函数依然可以访问和操作 outerVariable 变量，这就是闭包的特性。通过使用作用域和闭包，我们可以实现封装、数据私有化和模块化等编程概念。闭包还可以用于创建函数工厂和实现函数柯里化等高级编程技巧。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack性能优化</title>
      <link href="/performance-optimization/%E6%8F%90%E9%AB%98Webpack%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/"/>
      <url>/performance-optimization/%E6%8F%90%E9%AB%98Webpack%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="如何提高Webpack构建速度"><a href="#如何提高Webpack构建速度" class="headerlink" title="如何提高Webpack构建速度"></a>如何提高Webpack构建速度</h1><pre><code class="javascript">1. 代码压缩JS 压缩webpack 4.0默认在生产环境的时候是支持代码压缩的，即mode=production模式下。实际上webpack 4.0默认是使用terser-webpack-plugin这个压缩插件，在此之前是使用 uglifyjs-webpack-plugin，两者的区别是后者对 ES6 的压缩不是很好，同时我们可以开启 parallel参数，使用多进程压缩，加快压缩。CSS 压缩CSS 压缩通常是去除无用的空格等，因为很难去修改选择器、属性的名称、值等。可以使用另外一个插件：css-minimizer-webpack-plugin。HTML 压缩使用HtmlWebpackPlugin插件来生成 HTML 的模板时候，通过配置属性minify进行 html 优化。module.exports = &#123;plugin:[  new HtmlwebpackPlugin(&#123;    minify:&#123;      minifyCSS: false, // 是否压缩css      collapseWhitespace: false, // 是否折叠空格      removeComments: true // 是否移除注释    &#125;  &#125;)  ]&#125;2. 图片压缩配置image-webpack-loader3. Tree ShakingTree Shaking是一个术语，在计算机中表示消除死代码，依赖于 ES Module 的静态语法分析（不执行任何的代码，可以明确知道模块的依赖关系）。在webpack实现Tree shaking有两种方案：usedExports：通过标记某些函数是否被使用，之后通过 Terser 来进行优化的module.exports = &#123;    ...    optimization:&#123;        usedExports    &#125;  &#125;使用之后，没被用上的代码在webpack打包中会加入unused harmony export mul注释，用来告知Terser在优化时，可以删除掉这段代码。sideEffects：跳过整个模块/文件，直接查看该文件是否有副作用sideEffects用于告知webpack compiler哪些模块时有副作用，配置方法是在package.json中设置sideEffects属性。如果sideEffects设置为false，就是告知webpack可以安全的删除未用到的exports。如果有些文件需要保留，可以设置为数组的形式，如：&quot;sideEffecis&quot;:[    &quot;./src/util/format.js&quot;,    &quot;*.css&quot; // 所有的css文件]4. 缩小打包域排除webpack不需要解析的模块，即在使用loader的时候，在尽量少的模块中去使用。可以借助 include和exclude这两个参数，规定loader只在那些模块应用和在哪些模块不应用。5. 减少 ES6 转为 ES5 的冗余代码使用bable-plugin-transform-runtime插件6. 提取公共代码通过配置CommonsChunkPlugin插件，将多个页面的公共代码抽离成单独的文件7. 其他组件懒加载、路由懒加载、开启gzip、公共的第三方包上cdn、配置cache缓存Loader对文件的编译副本、配置resolve提高文件的搜索速度</code></pre><h1 id="webpack性能优化"><a href="#webpack性能优化" class="headerlink" title="webpack性能优化"></a>webpack性能优化</h1><h2 id="开发环境性能优化"><a href="#开发环境性能优化" class="headerlink" title="开发环境性能优化"></a>开发环境性能优化</h2><ol><li>优化打包构建速度</li><li>HMR</li><li>优化代码调试</li><li>source-map</li></ol><h2 id="生产环境性能优化"><a href="#生产环境性能优化" class="headerlink" title="生产环境性能优化"></a>生产环境性能优化</h2><ol><li>优化打包构建速度</li><li>oneOf(可以按照一组优先级顺序来定义不同类型或特定条件下的模块处理方式)</li></ol><pre><code class="javascript">module.exports = &#123;  // ...其他的Webpack配置  module: &#123;    rules: [      // ...其他规则      &#123;        oneOf: [          &#123;            test: /\.css$/,            use: [&#39;style-loader&#39;, &#39;css-loader&#39;]          &#125;,          &#123;            test: /\.less$/,            use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;less-loader&#39;]          &#125;,          &#123;            test: /\.js$/,            exclude: /node_modules/,            use: &#39;babel-loader&#39;          &#125;,          // ...其他的规则        ]      &#125;    ]  &#125;&#125;;</code></pre><ol start="3"><li>babel缓存</li><li>多进程打包</li><li>externals(拒绝某些包被打包进来)</li><li>dll(独立打包第三方库,减少构建时间)</li><li>优化代码运行的性能</li><li>缓存(hash-chunkhash-contenthash)</li><li>tree shaking</li></ol><pre><code class="text">tree shaking：去除无用代码  前提：1. 必须使用ES6模块化  2. 开启production环境  作用: 减少代码体积在package.json中配置   &quot;sideEffects&quot;: false 所有代码都没有副作用（都可以进行tree shaking）    问题：可能会把css / @babel/polyfill （副作用）文件干掉  &quot;sideEffects&quot;: [&quot;*.css&quot;, &quot;*.less&quot;]</code></pre><ol start="10"><li>code split</li><li>懒加载&#x2F;预加载</li><li>pwa(PWA 提供了一种融合了网页和原生应用优点的解决方案，能够提供离线访问、快速加载、类似原生应用的体验以及跨平台兼容性等优势)</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> 前端性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端性能优化大纲</title>
      <link href="/performance-optimization/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%A4%A7%E7%BA%B2/"/>
      <url>/performance-optimization/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%A4%A7%E7%BA%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="性能优化六大指标"><a href="#性能优化六大指标" class="headerlink" title="性能优化六大指标"></a>性能优化六大指标</h1><p><strong>六大指标基本囊括大部分性能优化细节，可作为优化策略的补充。</strong></p><ol><li>「加载优化」：资源在加载时可做的性能优化</li><li>「执行优化」：资源在执行时可做的性能优化</li><li>「渲染优化」：资源在渲染时可做的性能优化</li><li>「样式优化」：样式在编码时可做的性能优化</li><li>「脚本优化」：脚本在编码时可做的性能优化</li><li>「V8引擎优化」：针对V8引擎特征可做的性能优化</li></ol><h2 id="加载优化"><a href="#加载优化" class="headerlink" title="加载优化"></a>加载优化</h2><ol><li>优化HTTP请求：减少请求次数、合并与压缩静态资源、使用CDN等</li></ol><pre><code class="text">1. CDN：将资源分发到 CDN 的边缘网络节点，使用户可就近获取所需内容，大幅减小了光纤传输距离，使全球各地用户打开网站都拥有良好的网络体验。2. http2：http2 的诸多特性决定了它更快的传输速度。2.1.多路复用，在浏览器可并行发送 N 条请求。2.2.首部压缩，更小的负载体积。2.3.请求优先级，更快的关键请求目前，网站已大多上了 http2，可在控制台面板进行查看。由于 http2 可并行请求，解决了 http1.1 线头阻塞的问题，以下几个性能优化点将会过时资源合并。如 https://shanyue.tech/assets??index.js,interview.js,report.js域名分片。雪碧图。将无数小图片合并成单个大图片。3. 充分利用 HTTP 缓存更好的资源缓存策略，对于 CDN 来讲可减少回源次数，对于浏览器而言可减少请求发送次数。无论哪一点，对于二次网站访问都具有更好的访问体验。一:缓存策略  1.强缓存: 打包后带有 hash 值的资源 (如 /build/a3b4c8a8.js)  2.协商缓存: 打包后不带有 hash 值的资源 (如 /index.html)二:分包加载 (Bundle Spliting)  1.避免一行代码修改导致整个 bundle 的缓存失效 4. 减少 HTTP 请求及负载对一个网站的资源进行压缩优化，从而达到减少 HTTP 负载的目的。js/css/image 等常规资源体积优化，这是一个大话题，再以下分别讨论4.1小图片优化，将小图片内联为 Data URI，减小请求数量4.2图片懒加载4.3新的 API: IntersectionObserver API4.4新的属性: loading=lazy 5. preload/prefetch preload/prefetch 可控制 HTTP 优先级，从而达到关键请求更快响应的目的。&lt;link rel=&quot;prefetch&quot; href=&quot;style.css&quot; as=&quot;style&quot;&gt;&lt;link rel=&quot;preload&quot; href=&quot;main.js&quot; as=&quot;script&quot;&gt;1. preload 加载当前路由必需资源，优先级高。一般对于 Bundle Spliting 资源与 Code Spliting 资源做 preload2. prefetch 优先级低，在浏览器 idle 状态时加载资源。一般用以加载其它路由资源，如当页面出现 Link，可 prefetch 当前 Link 的路由资源。（next.js 默认会对 link 做懒加载+prefetch，即当某条 Link 出现页面中，即自动 prefetch 该 Link 指向的路由资源捎带说一下 dns-prefetch，可对主机地址的 DNS 进行预解析。&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//shanyue.tech&quot;&gt;</code></pre><ol start="2"><li>使用缓存：利用浏览器缓存机制，设置适当的缓存头信息</li><li>图片优化：选择合适的图片格式、压缩图片文件大小、响应式图片或按需加载图片</li></ol><pre><code class="text">在前端发展的现在，webp 普遍比 jpeg/png 更小，而 avif 又比 webp 小一个级别为了无缝兼容，可选择 picture/source 进行回退处理&lt;picture&gt;  &lt;source srcset=&quot;img/photo.avif&quot; type=&quot;image/avif&quot;&gt;  &lt;source srcset=&quot;img/photo.webp&quot; type=&quot;image/webp&quot;&gt;  &lt;img src=&quot;img/photo.jpg&quot; width=&quot;360&quot; height=&quot;240&quot;&gt;&lt;/picture&gt;1.更合适的尺寸: 当页面仅需显示 100px/100px 大小图片时，对图片进行压缩到 100px/100px2.更合适的压缩: 可对前端图片进行适当压缩，如通过 sharp 等</code></pre><ol start="4"><li>延迟加载：将非关键资源延迟加载，如图片、视频、第三方插件等</li><li>使用字体图标和矢量图形：替代大量图片的使用</li><li>更小的 Javascript</li></ol><pre><code class="text">gzip/brotliterser (minify)还有以下几点可以考虑考虑:路由懒加载，无需加载整个应用的资源Tree Shaking: 无用导出将在生产环境进行删除browserlist/babel: 及时更新 browserlist，将会产生更小的垫片体积再补充一个问题:如何分析并优化当前项目的 Javascript 体积？如果使用 webpack 那就简单很多。使用 webpack-bundle-analyze 分析打包体积对一些库替换为更小体积的库，如 moment -&gt; dayjs对一些库进行按需加载，如 import lodash -&gt; import lodash/get对一些库使用支持 Tree Shaking，如 import lodash -&gt; import lodash-es</code></pre><ol start="7"><li>压缩混淆工具</li></ol><pre><code class="text">1.Terser (opens new window)是 Javascript 资源压缩混淆的神器。它可以根据以下策略进行压缩处理:长变量名替换短变量删除空格换行符预计算: const a = 24 * 60 * 60 * 1000 -&gt; const a = 86400000移除无法被执行的代码·移除无用的变量及函数可在 Terser Repl (opens new window)在线查看代码压缩效果。2.swc (opens new window)是另外一个用以压缩 Javascript 的工具，它拥有与 terser 相同的 API，由于它是由 rust 所写，因此它拥有更高的性能。3.html-minifier-terser (opens new window)用以压缩 HTML 的工具4. gzip/brotli对 JS、CSS、HTML 等文本资源均有效，但是对图片效果不大。gzip 通过 LZ77 算法与 Huffman 编码来压缩文件，重复度越高的文件可压缩的空间就越大。brotli 通过变种的 LZ77 算法、Huffman 编码及二阶文本建模来压缩文件，更先进的压缩算法，比 gzip 有更高的性能及压缩率可在浏览器的 Content-Encoding 响应头查看该网站是否开启了压缩算法，目前知乎、掘金等已全面开启了 brotli 压缩。Request HeaderAccept-Encoding: gzip, deflate, brgzipContent-Encoding: gzipgzipContent-Encoding: br </code></pre><h2 id="执行优化"><a href="#执行优化" class="headerlink" title="执行优化"></a>执行优化</h2><ol><li>代码优化：精简html，css，js代码，避免重复代码</li><li>异步加载：将JavaScript放在底部，使用async,defer熟悉</li><li>代码分割和懒加载：拆分大型应用程序为小模块，按需加载模块，减少初始加载时间</li><li>前端代码压缩混淆：对前端代码进行压缩和混淆，减小文件大小，提高加载速度</li></ol><h2 id="渲染优化"><a href="#渲染优化" class="headerlink" title="渲染优化"></a>渲染优化</h2><p><strong>「渲染层面」</strong>的性能优化，无疑是如何让代码解析更好执行更快。</p><ol><li>「CSS策略」：基于CSS规则</li><li>「DOM策略」：基于DOM操作</li><li>「阻塞策略」：基于脚本加载</li><li>「回流重绘策略」：基于回流重绘</li><li>「异步更新策略」：基于异步更新</li><li>「缓存策略」</li></ol><p><strong>CSS策略</strong><br>避免出现超过三层的嵌套规则<br>避免为ID选择器添加多余选择器<br>避免使用标签选择器代替类选择器<br>避免使用通配选择器，只对目标节点声明规则<br>避免重复匹配重复定义，关注可继承属性</p><p><strong>DOM策略</strong><br>缓存DOM计算属性<br>避免过多DOM操作<br>使用DOMFragment缓存批量化DOM操作<br>虚拟列表优化</p><p><strong>阻塞策略</strong><br>脚本与DOM&#x2F;其它脚本的依赖关系很强：对<script>设置defer<br>脚本与DOM/其它脚本的依赖关系不强：对<script>设置async</p><p><strong>「回流重绘策略」</strong>在渲染层面的性能优化里占比较重，也是最常规的性能优化之一。<br>缓存DOM计算属性<br>使用类合并样式，避免逐条改变样式<br>使用display控制DOM显隐，将DOM离线化</p><p><strong>异步更新策略</strong><br>在异步任务中修改DOM时把其包装成微任务</p><p><strong>缓存策略</strong></p><pre><code class="javascript">在一些前端系统中，当加载页面时会发送请求，路由切换出去再切换回来时又会重新发送请求，每次请求完成后会对页面重新渲染。然而这些重新请求再大多数时是没有必要的，合理地对 API 进行缓存将达到优化渲染的目的。1.对每一条 GET API 添加 key2.根据 key 控制该 API 缓存，重复发生请求时将从缓存中取得function Example() &#123;  // 设置缓存的 Key 为 Users:10086  const &#123; isLoading, data &#125; = useQuery([&#39;users&#39;, userId], () =&gt; fetchUserById(userId))&#125;</code></pre><h2 id="样式优化"><a href="#样式优化" class="headerlink" title="样式优化"></a>样式优化</h2><ol><li>响应式设计：使用响应式布局和媒体查询适应不同设备和屏幕大小</li><li>使用CSS预处理器：如Less、Sass等，提高样式编写的效率</li></ol><h2 id="脚本优化"><a href="#脚本优化" class="headerlink" title="脚本优化"></a>脚本优化</h2><ol><li>使用模块化开发：使用模块化/组件化的方式组织JavaScript代码</li><li>优化DOM操作：减少DOM操作的次数，对多次操作进行批量处理</li></ol><h2 id="V8引擎优化"><a href="#V8引擎优化" class="headerlink" title="V8引擎优化"></a>V8引擎优化</h2><ol><li>避免不必要的闭包：过多的闭包会导致内存消耗增加</li><li>使用高性能API和方法：如使用map而不是for循环等</li><li>优化循环和递归：尽量减少循环和递归的层数和次数，避免性能问题</li></ol><h1 id="性能评测指标"><a href="#性能评测指标" class="headerlink" title="性能评测指标"></a>性能评测指标</h1><p><strong>三大指标</strong> 使用工具 lighthouse，web-vitals 等<br>LCP: 加载性能。最大内容绘制应在 2.5s 内完成。<br>FID: 交互性能。首次输入延迟应在 100ms 内完成。<br>CLS: 页面稳定性。累积布局偏移，需手动计算，CLS 应保持在 0.1 以下。</p><h1 id="优化-DOM-操作并减少其次数"><a href="#优化-DOM-操作并减少其次数" class="headerlink" title="优化 DOM 操作并减少其次数"></a>优化 DOM 操作并减少其次数</h1><pre><code class="javascript">1. 批量更新：将多个 DOM 操作合并为一个操作，以减少重排和重绘的次数。例如，如果要对一个元素进行多次样式修改，可以先使用 CSS 类来添加或删除样式，最后再应用一次类，而不是每次修改都直接操作样式属性。// 不优化的写法element.style.width = &#39;100px&#39;;element.style.height = &#39;200px&#39;;element.style.backgroundColor = &#39;red&#39;;// 优化的写法element.classList.add(&#39;my-class&#39;);element.classList.remove(&#39;my-class&#39;);2. 使用文档片段（DocumentFragment）：将多个 DOM 节点先添加到文档片段中，然后再一次性插入文档中，这样只会触发一次重排和重绘。这在需要动态添加大量元素时特别有效。// 不优化的写法for (let i = 0; i &lt; 1000; i++) &#123;  const element = document.createElement(&#39;div&#39;);  document.body.appendChild(element);&#125;// 优化的写法const fragment = document.createDocumentFragment();for (let i = 0; i &lt; 1000; i++) &#123;  const element = document.createElement(&#39;div&#39;);  fragment.appendChild(element);&#125;document.body.appendChild(fragment);3. 缓存 DOM 查询结果：当需要多次访问同一个 DOM 元素时，将查询结果缓存在变量中，避免重复查询。// 不优化的写法for (let i = 0; i &lt; 100; i++) &#123;  document.getElementById(&#39;myElement&#39;).innerHTML += &#39;new content&#39;;&#125;// 优化的写法const element = document.getElementById(&#39;myElement&#39;);for (let i = 0; i &lt; 100; i++) &#123;  element.innerHTML += &#39;new content&#39;;&#125;4. 使用虚拟 DOM：在涉及大量数据变动和复杂视图更新的情况下，可以使用虚拟 DOM 技术，通过比对虚拟 DOM 树来最小化实际 DOM 操作的次数。这些是一些常见的优化 DOM 操作的方法。请根据具体场景选择合适的方法进行优化。记住，减少 DOM 操作次数会显著提高性能和用户体验。</code></pre><h1 id="浏览器缓存优化"><a href="#浏览器缓存优化" class="headerlink" title="浏览器缓存优化"></a>浏览器缓存优化</h1><p>为了让浏览器缓存发挥最大作用，该策略尽量遵循以下五点就能发挥浏览器缓存最大作用。</p><p>「考虑拒绝一切缓存策略」：Cache-Control:no-store<br>「考虑资源是否每次向服务器请求」：Cache-Control:no-cache<br>「考虑资源是否被代理服务器缓存」：Cache-Control:public/private<br>「考虑资源过期时间」：Expires:t/Cache-Control:max-age=t,s-maxage=t<br>「考虑协商缓存」：Last-Modified/Etag<br>缓存策略通过设置HTTP报文实现，在形式上分为<strong>「强缓存/强制缓存」和「协商缓存/对比缓存」</strong>。</p><p><img data-src="/images/xn/%E5%BC%BA%E7%BC%93%E5%AD%98.png"><br><img data-src="/images/xn/%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98.png"></p><p>整个缓存策略机制很明了，先走强缓存，若命中失败才走协商缓存。若命中强缓存，直接使用强缓存；若未命中强缓存，发送请求到服务器检查是否命中协商缓存；若命中协商缓存，服务器返回304通知浏览器使用本地缓存，否则返回最新资源。</p><p>有两种较常用的应用场景值得使用缓存策略一试，当然更多应用场景都可根据项目需求制定。</p><p>「频繁变动资源」：设置Cache-Control:no-cache，使浏览器每次都发送请求到服务器，配合Last-Modified/ETag验证资源是否有效<br>「不常变化资源」：设置Cache-Control:max-age=31536000，对文件名哈希处理，当代码修改后生成新的文件名，当HTML文件引入文件名发生改变才会下载最新文件</p><h1 id="Web-Worker"><a href="#Web-Worker" class="headerlink" title="Web Worker"></a>Web Worker</h1><p>在纯浏览器中，如何实现高性能的实时代码编译及转换？</p><p>Babel Repl(opens new window)<br>如果纯碎使用传统的 Javascript 实现，将会耗时过多阻塞主线程，有可能导致页面卡顿。</p><p>如果使用 Web Worker 交由额外的线程来做这件事，将会高效很多，基本上所有在浏览器端进行代码编译的功能都由 Web Worker 实现。</p><h1 id="WASM"><a href="#WASM" class="headerlink" title="WASM"></a>WASM</h1><ol><li>JS 性能低下</li><li>C++/Rust 高性能</li><li>使用 C++/Rust 编写代码，然后在 Javascript 环境运行<br>试举一例:</li></ol><p>在纯浏览器中，如何实现高性能的图片压缩？</p><p>基本上很难做到，Javascript 的性能与生态决定了实现图片压缩的艰难。</p><p>而借助于 WASM 就相当于借用了其它语言的生态。</p><p>1.libavif (opens new window): C语言写的 avif 解码编码库<br>2.libwebp (opens new window): C语言写的 webp 解码编码库<br>3.mozjpeg (opens new window): C语言写的 jpeg 解码编码库<br>4.oxipng (opens new window): Rust语言写的 png 优化库<br>而由于 WASM，完全可以把这些其它语言的生态移植到浏览器中，从而实现一个高性能的离线式的图片压缩工具。</p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> 前端性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在某某企业小程序优化思考(uniapp)</title>
      <link href="/performance-optimization/%E5%9C%A8%E6%9F%90%E6%9F%90%E4%BC%81%E4%B8%9A%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BC%98%E5%8C%96%E6%80%9D%E8%80%83(uniapp)/"/>
      <url>/performance-optimization/%E5%9C%A8%E6%9F%90%E6%9F%90%E4%BC%81%E4%B8%9A%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BC%98%E5%8C%96%E6%80%9D%E8%80%83(uniapp)/</url>
      
        <content type="html"><![CDATA[<ol><li><p>vuex 对启动耗时的影响<br>Vuex 是一个状态管理库，在启动阶段如果存在大量的业务逻辑，会使启动耗时增加。这是因为在启动过程中，需要初始化 Vuex 的状态和相关的模块，可能会触发一些异步操作和计算，导致启动时间延长。因此，在设计和使用 Vuex 时，需要注意避免在启动阶段执行过多的繁重操作，以减少启动耗时。</p></li><li><p>mixins 对启动耗时的影响<br>Mixins 是一种在组件中复用代码的机制，通过将相同的逻辑和功能抽离到 Mixins 中，可以在多个组件中共享使用。在启动阶段，如果组件使用了 Mixins，会在组件实例化时执行 Mixins 中的代码逻辑，因此会增加启动耗时。如果 Mixins 中存在大量或复杂的业务逻辑，会进一步增加启动耗时。因此，使用 Mixins 时需要注意控制逻辑的复杂度，避免影响启动性能。</p></li><li><p>子组件中的请求是从onReady 加载完再去调用请求的，所以是否组件中不要使用请求?<br>在小程序中，子组件的请求通常是在组件的 onReady 生命周期钩子函数中进行调用。由于 onReady 是在页面的渲染准备完成后调用的，此时页面已经可见，用户可以看到页面内容。因此，在 onReady 钩子中进行请求可能会导致页面加载完成后才开始请求数据，从而延长了页面加载时间。</p></li><li><p>挂载到原型上的东西 ,每次生成的页面都会执行这个数据 , 这里的影响多大?<br>当一些数据或方法挂载到小程序的原型对象上时，每次生成的页面都可以通过原型链访问到这些数据或方法。这样做的好处是可以实现数据和方法的全局共享和复用。</p></li><li><p>有没有根据包大小计算出来的 平均启动时间&#x2F;加载耗时<br>通常情况下，并没有一个直接根据包大小计算出来的平均启动时间或加载耗时的公式或算法。因为启动时间和加载耗时受到多个因素的影响，如网络环境、设备性能、代码复杂度等。<br>包大小的增加可能会导致下载时间变长，从而影响启动时间。然而，仅仅根据包大小无法准确预测启动时间的增加，还需要考虑其他因素的综合影响。因此，对于不同的小程序和具体场景，需要进行实际测试和评估来得出准确的启动时间和加载耗时。</p></li></ol><ul><li>计算最佳收益点</li><li>其实这里想表达的是否2M 和 1.5M的包下载时间的差距是否几乎不计?</li></ul><ol start="6"><li>从小程序加载流程上来讲，对于首次打开小程序用户，会去下载包，包大会造成下载时间变长（在相同网络条件下）；影响启动耗时的直接因素：<br>● 平台：不同的平台下（安卓、IOS）设备性能、操作系统、框架实现、优化方案存在较大的差异，启动耗时也存在较大的差异。只有分平台比较启动耗时（包括各阶段耗时）才有意义；<br> 1.怎么做到只是针对某个机型去判断?<br> 2.是不是要去处理慢的机型呢? 怎么处理是个问题<br>● 下载比例及大小：代码包下载和更新都会显著影响小程序启动耗时，在其他流程耗时稳定的情况下，下载比例升高会影响大盘启动耗时。<br>● 入口页面：不同页面启动时，根据所在分包的不同，需要下载的代码包数量和大小和代码注入量都存在差异。不同页面渲染耗时也存在差异。<br>● 机型分布：启动耗时和设备性能有较强关联，不同小程序或使用场景用户群体的差异可能导致机型分布的差异，进而影响大盘启动耗时。<br>● 网络环境：网络环境主要影响网络请求的耗时，如小程序信息获取、代码包下载等。<br>间接因素：<br>● 场景&#x2F;访问来源：不同场景下，用户访问的页面不同，新用户比例也有差异，对启动耗时会有一定影响。此外，用户访问的目的性和自身的等待意愿也有差异，也会影响打开率。<br> 1.这里可能存在有些页面分享进来的，但是这个页面其实是不允许直接进入的，可能会造成某些问题导致的耗时<br> 2.进入的页面不是首页，这是一种什么场景?<br>● 首次访问用户比例：用户首次访问小程序时，需要完整的进行小程序信息准备、代码包下载的流程，代码缓存也需要重新生成，启动耗时会比非首次访问高。<br>● 小程序版本更新：小程序版本更新时，用户需要更新小程序信息和代码包，代码缓存也需要重新生成，启动耗时会出现上涨。<br> 1.这个其实就是每次更新版本对启动时长的影响，特别是发布灰度的时候<br> 2.一段时间不发新版本,启动时间会降低。这里其实说明我们登报的人，他存在多次进来看的情况（这个是肯定的）</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> 前端性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web安全</title>
      <link href="/Web-Integration/web%E5%AE%89%E5%85%A8/"/>
      <url>/Web-Integration/web%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="XSS（跨站脚本攻击）："><a href="#XSS（跨站脚本攻击）：" class="headerlink" title="XSS（跨站脚本攻击）："></a>XSS（跨站脚本攻击）：</h1><pre><code class="text">使用合适的编码和转义方式来处理输入和输出的数据。对用户输入进行验证和过滤，避免将恶意脚本插入到页面中。</code></pre><h1 id="CSRF（跨站请求伪造）："><a href="#CSRF（跨站请求伪造）：" class="headerlink" title="CSRF（跨站请求伪造）："></a>CSRF（跨站请求伪造）：</h1><pre><code class="text">在关键操作上使用随机生成的令牌（CSRF Token），并验证该令牌的合法性。设置合适的 SameSite Cookie 属性，限制跨站点访问。</code></pre><h1 id="点击劫持（Clickjacking）："><a href="#点击劫持（Clickjacking）：" class="headerlink" title="点击劫持（Clickjacking）："></a>点击劫持（Clickjacking）：</h1><pre><code class="text">使用 X-Frame-Options 或 Content-Security-Policy 来限制页面被嵌套到其他网站的情况。可以使用 JavaScript 检测页面是否在 iframe 中展示，并弹出警告或拒绝加载。</code></pre><h1 id="密码安全："><a href="#密码安全：" class="headerlink" title="密码安全："></a>密码安全：</h1><pre><code class="text">采用密码哈希算法（如 bcrypt）对用户密码进行加密存储，避免明文存储。强制要求用户设置强密码，并进行密码策略的验证（如长度、大小写字母、特殊字符等）。</code></pre><h1 id="客户端数据验证和过滤："><a href="#客户端数据验证和过滤：" class="headerlink" title="客户端数据验证和过滤："></a>客户端数据验证和过滤：</h1><pre><code class="text">不要依赖前端验证，一定要在后端进行数据验证和过滤。对客户端输入的数据进行严格验证，避免恶意输入和攻击。</code></pre><h1 id="安全更新和依赖管理："><a href="#安全更新和依赖管理：" class="headerlink" title="安全更新和依赖管理："></a>安全更新和依赖管理：</h1><pre><code class="text">及时更新和升级前端框架、库和依赖，以获取最新的安全修复和补丁。定期审查和监控项目的依赖项，确保没有包含已知的漏洞和安全问题。</code></pre><h1 id="HTTPS-的使用："><a href="#HTTPS-的使用：" class="headerlink" title="HTTPS 的使用："></a>HTTPS 的使用：</h1><pre><code class="text">在页面上使用 HTTPS 协议来加密数据传输，防止数据被窃取和篡改。配置合适的 TLS/SSL 加密套件和证书，确保通信的安全性。</code></pre><h1 id="安全审计和日志记录："><a href="#安全审计和日志记录：" class="headerlink" title="安全审计和日志记录："></a>安全审计和日志记录：</h1><pre><code class="text">记录用户操作日志，追溯异常行为和安全事件。定期进行安全审计，检查应用程序的漏洞和安全风险。</code></pre><h1 id="输入验证与过滤："><a href="#输入验证与过滤：" class="headerlink" title="输入验证与过滤："></a>输入验证与过滤：</h1><pre><code class="text">对用户输入进行验证和过滤，确保只接受预期的合法输入。使用白名单过滤，而不是黑名单过滤，避免遗漏恶意输入。</code></pre><h1 id="安全的跨域资源共享（CORS）配置："><a href="#安全的跨域资源共享（CORS）配置：" class="headerlink" title="安全的跨域资源共享（CORS）配置："></a>安全的跨域资源共享（CORS）配置：</h1><pre><code class="text">配置合适的 CORS 头信息，限制跨域请求的访问权限。设置合理的源和目标组合，防止未经授权的访问和信息泄露。</code></pre><h1 id="客户端存储的安全性："><a href="#客户端存储的安全性：" class="headerlink" title="客户端存储的安全性："></a>客户端存储的安全性：</h1><pre><code class="text">避免在客户端存储敏感信息，如密码、令牌等。使用合适的存储机制，如浏览器提供的 localStorage 或 sessionStorage，加密存储敏感数据。</code></pre><h1 id="CDN-安全："><a href="#CDN-安全：" class="headerlink" title="CDN 安全："></a>CDN 安全：</h1><pre><code class="text">如果使用内容分发网络（CDN），确保从可信任的来源获取资源并验证其完整性。配置适当的安全头部，如 Content Security Policy (CSP)。</code></pre><h1 id="防御点击劫持："><a href="#防御点击劫持：" class="headerlink" title="防御点击劫持："></a>防御点击劫持：</h1><pre><code class="text">通过在响应头中设置 X-Frame-Options 或 Content-Security-Policy，限制页面被嵌套到其他网站的情况。对于现代浏览器，可以使用 Frame-ancestors CSP 指令来进一步控制允许嵌套页面的来源。</code></pre><h1 id="定期安全审查和漏洞扫描："><a href="#定期安全审查和漏洞扫描：" class="headerlink" title="定期安全审查和漏洞扫描："></a>定期安全审查和漏洞扫描：</h1><pre><code class="text">定期进行安全审查，检查代码中的潜在漏洞和安全隐患。使用自动化工具进行漏洞扫描和代码静态分析，及时发现可能存在的安全问题。</code></pre><h1 id="消息传递的安全性："><a href="#消息传递的安全性：" class="headerlink" title="消息传递的安全性："></a>消息传递的安全性：</h1><pre><code class="text">对于敏感信息的传递，尽量使用加密算法加密数据。避免将敏感信息直接传递给前端，而是在后端进行敏感信息的处理和加密。</code></pre><h1 id="防御代码注入攻击："><a href="#防御代码注入攻击：" class="headerlink" title="防御代码注入攻击："></a>防御代码注入攻击：</h1><pre><code class="text">避免在前端中执行不受信任的代码。不要将用户输入直接拼接到代码字符串中，以防止代码注入攻击。</code></pre><h1 id="防御文件上传漏洞："><a href="#防御文件上传漏洞：" class="headerlink" title="防御文件上传漏洞："></a>防御文件上传漏洞：</h1><pre><code class="text">对用户上传的文件进行严格的验证和过滤，并使用独立的文件存储来避免安全问题。验证文件类型、大小和内容，确保只接受合法和安全的文件。</code></pre><h1 id="安全的第三方组件和库："><a href="#安全的第三方组件和库：" class="headerlink" title="安全的第三方组件和库："></a>安全的第三方组件和库：</h1><pre><code class="text">在使用第三方组件和库时，选择经过广泛审查和更新的可信来源。定期更新和升级第三方组件，以获取最新的安全修复和功能改进。</code></pre><h1 id="保护敏感信息："><a href="#保护敏感信息：" class="headerlink" title="保护敏感信息："></a>保护敏感信息：</h1><pre><code class="text">不要将敏感信息直接存储在前端，如密码、密钥等。使用加密算法对敏感信息进行加密，并在后端进行处理和存储。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web综合问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器渲染原理以及优化思路</title>
      <link href="/Web-Integration/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/"/>
      <url>/Web-Integration/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="浏览器渲染原理"><a href="#浏览器渲染原理" class="headerlink" title="浏览器渲染原理"></a>浏览器渲染原理</h1><pre><code class="text">1. 渲染过程：解析HTML：浏览器解析HTML代码，构建DOM树。解析CSS：浏览器解析CSS样式表，构建CSSOM树。构建渲染树：将DOM树和CSSOM树合并成渲染树，该树只包含需要显示元素的信息。布局（Layout）：计算每个元素的大小和位置。绘制（Paint）：根据计算好的布局信息，将每个元素绘制成屏幕上的像素。合成（Composite）：将绘制好的元素按正确的顺序合成到最终的图像上。2. 阻塞过程：脚本阻塞：当浏览器遇到&lt;script&gt;标签或执行JavaScript代码时，会暂停HTML解析和渲染，直到脚本执行完毕。样式加载阻塞：如果浏览器遇到外部CSS文件，会等待该文件下载和解析完毕后再继续渲染。资源加载阻塞：当浏览器遇到资源文件如图片、字体或其他媒体时，会等待资源下载和加载完毕后再继续渲染。3. 重绘与汇流：重绘（Repaint）：当元素的样式改变，但不影响布局时，浏览器只需要重新绘制元素的可视部分。汇流（Reflow）：当布局发生改变，例如改变元素的大小或位置时，浏览器需要重新计算并调整元素的布局和相关元素的位置。</code></pre><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><pre><code class="text">1. 减少阻塞时间：脚本加载优化：将JavaScript脚本放在页面底部，或者使用defer属性将其延迟执行，以免阻塞HTML解析和渲染过程。样式加载优化：将CSS样式表放在&lt;head&gt;标签中，避免样式表的加载阻塞页面渲染。资源加载优化：使用合适的缓存策略、减小资源文件的大小，以及使用CDN等方式来提高资源加载速度。2. 最小化重绘与汇流：批量修改样式：避免频繁读取和修改单个元素的样式属性，最好使用CSS类进行批量修改，这样可以减少重绘和汇流的次数。避免强制同步布局：在修改多个元素的样式时，避免强制同步布局，即尽量将布局相关的修改集中在一起，减少不必要的重绘和汇流。3.使用现代CSS特性：使用CSS动画代替JavaScript动画：CSS动画借助浏览器的硬件加速，性能更高，并且不会阻塞JavaScript主线程。使用CSS Grid 和 Flexbox 布局：这些现代的布局方式能够更有效地处理布局，减少重绘和汇流的次数。4.图片优化：使用适当的图片格式：根据图片特性选择合适的图片格式，例如JPEG、PNG、WebP等，以尽量减小文件大小。图片懒加载：只在视口范围内加载可见区域的图片，延迟加载其他图片，以提高页面加载速度。5. 代码优化：避免频繁操作DOM：减少对DOM的修改和查询次数，可以使用文档片段（DocumentFragment）来进行批量操作。压缩和合并代码：对CSS和JavaScript文件进行压缩和合并，减小文件体积，加快加载速度。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web综合问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器缓存机制</title>
      <link href="/Web-Integration/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
      <url>/Web-Integration/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="浏览器缓存机制"><a href="#浏览器缓存机制" class="headerlink" title="浏览器缓存机制"></a>浏览器缓存机制</h1><p>浏览器缓存机制是指浏览器在处理网页资源时，将一部分资源保存在本地存储中，以便下次请求相同资源时可以快速获取，从而提高网页加载速度和用户体验。以下是常见的浏览器缓存机制：</p><h1 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h1><ol><li>浏览器在第一次请求资源时，服务器通过响应头中的Cache-Control或Expires字段返回资源，并将这些信息保存在浏览器缓存中。在下一次请求相同资源时，浏览器会直接从缓存中读取，而不发起请求</li><li>常用的Cache-Control值有：</li></ol><ul><li>public：表示资源可以被所有用户及代理服务器缓存。</li><li>private：表示资源只能被单个用户缓存，不允许代理服务器缓存。</li><li>max-age：表示资源在缓存中的有效期，单位为秒。</li></ul><h1 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h1><ol><li>在资源过期后，浏览器会发送一个带有If-Modified-Since（Last-Modified）或If-None-Match（ETag）字段的请求到服务器，询问该资源是否有更新。如果服务器返回304 Not Modified状态码，则表示资源未发生变化，浏览器会直接从缓存中读取。</li><li>常用的响应头字段有：</li></ol><ul><li>Last-Modified：表示资源的最后修改时间。</li><li>ETag：表示资源的唯一标识符。</li></ul><h1 id="离线缓存"><a href="#离线缓存" class="headerlink" title="离线缓存"></a>离线缓存</h1><ol><li>HTML5提供了离线缓存机制，使用manifest文件来定义需要缓存的资源。浏览器在第一次访问网页时会下载manifest文件并根据文件中的信息缓存相应资源。在之后的访问中，即使处于离线状态，浏览器仍然能够加载并显示已缓存的页面。离线缓存可以提高网页的可访问性和性能。</li></ol><h1 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h1><ol><li><p>内存缓存（Memory Cache）：<br>内存缓存是最快的缓存位置，将资源直接保存在浏览器内存中。<br>内存缓存的读取速度非常快，可以快速响应请求，适用于频繁请求和临时性资源。<br>但是，内存缓存的容量有限，并且在浏览器关闭时会被清空。</p></li><li><p>硬盘缓存（Disk Cache）：<br>硬盘缓存将资源保存在硬盘上，相对于内存缓存来说读取速度较慢，但比重新请求资源要快得多。<br>硬盘缓存可以持久保存资源，并且在浏览器关闭后仍然可用。<br>硬盘缓存的容量相对较大，可以保存更多的资源。</p></li><li><p>服务端缓存：<br>服务端缓存是指将资源保存在服务器端，由服务器返回缓存的资源给浏览器。<br>服务端缓存可以利用类似缓存代理、CDN等方式来提升资源获取速度，减轻服务器的压力。<br>服务端缓存可以根据资源的过期时间或版本号来判断是否返回缓存资源。</p></li><li><p>Service Worker 缓存：<br>Service Worker 是运行在浏览器后台的脚本，可以拦截网络请求并自定义响应。<br>Service Worker 可以将资源保存在本地缓存中，实现离线访问或快速加载。<br>Service Worker 缓存具有灵活性和高度可自定义的特性，适用于离线应用、推送通知等场景。</p></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过合理设置缓存策略，可以减少对服务器的请求次数，加快网页加载速度，降低网络流量消耗。同时，如果网页内容有更新，通过修改资源的版本号或过期时间等方式来使浏览器重新请求新的资源版本。</p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web综合问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web综合问题</title>
      <link href="/Web-Integration/%E6%B5%8F%E8%A7%88%E5%99%A8%E9%9D%A2%E8%AF%95/"/>
      <url>/Web-Integration/%E6%B5%8F%E8%A7%88%E5%99%A8%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="常见的浏览器内核有哪些？"><a href="#常见的浏览器内核有哪些？" class="headerlink" title="常见的浏览器内核有哪些？"></a>常见的浏览器内核有哪些？</h1><p>主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。<br>渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。<br>JS引擎则：解析和执行javascript来实现网页的动态效果。<br>最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。<br>常见内核<br>Trident 内核：IE, MaxThon, TT, The World, 360, 搜狗浏览器等。[又称 MSHTML]<br>Gecko 内核：Netscape6 及以上版本，FF, MozillaSuite &#x2F; SeaMonkey 等<br>Presto 内核：Opera7 及以上。 [Opera内核原为：Presto，现为：Blink;]<br>Webkit 内核：Safari, Chrome等。 [ Chrome的：Blink（WebKit 的分支）]</p><h1 id="网页前端性能优化的方式有哪些？"><a href="#网页前端性能优化的方式有哪些？" class="headerlink" title="网页前端性能优化的方式有哪些？"></a>网页前端性能优化的方式有哪些？</h1><p>1.压缩 css, js, 图片<br>2.减少 http 请求次数， 合并 css、js 、合并图片（雪碧图）<br>3.使用 CDN<br>4.减少 dom 元素数量<br>5.图片懒加载<br>6.静态资源另外用无 cookie 的域名<br>7.减少 dom 的访问（缓存 dom）<br>8.巧用事件委托<br>9.样式表置顶、脚本置低</p><h1 id="网页从输入网址到渲染完成经历了哪些过程？"><a href="#网页从输入网址到渲染完成经历了哪些过程？" class="headerlink" title="网页从输入网址到渲染完成经历了哪些过程？"></a>网页从输入网址到渲染完成经历了哪些过程？</h1><p>大致可以分为如下7步：</p><p>输入网址；<br>发送到DNS服务器，并获取域名对应的web服务器对应的ip地址；<br>与web服务器建立TCP连接；<br>浏览器向web服务器发送http请求；<br>web服务器响应请求，并返回指定url的数据（或错误信息，或重定向的新的url地址）；<br>浏览器下载web服务器返回的数据及解析html源文件；<br>生成DOM树，解析css和js，渲染页面，直至显示完成；</p><h1 id="线程与进程的区别？"><a href="#线程与进程的区别？" class="headerlink" title="线程与进程的区别？"></a>线程与进程的区别？</h1><p>一个程序至少有一个进程,一个进程至少有一个线程.<br>线程的划分尺度小于进程，使得多线程程序的并发性高。<br>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。<br>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。<br>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</p><h1 id="HTTP常见的状态码？"><a href="#HTTP常见的状态码？" class="headerlink" title="HTTP常见的状态码？"></a>HTTP常见的状态码？</h1><p>100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息<br>200 OK 正常返回信息<br>201 Created 请求成功并且服务器创建了新的资源<br>202 Accepted 服务器已接受请求，但尚未处理<br>301 Moved Permanently 请求的网页已永久移动到新位置。<br>302 Found 临时性重定向。<br>303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。<br>304 Not Modified 自从上次请求后，请求的网页未修改过。<br>400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。<br>401 Unauthorized 请求未授权。<br>403 Forbidden 禁止访问。<br>404 Not Found 找不到如何与 URI 相匹配的资源。<br>500 Internal Server Error 最常见的服务器端错误。<br>503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。</p><h1 id="图片懒加载？"><a href="#图片懒加载？" class="headerlink" title="图片懒加载？"></a>图片懒加载？</h1><p>当页面滚动的时间被触发 -&gt; 执行加载图片操作 -&gt; 判断图片是否在可视区域内 -&gt; 在，则动态将data-src的值赋予该图片</p><h1 id="移动端性能优化？"><a href="#移动端性能优化？" class="headerlink" title="移动端性能优化？"></a>移动端性能优化？</h1><p>尽量使用css3动画，开启硬件加速<br>适当使用touch时间代替click时间<br>避免使用css3渐变阴影效果<br>可以用transform: translateZ(0) 来开启硬件加速<br>不滥用float。float在渲染时计算量比较大，尽量减少使用<br>不滥用web字体。web字体需要下载，解析，重绘当前页面<br>合理使用requestAnimationFrame动画代替setTimeout<br>css中的属性（css3 transitions、css3 3D transforms、opacity、webGL、video）会触发GUP渲染，耗电</p><h1 id="TCP-传输的三次握手、四次挥手策略"><a href="#TCP-传输的三次握手、四次挥手策略" class="headerlink" title="TCP 传输的三次握手、四次挥手策略"></a>TCP 传输的三次握手、四次挥手策略</h1><p>三次握手：<br>为了准确无误地吧数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送出去后，TCP不会对传送后的情况置之不理，他一定会向对方确认是否送达，握手过程中使用TCP的标志：SYN和ACK<br>发送端首先发送一个带SYN的标志的数据包给对方<br>接收端收到后，回传一个带有SYN&#x2F;ACK标志的数据包以示传达确认信息<br>最后，发送端再回传一个带ACK的标志的数据包，代表“握手”结束<br>如在握手过程中某个阶段莫明中断，TCP协议会再次以相同的顺序发送相同的数据包</p><p>断开一个TCP连接需要“四次挥手”<br>第一次挥手：主动关闭方发送一个FIN，用来关注主动方到被动关闭方的数据传送，也即是主动关闭方告诫被动关闭方：我已经不会再给你发数据了（在FIN包之前发送的数据，如果没有收到对应的ACK确认报文，主动关闭方依然会重发这些数据）。但是，此时主动关闭方还可以接受数据<br>第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号收到序号 +1（与SYN相同，一个 FIN占用一个序号）<br>第三次挥手：被动关闭方发送一个 FIN。用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会给你发送数据了<br>第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手</p><h1 id="HTTP-和-HTTPS，为什么HTTPS安全？"><a href="#HTTP-和-HTTPS，为什么HTTPS安全？" class="headerlink" title="HTTP 和 HTTPS，为什么HTTPS安全？"></a>HTTP 和 HTTPS，为什么HTTPS安全？</h1><p>HTTP协议通常承载与 TCP协议之上，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的HTTPS<br>默认HTTP的端口号为80，HTTPS的端口号为443<br>因为网络请求需要中间有很多的服务器路由的转发，中间的节点都可能篡改信息，而如果使用HTTPS，密钥在你和终点站才有，https之所有说比http安全，是因为他利用ssl&#x2F;tls协议传输。包含证书，流量转发，负载均衡，页面适配，浏览器适配，refer传递等，保障了传输过程的安全性</p><h1 id="axios和fetch区别对比"><a href="#axios和fetch区别对比" class="headerlink" title="axios和fetch区别对比"></a>axios和fetch区别对比</h1><p>axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，本质上也是对原生XHR的封装，只不过它是Promise的实现版本，符合最新的ES规范，它本身具有以下特征</p><p>从浏览器中创建 XMLHttpRequest<br>支持 Promise API<br>客户端支持防止CSRF<br>提供了一些并发请求的接口（重要，方便了很多的操作）<br>从 node.js 创建 http 请求<br>拦截请求和响应<br>转换请求和响应数据<br>取消请求<br>自动转换JSON数据<br>fetch优势：</p><p>语法简洁，更加语义化<br>基于标准 Promise 实现，支持 async&#x2F;await<br>同构方便，使用 isomorphic-fetch<br>更加底层，提供的API丰富（request, response）<br>脱离了XHR，是ES规范里新的实现方式<br>fetch存在问题</p><p>fetch是一个低层次的API，你可以把它考虑成原生的XHR，所以使用起来并不是那么舒服，需要进行封装。<br>fetch只对网络请求报错，对400，500都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。<br>fetch默认不会带cookie，需要添加配置项： fetch(url, {credentials: ‘include’})<br>fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费<br>fetch没有办法原生监测请求的进度，而XHR可以</p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web综合问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bootstrap</title>
      <link href="/front-end/Bootstrap/"/>
      <url>/front-end/Bootstrap/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是Bootstrap？以及为什么要使⽤Bootstrap？"><a href="#什么是Bootstrap？以及为什么要使⽤Bootstrap？" class="headerlink" title="什么是Bootstrap？以及为什么要使⽤Bootstrap？"></a>什么是Bootstrap？以及为什么要使⽤Bootstrap？</h1><ol><li>Bootstrap 是⼀个⽤于快速开发 Web 应⽤程序和⽹站的前端框架。</li><li>Bootstrap 是基于 HTML 、 CSS 、 JAVASCRIPT 的</li><li>Bootstrap 具有移动设备优先、浏览器⽀持良好、容易上⼿、响应式设计等优点，所以Bootstrap 被⼴泛应⽤</li></ol><h1 id="使⽤Bootstrap时，要声明的⽂档类型是什么？以及为什么要这样声明？"><a href="#使⽤Bootstrap时，要声明的⽂档类型是什么？以及为什么要这样声明？" class="headerlink" title="使⽤Bootstrap时，要声明的⽂档类型是什么？以及为什么要这样声明？"></a>使⽤Bootstrap时，要声明的⽂档类型是什么？以及为什么要这样声明？</h1><ol><li>使⽤ Bootstrap 时，需要使⽤ HTML5 ⽂档类型（ Doctype ）。 <!DOCTYPE html></li><li>因为 Bootstrap 使⽤了⼀些 HTML5 元素和 CSS 属性，如果在 Bootstrap 创建的⽹⻚开头不使⽤ HTML5 的⽂档类型（ Doctype ），可能会⾯临⼀些浏览器显示不⼀致的问题，甚⾄可能⾯临⼀些特定情境下的不⼀致，以致于代码不能通过 W3C 标准的验证</li></ol><h1 id="什么是Bootstrap⽹格系统"><a href="#什么是Bootstrap⽹格系统" class="headerlink" title="什么是Bootstrap⽹格系统"></a>什么是Bootstrap⽹格系统</h1><ol><li>Bootstrap 包含了⼀个响应式的、移动设备优先的、不固定的⽹格系统，可以随着设备或视⼝⼤⼩的增加⽽适当地扩展到 12 列。它包含了⽤于简单的布局选项的预定义类，也包含了⽤于⽣成更多语义布局的功能强⼤的混合类</li><li>响应式⽹格系统随着屏幕或视⼝（ viewport ）尺⼨的增加，系统会⾃动分为最多 12列。</li></ol><h1 id="Bootstrap-⽹格系统（Grid-System）的⼯作原理"><a href="#Bootstrap-⽹格系统（Grid-System）的⼯作原理" class="headerlink" title="Bootstrap ⽹格系统（Grid System）的⼯作原理"></a>Bootstrap ⽹格系统（Grid System）的⼯作原理</h1><p>（1）⾏必须放置在 .container class 内，以便获得适当的对⻬（ alignment ）和内<br>边距（ padding ）。<br>（2）使⽤⾏来创建列的⽔平组。<br>（3）内容应该放置在列内，且唯有列可以是⾏的直接⼦元素。<br>（4）预定义的⽹格类，⽐如 .row 和 .col-xs-4 ，可⽤于快速创建⽹格布局。 LESS<br>混合类可⽤于更多语义布局。<br>（5）列通过内边距（ padding ）来创建列内容之间的间隙。该内边距是通过 .rows 上<br>的外边距（ margin ）取负，表示第⼀列和最后⼀列的⾏偏移。<br>（6）⽹格系统是通过指定您想要横跨的⼗⼆个可⽤的列来创建的。例如，要创建三个相等<br>的列，则使⽤三个 .col-xs-4</p><h1 id="对于各类尺⼨的设备，Bootstrap设置的class前缀分别是什么"><a href="#对于各类尺⼨的设备，Bootstrap设置的class前缀分别是什么" class="headerlink" title="对于各类尺⼨的设备，Bootstrap设置的class前缀分别是什么"></a>对于各类尺⼨的设备，Bootstrap设置的class前缀分别是什么</h1><ol><li>超⼩设备⼿机（ &lt;768px ）： .col-xs-*</li><li>⼩型设备平板电脑（ &gt;&#x3D;768px ）： .col-sm-*</li><li>中型设备台式电脑（ &gt;&#x3D;992px ）： .col-md-*</li><li>⼤型设备台式电脑（ &gt;&#x3D;1200px ）： .col-lg-*</li></ol><h1 id="Bootstrap-⽹格系统列与列之间的间隙宽度是多少"><a href="#Bootstrap-⽹格系统列与列之间的间隙宽度是多少" class="headerlink" title="Bootstrap ⽹格系统列与列之间的间隙宽度是多少"></a>Bootstrap ⽹格系统列与列之间的间隙宽度是多少</h1><p>间隙宽度为 30px （⼀个列的每边分别是 15px ）</p><h1 id="如果需要在⼀个标题的旁边创建副标题，可以怎样操作"><a href="#如果需要在⼀个标题的旁边创建副标题，可以怎样操作" class="headerlink" title="如果需要在⼀个标题的旁边创建副标题，可以怎样操作"></a>如果需要在⼀个标题的旁边创建副标题，可以怎样操作</h1><p>在元素两旁添加 <small> ，或者添加 .small 的 class</p><h1 id="⽤Bootstrap，如何设置⽂字的对⻬⽅式"><a href="#⽤Bootstrap，如何设置⽂字的对⻬⽅式" class="headerlink" title="⽤Bootstrap，如何设置⽂字的对⻬⽅式"></a>⽤Bootstrap，如何设置⽂字的对⻬⽅式</h1><ol><li>class&#x3D;”text-center” 设置居中⽂本</li><li>class&#x3D;”text-right” 设置向右对⻬⽂本</li><li>class&#x3D;”text-left” 设置向左对⻬⽂本</li></ol><h1 id="Bootstrap如何设置响应式表格？"><a href="#Bootstrap如何设置响应式表格？" class="headerlink" title="Bootstrap如何设置响应式表格？"></a>Bootstrap如何设置响应式表格？</h1><p>增加 class&#x3D;”table-responsive”</p><h1 id="使⽤Bootstrap创建垂直表单的基本步骤？"><a href="#使⽤Bootstrap创建垂直表单的基本步骤？" class="headerlink" title="使⽤Bootstrap创建垂直表单的基本步骤？"></a>使⽤Bootstrap创建垂直表单的基本步骤？</h1><p>（1）向⽗ <form> 元素添加 role&#x3D;”form” ；<br>（2）把标签和控件放在⼀个带有 class&#x3D;”form-group” 的 <div> 中，这是获取最佳间距<br>所必需的；<br>（3）向所有的⽂本元素 <input> 、 <textarea> 、 <select> 添加 class&#x3D;”form-control”</p><h1 id="使⽤Bootstrap创建⽔平表单的基本步骤？"><a href="#使⽤Bootstrap创建⽔平表单的基本步骤？" class="headerlink" title="使⽤Bootstrap创建⽔平表单的基本步骤？"></a>使⽤Bootstrap创建⽔平表单的基本步骤？</h1><p>（1）向⽗ <form> 元素添加 class&#x3D;”form-horizontal” ；<br>（2）把标签和控件放在⼀个带有 class&#x3D;”form-group” 的 <div> 中；<br>（3）向标签添加 class&#x3D;”control-label” 。</p><h1 id="使⽤Bootstrap如何创建表单控件的帮助⽂本？"><a href="#使⽤Bootstrap如何创建表单控件的帮助⽂本？" class="headerlink" title="使⽤Bootstrap如何创建表单控件的帮助⽂本？"></a>使⽤Bootstrap如何创建表单控件的帮助⽂本？</h1><p>增加 class&#x3D;”help-block” 的 span 标签或 p 标签。</p><h1 id="使⽤Bootstrap激活或禁⽤按钮要如何操作？"><a href="#使⽤Bootstrap激活或禁⽤按钮要如何操作？" class="headerlink" title="使⽤Bootstrap激活或禁⽤按钮要如何操作？"></a>使⽤Bootstrap激活或禁⽤按钮要如何操作？</h1><ol><li>激活按钮：给按钮增加 .active 的 class</li><li>禁⽤按钮：给按钮增加 disabled&#x3D;”disabled” 的属性</li></ol><h1 id="Bootstrap有哪些关于的class？"><a href="#Bootstrap有哪些关于的class？" class="headerlink" title="Bootstrap有哪些关于的class？"></a>Bootstrap有哪些关于的class？</h1><p>（1） .img-rounded 为图⽚添加圆⻆<br>（2） .img-circle 将图⽚变为圆形<br>（3） .img-thumbnail 缩略图功能<br>（4） .img-responsive 图⽚响应式 (将很好地扩展到⽗元素)</p><h1 id="Bootstrap中有关元素浮动及清除浮动的class？"><a href="#Bootstrap中有关元素浮动及清除浮动的class？" class="headerlink" title="Bootstrap中有关元素浮动及清除浮动的class？"></a>Bootstrap中有关元素浮动及清除浮动的class？</h1><p>（1） class&#x3D;”pull-left” 元素浮动到左边<br>（2） class&#x3D;”pull-right” 元素浮动到右边<br>（3） class&#x3D;”clearfix” 清除浮动</p><h1 id="除了屏幕阅读器外，其他设备上隐藏元素的class？"><a href="#除了屏幕阅读器外，其他设备上隐藏元素的class？" class="headerlink" title="除了屏幕阅读器外，其他设备上隐藏元素的class？"></a>除了屏幕阅读器外，其他设备上隐藏元素的class？</h1><p><code>class=&quot;sr-only</code></p><h1 id="Bootstrap如何制作下拉菜单？"><a href="#Bootstrap如何制作下拉菜单？" class="headerlink" title="Bootstrap如何制作下拉菜单？"></a>Bootstrap如何制作下拉菜单？</h1><p>（1）将下拉菜单包裹在 class&#x3D;”dropdown” 的 <div> 中；<br>（2）在触发下拉菜单的按钮中添加： class&#x3D;”btn dropdown-toggle”<br>id&#x3D;”dropdownMenu1” data-toggle&#x3D;”dropdown”<br>（3）在包裹下拉菜单的ul中添加： class&#x3D;”dropdown-menu” role&#x3D;”menu” aria-labelledby&#x3D;”dropdownMenu1”<br>（4）在下拉菜单的列表项中添加： role&#x3D;”presentation” 。其中，下拉菜单的标题要添<br>加 class&#x3D;”dropdown-header” ，选项部分要添加 tabindex&#x3D;”-1” 。</p><h1 id="Bootstrap如何制作按钮组？以及⽔平按钮组和垂直按钮组的优先级？"><a href="#Bootstrap如何制作按钮组？以及⽔平按钮组和垂直按钮组的优先级？" class="headerlink" title="Bootstrap如何制作按钮组？以及⽔平按钮组和垂直按钮组的优先级？"></a>Bootstrap如何制作按钮组？以及⽔平按钮组和垂直按钮组的优先级？</h1><p>（1）⽤ class&#x3D;”btn-group” 的 <div> 去包裹按钮组； class&#x3D;”btn-group-vertical” 可设置垂直按钮组。<br>（2） btn-group 的优先级⾼于 btn-group-vertical 的优先级。</p><h1 id="Bootstrap如何设置按钮的下拉菜单？"><a href="#Bootstrap如何设置按钮的下拉菜单？" class="headerlink" title="Bootstrap如何设置按钮的下拉菜单？"></a>Bootstrap如何设置按钮的下拉菜单？</h1><p>在⼀个 .btn-group 中放置按钮和下拉菜单即可。</p><h1 id="Bootstrap中的输⼊框组如何制作？"><a href="#Bootstrap中的输⼊框组如何制作？" class="headerlink" title="Bootstrap中的输⼊框组如何制作？"></a>Bootstrap中的输⼊框组如何制作？</h1><p>（1）把前缀或者后缀元素放在⼀个带有 class&#x3D;”input-group” 中的 <div> 中<br>（2）在该 <div> 内，在 class&#x3D;”input-group-addon” 的 <span> ⾥⾯放置额外的内<br>容；<br>（3）把 <span> 放在 <input> 元素的前⾯或后⾯。</p><h1 id="Bootstrap中的导航都有哪些？"><a href="#Bootstrap中的导航都有哪些？" class="headerlink" title="Bootstrap中的导航都有哪些？"></a>Bootstrap中的导航都有哪些？</h1><p>（1）导航元素：有 class&#x3D;”nav nav-tabs” 的标签⻚导航，还有 class&#x3D;”nav navpills” 的胶囊式标签⻚导航；<br>（2）导航栏： class&#x3D;”navbar navbar-default” role&#x3D;”navigation” ；<br>（3）⾯包屑导航： class&#x3D;”breadcrumb”</p><h1 id="Bootstrap中设置分⻚的class？"><a href="#Bootstrap中设置分⻚的class？" class="headerlink" title="Bootstrap中设置分⻚的class？"></a>Bootstrap中设置分⻚的class？</h1><ol><li>默认的分⻚： class&#x3D;”pagination”</li><li>默认的翻⻚： class&#x3D;”pager”</li></ol><h1 id="Bootstrap中显示标签的class？"><a href="#Bootstrap中显示标签的class？" class="headerlink" title="Bootstrap中显示标签的class？"></a>Bootstrap中显示标签的class？</h1><p>class&#x3D;”label”</p><h1 id="Bootstrap中如何制作徽章？"><a href="#Bootstrap中如何制作徽章？" class="headerlink" title="Bootstrap中如何制作徽章？"></a>Bootstrap中如何制作徽章？</h1><pre><code class="css">&lt;span class=&quot;badge&quot;&gt;26&lt;/span&gt;</code></pre><h1 id="Bootstrap中超⼤屏幕的作⽤是什么"><a href="#Bootstrap中超⼤屏幕的作⽤是什么" class="headerlink" title="Bootstrap中超⼤屏幕的作⽤是什么"></a>Bootstrap中超⼤屏幕的作⽤是什么</h1><pre><code class="text">设置 class=&quot;jumbotron&quot; 可以制作超⼤屏幕，该组件可以增加标题的⼤⼩并增加更多的外边距</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> Bootstrap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bootstrap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从浏览器地址栏输⼊url到显示⻚⾯的步骤</title>
      <link href="/Web-Integration/%E8%AF%A6%E8%A7%A3%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E2%BC%8Aurl%E5%88%B0%E6%98%BE%E7%A4%BA%E2%BB%9A%E2%BE%AF/"/>
      <url>/Web-Integration/%E8%AF%A6%E8%A7%A3%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E2%BC%8Aurl%E5%88%B0%E6%98%BE%E7%A4%BA%E2%BB%9A%E2%BE%AF/</url>
      
        <content type="html"><![CDATA[<ol><li>在浏览器地址栏输⼊URL</li><li>浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤</li></ol><ul><li>如果资源未缓存，发起新请求</li><li>如果已缓存，检验是否⾜够新鲜，⾜够新鲜直接提供给客户端，否则与服务器进⾏验证。</li><li>检验新鲜通常有两个HTTP头进⾏控制 Expires 和 Cache-Control ：(  HTTP1.0提供Expires，值为⼀个绝对时间表示缓存新鲜⽇期<br>  HTTP1.1增加了Cache-Control: max-age&#x3D;,值为以秒为单位的最⼤新鲜时间)</li></ul><ol start="3"><li>浏览器解析URL获取协议，主机，端⼝，path</li><li>浏览器组装⼀个HTTP（GET）请求报⽂</li><li>浏览器获取主机ip地址，过程如下：</li></ol><ul><li>浏览器缓存:(浏览器会在本地进行DNS缓存，将之前解析过的域名和其对应的IP地址保存起来。当再次请求相同的域名时，浏览器会首先检查本地缓存中是否存在对应的记录)</li><li>本机缓存:(如果在浏览器缓存中找不到域名的IP地址，浏览器将查找操作系统（如Windows、Mac等）的本机DNS缓存。操作系统也会对DNS查询结果进行缓存，以提高性能和减少网络请求)</li><li>hosts⽂件:(如果在本机缓存中没有找到域名的IP地址，系统将查找操作系统的Hosts文件。Hosts文件是一个文本文件，可以手动配置域名和对应的IP地址映射关系)</li><li>路由器缓存:(如果在Hosts文件中找不到域名的IP地址，系统将向路由器发送DNS查询请求。某些路由器会在自身进行DNS缓存，以便快速响应本地网络设备的DNS查询)</li><li>ISP DNS缓存:(如果在路由器缓存中没有找到域名的IP地址，系统将向互联网服务提供商（ISP）的DNS服务器发送DNS查询请求。ISP的DNS服务器也会进行缓存，以提高DNS解析速度和网络访问效率)</li><li>DNS递归查询:(如果在ISP DNS缓存中找不到域名的IP地址，ISP的DNS服务器将发起递归查询。递归查询是指DNS服务器按照一定的顺序向上级DNS服务器发出查询请求，直到找到所需的IP地址或者查询失败。在递归查询过程中，可能会经过多个DNS服务器，这可能导致负载均衡使得每次获得的IP地址可能不一样)（可能存在负载均衡导致每次IP不⼀样）</li></ul><ol start="6"><li>打开⼀个socket与⽬标IP地址，端⼝建⽴TCP链接，三次握⼿如下：</li></ol><ul><li>客户端发送⼀个TCP的SYN&#x3D;1，Seq&#x3D;X的包到服务器端⼝</li><li>服务器发回SYN&#x3D;1， ACK&#x3D;X+1， Seq&#x3D;Y的响应包</li><li>客户端发送ACK&#x3D;Y+1， Seq&#x3D;Z</li></ul><ol start="7"><li>TCP链接建⽴后发送HTTP请求</li><li>服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使⽤HTTP Host头部判断请求的服务程序</li><li>服务器检查HTTP请求头是否包含缓存验证信息如果验证缓存新鲜，返回304等对应状态码</li><li>处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作</li><li>服务器将响应报⽂通过TCP连接发送回浏览器</li><li>浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重⽤，关闭TCP连接的四<br>次握⼿如下：</li></ol><ul><li>主动⽅发送Fin&#x3D;1， Ack&#x3D;Z， Seq&#x3D; X报⽂</li><li>被动⽅发送ACK&#x3D;X+1， Seq&#x3D;Z报⽂</li><li>被动⽅发送Fin&#x3D;1， ACK&#x3D;X， Seq&#x3D;Y报⽂</li><li>主动⽅发送ACK&#x3D;Y， Seq&#x3D;X报⽂</li></ul><ol start="13"><li>浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同</li><li>如果资源可缓存，进⾏缓存</li><li>对响应进⾏解码（例如gzip压缩）</li><li>根据资源类型决定如何处理（假设资源为HTML⽂档）</li><li>解析HTML⽂档，构件DOM树，下载资源，构造CSSOM树，执⾏js脚本，这些操作没有严格的先后顺序，以下分别解释</li><li>构建DOM树：</li></ol><ul><li>Tokenizing：根据HTML规范将字符流解析为标记</li><li>Lexing：词法分析将标记转换为对象并定义属性和规则</li><li>DOM construction：根据HTML标记关系将对象组成DOM树</li></ul><ol start="19"><li>解析过程中遇到图⽚、样式表、js⽂件，启动下载</li><li>构建CSSOM树：</li></ol><ul><li>Tokenizing：字符流转换为标记流</li><li>Node：根据标记创建节点</li><li>CSSOM：节点创建CSSOM树</li></ul><ol start="21"><li>根据DOM树和CSSOM树构建渲染树 :</li></ol><ul><li>从DOM树的根节点遍历所有可⻅节点，不可⻅节点包括：1） script , meta 这样本身<br>不可⻅的标签。2)被css隐藏的节点，如 display: none</li><li>对每⼀个可⻅节点，找到恰当的CSSOM规则并应⽤</li><li>发布可视节点的内容和计算样式</li></ul><ol start="22"><li>js解析如下：</li></ol><ul><li>浏览器创建Document对象并解析HTML，将解析到的元素和⽂本节点添加到⽂档中，此<br>时document.readystate为loading</li><li>HTML解析器遇到没有async和defer的script时，将他们添加到⽂档中，然后执⾏⾏内<br>或外部脚本。这些脚本会同步执⾏，并且在脚本下载和执⾏时解析器会暂停。这样就可<br>以⽤document.write()把⽂本插⼊到输⼊流中。同步脚本经常简单定义函数和注册事件<br>处理程序，他们可以遍历和操作script和他们之前的⽂档内容</li><li>当解析器遇到设置了async属性的script时，开始下载脚本并继续解析⽂档。脚本会在它下载完成后尽快执⾏，但是解析器不会停下来等它下载。异步脚本禁使⽤document.write()，它们可以访问⾃⼰script和之前的⽂档元素</li><li>当⽂档完成解析，document.readState变成interactive</li><li>所有defer脚本会按照在⽂档出现的顺序执⾏，延迟脚本能访问完整⽂档树，禁⽌使⽤document.write()</li><li>浏览器在Document对象上触发DOMContentLoaded事件</li><li>此时⽂档完全解析完成，浏览器可能还在等待如图⽚等内容加载，等这些内容完成载⼊并且所有异步脚本完成载⼊和执⾏，document.readState变complete，window触发load事件</li></ul><ol start="23"><li>显示⻚⾯（HTML解析过程中会逐步显示⻚⾯）</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web综合问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨域解决方案</title>
      <link href="/Web-Integration/%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/Web-Integration/%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是跨域？"><a href="#什么是跨域？" class="headerlink" title="什么是跨域？"></a>什么是跨域？</h1><pre><code class="text">在前端领域中，跨域是指浏览器允许向服务器发送跨域请求，从而克服Ajax只能**同源**使用的限制。什么是同源策略？**同源策略**是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指&quot;协议+域名+端口&quot;三者相同，即便两个不同的域名指向同一个ip地址，也非同源同源策略限制以下几种行为：- Cookie、LocalStorage 和 IndexDB 无法读取- DOM和JS对象无法获得- AJAX 请求不能发送举例说明：⽐如⼀个⿊客程序，他利⽤ Iframe 把真正的银⾏登录⻚⾯嵌到他的⻚⾯上，当你使⽤真实的⽤户名，密码登录时，他的⻚⾯就可以通过 Javascript 读取到你的表单中 input 中的内容，这样⽤户名，密码就轻松到⼿了。</code></pre><h1 id="JSONP跨域"><a href="#JSONP跨域" class="headerlink" title="JSONP跨域"></a>JSONP跨域</h1><p><strong>jsonp</strong>的原理就是利用<code>&lt;script&gt;</code>标签没有跨域限制，通过<code>&lt;script&gt;</code>标签src属性，发送带有callback参数的GET请求，服务端将接口返回数据拼凑到callback函数中，返回给浏览器，浏览器解析执行，从而前端拿到callback函数返回的数据。</p><p>1）原生JS实现：</p><pre><code class="text">&lt;script&gt;    var script = document.createElement(&#39;script&#39;);    script.type = &#39;text/javascript&#39;;    // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数    script.src = &#39;http://www.domain2.com:8080/login?user=admin&amp;callback=handleCallback&#39;;    document.head.appendChild(script);    // 回调执行函数    function handleCallback(res) &#123;        alert(JSON.stringify(res));    &#125; &lt;/script&gt;</code></pre><p>服务端返回如下（返回时即执行全局函数）：</p><pre><code class="text">handleCallback(&#123;&quot;success&quot;: true, &quot;user&quot;: &quot;admin&quot;&#125;)</code></pre><p>2）jquery Ajax实现：</p><pre><code class="text">$.ajax(&#123;    url: &#39;http://www.domain2.com:8080/login&#39;,    type: &#39;get&#39;,    dataType: &#39;jsonp&#39;,  // 请求方式为jsonp    jsonpCallback: &quot;handleCallback&quot;,  // 自定义回调函数名    data: &#123;&#125;&#125;);</code></pre><p>3）Vue axios实现：</p><pre><code class="text">this.$http = axios;this.$http.jsonp(&#39;http://www.domain2.com:8080/login&#39;, &#123;    params: &#123;&#125;,    jsonp: &#39;handleCallback&#39;&#125;).then((res) =&gt; &#123;    console.log(res); &#125;)</code></pre><p>后端node.js代码：</p><pre><code class="text">var querystring = require(&#39;querystring&#39;);var http = require(&#39;http&#39;);var server = http.createServer();server.on(&#39;request&#39;, function(req, res) &#123;    var params = querystring.parse(req.url.split(&#39;?&#39;)[1]);    var fn = params.callback;    // jsonp返回设置    res.writeHead(200, &#123; &#39;Content-Type&#39;: &#39;text/javascript&#39; &#125;);    res.write(fn + &#39;(&#39; + JSON.stringify(params) + &#39;)&#39;);    res.end();&#125;);server.listen(&#39;8080&#39;);console.log(&#39;Server is running at port 8080...&#39;);</code></pre><p>jsonp的缺点：只能发送get一种请求。</p><h1 id="跨域资源共享（CORS）（后端配置跨域）"><a href="#跨域资源共享（CORS）（后端配置跨域）" class="headerlink" title="跨域资源共享（CORS）（后端配置跨域）"></a>跨域资源共享（CORS）（后端配置跨域）</h1><p><strong>CORS</strong>是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。<br>它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。<br>CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。</p><p>浏览器将CORS跨域请求分为简单请求和非简单请求。</p><p>只要同时满足一下两个条件，就属于简单请求</p><p>(1)使用下列方法之一：</p><ul><li>head</li><li>get</li><li>post</li></ul><p>(2)请求的Heder是</p><ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Content-Type: 只限于三个值：application&#x2F;x-www-form-urlencoded、multipart&#x2F;form-data、text&#x2F;plain</li></ul><p>不同时满足上面的两个条件，就属于非简单请求。浏览器对这两种的处理，是不一样的。</p><p>简单请求</p><p>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。</p><pre><code class="text">GET /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0...</code></pre><p>上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</p><p>CORS请求设置的响应头字段，都以 Access-Control-开头:</p><p><strong>1）Access-Control-Allow-Origin</strong>：必选</p><p>它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。</p><p><strong>2）Access-Control-Allow-Credentials</strong>：可选</p><p>它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。</p><p><strong>3）Access-Control-Expose-Headers</strong>：可选</p><p>CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。</p><p>非简单请求</p><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application&#x2F;json。非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。</p><p>预检请求</p><p>预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。请求头信息里面，关键字段是Origin，表示请求来自哪个源。除了Origin字段，”预检”请求的头信息包括两个特殊字段。</p><pre><code class="text">OPTIONS /cors HTTP/1.1Origin: http://api.bob.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0..</code></pre><p><strong>1）Access-Control-Request-Method</strong>：必选</p><p>用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。</p><p><strong>2）Access-Control-Request-Headers</strong>：可选</p><p>该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。</p><p>预检请求的回应</p><p>服务器收到”预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。</p><p>HTTP回应中，除了关键的是Access-Control-Allow-Origin字段，其他CORS相关字段如下：</p><p><strong>1）Access-Control-Allow-Methods</strong>：必选</p><p>它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。</p><p><strong>2）Access-Control-Allow-Headers</strong></p><p>如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。</p><p><strong>3）Access-Control-Allow-Credentials</strong>：可选</p><p>该字段与简单请求时的含义相同。</p><p><strong>4）Access-Control-Max-Age</strong>：可选</p><p>用来指定本次预检请求的有效期，单位为秒。</p><p>CORS跨域示例</p><p><strong>1）前端设置</strong>：</p><ul><li>原生ajax：</li></ul><pre><code class="text">var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容// 前端设置是否带cookiexhr.withCredentials = true;xhr.open(&#39;post&#39;, &#39;http://www.domain2.com:8080/login&#39;, true);xhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application/x-www-form-urlencoded&#39;);xhr.send(&#39;user=admin&#39;);xhr.onreadystatechange = function() &#123;    if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123;        alert(xhr.responseText);    &#125;&#125;;</code></pre><ul><li>jquery ajax：</li></ul><pre><code class="text">$.ajax(&#123;    ...   xhrFields: &#123;       withCredentials: true    // 前端设置是否带cookie   &#125;,   crossDomain: true,   // 会让请求头中包含跨域的额外信息，但不会含cookie    ...&#125;);</code></pre><p><strong>2）服务端设置</strong>：</p><ul><li>nodejs代码</li></ul><pre><code class="text">var http = require(&#39;http&#39;);var server = http.createServer();var qs = require(&#39;querystring&#39;);server.on(&#39;request&#39;, function(req, res) &#123;    var postData = &#39;&#39;;    // 数据块接收中    req.addListener(&#39;data&#39;, function(chunk) &#123;        postData += chunk;    &#125;);    // 数据接收完毕    req.addListener(&#39;end&#39;, function() &#123;        postData = qs.parse(postData);        // 跨域后台设置        res.writeHead(200, &#123;            &#39;Access-Control-Allow-Credentials&#39;: &#39;true&#39;,     // 后端允许发送Cookie            &#39;Access-Control-Allow-Origin&#39;: &#39;http://www.domain1.com&#39;,    // 允许访问的域（协议+域名+端口）            /*              * 此处设置的cookie还是domain2的而非domain1，因为后端也不能跨域写cookie(nginx反向代理可以实现)，             * 但只要domain2中写入一次cookie认证，后面的跨域接口都能从domain2中获取cookie，从而实现所有的接口都能跨域访问             */            &#39;Set-Cookie&#39;: &#39;l=a123456;Path=/;Domain=www.domain2.com;HttpOnly&#39;  // HttpOnly的作用是让js无法读取cookie        &#125;);        res.write(JSON.stringify(postData));        res.end();    &#125;);&#125;);server.listen(&#39;8080&#39;);console.log(&#39;Server is running at port 8080...&#39;);</code></pre><h1 id="nginx代理跨域"><a href="#nginx代理跨域" class="headerlink" title="nginx代理跨域"></a>nginx代理跨域</h1><p>nginx代理跨域，实质和CORS跨域原理一样，通过配置文件设置请求响应头Access-Control-Allow-Origin…等字段。</p><p>1）nginx配置解决iconfont跨域</p><p>浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。</p><pre><code class="text">location / &#123;  add_header Access-Control-Allow-Origin *;&#125;</code></pre><p>2）nginx反向代理接口跨域</p><p>跨域问题：同源策略仅是针对浏览器的安全策略。服务器端调用HTTP接口只是使用HTTP协议，不需要同源策略，也就不存在跨域问题。</p><p>实现思路：通过Nginx配置一个代理服务器域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域访问。</p><p>nginx具体配置：</p><pre><code class="text">#proxy服务器server &#123;    listen       81;    server_name  www.domain1.com;    location / &#123;        proxy_pass   http://www.domain2.com:8080;  #反向代理        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名        index  index.html index.htm;        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*        add_header Access-Control-Allow-Credentials true;    &#125;&#125;</code></pre><h1 id="nodejs中间件代理跨域"><a href="#nodejs中间件代理跨域" class="headerlink" title="nodejs中间件代理跨域"></a>nodejs中间件代理跨域</h1><p>node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。</p><p><strong>1）非vue框架的跨域</strong></p><p>使用node + express + http-proxy-middleware搭建一个proxy服务器。</p><ul><li>前端代码：</li></ul><pre><code class="text">var xhr = new XMLHttpRequest();// 前端开关：浏览器是否读写cookiexhr.withCredentials = true;// 访问http-proxy-middleware代理服务器xhr.open(&#39;get&#39;, &#39;http://www.domain1.com:3000/login?user=admin&#39;, true);xhr.send();</code></pre><ul><li>中间件服务器代码：</li></ul><pre><code class="text">var express = require(&#39;express&#39;);var proxy = require(&#39;http-proxy-middleware&#39;);var app = express();app.use(&#39;/&#39;, proxy(&#123;    // 代理跨域目标接口    target: &#39;http://www.domain2.com:8080&#39;,    changeOrigin: true,    // 修改响应头信息，实现跨域并允许带cookie    onProxyRes: function(proxyRes, req, res) &#123;        res.header(&#39;Access-Control-Allow-Origin&#39;, &#39;http://www.domain1.com&#39;);        res.header(&#39;Access-Control-Allow-Credentials&#39;, &#39;true&#39;);    &#125;,    // 修改响应信息中的cookie域名    cookieDomainRewrite: &#39;www.domain1.com&#39;  // 可以为false，表示不修改&#125;));app.listen(3000);console.log(&#39;Proxy server is listen at port 3000...&#39;);</code></pre><p><strong>2）vue框架的跨域</strong></p><p>node + vue + webpack + webpack-dev-server搭建的项目，跨域请求接口，直接修改webpack.config.js配置。开发环境下，vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域。</p><p>webpack.config.js部分配置：</p><pre><code class="text">module.exports = &#123;    entry: &#123;&#125;,    module: &#123;&#125;,    ...    devServer: &#123;        historyApiFallback: true,        proxy: [&#123;            context: &#39;/login&#39;,            target: &#39;http://www.domain2.com:8080&#39;,  // 代理跨域目标接口            changeOrigin: true,            secure: false,  // 当代理某些https服务报错时用            cookieDomainRewrite: &#39;www.domain1.com&#39;  // 可以为false，表示不修改        &#125;],        noInfo: true    &#125;&#125;</code></pre><h1 id="document-domain-iframe跨域"><a href="#document-domain-iframe跨域" class="headerlink" title="document.domain + iframe跨域"></a>document.domain + iframe跨域</h1><p>此方案仅限主域相同，子域不同的跨域应用场景。实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。</p><p>1）父窗口：(<span class="exturl" data-url="aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHA6Ly93d3cuZG9tYWluLmNvbS9hLmh0bWw=">http://www.domain.com/a.html</span>)</p><pre><code class="text">&lt;iframe id=&quot;iframe&quot; src=&quot;http://child.domain.com/b.html&quot;&gt;&lt;/iframe&gt;&lt;script&gt;    document.domain = &#39;domain.com&#39;;    var user = &#39;admin&#39;;&lt;/script&gt;</code></pre><p>1）子窗口：(<span class="exturl" data-url="aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHA6Ly9jaGlsZC5kb21haW4uY29tL2EuaHRtbA==">http://child.domain.com/a.html</span>)</p><pre><code class="text">&lt;script&gt;    document.domain = &#39;domain.com&#39;;    // 获取父窗口中变量    console.log(&#39;get js data from parent ---&gt; &#39; + window.parent.user);&lt;/script&gt;</code></pre><h1 id="location-hash-iframe跨域"><a href="#location-hash-iframe跨域" class="headerlink" title="location.hash + iframe跨域"></a>location.hash + iframe跨域</h1><p>实现原理： a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。</p><p>具体实现：A域：a.html -&gt; B域：b.html -&gt; A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。</p><p>1）a.html：(<span class="exturl" data-url="aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHA6Ly93d3cuZG9tYWluMS5jb20vYS5odG1s">http://www.domain1.com/a.html</span>)</p><pre><code class="text">&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain2.com/b.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;&lt;script&gt;    var iframe = document.getElementById(&#39;iframe&#39;);    // 向b.html传hash值    setTimeout(function() &#123;        iframe.src = iframe.src + &#39;#user=admin&#39;;    &#125;, 1000);        // 开放给同域c.html的回调方法    function onCallback(res) &#123;        alert(&#39;data from c.html ---&gt; &#39; + res);    &#125;&lt;/script&gt;</code></pre><p>2）b.html：(<span class="exturl" data-url="aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHA6Ly93d3cuZG9tYWluMi5jb20vYi5odG1s">http://www.domain2.com/b.html</span>)</p><pre><code class="text">&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain1.com/c.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;&lt;script&gt;    var iframe = document.getElementById(&#39;iframe&#39;);    // 监听a.html传来的hash值，再传给c.html    window.onhashchange = function () &#123;        iframe.src = iframe.src + location.hash;    &#125;;&lt;/script&gt;</code></pre><p>3）c.html：(<span class="exturl" data-url="aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHA6Ly93d3cuZG9tYWluMS5jb20vYy5odG1s">http://www.domain1.com/c.html</span>)</p><pre><code class="text">&lt;script&gt;    // 监听b.html传来的hash值    window.onhashchange = function () &#123;        // 再通过操作同域a.html的js回调，将结果传回        window.parent.parent.onCallback(&#39;hello: &#39; + location.hash.replace(&#39;#user=&#39;, &#39;&#39;));    &#125;;&lt;/script&gt;</code></pre><h1 id="window-name-iframe跨域"><a href="#window-name-iframe跨域" class="headerlink" title="window.name + iframe跨域"></a>window.name + iframe跨域</h1><p>window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。</p><p>1）a.html：(<span class="exturl" data-url="aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHA6Ly93d3cuZG9tYWluMS5jb20vYS5odG1s">http://www.domain1.com/a.html</span>)</p><pre><code class="text">var proxy = function(url, callback) &#123;    var state = 0;    var iframe = document.createElement(&#39;iframe&#39;);    // 加载跨域页面    iframe.src = url;    // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name    iframe.onload = function() &#123;        if (state === 1) &#123;            // 第2次onload(同域proxy页)成功后，读取同域window.name中数据            callback(iframe.contentWindow.name);            destoryFrame();        &#125; else if (state === 0) &#123;            // 第1次onload(跨域页)成功后，切换到同域代理页面            iframe.contentWindow.location = &#39;http://www.domain1.com/proxy.html&#39;;            state = 1;        &#125;    &#125;;    document.body.appendChild(iframe);    // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）    function destoryFrame() &#123;        iframe.contentWindow.document.write(&#39;&#39;);        iframe.contentWindow.close();        document.body.removeChild(iframe);    &#125;&#125;;// 请求跨域b页面数据proxy(&#39;http://www.domain2.com/b.html&#39;, function(data)&#123;    alert(data);&#125;);</code></pre><p>2）proxy.html：(<span class="exturl" data-url="aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHA6Ly93d3cuZG9tYWluMS5jb20vcHJveHkuaHRtbA==">http://www.domain1.com/proxy.html</span>)</p><p>中间代理页，与a.html同域，内容为空即可。</p><p>3）b.html：(<span class="exturl" data-url="aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHA6Ly93d3cuZG9tYWluMi5jb20vYi5odG1s">http://www.domain2.com/b.html</span>)</p><pre><code class="text">&lt;script&gt;    window.name = &#39;This is domain2 data!&#39;;&lt;/script&gt;</code></pre><p>通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p><h1 id="postMessage跨域"><a href="#postMessage跨域" class="headerlink" title="postMessage跨域"></a>postMessage跨域</h1><p>postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：</p><ul><li>页面和其打开的新窗口的数据传递</li><li>多窗口之间消息传递</li><li>页面与嵌套的iframe消息传递</li><li>上面三个场景的跨域数据传递</li></ul><p>用法：postMessage(data,origin)方法接受两个参数：</p><ul><li><strong>data</strong>： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。</li><li><strong>origin</strong>： 协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”&#x2F;“。</li></ul><p>1）a.html：(<span class="exturl" data-url="aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHA6Ly93d3cuZG9tYWluMS5jb20vYS5odG1s">http://www.domain1.com/a.html</span>)</p><pre><code class="text">&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain2.com/b.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;&lt;script&gt;           var iframe = document.getElementById(&#39;iframe&#39;);    iframe.onload = function() &#123;        var data = &#123;            name: &#39;aym&#39;        &#125;;        // 向domain2传送跨域数据        iframe.contentWindow.postMessage(JSON.stringify(data), &#39;http://www.domain2.com&#39;);    &#125;;    // 接受domain2返回数据    window.addEventListener(&#39;message&#39;, function(e) &#123;        alert(&#39;data from domain2 ---&gt; &#39; + e.data);    &#125;, false);&lt;/script&gt;</code></pre><p>2）b.html：(<span class="exturl" data-url="aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHA6Ly93d3cuZG9tYWluMi5jb20vYi5odG1s">http://www.domain2.com/b.html</span>)</p><pre><code class="text">&lt;script&gt;    // 接收domain1的数据    window.addEventListener(&#39;message&#39;, function(e) &#123;        alert(&#39;data from domain1 ---&gt; &#39; + e.data);        var data = JSON.parse(e.data);        if (data) &#123;            data.number = 16;            // 处理后再发回domain1            window.parent.postMessage(JSON.stringify(data), &#39;http://www.domain1.com&#39;);        &#125;    &#125;, false);&lt;/script&gt;</code></pre><h1 id="WebSocket协议跨域"><a href="#WebSocket协议跨域" class="headerlink" title="WebSocket协议跨域"></a>WebSocket协议跨域</h1><p>WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。<br>原生WebSocket API使用起来不太方便，我们使用<span class="exturl" data-url="aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHA6Ly9Tb2NrZXQuaW8=">http://Socket.io</span>，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。</p><p>1）前端代码：</p><pre><code class="text">&lt;div&gt;user input：&lt;input type=&quot;text&quot;&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.bootcss.com/socket.io/2.2.0/socket.io.js&quot;&gt;&lt;/script&gt;&lt;script&gt;var socket = io(&#39;http://www.domain2.com:8080&#39;);// 连接成功处理socket.on(&#39;connect&#39;, function() &#123;    // 监听服务端消息    socket.on(&#39;message&#39;, function(msg) &#123;        console.log(&#39;data from server: ---&gt; &#39; + msg);     &#125;);    // 监听服务端关闭    socket.on(&#39;disconnect&#39;, function() &#123;         console.log(&#39;Server socket has closed.&#39;);     &#125;);&#125;);document.getElementsByTagName(&#39;input&#39;)[0].onblur = function() &#123;    socket.send(this.value);&#125;;&lt;/script&gt;</code></pre><p>2）Nodejs socket后台：</p><pre><code class="text">var http = require(&#39;http&#39;);var socket = require(&#39;socket.io&#39;);// 启http服务var server = http.createServer(function(req, res) &#123;    res.writeHead(200, &#123;        &#39;Content-type&#39;: &#39;text/html&#39;    &#125;);    res.end();&#125;);server.listen(&#39;8080&#39;);console.log(&#39;Server is running at port 8080...&#39;);// 监听socket连接socket.listen(server).on(&#39;connection&#39;, function(client) &#123;    // 接收信息    client.on(&#39;message&#39;, function(msg) &#123;        client.send(&#39;hello：&#39; + msg);        console.log(&#39;data from client: ---&gt; &#39; + msg);    &#125;);    // 断开处理    client.on(&#39;disconnect&#39;, function() &#123;        console.log(&#39;Client socket has closed.&#39;);     &#125;);&#125;);</code></pre><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><pre><code class="text">以上就是9种常见的跨域解决方案，jsonp（只支持get请求，支持老的IE浏览器）适合加载不同域名的js、css，img等静态资源；CORS（支持所有类型的HTTP请求，但浏览器IE10以下不支持）适合做ajax各种跨域请求；Nginx代理跨域和nodejs中间件跨域原理都相似，都是搭建一个服务器，直接在服务器端请求HTTP接口，这适合前后端分离的前端项目调后端接口。document.domain+iframe适合主域名相同，子域名不同的跨域请求。postMessage、websocket都是HTML5新特性，兼容性不是很好，只适用于主流浏览器和IE10+</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> 跨域 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web综合问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React基础</title>
      <link href="/front-end/React%E5%B8%B8%E7%94%A8%E5%9F%BA%E7%A1%80/"/>
      <url>/front-end/React%E5%B8%B8%E7%94%A8%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="一：React-基础"><a href="#一：React-基础" class="headerlink" title="一：React 基础"></a>一：React 基础</h1><h2 id="1-jsx"><a href="#1-jsx" class="headerlink" title="1.jsx"></a>1.jsx</h2><h2 id="2-虚拟dom"><a href="#2-虚拟dom" class="headerlink" title="2.虚拟dom"></a>2.虚拟dom</h2><h1 id="二：组件化"><a href="#二：组件化" class="headerlink" title="二：组件化"></a>二：组件化</h1><h2 id="1-context"><a href="#1-context" class="headerlink" title="1.context"></a>1.context</h2><h2 id="2-ant-design"><a href="#2-ant-design" class="headerlink" title="2.ant-design"></a>2.ant-design</h2><h2 id="3-高阶组件"><a href="#3-高阶组件" class="headerlink" title="3.高阶组件"></a>3.高阶组件</h2><h1 id="三：react全家桶"><a href="#三：react全家桶" class="headerlink" title="三：react全家桶"></a>三：react全家桶</h1><h2 id="1-redux"><a href="#1-redux" class="headerlink" title="1.redux"></a>1.redux</h2><h2 id="2-react-router"><a href="#2-react-router" class="headerlink" title="2.react-router"></a>2.react-router</h2><h2 id="3-umi"><a href="#3-umi" class="headerlink" title="3.umi"></a>3.umi</h2><h2 id="4-dva"><a href="#4-dva" class="headerlink" title="4.dva"></a>4.dva</h2><h1 id="四：react源码"><a href="#四：react源码" class="headerlink" title="四：react源码"></a>四：react源码</h1><h2 id="1-虚拟dom构建"><a href="#1-虚拟dom构建" class="headerlink" title="1.虚拟dom构建"></a>1.虚拟dom构建</h2><h2 id="2-createElement"><a href="#2-createElement" class="headerlink" title="2.createElement"></a>2.createElement</h2><h2 id="3-Component"><a href="#3-Component" class="headerlink" title="3.Component"></a>3.Component</h2><h2 id="4-rander"><a href="#4-rander" class="headerlink" title="4.rander"></a>4.rander</h2><h1 id="五：react性能优化"><a href="#五：react性能优化" class="headerlink" title="五：react性能优化"></a>五：react性能优化</h1><h1 id="六：服务端渲染SSR"><a href="#六：服务端渲染SSR" class="headerlink" title="六：服务端渲染SSR"></a>六：服务端渲染SSR</h1><h2 id="1-next-js"><a href="#1-next-js" class="headerlink" title="1.next.js"></a>1.next.js</h2>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PM2</title>
      <link href="/front-end/PM2%20+%20linux/"/>
      <url>/front-end/PM2%20+%20linux/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是pm2"><a href="#什么是pm2" class="headerlink" title="什么是pm2"></a>什么是pm2</h1><p>pm2 是一个带有负载均衡功能的Node应用的进程管理器.<br>当你要把你的独立代码利用全部的服务器上的所有CPU，并保证进程永远都活着，0秒的重载， PM2是完美的。它非常适合IaaS结构，但不要把它用于PaaS方案（随后将开发Paas的解决方案）</p><h1 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h1><p>内建负载均衡（使用Node cluster 集群模块）<br>后台运行<br>0秒停机重载，我理解大概意思是维护升级的时候不需要停机.<br>具有Ubuntu和CentOS 的启动脚本<br>停止不稳定的进程（避免无限循环）<br>控制台检测<br>提供 HTTP API<br>远程控制和实时的接口API ( Nodejs 模块,允许和PM2进程管理器交互 )<br>测试过Nodejs v0.11 v0.10 v0.8版本，兼容CoffeeScript,基于Linux 和MacOS.</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>npm install -g pm2</p><h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><p>pm2 start app.js -i 4 #后台运行pm2，启动4个app.js<br>                      # 也可以把’max’ 参数传递给 start<br>                      # 正确的进程数目依赖于Cpu的核心数目<br>pm2 start app.js –name my-api # 命名进程<br>pm2 list               # 显示所有进程状态<br>pm2 monit              # 监视所有进程<br>pm2 logs               # 显示所有进程日志<br>pm2 stop all           # 停止所有进程<br>pm2 restart all        # 重启所有进程<br>pm2 reload all         # 0秒停机重载进程 (用于 NETWORKED 进程)<br>pm2 stop 0             # 停止指定的进程<br>pm2 restart 0          # 重启指定的进程<br>pm2 startup            # 产生 init 脚本 保持进程活着<br>pm2 web                # 运行健壮的 computer API endpoint (<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo5NjE1Lw==">http://localhost:9615</span>)<br>pm2 delete 0           # 杀死指定的进程<br>pm2 delete all         # 杀死全部进程</p><h2 id="运行进程的不同方式："><a href="#运行进程的不同方式：" class="headerlink" title="运行进程的不同方式："></a>运行进程的不同方式：</h2><p>pm2 start app.js -i max  # 根据有效CPU数目启动最大进程数目<br>pm2 start app.js -i 3      # 启动3个进程<br>pm2 start app.js -x        #用fork模式启动 app.js 而不是使用 cluster<br>pm2 start app.js -x – -a 23   # 用fork模式启动 app.js 并且传递参数 (-a 23)<br>pm2 start app.js –name serverone  # 启动一个进程并把它命名为 serverone<br>pm2 stop serverone       # 停止 serverone 进程<br>pm2 start app.json        # 启动进程, 在 app.json里设置选项<br>pm2 start app.js -i max – -a 23        #在–之后给 app.js 传递参数<br>pm2 start app.js -i max -e err.log -o out.log  # 启动 并 生成一个配置文件</p><h2 id="你也可以执行用其他语言编写的app-fork-模式"><a href="#你也可以执行用其他语言编写的app-fork-模式" class="headerlink" title="你也可以执行用其他语言编写的app  ( fork 模式):"></a>你也可以执行用其他语言编写的app  ( fork 模式):</h2><p>pm2 start my-bash-script.sh    -x –interpreter bash<br>pm2 start my-python-script.py -x –interpreter python</p><p>0秒停机重载:<br>这项功能允许你重新载入代码而不用失去请求连接。<br>注意：<br>仅能用于web应用<br>运行于Node 0.11.x版本<br>运行于 cluster 模式（默认模式）<br>pm2 reload all<br>CoffeeScript:<br>pm2 start my_app.coffee  #这就是全部<br>PM2准备好为产品级服务了吗？<br>只需在你的服务器上测试<br>git clone <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1VuaXRlY2gvcG0yLmdpdA==">https://github.com/Unitech/pm2.git</span><br>cd pm2<br>npm install  # 或者 npm install –dev ，如果devDependencies 没有安装<br>npm test<br>pm2 list<br>列出由pm2管理的所有进程信息，还会显示一个进程会被启动多少次，因为没处理的异常。</p><p>pm2 monit<br>监视每个node进程的CPU和内存的使用情况。</p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> PM2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PM2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typescript基础</title>
      <link href="/front-end/Typescript/"/>
      <url>/front-end/Typescript/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> Typescript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ajax、axios、fetch区别</title>
      <link href="/front-end/ajax%E3%80%81axios%E3%80%81fetch%E5%8C%BA%E5%88%AB/"/>
      <url>/front-end/ajax%E3%80%81axios%E3%80%81fetch%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="API-和用法："><a href="#API-和用法：" class="headerlink" title="API 和用法："></a>API 和用法：</h1><p>Ajax：Ajax（Asynchronous JavaScript and XML）是一种使用原生JavaScript编写的技术，通过XMLHttpRequest对象实现异步通信。使用Ajax需要手动编写相对复杂的代码来处理请求和响应。<br>Axios：Axios是一个基于Promise的HTTP客户端库，可以在浏览器和Node.js中使用。Axios提供了简单易用的API，可以更方便地发送异步请求，并且支持拦截器、取消请求等功能。<br>Fetch：Fetch是浏览器内置的基于Promise的API，用于发送网络请求。Fetch提供了更现代化的API，使用起来更简洁，但是对一些特殊情况的处理可能相对不够灵活。</p><h1 id="兼容性："><a href="#兼容性：" class="headerlink" title="兼容性："></a>兼容性：</h1><p>Ajax：Ajax可以在大多数现代浏览器中使用，包括较旧的IE版本。<br>Axios：Axios同样支持大多数现代浏览器，但不支持较旧的IE版本（如IE8及以下）。<br>Fetch：Fetch是现代浏览器的原生API，不支持较旧的IE版本（如IE11及以下）。</p><h1 id="功能特性："><a href="#功能特性：" class="headerlink" title="功能特性："></a>功能特性：</h1><p>Ajax：由于Ajax是原生JavaScript实现的，可以更自由地进行定制和扩展，例如处理文件上传、设置请求超时等。<br>Axios：Axios提供了许多方便的功能，如拦截器、自动转换请求和响应数据、取消请求、防止CSRF攻击等。<br>Fetch：Fetch具有基本的功能，但是在某些高级功能（如请求取消、超时控制等）方面相对不够完善，需要通过额外的代码来实现。</p><h1 id="错误处理："><a href="#错误处理：" class="headerlink" title="错误处理："></a>错误处理：</h1><p>Ajax：通过手动编写错误处理代码来处理请求过程中可能出现的错误。<br>Axios：Axios提供了统一的错误处理机制，可以通过拦截器全局处理请求和响应的错误。<br>Fetch：Fetch使用Promise进行错误处理，可以通过catch语句捕获和处理错误。</p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> 网络请求 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络请求 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>babel</title>
      <link href="/front-end/babel/"/>
      <url>/front-end/babel/</url>
      
        <content type="html"><![CDATA[<h1 id="babel是什么"><a href="#babel是什么" class="headerlink" title="babel是什么"></a>babel是什么</h1><p>Babel 是一个流行的 JavaScript 编译工具，用于将新版本的 JavaScript 代码转换为向后兼容的旧版本 JavaScript 代码。</p><ol><li>插件（Plugins）和预设（Presets）：Babel 的核心功能是将新版本 JavaScript 转换成旧版本 JavaScript，这是通过使用插件和预设来实现的。插件是独立的功能模块，每个插件针对一种或多种特定的语法转换或转译任务。预设是插件的集合，提供了一组常用的插件配置，以便快速设置转译环境。</li></ol><p>例如，Babel 提供了一个 @babel&#x2F;preset-env 预设，该预设根据您指定的目标环境自动选择适当的插件，并根据需要进行转译。您可以根据项目的需要自定义配置并选择要使用的插件和预设。</p><ol start="2"><li>配置文件（.babelrc 或 babel.config.js）：Babel 使用配置文件来存储插件、预设和其他选项的配置信息。您可以在项目根目录下创建一个名为 .babelrc 的文件（JSON 格式），或者使用 babel.config.js 文件（JavaScript 模块格式）。配置文件中的内容包括指定要使用的插件和预设，以及其它选项，比如源码映射（source maps）和编译缓存等。</li></ol><p>通过配置文件，您可以灵活地配置 Babel 的转译规则，并可以为不同的项目和环境创建不同的配置文件。</p><ol start="3"><li>语法转换（Syntax Transformations）：Babel 提供了广泛的语法转换功能，使您能够使用最新的 JavaScript 语法并将其转换为向后兼容的旧版本 JavaScript 语法。这包括 ES6&#x2F;ES2015、ES7&#x2F;ES2016、ES8&#x2F;ES2017 等新标准的语法元素，例如箭头函数、解构赋值、模板字符串等。</li></ol><p>使用相应的插件，Babel 可以将这些新的语法转换为在较旧的 JavaScript 运行时上运行的代码。</p><ol start="4"><li>Polyfill：除了语法转换外，Babel 还提供了对一些新标准内置功能的支持，如 Promise、Generator、Set、Map 等。这些新功能在旧版本的 JavaScript 运行时中不可用，需要使用 Polyfill 来填充功能的缺失。</li></ol><p>Babel 的 @babel&#x2F;preset-env 预设可以根据您的配置目标自动添加必要的 Polyfill，以便代码在目标环境中正常运行。</p><ol start="5"><li>调试和开发工具：Babel 提供了一些辅助工具，帮助您进行调试和开发。其中之一是 Babel REPL（Read-Eval-Print Loop），它是一个在线工具，允许您输入和运行 ES6+ 代码，并查看转译之后的代码。</li></ol><p>另一个常用的工具是 Babel CLI（Command Line Interface），它允许您在命令行中使用 Babel，可以通过命令行快速进行转译和转换。</p><ol start="6"><li>结合构建工具：Babel 可以与许多构建工具进行集成，如 webpack、Rollup、Gulp 等。这些构建工具提供了对 Babel 的插件或加载器，使得在构建过程中自动运行 Babel 转译变得更加方便。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> babel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> babel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>electron</title>
      <link href="/front-end/electron/"/>
      <url>/front-end/electron/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是Electron？"><a href="#什么是Electron？" class="headerlink" title="什么是Electron？"></a>什么是Electron？</h1><p>最最重要的⼀点， electron 实际上是⼀个套了 Chrome 的 nodeJS 程序</p><p>所以应该是从两个⽅⾯说开来<br>Chrome （⽆各种兼容性问题）<br>NodeJS （ NodeJS 能做的它也能做）</p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> electron </category>
          
      </categories>
      
      
        <tags>
            
            <tag> electron </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gulp</title>
      <link href="/front-end/gulp/"/>
      <url>/front-end/gulp/</url>
      
        <content type="html"><![CDATA[<h1 id="gulp是什么"><a href="#gulp是什么" class="headerlink" title="gulp是什么"></a>gulp是什么</h1><ol><li><p>gulp 是前端开发过程中⼀种基于流的代码构建⼯具，是⾃动化项⽬的构建利器；它不仅能对⽹站资源进⾏优化，⽽且在开发过程中很多重复的任务能够使⽤正确的⼯具⾃动完成</p></li><li><p>Gulp的核⼼概念：流</p></li><li><p>流，简单来说就是建⽴在⾯向对象基础上的⼀种抽象的处理数据的⼯具。在流中，定义了⼀些处理数据的基本操作，如读取数据，写⼊数据等，程序员是对流进⾏所有操作的，⽽不⽤关⼼流的另⼀头数据的真正流向</p></li><li><p>gulp正是通过流和代码优于配置的策略来尽量简化任务编写的⼯作</p></li><li><p>Gulp的特点：</p></li></ol><ul><li>易于使⽤：通过代码优于配置的策略，gulp 让简单的任务简单，复杂的任务可管理</li><li>构建快速 利⽤ Node.js 流的威⼒，你可以快速构建项⽬并减少频繁的 IO 操作</li><li>易于学习 通过最少的 API ，掌握 gulp 毫不费⼒，构建⼯作尽在掌握：如同⼀系列流管道</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> gulp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gulp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css面试</title>
      <link href="/front-end/html+css%E9%9D%A2%E8%AF%95/"/>
      <url>/front-end/html+css%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h1><pre><code class="text">BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于普通流，即：元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。只要元素满足下面任一条件即可触发 BFC 特性body 根元素浮动元素：float 除 none 以外的值绝对定位元素：position (absolute、fixed)display 为 inline-block、table-cells、flexoverflow 除了 visible 以外的值 (hidden、auto、scroll)</code></pre><h1 id="多种方式实现同心圆"><a href="#多种方式实现同心圆" class="headerlink" title="多种方式实现同心圆"></a>多种方式实现同心圆</h1><pre><code class="text">1.  2个view 相对定位 + 绝对定位2.  2个view  flex布局3.  1个view  使用伪元素</code></pre><h1 id="介绍一下-CSS-的盒子模型？"><a href="#介绍一下-CSS-的盒子模型？" class="headerlink" title="介绍一下 CSS 的盒子模型？"></a>介绍一下 CSS 的盒子模型？</h1><pre><code class="text">有两种， IE 盒子模型、W3C 盒子模型；盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；区 别： IE 的 content 部分把 border 和 padding 计算了进去;</code></pre><h1 id="css-选择器优先级？"><a href="#css-选择器优先级？" class="headerlink" title="css 选择器优先级？"></a>css 选择器优先级？</h1><pre><code class="text">!important &gt; 行内样式（比重1000）&gt; ID 选择器（比重100） &gt; 类选择器（比重10） &gt; 标签（比重1） &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性</code></pre><h1 id="垂直居中几种方式？"><a href="#垂直居中几种方式？" class="headerlink" title="垂直居中几种方式？"></a>垂直居中几种方式？</h1><pre><code class="text">1.单行文本: line-height = height2.图片: vertical-align: middle;3.absolute 定位: top: 50%;left: 50%;transform: translate(-50%, -50%);4.flex:display:flex;justify-content: center;  align-items: center</code></pre><h1 id="简明说一下-CSS-link-与-import-的区别和用法？"><a href="#简明说一下-CSS-link-与-import-的区别和用法？" class="headerlink" title="简明说一下 CSS link 与 @import 的区别和用法？"></a>简明说一下 CSS link 与 @import 的区别和用法？</h1><pre><code class="text">link 是 XHTML 标签，除了加载CSS外，还可以定义 RSS 等其他事务；@import 属于 CSS 范畴，只能加载 CSS。link 引用 CSS 时，在页面载入时同时加载；@import 需要页面网页完全载入以后加载。link 是 XHTML 标签，无兼容问题；@import 是在 CSS2.1 提出的，低版本的浏览器不支持。link 支持使用 Javascript 控制 DOM 去改变样式；而@import不支持。</code></pre><h1 id="rgba和opacity的透明效果有什么不同？"><a href="#rgba和opacity的透明效果有什么不同？" class="headerlink" title="rgba和opacity的透明效果有什么不同？"></a>rgba和opacity的透明效果有什么不同？</h1><pre><code class="text">opacity 会继承父元素的 opacity 属性，而 RGBA 设置的元素的后代元素不会继承不透明属性。</code></pre><h1 id="display-none和visibility-hidden的区别？"><a href="#display-none和visibility-hidden的区别？" class="headerlink" title="display:none和visibility:hidden的区别？"></a>display:none和visibility:hidden的区别？</h1><pre><code class="text">display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。</code></pre><h1 id="position的值，-relative和absolute分别是相对于谁进行定位的？"><a href="#position的值，-relative和absolute分别是相对于谁进行定位的？" class="headerlink" title="position的值， relative和absolute分别是相对于谁进行定位的？"></a>position的值， relative和absolute分别是相对于谁进行定位的？</h1><pre><code class="text">relative:相对定位，相对于自己本身在正常文档流中的位置进行定位。absolute:生成绝对定位，相对于最近一级定位不为static的父元素进行定位。fixed: （老版本IE不支持）生成绝对定位，相对于浏览器窗口或者frame进行定位。static:默认值，没有定位，元素出现在正常的文档流中。sticky:生成粘性定位的元素，容器的位置根据正常文档流计算得出。</code></pre><h1 id="画一条0-5px的直线？"><a href="#画一条0-5px的直线？" class="headerlink" title="画一条0.5px的直线？"></a>画一条0.5px的直线？</h1><pre><code class="text">考查的是css3的transformheight: 1px;transform: scale(0.5);</code></pre><h1 id="calc-support-media各自的含义及用法？"><a href="#calc-support-media各自的含义及用法？" class="headerlink" title="calc, support, media各自的含义及用法？"></a>calc, support, media各自的含义及用法？</h1><pre><code class="text">@support 主要是用于检测浏览器是否支持CSS的某个属性，其实就是条件判断，如果支持某个属性，你可以写一套样式，如果不支持某个属性，你也可以提供另外一套样式作为替补。calc() 函数用于动态计算长度值。 calc()函数支持 “+”, “-”, “*”, “/” 运算；@media 查询，你可以针对不同的媒体类型定义不同的样式。</code></pre><h1 id="1rem、1em、1vh、1px各自代表的含义？"><a href="#1rem、1em、1vh、1px各自代表的含义？" class="headerlink" title="1rem、1em、1vh、1px各自代表的含义？"></a>1rem、1em、1vh、1px各自代表的含义？</h1><pre><code class="text">1.remrem是全部的长度都相对于根元素元素。通常做法是给html元素设置一个字体大小，然后其他元素的长度单位就为rem。    2. em子元素字体大小的em是相对于父元素字体大小元素的width/height/padding/margin用em的话是相对于该元素的font-sizevw/vh全称是 Viewport Width 和 Viewport Height，视窗的宽度和高度，相当于 屏幕宽度和高度的 1%，不过，处理宽度的时候%单位更合适，处理高度的 话 vh 单位更好。    3. pxpx像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的。一般电脑的分辨率有&#123;19201024&#125;等不同的分辨率19201024 前者是屏幕宽度总共有1920个像素,后者则是高度为1024个像素</code></pre><h1 id="css画一个三角形？"><a href="#css画一个三角形？" class="headerlink" title="css画一个三角形？"></a>css画一个三角形？</h1><pre><code class="css">.a &#123;    width: 0;    height: 0;    border-width: 100px;    border-style: solid;    border-color: transparent #0099CC transparent transparent;    transform: rotate(90deg); /*顺时针旋转90°*/&#125;&lt;div class=&quot;a&quot;&gt;&lt;/div&gt;</code></pre><h1 id="HTML5里面都新增了那些新特性？"><a href="#HTML5里面都新增了那些新特性？" class="headerlink" title="HTML5里面都新增了那些新特性？"></a>HTML5里面都新增了那些新特性？</h1><pre><code class="text">1. HTML5新的语义标签article 独立的内容。aside 侧边栏。header 头部。nav 导航。section 文档中的节。footer 页脚。2. 画布(Canvas) API3. 地理(Geolocation) API4. 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；5. sessionStorage 的数据在浏览器关闭后自动删除6. 新的技术webworker, websocket, Geolocation7. 拖拽释放(Drag and drop) API8. 音频、视频API(audio,video)9. 表单控件，calendar、date、time、email、url、searc</code></pre><h1 id="CSS3-里面都新增了那些新特性？"><a href="#CSS3-里面都新增了那些新特性？" class="headerlink" title="CSS3 里面都新增了那些新特性？"></a>CSS3 里面都新增了那些新特性？</h1><pre><code class="text">1. 发展历史：CSS于1996年发布，而CSS3是CSS的第三个主要版本，于2001年开始提出，但其功能逐渐得到实现并得以广泛支持直到近年来。2. 模块化：CSS3采用了模块化的方式来组织样式属性。每个模块专注于特定的功能，例如布局、动画、字体等。这使得开发人员可以根据需要选择特定的模块进行应用，而不需要引入整个CSS3规范。3. 新增功能：CSS3引入了许多新特性和功能，如圆角边框、阴影、渐变、过渡、动画、媒体查询、弹性盒子布局、网格布局等。这些功能扩展了网页设计师的能力，使其能够创建更丰富、更交互性的用户界面。4. 浏览器兼容性：传统的CSS规范在不同浏览器上的兼容性并不一致，需要使用特定的浏览器前缀进行适配。然而，CSS3的很多功能已经得到了主流浏览器的广泛支持，因此在一定程度上减少了兼容性的问题。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uniapp框架原理</title>
      <link href="/front-end/uniapp%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86/"/>
      <url>/front-end/uniapp%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<pre><code class="text">UniApp 是一种基于 Vue.js 的跨平台应用开发框架，它可以使用统一的代码编写方式，同时在多个平台上进行应用程序的开发，包括iOS、Android、Web等。下面是 UniApp 的基本原理：1. 基于 Vue.js：UniApp 使用了 Vue.js 作为其基础框架，所以开发者可以利用 Vue.js 的语法和特性进行开发。2. 编译打包：开发者编写的 UniApp 代码会经过编译打包的过程，将代码转换为不同平台的运行代码。UniApp 提供了自动化的编译打包工具，根据配置信息和目标平台生成相应的应用程序代码。3. 平台适配层：在编译打包过程中，UniApp 会根据目标平台生成相应的平台适配层。这些适配层负责处理不同平台的差异，将统一的代码转化为特定平台的代码。4. 原生渲染引擎：对于 iOS 和 Android 平台，UniApp 会使用各自的原生渲染引擎来展示界面。例如，在 iOS 平台上使用的是 WebView + JavaScriptCore，而在 Android 平台上使用的是 WebView + V8。5. Web 平台渲染：对于 Web 平台，UniApp 会使用浏览器的渲染引擎来展示界面，将 Vue.js 编译后的代码直接在浏览器中运行。6. API 封装：UniApp 提供了一套统一的 API，包括网络请求、文件操作、设备信息等功能。这些 API 会根据不同平台进行封装和适配，使得开发者可以使用相同的代码调用不同平台的功能。总体来说，UniApp 的原理就是通过 Vue.js 作为基础框架，结合编译打包工具和平台适配层，将统一的代码转化为不同平台上的运行代码，并在不同平台上使用相应的渲染引擎展示界面，最终实现跨平台应用的开发和运行。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> Uniapp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> uniapp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nodejs基础</title>
      <link href="/front-end/nodejs/"/>
      <url>/front-end/nodejs/</url>
      
        <content type="html"><![CDATA[<h1 id="nodejs特点："><a href="#nodejs特点：" class="headerlink" title="nodejs特点："></a>nodejs特点：</h1><p>1、它是⼀个 Javascript 运⾏环境<br>2、依赖于 Chrome V8 引擎进⾏代码解释<br>3、事件驱动<br>4、⾮阻塞 I&#x2F;O<br>5、单进程，单线程</p><h1 id="nodejs优点："><a href="#nodejs优点：" class="headerlink" title="nodejs优点："></a>nodejs优点：</h1><p>⾼并发（最重要的优点）</p><h1 id="nodejs缺点："><a href="#nodejs缺点：" class="headerlink" title="nodejs缺点："></a>nodejs缺点：</h1><p>1、只⽀持单核 CPU ，不能充分利⽤ CPU<br>2、可靠性低，⼀旦代码某个环节崩溃，整个系统都崩溃</p><h2 id="性能瓶颈优化"><a href="#性能瓶颈优化" class="headerlink" title="性能瓶颈优化"></a>性能瓶颈优化</h2><ol><li>代码优化：对 Node.js 代码进行性能分析和优化，找出潜在的性能瓶颈并加以改进。可以采用以下策略：</li></ol><ul><li>使用异步操作：Node.js 的异步非阻塞模型是其高性能的基础。确保尽可能使用异步操作，减少阻塞和等待时间。</li><li>避免同步调用：避免过多的同步调用，因为它们会导致阻塞，并阻止其他请求的处理。</li><li>减少文件操作：文件操作通常比较耗时。尽量减少文件的读写次数，可以考虑使用缓存或者内存数据库来提高性能。</li><li>注意内存管理：不正确的内存管理可能导致内存泄漏和频繁的垃圾回收。注意及时释放不再使用的资源，避免内存问题。</li></ul><ol start="2"><li>并发处理：Node.js 对并发具有天然的优势，可以通过以下方式提高并发处理性能：</li></ol><ul><li>使用集群和负载均衡：通过使用多个 Node.js 实例构建集群，并使用负载均衡器将请求分发到不同的实例上，可以提高系统的并发处理能力。</li><li>使用线程池：Node.js 中的部分任务可以使用线程池进行处理，以释放事件循环线程，提高并发性能。</li></ul><ol start="3"><li><p>缓存数据：对于一些计算结果或者频繁读取的数据，可以采用缓存策略，将结果缓存起来，下次需要时直接从缓存中获取，避免重复计算或者频繁的数据库操作。</p></li><li><p>使用适当的第三方库：选择适当的第三方库和模块，可以优化代码的性能。例如，选择高性能的数据库驱动程序、HTTP 请求库等。</p></li><li><p>使用流式处理：对于大量数据的处理，使用流式处理方式可以减少内存消耗和提高处理效率。</p></li><li><p>监控和调优：对 Node.js 应用程序进行持续监控和性能调优，使用工具分析应用程序的运行情况，找出性能瓶颈，及时进行优化。</p></li><li><p>资源优化：合理配置服务器资源，包括 CPU、内存、网络等，以满足应用程序的需求。</p></li></ol><h1 id="一：nodejs-基础"><a href="#一：nodejs-基础" class="headerlink" title="一：nodejs 基础"></a>一：nodejs 基础</h1><h2 id="1-异步"><a href="#1-异步" class="headerlink" title="1.异步"></a>1.异步</h2><h2 id="2-io"><a href="#2-io" class="headerlink" title="2.io"></a>2.io</h2><h2 id="3-fs"><a href="#3-fs" class="headerlink" title="3.fs"></a>3.fs</h2><h1 id="二：nodeweb开发"><a href="#二：nodeweb开发" class="headerlink" title="二：nodeweb开发"></a>二：nodeweb开发</h1><h2 id="1-koa2"><a href="#1-koa2" class="headerlink" title="1.koa2"></a>1.koa2</h2><h2 id="2-router"><a href="#2-router" class="headerlink" title="2.router"></a>2.router</h2><h2 id="3-eggjs"><a href="#3-eggjs" class="headerlink" title="3.eggjs"></a>3.eggjs</h2><h1 id="三：鉴权"><a href="#三：鉴权" class="headerlink" title="三：鉴权"></a>三：鉴权</h1><h2 id="1-cookie"><a href="#1-cookie" class="headerlink" title="1.cookie"></a>1.cookie</h2><h2 id="2-jwt"><a href="#2-jwt" class="headerlink" title="2.jwt"></a>2.jwt</h2><h2 id="3-oauth"><a href="#3-oauth" class="headerlink" title="3.oauth"></a>3.oauth</h2><h1 id="四：数据库"><a href="#四：数据库" class="headerlink" title="四：数据库"></a>四：数据库</h1><h2 id="1-mysql"><a href="#1-mysql" class="headerlink" title="1.mysql"></a>1.mysql</h2><h2 id="2-redis"><a href="#2-redis" class="headerlink" title="2.redis"></a>2.redis</h2><h2 id="3-mongodb"><a href="#3-mongodb" class="headerlink" title="3.mongodb"></a>3.mongodb</h2><h1 id="五：中间件"><a href="#五：中间件" class="headerlink" title="五：中间件"></a>五：中间件</h1><h1 id="六：部署发布"><a href="#六：部署发布" class="headerlink" title="六：部署发布"></a>六：部署发布</h1><h2 id="1-PM2"><a href="#1-PM2" class="headerlink" title="1.PM2"></a>1.PM2</h2><h2 id="2-nginx"><a href="#2-nginx" class="headerlink" title="2.nginx"></a>2.nginx</h2><h2 id="3-docker"><a href="#3-docker" class="headerlink" title="3.docker"></a>3.docker</h2>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> Nodejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nodejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uniapp编译到小程序</title>
      <link href="/front-end/uniapp%E7%BC%96%E8%AF%91%E5%88%B0%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
      <url>/front-end/uniapp%E7%BC%96%E8%AF%91%E5%88%B0%E5%B0%8F%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<pre><code class="text">UniApp 支持将应用代码编译成小程序，包括微信小程序、支付宝小程序、百度小程序等。下面是 UniApp 编译到小程序的基本原理：1. 配置文件：在 UniApp 项目中，需要提供一个特定的配置文件 manifest.json，用于描述小程序的基本信息和配置。配置文件包括小程序的名称、图标、页面路径等。2. 编译过程：在使用 UniApp 提供的编译工具时，UniApp 会根据项目中的配置文件以及特定的编译规则，将项目代码转化为小程序可识别的代码。编译过程中，UniApp 将 Vue.js 的模板语法转换为小程序的 WXML，将样式转换为 WXSS，将逻辑代码转换为小程序的 JavaScript 代码。3. 平台适配层：与其他平台类似，UniApp 在编译过程中也会生成对应小程序平台的适配层代码，处理小程序平台的特定差异。4. 小程序框架：UniApp 编译后的代码会使用相应小程序框架进行运行。比如，在编译为微信小程序时，会调用微信小程序的框架进行渲染和交互，而编译为支付宝小程序时，则会调用支付宝小程序的框架。5. API 适配：UniApp 会对小程序平台的 API 进行封装适配，使得开发者可以使用相同的代码调用不同小程序平台的功能。UniApp 提供了一套统一的 API，封装了诸如网络请求、文件操作、设备信息等功能。总结来说，UniApp 编译到小程序的过程包括通过编译工具将项目代码转化为小程序可识别的代码，并生成小程序平台的适配层和调用相应的小程序框架进行渲染和交互。UniApp 还提供了一套统一的 API，使得开发者可以在不同小程序平台上使用相同的代码调用相应的功能。这样，开发者可以使用 UniApp 来开发一次代码，即可在多个小程序平台上进行发布和运行。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> Uniapp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> uniapp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack</title>
      <link href="/front-end/webpack/"/>
      <url>/front-end/webpack/</url>
      
        <content type="html"><![CDATA[<h1 id="对Webpack的理解"><a href="#对Webpack的理解" class="headerlink" title="对Webpack的理解"></a>对Webpack的理解</h1><p>Webpack 的主要作用是进行模块打包、编译兼容和能力扩展。通过分析模块的依赖关系，Webpack 可以将各个模块打包成一个或多个 bundle。它使用一条生产线的方式，通过一系列处理流程（loader）将源文件转换成输出结果，每个处理流程都有单一的职责，并存在依赖关系。插件则可以在特定的时机对生产线上的资源进行处理，监听事件来改变整个生产线的运作。Webpack 可以实现模块化打包、编译兼容以及提供各种能力扩展，例如按需加载、代码压缩等功能，从而提高开发效率、自动化程度和打包输出质量。</p><h1 id="webpack和vite的区别"><a href="#webpack和vite的区别" class="headerlink" title="webpack和vite的区别"></a>webpack和vite的区别</h1><p>工具本身定位不同<br>webpack是底层的东西，vite则是更上层的工具。webpack是配置化，灵活度极高的工具，vite是开箱即用，使用更简单的工具<br>原理不同<br>webpack是bundle，自己实现了一套模块导入导出机制。vite是利用浏览器的esm能力，是bundless。<br>优缺点<br>vite开箱即用，更加简单，基于浏览器esm，使得hmr更加优秀，达到极速的效果；webpack更加灵活，api以及插件生态更加丰富。<br>webpack先打包，再启动服务器，请求服务器时直接给予打包后的结果；vite直接启动服务器，请求哪个模块再对哪个模块进行实时编译。</p><h1 id="Webpack的打包过程-x2F-打包原理-x2F-构建流程"><a href="#Webpack的打包过程-x2F-打包原理-x2F-构建流程" class="headerlink" title="Webpack的打包过程&#x2F;打包原理&#x2F;构建流程"></a>Webpack的打包过程&#x2F;打包原理&#x2F;构建流程</h1><pre><code class="text">初始化：启动构建，读取与合并配置参数，加载plugin,实例化Compiler编译：从Entry出发，针对每个Module串行调用对应的Loader去翻译文件中的内容，再找到该Module依赖的Module，递归的进行编译处理输出：将编译后的Module组合成Chunk,将Chunk转换成文件，输出到文件系统中细节：Webpack CLI 通过 yargs模块解析 CLI 参数，并转化为配置对象option（单入口：Object，多入口：Array），调用 webpack(option) 创建 compiler 对象。如果有 option.plugin，则遍历调用plugin.apply()来注册 plugin，判断是否开启了 watch，如果开启则调用 compiler.watch，否则调用 compiler.run，开始构建。创建 Compilation 对象来收集全部资源和信息，然后触发 make 钩子。make阶段从入口开始递归所有依赖，每次遍历时调用对应Loader翻译文件中内容，然后生成AST，遍历AST找到下个依赖继续递归，根据入口和模块之间关系组装chunk，输出到dist中的一个文件内。在以上过程中，webpack会在特定的时间点（使用tapable模块）广播特定的事件，插件监听事件并执行相应的逻辑，并且插件可以调用webpack提供的api改变webpack的运行结果</code></pre><h1 id="loader的作用"><a href="#loader的作用" class="headerlink" title="loader的作用"></a>loader的作用</h1><pre><code class="text">webpack中的loader是一个函数，主要为了实现源码的转换，所以loader函数会以源码作为参数，比如，将ES6转换为ES5，将less转换为css，然后再将css转换为js，以便能嵌入到html文件中。默认情况下，webpack只支持对js和json文件进行打包，但是像css、html、png等其他类型的文件，webpack则无能为力。因此，就需要配置相应的loader进行文件内容的解析转换。</code></pre><h1 id="有哪些常见的Loader？他们是解决什么问题的？"><a href="#有哪些常见的Loader？他们是解决什么问题的？" class="headerlink" title="有哪些常见的Loader？他们是解决什么问题的？"></a>有哪些常见的Loader？他们是解决什么问题的？</h1><p>image-loader：加载并且压缩图片文件。<br>less-loader：加载并编译 LESS 文件。<br>sass-loader：加载并编译 SASS&#x2F;SCSS 文件。<br>css-loader：加载 CSS，支持模块化、压缩、文件导入等特性，使用css-loader必须要配合使用style-loader。<br>style-loader：用于将 CSS 编译完成的样式，挂载到页面的 style 标签上。需要注意 loader 执行顺序，style-loader 要放在第一位，loader 都是从后往前执行。<br>babel-loader：把 ES6 转换成 ES5<br>postcss-loader：扩展 CSS 语法，使用下一代 CSS，可以配合 autoprefixer 插件自动补齐 CSS3 前缀。<br>eslint-loader：通过 ESLint 检查 JavaScript 代码。<br>vue-loader：加载并编译 Vue 组件。<br>file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件 (处理图片和字体)<br>url-loader：与 file-loader 类似，区别是用户可以设置一个阈值，大于阈值会交给 file-loader 处理，小于阈值时返回文件 base64 形式编码 (处理图片和字体)。<br>source-map-loader：加载额外的 Source Map 文件，以方便断点调试。</p><h1 id="plugin的作用"><a href="#plugin的作用" class="headerlink" title="plugin的作用"></a>plugin的作用</h1><pre><code class="text">plugin是一个类，类中有一个apply()方法，主要用于Plugin的安装，可以在其中监听一些来自编译器发出的事件，在合适的时机做一些事情。webpack中的plugin赋予其各种灵活的功能，例如打包优化、资源管理、环境变量注入等，它们会运行在webpack的不同阶段（钩子 / 生命周期），贯穿了webpack整个编译周期。目的在于「解决 loader 无法实现的其他事」。</code></pre><h1 id="有哪些常见的Plugin？他们是解决什么问题的？"><a href="#有哪些常见的Plugin？他们是解决什么问题的？" class="headerlink" title="有哪些常见的Plugin？他们是解决什么问题的？"></a>有哪些常见的Plugin？他们是解决什么问题的？</h1><pre><code class="text">html-webpack-plugin：可以复制一个有结构的html文件，并自动引入打包输出的所有资源（JS/CSS）clean-webpack-plugin：重新打包自动清空 dist 目录mini-css-extract-plugin：提取 js 中的 css 成单独文件optimize-css-assets-webpack-plugin：压缩cssuglifyjs-webpack-plugin：压缩jscommons-chunk-plugin：提取公共代码define-plugin：定义环境变量</code></pre><h1 id="Webpack中Loader和Plugin的区别"><a href="#Webpack中Loader和Plugin的区别" class="headerlink" title="Webpack中Loader和Plugin的区别"></a>Webpack中Loader和Plugin的区别</h1><pre><code class="text">运行时机1.loader运行在编译阶段2.plugins 在整个周期都起作用使用方式Loader:1.下载 2.使用Plugin:1.下载 2.引用 3.使用loader是文件加载器，能够加载资源文件，并对这些文件进行一些处理，诸如编译、压缩等，最终一起打包到指定的文件中；plugin赋予了webpack各种灵活的功能，例如打包优化、资源管理、环境变量注入等，目的是解决 loader无法实现的其他事。在运行时机上，loader 运行在打包文件之前；plugin则是在整个编译周期都起作用。在配置上，loader在module.rules中配置，作为模块的解析规则，类型为数组。每一项都是一个 Object，内部包含了 test(类型文件)、loader、options (参数)等属性；plugin在 plugins中单独配置，类型为数组，每一项是一个 plugin 的实例，参数都通过构造函数传入。</code></pre><h1 id="如何解决循环依赖问题"><a href="#如何解决循环依赖问题" class="headerlink" title="如何解决循环依赖问题"></a>如何解决循环依赖问题</h1><p>Webpack 中将 require 替换为 webpack_require，会根据 moduleId 到 installedModules 找是否加载过，加载过则直接返回之前的 export，不会重复加载。</p><h1 id="plugin-生命周期"><a href="#plugin-生命周期" class="headerlink" title="plugin 生命周期"></a>plugin 生命周期</h1><p>在 Webpack 中，插件的生命周期可以分为以下几个阶段：</p><p>apply：该阶段是插件被安装时的初始化阶段，通常用于获取 Webpack 的 Compiler 对象以及进行一些初始化配置。<br>environment：该阶段是在初始化阶段后，确定了 Webpack 的环境变量后执行的，通常用于读取和修改环境相关的配置。<br>afterEnvironment：该阶段在 environment 阶段之后执行，用于处理和修改环境相关配置的最后机会。<br>afterResolvers：该阶段在解析器完成设置之后执行，可以对解析器进行修改和扩展。<br>entryOption：该阶段用于检索和修改入口文件列表。<br>afterPlugins：该阶段在插件注册完成后执行，通常用于处理和修改插件相关的配置。<br>afterCompile：该阶段在编译完成之后执行，可以访问编译生成的模块和依赖信息。<br>emit：该阶段在输出阶段之前执行，用于对最终的资源文件进行处理和优化。<br>done：该阶段在打包完成后执行，可以执行一些额外的任务。<br>要编写一个自定义插件（Plugin），可以按照以下步骤进行：</p><p>创建一个 JavaScript 文件，并导出一个类或一个函数作为插件的实现。插件类或函数需要具备 apply 方法。<br>在 apply 方法中，通过接收一个 compiler 参数来获取 Webpack 的 Compiler 对象，并通过调用 Compiler 提供的钩子函数来挂载插件的任务。<br>在合适的生命周期钩子函数中，编写需要执行的任务逻辑，可以是文件处理、资源优化、代码注入等操作。<br>在插件的配置中使用 new 关键字创建插件的实例，然后将它添加到 Webpack 的配置文件中的 plugins 数组中。</p><h1 id="webpack的热更新原理"><a href="#webpack的热更新原理" class="headerlink" title="webpack的热更新原理"></a>webpack的热更新原理</h1><pre><code class="text">热更新的核心就是客户端从服务端拉去更新后的文件，准确的说是 chunk diff (chunk 需要更新的部分)，实际上webpack-dev-server与浏览器之间维护了一个websocket，当本地资源发生变化时，webpack-dev-server会向浏览器推送更新，并带上构建时的hash，让客户端与上一次资源进行对比。客户端对比出差异后会向webpack-dev-server发起 Ajax 请求来获取更改内容(文件列表、hash)，这样客户端就可以再借助这些信息继续向webpack-dev-server发起 jsonp 请求获取该chunk的增量更新。后续的部分(拿到增量更新之后如何处理？哪些状态该保留？哪些又需要更新？)由HotModulePlugin 来完成，提供了相关 API 以供开发者针对自身场景进行处理，像react-hot-loader和vue-loader都是借助这些 API 实现热更新。详细：1、在 webpack 的 watch 模式下，文件系统中某一个文件发生修改，webpack 监听到文件变化，根据配置文件对模块重新编译打包，并将打包后的代码通过简单的 JavaScript 对象保存在内存中。2、webpack-dev-server 和 webpack 之间的接口交互，而在这一步，主要是 dev-server 的中间件webpack-dev-middleware 和 webpack 之间的交互，webpack-dev-middleware 调用 webpack 暴露的 API对代码变化进行监控，并且告诉 webpack，将代码打包到内存中。3、webpack-dev-server 对文件变化的一个监控，这一步不同于第一步，并不是监控代码变化重新打包。当我们在配置文件中配置了devServer.watchContentBase 为 true 的时候，Server 会监听这些配置文件夹中静态文件的变化，变化后会通知浏览器端对应用进行 live reload。注意，这儿是浏览器刷新，和 HMR 是两个概念4、webpack-dev-server 代码的工作，该步骤主要是通过 sockjs（webpack-dev-server 的依赖）在浏览器端和服务端之间建立一个 websocket 长连接，将 webpack 编译打包的各个阶段的状态信息告知浏览器端，同时也包括第三步中 Server 监听静态文件变化的信息。浏览器端根据这些 socket 消息进行不同的操作。当然服务端传递的最主要信息还是新模块的 hash 值，后面的步骤根据这一 hash 值来进行模块热替换。webpack-dev-server/client 端并不能够请求更新的代码，也不会执行热更模块操作，而把这些工作又交回给了 webpack，webpack/hot/dev-server 的工作就是根据 webpack-dev-server/client 传给它的信息以及 dev-server 的配置决定是刷新浏览器呢还是进行模块热更新。当然如果仅仅是刷新浏览器，也就没有后面那些步骤了。HotModuleReplacement.runtime 是客户端 HMR 的中枢，它接收到上一步传递给他的新模块的 hash 值，它通过 JsonpMainTemplate.runtime 向 server 端发送 Ajax 请求，服务端返回一个 json，该 json 包含了所有要更新的模块的 hash 值，获取到更新列表后，该模块再次通过 jsonp 请求，获取到最新的模块代码。5、决定 HMR 成功与否的关键步骤，在该步骤中，HotModulePlugin 将会对新旧模块进行对比，决定是否更新模块，在决定更新模块后，检查模块之间的依赖关系，更新模块的同时更新模块间的依赖引用。最后一步，当 HMR 失败后，回退到 live reload 操作，也就是进行浏览器刷新来获取最新打包代码。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> 前端工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序</title>
      <link href="/front-end/%E5%BE%AE%E4%BF%A1%E2%BC%A9%E7%A8%8B%E5%BA%8F/"/>
      <url>/front-end/%E5%BE%AE%E4%BF%A1%E2%BC%A9%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="微信⼩程序有⼏个⽂件"><a href="#微信⼩程序有⼏个⽂件" class="headerlink" title="微信⼩程序有⼏个⽂件"></a>微信⼩程序有⼏个⽂件</h1><ol><li>WXSS (WeiXin Style Sheets) 是⼀套样式语⾔，⽤于描述 WXML 的组件样式， js逻辑处理，⽹络请求 json ⼩程序设置，如⻚⾯注册，⻚⾯标题及 tabBar 。</li><li>app.json 必须要有这个⽂件，如果没有这个⽂件，项⽬⽆法运⾏，因为微信框架把这个作为配置⽂件⼊⼝，整个⼩程序的全局配置。包括⻚⾯注册，⽹络设置，以及⼩程序的window 背景⾊，配置导航条样式，配置默认标题。</li><li>app.js 必须要有这个⽂件，没有也是会报错！但是这个⽂件创建⼀下就⾏ 什么都不需要写以后我们可以在这个⽂件中监听并处理⼩程序的⽣命周期函数、声明全局变量。</li><li>app.wxss 配置全局 css</li></ol><h1 id="微信⼩程序怎样跟事件传值"><a href="#微信⼩程序怎样跟事件传值" class="headerlink" title="微信⼩程序怎样跟事件传值"></a>微信⼩程序怎样跟事件传值</h1><p>给 HTML 元素添加 data-* 属性来传递我们需要的值，然后通过e.currentTarget.dataset 或 onload 的 param 参数获取。但 data -名称不能有⼤写字⺟和不可以存放对象</p><h1 id="⼩程序的-wxss-和-css-有哪些不⼀样的地⽅？"><a href="#⼩程序的-wxss-和-css-有哪些不⼀样的地⽅？" class="headerlink" title="⼩程序的 wxss 和 css 有哪些不⼀样的地⽅？"></a>⼩程序的 wxss 和 css 有哪些不⼀样的地⽅？</h1><ol><li>wxss 的图⽚引⼊需使⽤外链地址</li><li>没有 Body ；样式可直接使⽤ import 导⼊</li></ol><h1 id="⼩程序关联微信公众号如何确定⽤户的唯⼀性"><a href="#⼩程序关联微信公众号如何确定⽤户的唯⼀性" class="headerlink" title="⼩程序关联微信公众号如何确定⽤户的唯⼀性"></a>⼩程序关联微信公众号如何确定⽤户的唯⼀性</h1><p>使⽤ wx.getUserInfo ⽅法 withCredentials 为 true 时 可获取encryptedData ，⾥⾯有 union_id 。后端需要进⾏对称解密</p><h1 id="微信⼩程序与vue区别"><a href="#微信⼩程序与vue区别" class="headerlink" title="微信⼩程序与vue区别"></a>微信⼩程序与vue区别</h1><ol><li>⽣命周期不⼀样，微信⼩程序⽣命周期⽐较简单</li><li>数据绑定也不同，微信⼩程序数据绑定需要使⽤ <code>&#123;&#123;&#125;&#125;</code> ， vue 直接 : 就可以</li><li>显示与隐藏元素， vue 中，使⽤ v-if 和 v-show 控制元素的显示和隐藏，⼩程序中，使⽤ wx-if 和 hidden 控制元素的显示和隐藏</li><li>事件处理不同，⼩程序中，全⽤ bindtap(bind+event) ，或者catchtap(catch+event) 绑定事件, vue： 使⽤ v-on:event 绑定事件，或者使⽤@event 绑定事件</li><li>数据双向绑定也不也不⼀样在 vue 中,只需要再表单元素上加上 v-model ,然后再绑定data 中对应的⼀个值，当表单元素内容发⽣变化时， data 中对应的值也会相应改变，这是 vue ⾮常 nice 的⼀点。微信⼩程序必须获取到表单元素，改变的值，然后再把值赋给⼀个 data 中声明的变量。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端常见布局</title>
      <link href="/front-end/%E5%89%8D%E7%AB%AF%E5%B8%83%E5%B1%80/"/>
      <url>/front-end/%E5%89%8D%E7%AB%AF%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<ol><li><p>流式布局（Flow Layout）：流式布局是基于元素在文档流中的位置进行自然排列的方式。元素会根据父容器的大小自动调整位置和大小。</p></li><li><p>浮动布局（Float Layout）：浮动布局使用 float 属性来使元素脱离文档流并进行排列。通过设置不同的浮动值，可以让元素向左或向右浮动，并实现多列布局。</p></li><li><p>定位布局（Positioned Layout）：定位布局使用 position 属性来控制元素的位置。常见的属性值包括 relative、absolute 和 fixed。通过设置元素的定位属性和偏移值，可以将元素精确地放置在指定位置。</p></li><li><p>弹性布局（Flexbox Layout）：弹性布局使用 flexbox 模型来实现灵活的布局。通过设置容器的 display 属性为 flex，可以指定元素以弹性布局方式排列。弹性布局提供了一套强大的属性和方法，用于控制元素的尺寸、位置和排列顺序。</p></li><li><p>表格布局（Table Layout）：表格布局使用 HTML 表格标签来实现布局。通过设置 table、tr 和 td 等标签来定义表格的结构和样式。</p></li><li><p>网格布局（Grid Layout）：网格布局是一种二维布局系统，通过将页面划分为网格来进行布局。可以使用 grid-template-columns 和 grid-template-rows 属性来定义行列的大小和数量。</p></li><li><p>百分比单位（Percentage）：百分比单位是相对于父元素的尺寸进行计算的单位。例如，设置一个元素的宽度为 50% 表示该元素的宽度是父元素宽度的一半。</p></li><li><p>rem 单位：rem 是相对于根元素（html）的字体大小进行计算的单位。通过设置根元素的字体大小，可以统一调整整个页面中的元素大小。</p></li><li><p>vw&#x2F;vh 单位：vw 表示相对于视口宽度的百分比，vh 表示相对于视口高度的百分比。这两个单位可以用来实现响应式布局，根据视口的大小动态调整元素的尺寸。</p></li><li><p>响应式布局（Responsive Layout）：响应式布局是一种根据不同设备屏幕大小和分辨率自适应调整布局的方式。通过使用媒体查询、弹性布局、网格布局等技术，使得网页在不同设备上都能显示出最佳效果。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信公众号html js 实现登录</title>
      <link href="/front-end/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7html%20js%20%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95/"/>
      <url>/front-end/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7html%20js%20%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<pre><code class="JavaScript">1. 在微信公众平台上创建并配置好您的公众号，获取到相应的开发者ID（AppID）和密钥（AppSecret）。2. 在您的网页中引入微信 JS-SDK，以便与微信进行交互。可以使用以下 JS 代码进行引入：script src=&quot;http://res.wx.qq.com/open/js/jweixin-1.6.0.js&quot;&gt;&lt;/script&gt;3. 初始化微信 JS-SDK，设置相关配置信息，并在初始化完成后执行授权登录操作。可以使用以下 JS 代码进行初始化和授权登录操作：wx.config(&#123;    appId: &#39;YOUR_APP_ID&#39;,    timestamp: &#39;TIMESTAMP&#39;,    nonceStr: &#39;NONCE_STR&#39;,    signature: &#39;SIGNATURE&#39;,    jsApiList: [&#39;checkJsApi&#39;, &#39;chooseWXPay&#39;, &#39;openLocation&#39;, &#39;scanQRCode&#39;, &#39;authorize&#39;] // 需要使用的微信 API 列表&#125;);wx.ready(function() &#123;    // 在这里执行授权登录操作    wx.authorize(&#123;        scope: &#39;snsapi_base&#39;,        success: function(res) &#123;            // 用户同意授权，可以获取到用户的基本信息            var code = res.code; // 获取到授权登录的code            // 在这里可以将code发送到服务器进行进一步处理        &#125;,        fail: function(res) &#123;            // 用户拒绝授权或授权失败            console.log(res);        &#125;    &#125;);&#125;);请将 YOUR_APP_ID 替换为您的公众号的开发者ID，TIMESTAMP、NONCE_STR 和 SIGNATURE 替换为相应的值，这些信息可以通过后台服务器签名获取。4. 根据需要进行进一步的处理。在获得用户授权登录的code后，您可以将其发送到后台服务器，通过调用微信提供的接口来获取用户的详细信息或执行其他操作。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> 微信公众号 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信公众号 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信公众号vue实现登录</title>
      <link href="/front-end/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7vue%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95/"/>
      <url>/front-end/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7vue%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<pre><code class="javascript">1. 在Vue项目中安装并引入微信 JS-SDK库（jweixin.js）。npm install weixin-js-sdk引入 import wx from &#39;weixin-js-sdk&#39;;2. 在Vue的组件中，创建一个用于授权登录的按钮，并定义触发登录的方法。&lt;template&gt;  &lt;div&gt;    &lt;button @click=&quot;wechatLogin&quot;&gt;微信登录&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;methods: &#123;  wechatLogin() &#123;    // 微信公众号授权登录的逻辑  &#125;&#125;3. 在微信授权登录的方法内部，进行微信 JS-SDK的初始化和授权登录操作。// 引入后端提供的获取微信 JS-SDK配置的接口import &#123; getWechatConfig &#125; from &#39;@/api/wechat&#39;; // 替换成实际的接口路径methods: &#123;  async wechatLogin() &#123;    const config = await getWechatConfig(); // 调用后端接口获取微信 JS-SDK的配置信息    wx.config(&#123;      debug: false,      appId: config.appId,      timestamp: config.timestamp,      nonceStr: config.nonceStr,      signature: config.signature,      jsApiList: [&#39;checkJsApi&#39;, &#39;authorize&#39;] // 需要使用的微信 API 列表    &#125;);    wx.error(function(res) &#123;      // 初始化失败的处理逻辑      console.error(&#39;微信 JS-SDK初始化失败:&#39;, res);    &#125;);    const vm = this;    wx.ready(function() &#123;      // 在这里执行授权登录操作      wx.authorize(&#123;        scope: &#39;snsapi_base&#39;,        success: function(res) &#123;          // 用户同意授权，可以获取到用户的基本信息          const code = res.code; // 获取到授权登录的code          // 在这里可以将code发送到服务器进行进一步处理          console.log(&#39;授权登录成功，code:&#39;, code);        &#125;,        fail: function(res) &#123;          // 用户拒绝授权或授权失败          console.log(&#39;授权登录失败:&#39;, res);        &#125;      &#125;);    &#125;);  &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> 微信公众号 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信公众号 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次vue转uniapp</title>
      <link href="/front-end/%E8%AE%B0%E4%B8%80%E6%AC%A1vue%E8%BD%ACuniapp/"/>
      <url>/front-end/%E8%AE%B0%E4%B8%80%E6%AC%A1vue%E8%BD%ACuniapp/</url>
      
        <content type="html"><![CDATA[<h1 id="vue的相关标签怎么转"><a href="#vue的相关标签怎么转" class="headerlink" title="vue的相关标签怎么转?"></a>vue的相关标签怎么转?</h1><pre><code class="text">div  header main section -&gt; viewspan -&gt; textul li -&gt; view ?  这个还不太确定，这个只要有样式类的情况下直接改img -&gt; image   这里注意的是转成uniapp的image标签要把宽高都设置一下      总结为只要有class类的情况下，基本上都是用的view</code></pre><h1 id="字体处理：-px-转-rpx-2倍化怎么处理？-全局样式怎么转化"><a href="#字体处理：-px-转-rpx-2倍化怎么处理？-全局样式怎么转化" class="headerlink" title="字体处理： px 转 rpx  2倍化怎么处理？ 全局样式怎么转化?"></a>字体处理： px 转 rpx  2倍化怎么处理？ 全局样式怎么转化?</h1><pre><code class="text">uniapp有个&lt;page-meta :root-font-size=&quot;&#39;12px&#39;&quot;/&gt;1rem 就是12px现在某个页面盒子得大小是22px  但是实际我需要得大小是44px  so  在不改变前面数字得情况下，1rem = 2px但是这个是有一定缺陷的，浏览器里最小的字体是12px ,如果字体大小已经写死的情况下就不能用了   so  其实还有一个办法，直接全局替换px 为 px * 2  </code></pre><h1 id="对于已经使用axios写得api接口，怎么快速转化成uniapp的请求方式"><a href="#对于已经使用axios写得api接口，怎么快速转化成uniapp的请求方式" class="headerlink" title="对于已经使用axios写得api接口，怎么快速转化成uniapp的请求方式"></a>对于已经使用axios写得api接口，怎么快速转化成uniapp的请求方式</h1><pre><code class="javascript">针对当前的项目，进行对函数导出和数据传入进行分布封装import config from &quot;@/config/index.js&quot;import store from &#39;@/store/index.js&#39;;export const requestApi = (options) =&gt; &#123;    const ppsessid = store.state.user.ppSessId    const sessid = store.state.user.sessId    const cid = store.state.env.cid    const publicHeaders = &#123;        &quot;Content-Type&quot;: &quot;application/json&quot;,        &#39;Accept&#39;: &#39;application/json&#39;,        &#39;X-Yf-CID&#39;: cid,        &#39;X-Yf-PPSessid&#39; : ppsessid,        &#39;X-Yf-Sessid&#39; : sessid    &#125;    return (function() &#123;        let &#123;            url,            method,            params,            data        &#125; = options        // console.log(&#39;options&#39;, options)        return new Promise((resolve, reject) =&gt; &#123;            uni.request(&#123;                url: config.url.devServer + url,                method: method || &#39;GET&#39;,                header: publicHeaders,                data: data || params,                success: (res) =&gt; &#123;                    resolve(res);                &#125;,                fail: (err) =&gt; &#123;                    reject(err);                &#125;            &#125;)        &#125;);    &#125;)(options)&#125;</code></pre><h1 id="vue中的good-storage-unaiapp的替代方案"><a href="#vue中的good-storage-unaiapp的替代方案" class="headerlink" title="vue中的good-storage    unaiapp的替代方案"></a>vue中的good-storage    unaiapp的替代方案</h1><pre><code class="javascript">这个js库其实就是一个操作缓存的库自己封装一个简单的对象即可解决let storage = &#123;&#125;storage.get = function(options) &#123;    uni.getStorageSync(options)&#125;storage.set = function(options) &#123;    uni.setStorageSync(options)&#125;storage.remove = function(options) &#123;    uni.removeStorageSync(options)&#125;</code></pre><h1 id="vue中的相关跳转"><a href="#vue中的相关跳转" class="headerlink" title="vue中的相关跳转"></a>vue中的相关跳转</h1><pre><code class="javascript">1.封装vue的原型对象。这个是最方便的，但是需要适配一些东西，? 可以试一下。2.push -&gt; navigateTo  replace -&gt; redirectToback  -&gt;         let pages = getCurrentPages(); // 当前页面                    let beforePage = pages[pages.length - 2]; // 上一页                    uni.navigateBack(&#123;                        success: function() &#123;                            beforePage.onLoad(); // 执行上一页的onLoad方法                        &#125;                    &#125;);</code></pre><h1 id="怎么快速的处理css样式完成转化"><a href="#怎么快速的处理css样式完成转化" class="headerlink" title="怎么快速的处理css样式完成转化"></a>怎么快速的处理css样式完成转化</h1><pre><code class="javascript">采取   1.就地取材2.转vue标签为类举个例子。 比如当前的页面p 标签哟样式，就直接，吧类名变成p ,然后p标签改为view</code></pre><h1 id="路由相关"><a href="#路由相关" class="headerlink" title="路由相关"></a>路由相关</h1><pre><code class="java">this.$route.query.canshu1      就是在 onload 里接收 options 里接收canshu1  </code></pre><h1 id="记一次ui-li-scss-转化的过程"><a href="#记一次ui-li-scss-转化的过程" class="headerlink" title="记一次ui li  scss 转化的过程"></a>记一次ui li  scss 转化的过程</h1><pre><code class="javascript">*****转化之前&lt;ul&gt;    &lt;template v-if=&quot;currentSku.coupon &amp;&amp; currentSku.coupon.length&quot;&gt;        &lt;li class=&quot;has-coupon&quot; v-for=&quot;(item, index) in currentSku.coupon.slice(0, 2)&quot;        :key=&quot;index&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/li&gt;    &lt;/template&gt;    &lt;li v-else&gt;暂无优惠券&lt;/li&gt;&lt;/ul&gt;.goods-tickets &#123;        ul &#123;          display: flex;          li &#123;            color: #378BF7;            &amp;.has-coupon &#123;              display: flex;              align-items: center;              height: 20px * 2;              font-size: 12px * 2;              padding: 0 9px * 2;              margin-right: 6px * 2;              background-color: #378BF7;              background-repeat: no-repeat;              position: relative;              overflow: hidden;              color: #FFFFFF;              &amp;:last-child &#123;                margin-right: 0;              &#125;              &amp;:before, &amp;:after &#123;                content: &#39;&#39;;                display: block;                position: absolute;                width: 8px * 2;                height: 8px * 2;                background-color: #FFF;                border-radius: 50%;                top: 50%;                transform: translateY(-50%);              &#125;              &amp;:before &#123;                left: -4px * 2;              &#125;              &amp;:after &#123;                right: -4px * 2;              &#125;            &#125;          &#125;        &#125;      &#125; *****转化过后&lt;view class=&quot;ul222&quot;&gt;    &lt;template v-if=&quot;currentSku.coupon &amp;&amp; currentSku.coupon.length&quot;&gt;        &lt;view class=&quot;has-coupon&quot; v-for=&quot;(item, index) in currentSku.coupon.slice(0, 2)&quot;        :key=&quot;index&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/view&gt;    &lt;/template&gt;    &lt;view v-else&gt;暂无优惠券&lt;/view&gt;&lt;/view&gt; .goods-tickets &#123;        .ul222 &#123;          display: flex;          view &#123;            color: #378BF7;            &amp;.has-coupon &#123;              display: flex;              align-items: center;              height: 20px * 2;              font-size: 12px * 2;              padding: 0 9px * 2;              margin-right: 6px * 2;              background-color: #378BF7;              background-repeat: no-repeat;              position: relative;              overflow: hidden;              color: #FFFFFF;              &amp;:last-child &#123;                margin-right: 0;              &#125;              &amp;:before, &amp;:after &#123;                content: &#39;&#39;;                display: block;                position: absolute;                width: 8px * 2;                height: 8px * 2;                background-color: #FFF;                border-radius: 50%;                top: 50%;                transform: translateY(-50%);              &#125;              &amp;:before &#123;                left: -4px * 2;              &#125;              &amp;:after &#123;                right: -4px * 2;              &#125;            &#125;          &#125;        &#125;      &#125;</code></pre><h1 id="uniapp的图片路径相关问题"><a href="#uniapp的图片路径相关问题" class="headerlink" title="uniapp的图片路径相关问题"></a>uniapp的图片路径相关问题</h1><p>编译成H5 的时候图片在哪里都无所谓</p><p>编译成小程序 的时候图片必须要在 static 下</p><h1 id="分包应该在项目改写之前"><a href="#分包应该在项目改写之前" class="headerlink" title="分包应该在项目改写之前"></a>分包应该在项目改写之前</h1><p>不然后面又得改写跳转路径</p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> Uniapp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> uniapp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动端相关适配方案</title>
      <link href="/front-end/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/"/>
      <url>/front-end/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="参考文档-得先了解视口的概念"><a href="#参考文档-得先了解视口的概念" class="headerlink" title="参考文档 得先了解视口的概念"></a>参考文档 得先了解视口的概念</h1><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM0MDAzMTQvYXJ0aWNsZS9kZXRhaWxzLzEyNTQ4ODM3Ng==">https://blog.csdn.net/u013400314/article/details/125488376</span></p><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81MjU1NTIyNDg=">https://zhuanlan.zhihu.com/p/525552248</span></p><h1 id="移动端适配常见的方法"><a href="#移动端适配常见的方法" class="headerlink" title="移动端适配常见的方法"></a>移动端适配常见的方法</h1><ol><li>视口（Viewport）设置：视口是指用户在浏览器中看到的网页的可见区域。在移动设备上，默认的视口宽度通常比设备的实际屏幕宽度要宽，这样会导致页面缩小显示。为了解决这个问题，可以通过设置视口的宽度等于设备的屏幕宽度，使页面按照设备的实际尺寸进行显示。</li></ol><pre><code class="html">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</code></pre><ol start="2"><li>媒体查询（Media Queries）：媒体查询是一种CSS技术，通过检测设备的特性（如屏幕宽度、像素密度等）来应用不同的CSS样式。通过使用媒体查询，可以针对不同的屏幕尺寸应用不同的样式，从而实现响应式布局。</li></ol><pre><code class="css">@media (max-width: 768px) &#123;  /* 在宽度小于等于768px时应用的样式 */&#125;</code></pre><ol start="3"><li><p>弹性布局（Flexbox）：Flexbox布局是一种灵活的布局模型，可以以响应式的方式自动调整元素的位置和大小，适应不同尺寸的屏幕。通过使用Flexbox布局，可以方便地实现移动端页面的自适应布局。</p></li><li><p>图片适配：在移动端适配中，图片的尺寸也需要进行适配。可以使用CSS的max-width: 100%属性来确保图片在不超出父容器宽度的情况下按比例缩放。</p></li></ol><pre><code class="css">img &#123;  max-width: 100%;  height: auto;&#125;</code></pre><ol start="5"><li>rem单位：rem（root em）是相对于根元素的字体大小的单位。通过设置根元素的字体大小，可以实现基于视口尺寸的动态适配。可以结合媒体查询和rem单位来实现根据屏幕尺寸改变布局和字体大小。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> 移动端适配 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 移动端适配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端设计模式</title>
      <link href="/front-end/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/front-end/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="MVC（Model-View-Controller）模式："><a href="#MVC（Model-View-Controller）模式：" class="headerlink" title="MVC（Model-View-Controller）模式："></a>MVC（Model-View-Controller）模式：</h1><pre><code class="text">将应用程序分为三个核心组件：模型（数据）、视图（用户界面）和控制器（处理逻辑）。模型负责数据操作和状态管理，视图负责用户界面展示，控制器负责调度模型和视图之间的交互。</code></pre><h1 id="MVVM（Model-View-ViewModel）模式："><a href="#MVVM（Model-View-ViewModel）模式：" class="headerlink" title="MVVM（Model-View-ViewModel）模式："></a>MVVM（Model-View-ViewModel）模式：</h1><pre><code class="text">类似于 MVC 模式，将应用程序分为三个组件：模型、视图和视图模型。视图模型是视图和模型之间的连接层，负责将模型数据绑定到视图并处理视图上的用户事件。</code></pre><h1 id="单例模式（Singleton-Pattern）："><a href="#单例模式（Singleton-Pattern）：" class="headerlink" title="单例模式（Singleton Pattern）："></a>单例模式（Singleton Pattern）：</h1><pre><code class="text">保证一个类只有一个实例，并提供一个全局的访问点。在前端开发中，常用于管理全局状态、共享资源、日志记录等。</code></pre><h1 id="观察者模式（Observer-Pattern）："><a href="#观察者模式（Observer-Pattern）：" class="headerlink" title="观察者模式（Observer Pattern）："></a>观察者模式（Observer Pattern）：</h1><pre><code class="text">定义了一种一对多的依赖关系，当一个对象状态发生变化时，其所有依赖者会被通知并自动更新。常用于实现事件系统、订阅/发布模式等。</code></pre><h1 id="工厂模式（Factory-Pattern）："><a href="#工厂模式（Factory-Pattern）：" class="headerlink" title="工厂模式（Factory Pattern）："></a>工厂模式（Factory Pattern）：</h1><pre><code class="text">通过一个工厂对象创建其他对象，隐藏对象创建的细节，提供统一的接口。常用于创建具有相似功能的对象，实现对象的解耦和复用。</code></pre><h1 id="适配器模式（Adapter-Pattern）："><a href="#适配器模式（Adapter-Pattern）：" class="headerlink" title="适配器模式（Adapter Pattern）："></a>适配器模式（Adapter Pattern）：</h1><pre><code class="text">将一个类的接口转换成另一个客户端所期望的接口，使得原本不兼容的类可以一起工作。常用于兼容不同版本的 API、封装第三方库等。</code></pre><h1 id="策略模式（Strategy-Pattern）："><a href="#策略模式（Strategy-Pattern）：" class="headerlink" title="策略模式（Strategy Pattern）："></a>策略模式（Strategy Pattern）：</h1><pre><code class="text">定义了一系列算法，并将每个算法封装成独立的对象，使得它们可以相互替换。常用于根据不同的情况选择不同的处理策略，提高代码的灵活性和可维护性。</code></pre><h1 id="装饰者模式（Decorator-Pattern）："><a href="#装饰者模式（Decorator-Pattern）：" class="headerlink" title="装饰者模式（Decorator Pattern）："></a>装饰者模式（Decorator Pattern）：</h1><pre><code class="text">动态地给对象添加额外的功能，同时不改变其接口。常用于对已有对象进行包装，增强其功能或修改其行为。</code></pre><h1 id="策略工厂模式（Strategy-Factory-Pattern）："><a href="#策略工厂模式（Strategy-Factory-Pattern）：" class="headerlink" title="策略工厂模式（Strategy Factory Pattern）："></a>策略工厂模式（Strategy Factory Pattern）：</h1><pre><code class="text">结合策略模式和工厂模式，通过工厂类动态创建策略对象。常用于根据配置或条件动态选择并创建不同的策略对象。</code></pre><h1 id="组合模式（Composite-Pattern）："><a href="#组合模式（Composite-Pattern）：" class="headerlink" title="组合模式（Composite Pattern）："></a>组合模式（Composite Pattern）：</h1><pre><code class="text">将对象组合成树形结构，以表示“部分-整体”的层次关系。常用于处理树形数据结构，实现递归操作。</code></pre><h1 id="享元模式（Flyweight-Pattern）："><a href="#享元模式（Flyweight-Pattern）：" class="headerlink" title="享元模式（Flyweight Pattern）："></a>享元模式（Flyweight Pattern）：</h1><pre><code class="text">共享对象以减少内存占用，用于有效支持大量细粒度的对象。常用于优化性能和内存消耗，特别是在大规模数据渲染时。</code></pre><h1 id="外观模式（Facade-Pattern）："><a href="#外观模式（Facade-Pattern）：" class="headerlink" title="外观模式（Facade Pattern）："></a>外观模式（Facade Pattern）：</h1><pre><code class="text">提供了一个简化的接口，隐藏了底层复杂的逻辑和调用。常用于提供统一的接口，简化复杂系统的使用。</code></pre><h1 id="命令模式（Command-Pattern）："><a href="#命令模式（Command-Pattern）：" class="headerlink" title="命令模式（Command Pattern）："></a>命令模式（Command Pattern）：</h1><pre><code class="text">将请求封装成一个对象，使得可以用不同的请求对客户进行参数化。常用于实现撤销、重做、延迟执行等操作。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> 前端设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解ajax</title>
      <link href="/front-end/%E8%AF%A6%E8%A7%A3ajax/"/>
      <url>/front-end/%E8%AF%A6%E8%A7%A3ajax/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ4MDQxODc3L2FydGljbGUvZGV0YWlscy8xMjY1NDUwMTU=">参考博客</span></p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> 网络请求 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络请求 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>event loop</title>
      <link href="/js-base/event%20loop/"/>
      <url>/js-base/event%20loop/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是event-loop"><a href="#什么是event-loop" class="headerlink" title="什么是event loop"></a>什么是event loop</h1><ol><li><p>JavaScript中的事件循环（Event Loop）是一种机制，用于管理异步任务的执行顺序和调度。它确保JavaScript的单线程执行模型能够处理异步任务，并保持代码的执行顺序</p></li><li><p>事件循环的工作原理如下：</p></li><li><p>执行栈（Call Stack）：JavaScript代码的执行顺序通过执行栈来管理，每个函数调用都会将其对应的执行上下文压入执行栈，然后按照先入后出的顺序执行。</p></li><li><p>任务队列（Task Queue）：除了执行栈外，事件循环还会维护多个任务队列，包括宏任务队列（Macro Task Queue）和微任务队列（Micro Task Queue）。<br>- 微任务（Micro Task）：微任务包括Promise、MutationObserver、process.nextTick（Node.js）等。微任务会被推入微任务队列。<br>- 宏任务（Macro Task）：宏任务包括定时器（setTimeout、setInterval）、I&#x2F;O 操作（例如文件读写、网络请求）、UI 交互事件（例如点击事件、键盘事件）、requestAnimationFrame（用于优化动画效果的定时器）等。宏任务会被推入宏任务队列。</p></li><li><p>事件循环（Event Loop）：当执行栈为空时，事件循环会首先处理微任务队列中的所有任务，然后再从宏任务队列中选取一个任务执行。执行完该任务后，再次处理微任务，不断循环执行，直到所有任务完成。</p></li></ol><h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><p>进程是指操作系统中正在运行的一个应用程序，它具有独立的内存空间和系统资源，并且可以执行多个任务。每个进程包含一个或多个线程，线程是进程中的执行单元，用于执行实际的计算任务。</p><h1 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h1><p>执行栈是一种数据结构，用于管理函数的调用顺序。当一个函数被调用时，它的上下文（包括参数、局部变量等）会被压入执行栈中，被称为帧。当函数执行完成后，对应的帧会从执行栈中弹出，控制权交给调用该函数的地方。</p><h1 id="为什么JavaScript是单线程，而不是多线程"><a href="#为什么JavaScript是单线程，而不是多线程" class="headerlink" title="为什么JavaScript是单线程，而不是多线程"></a>为什么JavaScript是单线程，而不是多线程</h1><p>JavaScript最初设计为单线程的语言，原因如下：</p><p>简单性：单线程模型简化了语言本身的复杂性和实现难度。<br>安全性：多线程需要处理共享内存的同步问题，容易导致死锁、竞态条件等问题。而单线程避免了这些问题，使得编写和调试代码更加安全。<br>兼容性：JavaScript最初主要用于浏览器中，而多线程模型在浏览器环境中可能导致页面无响应、卡顿等用户体验问题。</p><h1 id="浏览器与-Node-事件（有何区别）"><a href="#浏览器与-Node-事件（有何区别）" class="headerlink" title="浏览器与 Node 事件（有何区别）"></a>浏览器与 Node 事件（有何区别）</h1><ol><li>实现机制：浏览器事件循环是根据 HTML5 规范实现的，而 Node.js 事件循环则是基于 libuv 库实现的。</li><li>宿主环境：浏览器事件循环运行在浏览器环境中，而 Node.js 事件循环则运行在服务器端的 Node.js 环境中。</li><li>宏任务和微任务队列：浏览器事件循环中有一个宏任务队列和一个微任务队列，分别用于存储不同类型的任务。而 Node.js 事件循环中没有明确的宏任务队列和微任务队列的概念，在不同阶段会处理不同类型的任务，但任务的分类和执行顺序略有不同。</li><li>API 和事件回调：尽管浏览器和 Node.js 都提供了一些异步操作的 API（如定时器、网络请求等），但两者的底层实现和事件回调机制不完全相同。例如，在浏览器中，可以使用 setTimeout、setInterval 等方法创建定时器，而在 Node.js 中，可以使用 setTimeout、setInterval、setImmediate 等方法。此外，浏览器还支持 DOM 相关的事件回调，而 Node.js 则支持文件 I&#x2F;O、网络 I&#x2F;O 等事件回调。</li><li>默认宏任务数量限制：浏览器对于连续的宏任务（如多个 setTimeout 回调）有一个最小间隔（通常是 4 毫秒），这是为了避免过度占用 CPU 资源。而 Node.js 没有类似的限制，默认情况下可以连续执行多个宏任务。</li></ol><h2 id="浏览器事件循环的执行顺序如下："><a href="#浏览器事件循环的执行顺序如下：" class="headerlink" title="浏览器事件循环的执行顺序如下："></a>浏览器事件循环的执行顺序如下：</h2><ol><li>执行同步任务：从宏任务队列中取出一个任务，执行该任务，直到队列为空。</li><li>执行微任务：从微任务队列中取出一个任务，执行该任务，直到队列为空。</li><li>渲染：更新页面的渲染，并检查是否需要进行重新绘制或重排。</li><li>检查输入事件：检查并处理用户的输入，例如点击、滚动等。</li><li>更新页面显示：将更改后的页面内容显示给用户。</li><li>进入下一轮事件循环。</li></ol><h2 id="Node-js-事件循环的执行顺序如下："><a href="#Node-js-事件循环的执行顺序如下：" class="headerlink" title="Node.js 事件循环的执行顺序如下："></a>Node.js 事件循环的执行顺序如下：</h2><ol><li>执行同步任务：从事件队列中取出一个任务，执行该任务，直到队列为空。</li><li>执行下一个异步阶段：依次执行定时器（Timers）、待执行的 I&#x2F;O 回调（I&#x2F;O callbacks）、空闲回调（idle, prepare）等异步阶段的回调函数。</li><li>执行微任务：从微任务队列中取出一个任务，执行该任务，直到队列为空。</li><li>检查计时器：检查是否有计时器已经到期，如果有，则执行相应的计时器回调。</li><li>检查待定的操作：检查是否有待定的操作（例如关闭服务器），如果有，则执行相应的操作。</li><li>进入下一轮事件循环。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js面试</title>
      <link href="/js-base/javascript%E9%9D%A2%E8%AF%95/"/>
      <url>/js-base/javascript%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="JS-数据类型"><a href="#JS-数据类型" class="headerlink" title="JS 数据类型 ?"></a>JS 数据类型 ?</h1><pre><code class="javascript">1.数字（Number）：表示数值，包括整数和浮点数。例如：42, 3.14。2.字符串（String）：表示文本数据，用于存储和操作字符序列。字符串可以使用单引号或双引号括起来。例如：&#39;Hello&#39;, &quot;World&quot;。3.布尔值（Boolean）：表示逻辑值，只有两个取值：true 和 false。布尔值常用于条件判断和逻辑运算。4.空值（Null）：表示空值或不存在的对象。当变量被赋值为 null 时，表示该变量没有任何值。5.未定义（Undefined）：表示变量声明了但未赋值。如果一个变量没有初始化，它的值就是 undefined。6.符号（Symbol）：ES6 引入的新数据类型，表示独一无二的值。符号通常用作对象属性的键。除了这些基本数据类型，JavaScript 还提供了一种复杂类型：7.对象（Object）：表示复合值，可包含多个键值对。键是字符串或符号，值可以是任意类型。对象是 JavaScript 中最常见的数据类型之一，例如数组、函数等都是对象。</code></pre><h1 id="判断一个值是什么类型有哪些方法？"><a href="#判断一个值是什么类型有哪些方法？" class="headerlink" title="判断一个值是什么类型有哪些方法？"></a>判断一个值是什么类型有哪些方法？</h1><pre><code class="javascript">typeof 操作符：typeof 操作符用于检查一个值的类型。它返回一个表示该值类型的字符串。常见的返回值包括 &quot;number&quot;、&quot;string&quot;、&quot;boolean&quot;、&quot;object&quot;、&quot;function&quot;、&quot;undefined&quot;、&quot;symbol&quot;。例如：javascripttypeof 42; // &quot;number&quot;typeof &quot;Hello&quot;; // &quot;string&quot;typeof true; // &quot;boolean&quot;typeof undefined; // &quot;undefined&quot;typeof null; // &quot;object&quot;（注意这是一个历史遗留问题）typeof Symbol(&quot;symbol&quot;); // &quot;symbol&quot;typeof &#123;&#125;; // &quot;object&quot;typeof []; // &quot;object&quot;typeof function() &#123;&#125;; // &quot;function&quot;instanceof 操作符：instanceof 操作符用于检查一个对象是否属于某个构造函数的实例。它返回一个布尔值。例如：javascriptvar arr = [];arr instanceof Array; // truearr instanceof Object; // true，因为 Array 是 Object 的派生类var date = new Date();date instanceof Date; // truedate instanceof Object; // true，因为 Date 是 Object 的派生类constructor 属性：constructor 属性是对象的内置属性，指向创建该对象的构造函数。可以通过比较对象的 constructor 属性与预期构造函数来判断对象的类型。例如：javascriptvar num = 42;num.constructor === Number; // truevar str = &quot;Hello&quot;;str.constructor === String; // truevar bool = true;bool.constructor === Boolean; // trueObject.prototype.toString：Object 的原型对象上具有 toString 方法，可以通过调用该方法来获取一个值的类型字符串。例如：javascriptvar obj = &#123;&#125;;Object.prototype.toString.call(obj); // &quot;[object Object]&quot;var arr = [];Object.prototype.toString.call(arr); // &quot;[object Array]&quot;var date = new Date();Object.prototype.toString.call(date); // &quot;[object Date]&quot;总结：1：在`JavaScript`里使用`typeof`判断数据类型，只能区分**基本类型**，即：`number`、`string`、`undefined`、`boolean`、`object`。2：对于`null`、`array`、`function`、`object`来说，使用`typeof`都会统一返回`object`字符串。3：要想区分对象、数组、函数、单纯使用`typeof`是不行的。在JS中，可以通过`Object.prototype.toString.call()`方法，判断某个对象之属于哪种内置类型。分为`null`、`string`、`boolean`、`number`、`undefined`、`array`、`function`、`object`、`date`、`math`。4：constructor 本来是用于标识对象类型的。5：一般认为 instanceof 操作符是确定对象类型 更可靠的方式。  let obj = &#123;&#125;  let num1 = 1  console.log(typeof obj)   //object  console.log(obj instanceof Object)  //true  console.log(obj.constructor) //ƒ Object() &#123; [native code] &#125;  console.log( Object.prototype.toString.call(1)) // [object Number]  console.log(Object.prototype.toString.call(obj)) // [object Object]</code></pre><h1 id="null-和-undefined-的区别？"><a href="#null-和-undefined-的区别？" class="headerlink" title="null 和 undefined 的区别？"></a>null 和 undefined 的区别？</h1><pre><code class="javascript">undefined 通常表示缺少预期的值或变量尚未初始化。它是一个全局对象的属性，也可以通过声明变量但不进行赋值来获得该值。null 表示明确地指定一个变量为空值，一般用于表示对象或变量没有有效的值。它是一个关键字，不是全局对象的属性。</code></pre><h1 id="怎么判断一个变量arr的话是否为数组（此题用-typeof-不行）？"><a href="#怎么判断一个变量arr的话是否为数组（此题用-typeof-不行）？" class="headerlink" title="怎么判断一个变量arr的话是否为数组（此题用 typeof 不行）？"></a>怎么判断一个变量arr的话是否为数组（此题用 typeof 不行）？</h1><pre><code class="javascript">如果你不想使用 typeof 来判断一个变量是否为数组，可以使用 Array.isArray() 方法。这个方法会检查给定的值是否为一个数组，并返回一个布尔值。以下是一个示例：javascriptvar arr = [1, 2, 3];console.log(Array.isArray(arr)); // 输出 truevar obj = &#123;&#125;;console.log(Array.isArray(obj)); // 输出 false在上述示例中，Array.isArray() 方法被用来检查变量 arr 是否为数组。如果 arr 是一个数组，则返回 true；否则，返回 false。如果需要兼容老版本的浏览器，可以使用以下代码来实现类似的功能：javascriptfunction isArray(arr) &#123;  return Object.prototype.toString.call(arr) === &#39;[object Array]&#39;;&#125;var arr = [1, 2, 3];console.log(isArray(arr)); // 输出 truevar obj = &#123;&#125;;console.log(isArray(obj)); // 输出 false</code></pre><h1 id="“-x3D-x3D-x3D-”、“-x3D-x3D-”的区别？"><a href="#“-x3D-x3D-x3D-”、“-x3D-x3D-”的区别？" class="headerlink" title="“ &#x3D;&#x3D;&#x3D;”、“ &#x3D;&#x3D;”的区别？"></a>“ &#x3D;&#x3D;&#x3D;”、“ &#x3D;&#x3D;”的区别？</h1><pre><code class="javascript">==，当且仅当两个运算数相等时，它返回 true，即不检查数据类型===，只有在无需类型转换运算数就相等的情况下，才返回 true，需要检查数据类型</code></pre><h1 id="eval是做什么的？"><a href="#eval是做什么的？" class="headerlink" title="eval是做什么的？"></a>eval是做什么的？</h1><pre><code class="javascript">它的功能是把对应的字符串解析成 JS 代码并运行；应该避免使用 eval，不安全，非常耗性能（2次，一次解析成 js 语句，一次执行）。</code></pre><h1 id="箭头函数有哪些特点？"><a href="#箭头函数有哪些特点？" class="headerlink" title="箭头函数有哪些特点？"></a>箭头函数有哪些特点？</h1><pre><code class="javascript">不需要function关键字来创建函数省略return关键字改变this指向</code></pre><h1 id="var、let、const-区别？"><a href="#var、let、const-区别？" class="headerlink" title="var、let、const 区别？"></a>var、let、const 区别？</h1><pre><code class="javascript">var具有函数作用域，变量提升，并且可以重复声明。let和const具有块级作用域，没有变量提升，而且不允许重复声明（在同一个作用域内）。let声明的变量可重新赋值，而const声明的变量是常量，不可重新赋值。</code></pre><h1 id="new操作符具体干了什么呢？"><a href="#new操作符具体干了什么呢？" class="headerlink" title="new操作符具体干了什么呢？"></a>new操作符具体干了什么呢？</h1><pre><code class="javascript">1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。2、属性和方法被加入到 this 引用的对象中。3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。</code></pre><h1 id="JSON-的了解？"><a href="#JSON-的了解？" class="headerlink" title="JSON 的了解？"></a>JSON 的了解？</h1><pre><code class="javascript">JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小</code></pre><h1 id="document-write-和-innerHTML-的区别？"><a href="#document-write-和-innerHTML-的区别？" class="headerlink" title="document.write 和 innerHTML 的区别？"></a>document.write 和 innerHTML 的区别？</h1><pre><code class="javascript">document.write 只能重绘整个页面innerHTML 可以重绘页面的一部分</code></pre><h1 id="ajax过程？"><a href="#ajax过程？" class="headerlink" title="ajax过程？"></a>ajax过程？</h1><pre><code class="javascript">(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象.(2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.(3)设置响应HTTP请求状态变化的函数.(4)发送HTTP请求.(5)获取异步调用返回的数据.(6)使用JavaScript和DOM实现局部刷新.</code></pre><h1 id="请解释一下-JavaScript-的同源策略？"><a href="#请解释一下-JavaScript-的同源策略？" class="headerlink" title="请解释一下 JavaScript 的同源策略？"></a>请解释一下 JavaScript 的同源策略？</h1><pre><code class="javascript">概念:同源策略是客户端脚本（尤其是Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。指一段脚本只能读取来自同一来源的窗口和文档的属性。</code></pre><h1 id="介绍一下闭包和闭包常用场景？"><a href="#介绍一下闭包和闭包常用场景？" class="headerlink" title="介绍一下闭包和闭包常用场景？"></a>介绍一下闭包和闭包常用场景？</h1><pre><code class="javascript">闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包常见方式，就是在一个函数的内部创建另一个函数使用闭包主要为了设计私有的方法和变量，闭包的优点是可以避免变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念。闭包有三个特性：函数嵌套函数函数内部可以引用外部的参数和变量参数和变量不会被垃圾回收机制回收应用场景，设置私有变量的方法不适用场景：返回闭包的函数是个非常大的函数闭包的缺点就是常驻内存，会增大内存使用量，使用不当会造成内存泄漏</code></pre><h1 id="javascript的内存-垃圾-回收机制？"><a href="#javascript的内存-垃圾-回收机制？" class="headerlink" title="javascript的内存(垃圾)回收机制？"></a>javascript的内存(垃圾)回收机制？</h1><pre><code class="javascript">垃圾回收器会每隔一段时间找出那些不再使用的内存，然后为其释放内存一般使用标记清除方法(mark and sweep), 当变量进入环境标记为进入环境，离开环境标记为离开环境垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了还有引用计数方法(reference counting), 在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间。在IE中虽然JavaScript对象通过标记清除的方式进行垃圾回收，但BOM与DOM对象却是通过引用计数回收垃圾的， 也就是说只要涉及BOM及DOM就会出现循环引用问题。</code></pre><h1 id="事件队列（宏任务微任务）"><a href="#事件队列（宏任务微任务）" class="headerlink" title="事件队列（宏任务微任务）"></a>事件队列（宏任务微任务）</h1><pre><code class="微任务和宏任务的本质区别。">可以分为微任务（micro task）队列和宏任务（macro task）队列。微任务一般比宏任务先执行，并且微任务队列只有一个，宏任务队列可能有多个。另外我们常见的点击和键盘等事件也属于宏任务。下面我们看一下常见宏任务和常见微任务。常见宏任务：setTimeout()setInterval()setImmediate()常见微任务：promise.then()、promise.catch()new MutaionObserver()process.nextTick()微任务和宏任务的本质区别。宏任务特征：有明确的异步任务需要执行和回调；需要其他异步线程支持。微任务特征：没有明确的异步任务需要执行，只有回调；不需要其他异步线程支持。</code></pre><h1 id="async-x2F-await"><a href="#async-x2F-await" class="headerlink" title="async&#x2F;await"></a>async&#x2F;await</h1><pre><code class="javascript">async 是一个通过异步执行并隐式返回 Promise 作为结果的函数。是Generator函数的语法糖，并对Generator函数进行了改进。改进：内置执行器，无需手动执行 next() 方法。更好的语义更广的适用性：co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。返回值是 Promise，比 Generator 函数返回的 Iterator 对象方便，可以直接使用 then() 方法进行调用。async 隐式返回 Promise 作为结果的函数，那么可以简单理解为，await后面的函数执行完毕时，await会产生一个微任务(Promise.then是微任务)。</code></pre><h1 id="JavaScript-是单线程的，浏览器是多进程的"><a href="#JavaScript-是单线程的，浏览器是多进程的" class="headerlink" title="JavaScript 是单线程的，浏览器是多进程的"></a>JavaScript 是单线程的，浏览器是多进程的</h1><pre><code class="javascript">每打开一个新网页就会创建一个渲染进程渲染进程是多线程的负责页面渲染的 GUI 渲染线程负责JavaScript的执行的 JavaScript 引擎线程，负责浏览器事件循环的事件触发线程，注意这不归 JavaScript 引擎线程管负责定时器的定时触发器线程，setTimeout 中低于 4ms 的时间间隔算为4ms负责XMLHttpRequest的异步 http 请求线程GUI 渲染线程与 JavaScript 引擎线程是互斥的单线程JavaScript是因为避免 DOM 渲染的冲突，web worker 支持多线程，但是 web worker 不能访问 window 对象，document 对象等。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js中的事件</title>
      <link href="/js-base/js%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%B5%81/"/>
      <url>/js-base/js%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h1><p>事件流描述的是从页面中接收事件的顺序。在浏览器中，事件流分为三个阶段：捕获阶段、目标阶段和冒泡阶段。</p><h1 id="事件的三个阶段"><a href="#事件的三个阶段" class="headerlink" title="事件的三个阶段"></a>事件的三个阶段</h1><p>捕获阶段（Capture Phase）：事件从最外层的元素开始向内层元素逐级捕获，直到达到触发事件的目标元素。<br>目标阶段（Target Phase）：事件到达目标元素，触发事件处理函数。<br>冒泡阶段（Bubble Phase）：事件从目标元素开始向外层元素逐级冒泡，直到达到最外层的元素。</p><h1 id="事件的代理有何委托"><a href="#事件的代理有何委托" class="headerlink" title="事件的代理有何委托"></a>事件的代理有何委托</h1><p>事件代理（Event Delegation）是指将事件处理程序绑定到其父元素上，通过冒泡阶段来处理子元素触发的事件。这样可以减少事件处理程序的数量，提高性能和代码简洁度。</p><p>事件代理的优点：</p><ol><li>动态绑定：对新增的子元素也能够起作用，无需为每个子元素都绑定事件处理程序。</li><li>减少内存消耗：不需要为每个子元素都创建事件处理程序，只需一个事件处理程序即可。</li><li>提高性能：减少事件处理程序的数量，避免了大量的事件绑定和解绑操作。</li></ol><h1 id="如何派发事件"><a href="#如何派发事件" class="headerlink" title="如何派发事件"></a>如何派发事件</h1><p>在浏览器中，可以使用 JavaScript 来手动派发事件。常用的方法是使用 dispatchEvent() 方法。具体步骤如下：</p><p>创建一个合适的事件对象，可以使用 new Event(type, options) 或者 document.createEvent()。<br>使用 element.dispatchEvent(event) 方法将事件派发给指定元素。 注意：派发事件时需要确保目标元素和事件处理程序的关联，否则事件处理程序不会执行。</p><p>例如，可以创建一个点击事件并派发给按钮元素：</p><pre><code class="javascript">javascriptconst button = document.querySelector(&#39;button&#39;);const clickEvent = new Event(&#39;click&#39;);button.dispatchEvent(clickEvent);</code></pre><p>以上是基于浏览器环境中的事件派发方式，而在 Node.js 环境中，可以使用 EventEmitter API 来自定义事件，并通过 emit() 方法派发事件。</p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Array处理数据的方法总结</title>
      <link href="/js-base/js%E5%85%B3%E4%BA%8EArray%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/js-base/js%E5%85%B3%E4%BA%8EArray%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="创建数组的方式有2种"><a href="#创建数组的方式有2种" class="headerlink" title="创建数组的方式有2种"></a>创建数组的方式有2种</h1><pre><code class="javascript">1. 一种是构造函数的方式 一个是字面量的方式，最好使用字面量的方式2. 因为不管Array或者String本身也是构造函数        Array = String;        let aa = new Array(1,2,3,4,5);        console.log(aa);  //string        let bb = [1,2,3,4];        console.log(bb); //[1,2,3,4]</code></pre><h1 id="ECMAScript的数组每个槽位可以存储任意类型的数据，而且ECMAScript数组也是动态大小的，会随着数据的添加自动增长"><a href="#ECMAScript的数组每个槽位可以存储任意类型的数据，而且ECMAScript数组也是动态大小的，会随着数据的添加自动增长" class="headerlink" title="ECMAScript的数组每个槽位可以存储任意类型的数据，而且ECMAScript数组也是动态大小的，会随着数据的添加自动增长"></a>ECMAScript的数组每个槽位可以存储任意类型的数据，而且ECMAScript数组也是动态大小的，会随着数据的添加自动增长</h1><pre><code class="javascript">    let arr = [1,&#39;1&#39;,[1,2,3,4],&#123;obj1:11,obj2:[1,2,3,4]&#125;];</code></pre><h1 id="某些方法调用用会修改自身的数组"><a href="#某些方法调用用会修改自身的数组" class="headerlink" title="某些方法调用用会修改自身的数组?"></a>某些方法调用用会修改自身的数组?</h1><pre><code class="text">push(): 将一个或多个元素添加到数组的末尾，并返回新的长度。该方法会直接修改原数组。pop(): 移除并返回数组的最后一个元素。该方法会直接修改原数组。shift(): 移除并返回数组的第一个元素。该方法会直接修改原数组。unshift(): 将一个或多个元素添加到数组的开头，并返回新的长度。该方法会直接修改原数组。splice(): 在指定位置插入、删除或替换元素，并返回被删除的元素组成的新数组。该方法会直接修改原数组。sort(): 对数组进行排序。该方法会直接修改原数组。reverse(): 颠倒数组中元素的顺序。该方法会直接修改原数组。</code></pre><h1 id="数组排列位置"><a href="#数组排列位置" class="headerlink" title="数组排列位置"></a>数组排列位置</h1><pre><code class="javascript">1. 用for循环随机打乱位数组置  var Arr = [4, 1, 67, 12, 45, 121, 3];        function randArr(arr) &#123;            for (var i = 0; i &lt; arr.length; i++) &#123;                var iRand = parseInt(arr.length * Math.random());                var temp = arr[i];                arr[i] = arr[iRand];                arr[iRand] = temp;        &#125;        return arr;&#125;2. 使用sort方法错误打乱位数组置 arr.sort(function () &#123;            return (0.5 - Math.random());        &#125;);3. reverse()方法是倒序交换位置 会改变原来的数组  let newarr = arr.reverse()          console.log(newarr === arr)  //true4. 利用sort()对数组对象某个值进行升序排序 let arr = [&#123; &#39;a&#39;: 1, &#39;b&#39;: 2 &#125;, &#123; &#39;a&#39;: 466, &#39;b&#39;: 2 &#125;, &#123; &#39;a&#39;: 623, &#39;b&#39;: 2 &#125;, &#123; &#39;a&#39;: 7, &#39;b&#39;: 2 &#125;, &#123; &#39;a&#39;: 67, &#39;b&#39;: 2 &#125;]        function creatCompare(propertyName) &#123; //根据哪个属性值排序            return function (obj1, obj2) &#123;                //对象两两比较                let value1 = obj1[propertyName];                let value2 = obj2[propertyName];                if (value1 &lt; value2) &#123;                    return -1                &#125; else if (value1 &gt; value2) &#123;                    return 1                &#125; else &#123;                    return 0                &#125;            &#125;        &#125;        let newarr = arr.sort(creatCompare(&#39;a&#39;))        console.log(newarr)</code></pre><h1 id="数组的转换方法"><a href="#数组的转换方法" class="headerlink" title="数组的转换方法"></a>数组的转换方法</h1><pre><code class="javascript">1. 数组转成字符串        let color = [&#39;green&#39;,&#39;red&#39;,&#39;pink&#39;]        console.log(color.join())  // green,red,pink        console.log(color.join(&#39;,&#39;)) // green,red,pink        console.log(color.join(&#39;|&#39;))  // green|red|pink2. 以下这种方法只能转成以逗号分隔的字符串        let colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];         alert(colors.toString()); // red,blue,green        alert(colors.valueOf()); // red,blue,green        alert(colors); // red,blue,green3. 扩展：字符串转数组        console.log(color.join(&#39;|&#39;).split(&#39;|&#39;)) //[&#39;green&#39;,&#39;red&#39;,&#39;pink&#39;]</code></pre><h1 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h1><pre><code class="javascript">    let arr = [1,2,3,4];    arr.push(5); //向数组末尾添加5    let poparr = arr.pop();   //取得数组末尾的值，并且删除    console.log(arr);  //[1,2,3,4]</code></pre><h1 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h1><pre><code class="javascript">    let arr = [1,2,3,4];    let shiftarr = arr.shift(); //删除数组第一项并取得    arr.unshift(1); //向数组第一项添加    console.log(arr); // [1,2,3,4]</code></pre><h1 id="数组增删改"><a href="#数组增删改" class="headerlink" title="数组增删改"></a>数组增删改</h1><pre><code class="javascript">    let arr = [1,2,3,4]1.删除        arr.splice(1,1) //传入2个参数，第一个数数组开始位置，第二个是删除的数量    console.log(arr)   //[1,3,4] 2.插入    arr.splice(1,0,2) //传入3个参数  第一个参数是开始位置，第二个是要删除的数量，要插入的元素       console.log(arr) //[1,2,3,4]3.替换    arr.splice(3,0,4,5,6)  //方法同插入  ，在序列为3的位置后面，删除0个，添加 4，5，6    console.log(arr) //[1, 2, 3, 4, 5, 6, 4]</code></pre><h1 id="数组相关的操作方法"><a href="#数组相关的操作方法" class="headerlink" title="数组相关的操作方法"></a>数组相关的操作方法</h1><pre><code class="javascript">    let arr = [1,2,3,4,5]    1. 拼接2个数组  返回一个新的数组,不改变原来的数组    let zenarr = arr.concat(6,7,8)    console.log(zenarr) // [1, 2, 3, 4, 5, 6, 7, 8]    2. concat方法不传参数对数组进行第一层的深拷贝    let arr = [1,2,3];    let newarr = arr.concat()    3.数组截取    遵循左包，右不包    console.log(arr.slice(1))  //[2,3,4]    console.log(arr.slice(2))   //[3,4]    console.log(arr.slice(2,4)) //[3,4] 4.slice方法不传参数对数组进行第一层深拷贝    let arr = [1,2,3,4]    let slicearr = arr.slice()    console.log(slicearr) //返回跟原来一样的新数组   [1,2,3,4]</code></pre><h1 id="搜索和位置方法"><a href="#搜索和位置方法" class="headerlink" title="搜索和位置方法"></a>搜索和位置方法</h1><pre><code class="javascript">1.indexOf从索为0开始搜索   lastIndexOf从最后一项开始搜索        let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];        alert(numbers.indexOf(4)); // 3        alert(numbers.lastIndexOf(4)); // 5        alert(numbers.includes(4)); // true        alert(numbers.indexOf(4, 4)); // 5        alert(numbers.lastIndexOf(4, 4)); // 3        alert(numbers.includes(4, 7)); // false        let person = &#123; name: &quot;Nicholas&quot; &#125;;        let people = [&#123; name: &quot;Nicholas&quot; &#125;];        let morePeople = [person];        alert(people.indexOf(person)); // -1        alert(morePeople.indexOf(person)); // 0        alert(people.includes(person)); // false        alert(morePeople.includes(person)); // true2. 使用includes()方法判断数组里有无某数据          function test(fruit) &#123;        const redFruits = [&#39;apple&#39;, &#39;strawberry&#39;, &#39;cherry&#39;, &#39;cranberries&#39;];        if (redFruits.includes(fruit)) &#123;            console.log(&#39;存在&#39;);        &#125;else&#123;            console.log(&#39;不存在&#39;)        &#125;    &#125;</code></pre><h1 id="断言函数的运用"><a href="#断言函数的运用" class="headerlink" title="断言函数的运用"></a>断言函数的运用</h1><pre><code class="javascript">//找到匹配项后，这两个方法都不再继续搜索。 //可以说是查询判断里性能最好的方法        const people = [            &#123;                name: &quot;Matt&quot;,                age: 27            &#125;,            &#123;                name: &quot;Nicholas&quot;,                age: 29            &#125;        ];        alert(people.find((element, index, array) =&gt; element.age &lt; 28));        // &#123;name: &quot;Matt&quot;, age: 27&#125;        alert(people.findIndex((element, index, array) =&gt; element.age &lt; 28));        // 0//其实也可以当做循环使用        const evens = [2, 4, 6];        evens.find((element, index, array) =&gt; &#123;            console.log(element);            console.log(index);             console.log(array);            return element === 4;        &#125;);// 2// 0// [2, 4, 6]// 4// 1// [2, 4, 6]</code></pre><h1 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h1><pre><code class="text">every()：对数组每一项都运行传入的函数，如果对每一项函数都返回 true，则这个方法返回 true。filter()：对数组每一项都运行传入的函数，函数返回 true 的项会组成数组之后返回。forEach()：对数组每一项都运行传入的函数，没有返回值。map()：对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组。some()：对数组每一项都运行传入的函数，如果有一项函数返回 true，则这个方法返回 true。这些方法都不改变调用它们的数组,会重新返回一个数组</code></pre><h1 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h1><pre><code class="javascript">reduce()        //每一项都加1        let arr = [1,1,2,3,4,5]        const res = arr.reduce(function(prev,cur)&#123;            return [...prev,cur + 1]        &#125;,[])        //数组求和        const text = [&#123;            id: 1,            sex: 0        &#125;, &#123;            id: 2,            sex: 1        &#125;, &#123;            id: 3,            sex: 1        &#125;]        const res = text.reduce(function (prev, cur, index, array) &#123;            return prev + cur.id        &#125;, 0)        // 计算数组每个元素出现的次数        const arr = [1, 1, 2, 3, 4]        const rescount = arr.reduce(function (prev, cur, index, array) &#123;            if (cur in prev) &#123;                prev[cur]++            &#125; else &#123;                prev[cur] = 1            &#125;            return prev        &#125;, &#123;&#125;)                //取出最大值         const res = arr.reduce(function(prev,cur)&#123;           return prev &lt;= cur ? prev = cur : prev = prev        &#125;,0)        //数组去重        const res = arr.reduce(function(prev,cur)&#123;            return !prev.includes(cur) ? [...prev,cur] : prev        &#125;,[])        // 将二维数组转化为一维        const arrer = [[0, 1], [2, 3], [4, 5]]        const arrerres = arrer.reduce(function (prev, cur) &#123;            return prev.concat(cur)        &#125;, [])        // 将多维数组转化为一维        let arr = [[0, 1], [2, 3], [4, [5, 6, 7]]]        const newArr = function (arr) &#123;            return arr.reduce((pre, cur) =&gt; pre.concat(Array.isArray(cur) ? newArr(cur) : cur), [])        &#125;reduceRight()</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于String包装类型处理数据的总结</title>
      <link href="/js-base/js%E5%85%B3%E4%BA%8EString%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E7%9A%84%E6%80%BB%E7%BB%93/"/>
      <url>/js-base/js%E5%85%B3%E4%BA%8EString%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E7%9A%84%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="创建字符串的方式有3种"><a href="#创建字符串的方式有3种" class="headerlink" title="创建字符串的方式有3种"></a>创建字符串的方式有3种</h1><pre><code class="javascript">1. 使用单引号或双引号: 可以使用单引号（&#39;）或双引号（&quot;）来创建字符串。例如：let str = &#39;Hello World&#39;; 或 let str = &quot;Hello World&quot;2. 使用模板字面量（Template literals）：模板字面量是ES6引入的一种创建字符串的方式，使用反引号包裹字符串内容。这种方式可以包含变量和表达式，并支持多行字符串。例如：    let name = &#39;Alice&#39;;    let greeting = `Hello $&#123;name&#125;, welcome!`;3.使用String对象的构造函数：可以使用new关键字和String对象的构造函数来创建字符串。例如：let str = new String(&#39;Hello World&#39;);</code></pre><h1 id="字符串拼接-不改变原来的字符串，-返回一个新的字符串"><a href="#字符串拼接-不改变原来的字符串，-返回一个新的字符串" class="headerlink" title="字符串拼接  不改变原来的字符串， 返回一个新的字符串"></a>字符串拼接  不改变原来的字符串， 返回一个新的字符串</h1><pre><code class="javascript">1.采用concat方法    let stringvalue = &#39;hello&#39;    let result = stringvalue.concat(&#39;world&#39;) //可以接受多个参数，用逗号分开    console.log(result)  //  hello world    console.log(stringvalue) //hello     2. 采用 加号 +  实现快速拼接    let a = &#39;hello&#39;    let b = a + &#39;world&#39;    console.log(a)  // hello    console.log(b) //hello world</code></pre><h1 id="字符串提取"><a href="#字符串提取" class="headerlink" title="字符串提取"></a>字符串提取</h1><pre><code class="javascript">    let stringvalue = &#39;hello world&#39;    console.log(stringValue.slice(3)); // &quot;lo world&quot;    console.log(stringValue.substring(3)); // &quot;lo world&quot;    console.log(stringValue.substr(3)); // &quot;lo world&quot;    console.log(stringValue.slice(3, 7)); // &quot;lo w&quot;    console.log(stringValue.substring(3, 7)); // &quot;lo w&quot;    console.log(stringValue.substr(3, 7)); // &quot;lo worl&quot; //clice 单个参数是 左不包后面全要 (]        2个参数是 左不包，后包  (]//substring 单个参数是 左不包后面全要 (]         2个参数是 左包，后包   []//substr 单个参数是 左包后面全要  []           2个参数是 左包，第二个参数是截取个数  []</code></pre><h1 id="字符串位置方法"><a href="#字符串位置方法" class="headerlink" title="字符串位置方法"></a>字符串位置方法</h1><pre><code class="javascript">1. indexOf和lastIndexOf的区别就是前者是从前面开始寻找，后者是从后面开始寻找    let stringvalue = &#39;hello world&#39;    console.log(stringvalue.indexOf(&quot;o&quot;)) // 4    console.log(stringvalue.lastIndexOf(&quot;o&quot;)) // 7    传入第二个参数的时候，第二个参数代表从哪个序列开始寻找    console.log(stringValue.indexOf(&quot;o&quot;, 6)); // 7    console.log(stringValue.lastIndexOf(&quot;o&quot;, 6)); // 4 2. 寻找某段字符串里的某个字符，并全部记录它的序列位置    let stringValue = &quot;Lorem ipsum dolor sit amet, consectetur adipisicing elit&quot;;    let positions = new Array();    let pos = stringValue.indexOf(&quot;e&quot;);     while(pos &gt; -1)&#123;         positions.push(pos)        pos = stringValue.indexOf(&#39;e&#39;, pos + 1)    &#125;    console.log(positions)  // [3,24,32,35,52]</code></pre><h1 id="查看字符串里是否包含某个-字符串-或者字符"><a href="#查看字符串里是否包含某个-字符串-或者字符" class="headerlink" title="查看字符串里是否包含某个 字符串 或者字符"></a>查看字符串里是否包含某个 字符串 或者字符</h1><pre><code class="javascript">1.有三种方法可以判断      let message = &quot;foobarbaz&quot;;    console.log(message.startsWith(&quot;foo&quot;)); // true    console.log(message.startsWith(&quot;bar&quot;)); // false    console.log(message.endsWith(&quot;baz&quot;)); // true    console.log(message.endsWith(&quot;bar&quot;)); // false    console.log(message.includes(&quot;bar&quot;)); // true    console.log(message.includes(&quot;qux&quot;)); // false startsWith()检查开始于索引 0 的匹配项 endsWith()检查开始于索引(string.length - substring.length)的匹配项includes()检查整个字符串基本就是使用includes就完事了</code></pre><h1 id="trim"><a href="#trim" class="headerlink" title="trim()"></a>trim()</h1><pre><code class="javascript">    作用：删除2边空格 原字符串不受到影响 返回一个新的字符串    let stringValue = &quot; hello world &quot;;    let trimmedStringValue = stringValue.trim();    console.log(stringValue); // &quot; hello world &quot;    console.log(trimmedStringValue); // &quot;hello world&quot; 扩展：trimLeft()和 trimRight()方法分别用于从字符串开始和末尾清理空格符。</code></pre><h1 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h1><pre><code class="javascript">    作用：复制多次字符串 原字符串不受影响  返回一个新的字符串    let stringvalue = &#39;ha&#39;    console.log(stringvalue.repeat(12).concat(&#39; yyyy&#39;))  // hahahahahahahahahahahaha yyyy扩展：padStart()和 padEnd()方法会复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件。这两个方法的第一个参数是长度，第二个参数是可选的填充字符串，默认为空格</code></pre><h1 id="字符串迭代与解构简单的运用，原理参考js高程"><a href="#字符串迭代与解构简单的运用，原理参考js高程" class="headerlink" title="字符串迭代与解构简单的运用，原理参考js高程"></a>字符串迭代与解构简单的运用，原理参考js高程</h1><pre><code class="javascript">    let arr = []    let str = &#39;asddd&#39;    arr = [...str]    console.log(arr)  //[&quot;a&quot;, &quot;s&quot;, &quot;d&quot;, &quot;d&quot;, &quot;d&quot;]</code></pre><h1 id="字符串大小转换"><a href="#字符串大小转换" class="headerlink" title="字符串大小转换"></a>字符串大小转换</h1><pre><code class="javascript">    let stringValue = &quot;hello world&quot;;    console.log(stringValue.toLocaleUpperCase()); // &quot;HELLO WORLD&quot;    console.log(stringValue.toUpperCase()); // &quot;HELLO WORLD&quot;    console.log(stringValue.toLocaleLowerCase()); // &quot;hello world&quot;    console.log(stringValue.toLowerCase()); // &quot;hello world&quot; 原来就有的是 toUpperCase 和 toLowerCase ，但是在很多地区，地区特定的方法与通用的方法是一样的。但在少数语言中（如土耳其语），Unicode 大小写转换需应用特殊规则，要使用地区特定的方法才能实现正确转换。推荐使用 toLocaleUpperCase 和 toLocaleLowerCase记忆方法是一个是Up是向上 就是放大</code></pre><h1 id="字符串替换-简单用法"><a href="#字符串替换-简单用法" class="headerlink" title="字符串替换  简单用法"></a>字符串替换  简单用法</h1><pre><code class="javascript">    let text = &quot;cat, bat, sat, fat&quot;;    let result = text.replace(&quot;at&quot;, &quot;ond&quot;);    console.log(result); // &quot;cond, bat, sat, fat&quot;    配合正则表达式的高级用法    result = text.replace(/a t/g, &quot;ond&quot;);    console.log(result); // &quot;cond, bond, sond, fond&quot; </code></pre><h1 id="计算输入的字符个数"><a href="#计算输入的字符个数" class="headerlink" title="计算输入的字符个数"></a>计算输入的字符个数</h1><pre><code class="javascript">    getByteLen(val) &#123;        var len = 0        for (var i = 0; i &lt; val.length; i++) &#123;        var a = val.charAt(i)        if (a.match(/[^\x00-\xff]/gi) != null) &#123;            len += 2        &#125; else &#123;            len += 1        &#125;        &#125;        return len    &#125;</code></pre><h1 id="实现方法为将字符串按某个字符切割成若干个字符串，并以数组形式返回"><a href="#实现方法为将字符串按某个字符切割成若干个字符串，并以数组形式返回" class="headerlink" title="实现方法为将字符串按某个字符切割成若干个字符串，并以数组形式返回"></a>实现方法为将字符串按某个字符切割成若干个字符串，并以数组形式返回</h1><pre><code class="javascript">    var s = &quot;abc,abcd,aaa&quot;;    ss = s.split(&quot;,&quot;);// 在每个逗号(,)处进行分解  [&quot;abc&quot;, &quot;abcd&quot;, &quot;aaa&quot;]    var s1 = &quot;helloworld&quot;;    ss1 = s1.split(&#39;&#39;);  //[&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;, &quot;w&quot;, &quot;o&quot;, &quot;r&quot;, &quot;l&quot;, &quot;d&quot;]</code></pre><h1 id="其它方法"><a href="#其它方法" class="headerlink" title="其它方法"></a>其它方法</h1><pre><code class="javascript">    let mseesage = new String(&#39;hello&#39;)    console.log(mseesage.length)  //返回字符串的长度  5    console.log(mseesage.charAt(0))  //返回某个索引值  h    console.log(mseesage.charCodeAt(0))  //字符编码  h的字符编码是108</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈call和apply和bind</title>
      <link href="/js-base/js%E6%B5%85%E8%B0%88call%E5%92%8Capply%E5%92%8Cbind/"/>
      <url>/js-base/js%E6%B5%85%E8%B0%88call%E5%92%8Capply%E5%92%8Cbind/</url>
      
        <content type="html"><![CDATA[<h1 id="call-x2F-apply-x2F-bind-的作用"><a href="#call-x2F-apply-x2F-bind-的作用" class="headerlink" title="call&#x2F;apply&#x2F;bind 的作用"></a>call&#x2F;apply&#x2F;bind 的作用</h1><ol><li><p>call、apply和bind 都是 JavaScript 中用于改变函数执行上下文（Context）的方法。</p></li><li><p>先来解释下什么是执行上下文<br>JavaScript中的执行上下文（Execution Context）是指代码被执行时的环境。每当JavaScript代码执行时，都会创建一个执行上下文，并且这些执行上下文可以组成一个执行上下文栈（Execution Context Stack）。</p></li></ol><p>2.1执行上下文包含了以下三个重要的组成部分：</p><p>2.1.1变量对象（Variable Object）：用于存储在上下文中定义的变量、函数声明和函数参数。它包括函数的形参、函数声明、变量声明等。<br>2.1.2作用域链（Scope Chain）：作用域链是一个由当前执行上下文的变量对象和所有外部环境的变量对象组成的链。它用来查找和解析变量和函数标识符。<br>2.1.3this 值：this 值指定了函数的执行上下文中的当前对象，它根据函数的调用方式动态绑定。</p><ol start="3"><li>执行上下文的生命周期可以总结为以下几个阶段：</li></ol><p>3.1 创建阶段（Creation Phase）：在进入执行阶段之前，JavaScript 引擎会先创建执行上下文。</p><p>3.1.1创建变量对象<br>3.1.2建立作用域链<br>3.1.3确定 this 的指向</p><p>3.2 执行阶段（Execution Phase）：执行阶段是执行上下文中实际执行代码的阶段。</p><p>3.2.1 执行代码，逐行执行</p><p>每当函数调用时，都会创建一个新的执行上下文，并将其推入执行上下文栈的顶部。当函数执行完毕后，其执行上下文会从栈中弹出，控制权会回到调用该函数的执行上下文。</p><p>了解和理解执行上下文对于理解 JavaScript 中的变量作用域、作用域链以及 this 的指向等都非常重要。</p><h1 id="call-x2F-apply-x2F-bind-的使用"><a href="#call-x2F-apply-x2F-bind-的使用" class="headerlink" title="call&#x2F;apply&#x2F;bind 的使用"></a>call&#x2F;apply&#x2F;bind 的使用</h1><pre><code class="javascript">1. call: call 方法可以在指定的上下文中调用函数，并且可以传入多个参数。function greet(name) &#123;  console.log(`Hello, $&#123;name&#125;!`);&#125;greet.call(null, &#39;Alice&#39;); // 输出：Hello, Alice!在上述例子中，我们使用 call 方法将函数 greet 在 null 上下文中进行调用，并传入参数 &#39;Alice&#39;。2. apply: apply 方法与 call 类似，也可以在指定的上下文中调用函数，但参数以数组的形式传递。function greet(name, age) &#123;  console.log(`Hello, $&#123;name&#125;! You are $&#123;age&#125; years old.`);&#125;greet.apply(null, [&#39;Alice&#39;, 25]); // 输出：Hello, Alice! You are 25 years old.在上述例子中，我们使用 apply 方法将函数 greet 在 null 上下文中进行调用，并传入参数 &#39;Alice&#39; 和 25，这两个参数被放在一个数组中传递给 apply 方法。3. bind: bind 方法不会立即调用函数，而是创建一个新函数，并将指定的上下文绑定到该函数。绑定后的函数可以稍后调用，并传入参数。function greet(name) &#123;  console.log(`Hello, $&#123;name&#125;!`);&#125;const greetAlice = greet.bind(null, &#39;Alice&#39;);greetAlice(); // 输出：Hello, Alice!在上述例子中，我们使用 bind 方法将函数 greet 绑定到 null 上下文，同时传入参数 &#39;Alice&#39;。返回的绑定后的函数 greetAlice 可以在稍后的时候执行，而不需要再次传入参数。</code></pre><h1 id="call的模拟实现"><a href="#call的模拟实现" class="headerlink" title="call的模拟实现"></a>call的模拟实现</h1><pre><code class="javascript">// 模拟实现call方法Function.prototype.myCall = function (context, ...args) &#123;  // 判断是否传入了上下文，若未传入，默认为全局对象window  context = context || window;  // 将当前函数设为上下文对象的一个属性  context.fn = this;  // 调用函数并传入参数  const result = context.fn(...args);  // 删除临时添加的函数属性  delete context.fn;  // 返回函数执行结果  return result;&#125;;</code></pre><h1 id="apply的模拟实现"><a href="#apply的模拟实现" class="headerlink" title="apply的模拟实现"></a>apply的模拟实现</h1><pre><code class="javascript">// 模拟实现apply方法Function.prototype.myApply = function (context, args) &#123;  // 判断是否传入了上下文，若未传入，默认为全局对象window  context = context || window;  // 将当前函数设为上下文对象的一个属性  context.fn = this;  // 调用函数并传入参数  const result = context.fn(...args);  // 删除临时添加的函数属性  delete context.fn;  // 返回函数执行结果  return result;&#125;;</code></pre><h1 id="bind的模拟实现"><a href="#bind的模拟实现" class="headerlink" title="bind的模拟实现"></a>bind的模拟实现</h1><pre><code class="javascript">Function.prototype.myBind = function (context, ...args) &#123;  const fn = this; // 当前函数  return function (...innerArgs) &#123;    return fn.apply(context, [...args, ...innerArgs]);  &#125;;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js原型，原型链</title>
      <link href="/js-base/js%E5%8E%9F%E5%9E%8B%EF%BC%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
      <url>/js-base/js%E5%8E%9F%E5%9E%8B%EF%BC%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="原型规则"><a href="#原型规则" class="headerlink" title="原型规则"></a>原型规则</h1><ol><li>所有的引用类型(数组、函数、对象)都具有对象特性，即可自由扩展属性</li><li>所有的引用类型(数组、对象、函数)有一个__proto__ 属性，属性值是一个普通的对象</li><li>所有的函数都有一个prototype属性，属性值也是一个普通的对象</li><li>所有的引用类型(数组、对象、函数),__proto__属性指向它的构造函数的prototype属性</li><li>当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么回去他的__proto__(即它的构造函数的prototype中寻找)</li></ol><h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><pre><code class="javascript">function Person(name)&#123;    this.name = name&#125;let obj = new Person(&#39;jack&#39;)console.log(obj.__proto__ == Person.prototype)console.log(Person.prototype.__proto__ == Object.prototype)console.log(Object.prototype__proto__ == null)// 其实原始类型的__proto__  也是 Object.prototypeconsole.log(String.prototype__proto__ == Object.prototype)</code></pre><h1 id="图解原型链"><a href="#图解原型链" class="headerlink" title="图解原型链"></a>图解原型链</h1><p><img data-src="/images/fe/yxl.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组扁平化</title>
      <link href="/js-base/%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96/"/>
      <url>/js-base/%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<pre><code class="javascript">let arr = [1, [2, [3, 4, 5]]]// 1.递归function flatten(arr) &#123;    let newarr = [];    for (let i = 0; i &lt; arr.length; i++) &#123;        const element = arr[i];        if (Array.isArray(element)) &#123;            newarr = newarr.concat(flatten(element))        &#125; else &#123;            newarr.push(element)        &#125;    &#125;    return newarr&#125;// 2.reducefunction flatten(arr) &#123;    // reduce特点：能够把返回值给到下一次遍历的pre    return arr.reduce((pre, cur) =&gt; &#123;        return pre.concat(Array.isArray(cur) ? flatten(cur) : cur)    &#125;, [])&#125;// 3.toString + split  function flatten(arr) &#123;    // return arr.toString() // 1,2,3,4,5    return arr.toString().split(&#39;,&#39;) // [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;]&#125;// 4. 不用递归使用循环直接判断数组是不是包含数组function flatten(arr) &#123;    while (arr.some(arr =&gt; Array.isArray(arr))) &#123;        arr = [].concat(...arr)    &#125;    return arr&#125;//5.es6提供flat Infinity无限次console.log(arr.flat(Infinity))// 6.正则function flatten(arr) &#123;    let str = JSON.z(arr);    str = str.replace(/(\[|\])/g, &quot;&quot;);    str = &quot;[&quot; + str + &quot;]&quot;;    return JSON.parse(str);&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Promise</title>
      <link href="/js-base/promise/"/>
      <url>/js-base/promise/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是promise"><a href="#什么是promise" class="headerlink" title="什么是promise"></a>什么是promise</h1><p>Promise 是异步编程的一种解决方案： 从语法上讲，promise是一个对象，从它可以获取异步操作的消息；从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。 promise有三种状态：**pending(等待态)，fulfiled(成功态)，rejected(失败态)**；状态一旦改变，就不会再变。创造promise实例后，它会立即执行</p><h1 id="promise用来解决什么问题"><a href="#promise用来解决什么问题" class="headerlink" title="promise用来解决什么问题"></a>promise用来解决什么问题</h1><ol><li>回调地狱（Callback Hell）：在多个异步操作嵌套执行的情况下，使用传统的回调函数会导致代码结构混乱、可读性差，并且难以维护。Promise 可以通过链式调用的方式，使代码更加清晰易读，避免回调地狱的问题。</li><li>统一返回错误处理 catch </li><li>统一返回处理结果 then</li><li>并行异步操作的协调：有些场景下，需要同时执行多个异步操作，并在所有操作完成后进行进一步处理。Promise 提供了 Promise.all 方法，可以接收一个包含多个 Promise 对象的数组，并在所有 Promise 对象都成功解决后才返回结果，这样可以方便地协调并行异步操作。 </li><li>多个异步操作的竞态条件控制：有时候需要多个异步操作并发执行，但只需要获取最先完成的结果。Promise 提供了 Promise.race 方法，可以接收一个包含多个 Promise 对象的数组，并在其中任何一个 Promise 对象首次解决或拒绝后即返回结果，方便控制竞态条件。</li></ol><h1 id="promise的基础用法"><a href="#promise的基础用法" class="headerlink" title="promise的基础用法"></a>promise的基础用法</h1><pre><code class="javascript">1： Promise是一个构造函数，自己身上有all、reject、resolve这几个眼熟的方法，原型上有then、catch等同样很眼熟的方法。      let p = new Promise((resolve, reject) =&gt; &#123;          //执行异步操作          setTimeout(() =&gt; &#123;              console.log(&#39;执行完成&#39;)              resolve(&#39;我是成功！！&#39;)          &#125;, 2000);      &#125;)上段代码会直接执行 2秒后输出 &#39;执行完成&#39;Promise的构造函数接收一个参数：函数，并且这个函数需要传入两个参数：resolve：异步操作执行成功后的回调函数reject：异步操作执行失败后的回调函数2：then 链式操作的用法  从表面上看，Promise只是能够简化层层回调的写法，而实质上，Promise的精髓是“状态”，用维护状态、传递状态的方式来使得回调函数能够及时调用，它比传递callback函数要简单、灵活的多。所以使用Promise的正确场景是这样的：      p.then((data) =&gt; &#123;          console.log(data)      &#125;)3：reject的用法 把Promise的状态置为rejected，这样我们在then中就能捕捉到，然后执行“失败”情况的回调。看下面的代码。      let p = new Promise((resolve, reject) =&gt; &#123;          //执行异步操作          setTimeout(() =&gt; &#123;              let num = Math.ceil(Math.random()*10) //生成1 - 10的随机数               if(num &lt;= 5)&#123;                   resolve(num)               &#125;else&#123;                   reject(&#39;数字是大于5的&#39;)               &#125;          &#125;, 1000);      &#125;)      p.then((data) =&gt; &#123;          console.log(&#39;resolve&#39;,data)      &#125;,(err) =&gt; &#123;          console.log(&#39;rejeced&#39;,err)      &#125;)产生以一个随机数，如果大于5就会使用reject  错误(err)输出&#39;数字是大于5&#39;4：catch的用法 (前面的代码有错误可以报出来，不要promise是无法执行下来的)我们知道Promise对象除了then方法，还有一个catch方法，它是做什么用的呢？其实它和then的第二个参数一样，用来指定reject的回调。用法是这样：      let p = new Promise((resolve, reject) =&gt; &#123;          //执行异步操作          setTimeout(() =&gt; &#123;              let num = Math.ceil(Math.random()*10) //生成1 - 10的随机数               if(num &lt;= 5)&#123;                   resolve(num)               &#125;else&#123;                   reject(&#39;数字是大于5的&#39;)               &#125;          &#125;, 1000);      &#125;)      p.then((data) =&gt; &#123;          console.log(&#39;resolve&#39;,data)  // 假设随机数是 3  那么输出 resolve 为 3          console.log(aaaa)  //aaaa是没有被定义的      &#125;,(err) =&gt; &#123;          console.log(&#39;rejeced&#39;,err)      &#125;).catch((err) =&gt; &#123;          console.log(&#39;rejeced&#39;,err)  //  这里报错 ： rejeced ReferenceError: aaaa is not defined      &#125;)在resolve的回调中，我们console.log(somedata);而aaaa这个变量是没有被定义的。如果我们不用Promise，代码运行到这里就直接在控制台报错了，不往下运行了。</code></pre><h1 id="all的用法"><a href="#all的用法" class="headerlink" title="all的用法"></a>all的用法</h1><pre><code class="javascript">1:all的用法：谁跑的慢，以谁为准执行回调。all接收一个数组参数，里面的值最终都算返回Promise对象2:Promise的all方法提供了并行执行异步操作的能力，并且在所有异步操作执行完后才执行回调。看下面的例子：        let promise1 = new Promise((resolve, reject) =&gt; &#123;            setTimeout(() =&gt; &#123;                var num = Math.ceil(Math.random() * 10); //生成1-10的随机数                if (num &lt;= 5) &#123;                    resolve(num);                &#125;                else &#123;                    reject(&#39;数字太大了1&#39;);                &#125;            &#125;)        &#125;)        let promise2 = new Promise((resolve, reject) =&gt; &#123;            setTimeout(() =&gt; &#123;                var num = Math.ceil(Math.random() * 10); //生成1-10的随机数                if (num &lt;= 5) &#123;                    resolve(num);                &#125;                else &#123;                    reject(&#39;数字太大了2&#39;);                &#125;            &#125;)        &#125;)        let promise3 = new Promise((resolve, reject) =&gt; &#123;            setTimeout(() =&gt; &#123;                var num = Math.ceil(Math.random() * 10); //生成1-10的随机数                if (num &lt;= 5) &#123;                    resolve(num);                &#125;                else &#123;                    reject(&#39;数字太大了3&#39;);                &#125;            &#125;)        &#125;)        let p = Promise.all([promise1, promise2, promise3])        p.then(function (res) &#123;            //三个都成功则成功 res返回 [p1,p2,p3] 结果的数组            console.log(res)        &#125;, function (err) &#123;            //只要有失败，则失败  err 返回在哪个promise失败的回调            console.log(err)        &#125;)有了all，你就可以并行执行多个异步操作，并且在一个回调中处理所有的返回数据，是不是很酷？有一个场景是很适合用这个的，一些游戏类的素材比较多的应用，打开网页时，预先加载需要用到的各种资源如图片、flash以及各种静态文件。所有的都加载完后，我们再进行页面的初始化。</code></pre><h1 id="race的用法"><a href="#race的用法" class="headerlink" title="race的用法"></a>race的用法</h1><pre><code class="javascript">1:race的用法：谁跑的快，以谁为准执行回调2：race的使用场景：比如我们可以用race给某个异步请求设置超时时间，并且在超时后执行相应的操作，代码如下        //请求某个图片资源        function requestImg() &#123;            var p = new Promise((resolve, reject) =&gt; &#123;                var img = new Image();                img.onload = function () &#123;                    resolve(img);                &#125;                img.src = &#39;图片的路径&#39;;            &#125;);            return p;        &#125;        //延时函数，用于给请求计时        function timeout() &#123;            var p = new Promise((resolve, reject) =&gt; &#123;                setTimeout(() =&gt; &#123;                    reject(&#39;图片请求超时&#39;);                &#125;, 5000);            &#125;);            return p;        &#125;        Promise.race([requestImg(), timeout()]).then((data) =&gt; &#123;            console.log(data);        &#125;).catch((err) =&gt; &#123;            console.log(err);        &#125;);requestImg函数会异步请求一张图片，我把地址写为&quot;图片的路径&quot;，所以肯定是无法成功请求到的。timeout函数是一个延时5秒的异步操作。我们把这两个返回Promise对象的函数放进race，于是他俩就会赛跑，如果5秒之内图片请求成功了，那么遍进入then方法，执行正常的流程。如果5秒钟图片还未成功返回，那么timeout就跑赢了，则进入catch，报出“图片请求超时”的信息。</code></pre><h1 id="promise-上有哪些方法"><a href="#promise-上有哪些方法" class="headerlink" title="promise 上有哪些方法"></a>promise 上有哪些方法</h1><ol><li><p>Promise.prototype.then(onFulfilled, onRejected)：添加对 Promise 成功或失败状态的处理函数。onFulfilled 是当 Promise 成功时执行的回调函数，onRejected 是当 Promise 失败时执行的回调函数。该方法返回一个新的 Promise 对象，可以通过链式调用 then 方法来实现对异步操作的连续处理。</p></li><li><p>Promise.prototype.catch(onRejected)：添加对 Promise 失败状态的处理函数。相当于调用 then(undefined, onRejected)。该方法也返回一个新的 Promise 对象。</p></li><li><p>Promise.prototype.finally(onFinally)：添加一个回调函数，在 Promise 执行结束后无论成功或失败都会执行该函数。可以用于清理工作或处理一些需要在最后执行的逻辑。该方法返回一个新的 Promise 对象。</p></li><li><p>Promise.resolve(value)：返回一个以给定值解析后的 Promise 对象。如果给定的值是一个 Promise 对象，则直接返回该对象，否则创建一个新的 Promise 对象并使用给定的值进行解析。</p></li><li><p>Promise.reject(reason)：返回一个以给定原因拒绝的 Promise 对象。</p></li><li><p>Promise.all(iterable)：接收一个可迭代对象（例如数组或类数组对象），并返回一个新的 Promise 对象。该 Promise 对象在所有输入的 Promise 对象都成功解析后才会成功解析，并将解析结果按顺序作为数组传递。如果其中任何一个 Promise 对象失败，则整个 Promise.all 操作会立即失败。</p></li><li><p>Promise.race(iterable)：接收一个可迭代对象，并返回一个新的 Promise 对象。该 Promise 对象在输入的 Promise 对象中有任何一个完成（无论成功或失败）时就会完成，并采用第一个完成的 Promise 的结果。</p></li><li><p>Promise.allSettled(iterable)：接收一个可迭代对象，并返回一个新的 Promise 对象。该 Promise 对象在所有输入的 Promise 对象都完成后才会完成，不管是成功还是失败，结果会作为数组传递给回调函数。</p></li><li><p>Promise.any(iterable)：接收一个可迭代对象，并返回一个新的 Promise 对象。该 Promise 对象在输入的 Promise 对象中有任何一个成功解析时就会成功解析，并采用第一个成功解析的 Promise 的结果。如果所有 Promise 都失败，则整个 Promise.any 操作会立即失败。</p></li></ol><h1 id="手写一个promise"><a href="#手写一个promise" class="headerlink" title="手写一个promise"></a>手写一个promise</h1><pre><code class="javascript">    // 三种状态    const PENDING = &quot;pending&quot;;    const RESOLVED = &quot;resolved&quot;;    const REJECTED = &quot;rejected&quot;;    // promise 接收⼀个函数参数，该函数会⽴即执⾏    function MyPromise(fn) &#123;        let _this = this;        _this.currentState = PENDING;        _this.value = undefined;        // ⽤于保存 then 中的回调，只有当 promise        // 状态为 pending 时才会缓存，并且每个实例⾄多缓存⼀个        _this.resolvedCallbacks = [];        _this.rejectedCallbacks = [];        _this.resolve = function (value) &#123;            if (value instanceof MyPromise) &#123;                // 如果 value 是个 Promise，递归执⾏                return value.then(_this.resolve, _this.reject)            &#125;            setTimeout(() =&gt; &#123; // 异步执⾏，保证执⾏顺序                if (_this.currentState === PENDING) &#123;                    _this.currentState = RESOLVED;                    _this.value = value;                    _this.resolvedCallbacks.forEach(cb =&gt; cb());                &#125;            &#125;)        &#125;;        _this.reject = function (reason) &#123;            setTimeout(() =&gt; &#123; // 异步执⾏，保证执⾏顺序                if (_this.currentState === PENDING) &#123;                    _this.currentState = REJECTED;                    _this.value = reason;                    _this.rejectedCallbacks.forEach(cb =&gt; cb());                &#125;            &#125;)        &#125;        // ⽤于解决以下问题        // new Promise(() =&gt; throw Error(&#39;error))        try &#123;            fn(_this.resolve, _this.reject);        &#125; catch (e) &#123;            _this.reject(e);        &#125;    &#125;    MyPromise.prototype.then = function (onResolved, onRejected) &#123;        var self = this;        // 规范 2.2.7，then 必须返回⼀个新的 promise        var promise2;        // 规范 2.2.onResolved 和 onRejected 都为可选参数        // 如果类型不是函数需要忽略，同时也实现了透传        // Promise.resolve(4).then().then((value) =&gt; console.log(value))        onResolved = typeof onResolved === &#39;function&#39; ? onResolved : v =&gt; v;        onRejected = typeof onRejected === &#39;function&#39; ? onRejected : r =&gt; r        if (self.currentState === RESOLVED) &#123;            return (promise2 = new MyPromise(function (resolve, reject) &#123;                // 规范 2.2.4，保证 onFulfilled，onRjected 异步执⾏                // 所以⽤了 setTimeout 包裹下                setTimeout(function () &#123;                    try &#123;                        var x = onResolved(self.value);                        resolutionProcedure(promise2, x, resolve, reject);                    &#125; catch (reason) &#123;                        reject(reason);                    &#125;                &#125;);            &#125;));        &#125;        if (self.currentState === REJECTED) &#123;            return (promise2 = new MyPromise(function (resolve, reject) &#123;                setTimeout(function () &#123;                    // 异步执⾏onRejected                    try &#123;                        var x = onRejected(self.value);                        resolutionProcedure(promise2, x, resolve, reject);                    &#125; catch (reason) &#123;                        reject(reason);                    &#125;                &#125;);            &#125;));        &#125;        if (self.currentState === PENDING) &#123;            return (promise2 = new MyPromise(function (resolve, reject) &#123;                self.resolvedCallbacks.push(function () &#123;                    // 考虑到可能会有报错，所以使⽤ try/catch 包裹                    try &#123;                        var x = onResolved(self.value);                        resolutionProcedure(promise2, x, resolve, reject);                    &#125; catch (r) &#123;                        reject(r);                    &#125;                &#125;);                self.rejectedCallbacks.push(function () &#123;                    try &#123;                        var x = onRejected(self.value);                        resolutionProcedure(promise2, x, resolve, reject);                    &#125; catch (r) &#123;                        reject(r);                    &#125;                &#125;);            &#125;));        &#125;    &#125;;</code></pre><h1 id="promise经典案例加深理解"><a href="#promise经典案例加深理解" class="headerlink" title="promise经典案例加深理解"></a>promise经典案例加深理解</h1><pre><code class="javascript">1.const promise = new Promise((resolve, reject) =&gt; &#123;  console.log(1)  resolve()  console.log(2)&#125;)promise.then(() =&gt; &#123;  console.log(3)&#125;)console.log(4)输出:  1 2 4 3解释:  Promise构造函数是同步执行的,promsie.then 中的函数是异步执行的 </code></pre><pre><code class="javascript">2.const promise1 = new Promise((resolve, reject) =&gt; &#123;  setTimeout(() =&gt; &#123;    resolve(&#39;success&#39;)  &#125;, 1000)&#125;)const promise2 = promise1.then(() =&gt; &#123;  throw new Error(&#39;error!!!&#39;)&#125;)console.log(&#39;promise1&#39;, promise1)console.log(&#39;promise2&#39;, promise2)setTimeout(() =&gt; &#123;  console.log(&#39;promise1&#39;, promise1)  console.log(&#39;promise2&#39;, promise2)&#125;, 2000)输出:promise1 Promise &#123; &lt;pending&gt; &#125;promise2 Promise &#123; &lt;pending&gt; &#125;promise1 Promise &#123; &lt;fulfilled&gt;: &quot;success&quot; &#125;promise2 Promise &#123; &lt;rejected&gt;: Error: error!!! at promise1.then (…) &#125;解释：创建 Promise promise1，1 秒后变为已兑现状态。使用 then 方法将回调函数添加到 promise1 上并创建了 promise2。在第一轮事件循环结束前，打印 promise1 和 promise2，它们都是待定状态。在第二轮事件循环开始时，promise1 变为已兑现状态，promise2 变为已拒绝状态。</code></pre><pre><code class="javascript">3.const promise = new Promise((resolve, reject) =&gt; &#123;  resolve(&#39;success1&#39;)  reject(&#39;error&#39;)  resolve(&#39;success2&#39;)&#125;)promise  .then((res) =&gt; &#123;    console.log(&#39;then: &#39;, res)  &#125;)  .catch((err) =&gt; &#123;    console.log(&#39;catch: &#39;, err)  &#125;)输出: success1解释：构造函数中的 resolve 或 reject 只有第一次执行有效，多次调用没有任何作用，呼应代码二结论：promise 状态一旦改变则不能再变。</code></pre><pre><code class="javascript">4.Promise.resolve(1)  .then((res) =&gt; &#123;    console.log(res)    return 2  &#125;)  .catch((err) =&gt; &#123;    return 3  &#125;)  .then((res) =&gt; &#123;    console.log(res)  &#125;)输出:  1,2解释：promise 可以链式调用。提起链式调用我们通常会想到通过 return this 实现，不过 Promise 并不是这样实现的。promise 每次调用 .then 或者 .catch 都会返回一个新的 promise，从而实现了链式调用。</code></pre><pre><code class="javascript">5.const promise = new Promise((resolve, reject) =&gt; &#123;  setTimeout(() =&gt; &#123;    console.log(&#39;once&#39;)    resolve(&#39;success&#39;)  &#125;, 1000)&#125;)const start = Date.now()promise.then((res) =&gt; &#123;  console.log(res, Date.now() - start)&#125;)promise.then((res) =&gt; &#123;  console.log(res, Date.now() - start)&#125;)输出:oncesuccess 1000success 1000解释：promise 的 .then 或者 .catch 可以被调用多次，但这里 Promise 构造函数只执行一次。或者说 promise 内部状态一经改变，并且有了一个值，那么后续每次调用 .then 或者 .catch 都会直接拿到该值</code></pre><pre><code class="javascript">6.Promise.resolve()  .then(() =&gt; &#123;    return new Error(&#39;error!!!&#39;)  &#125;)  .then((res) =&gt; &#123;    console.log(&#39;then: &#39;, res)  &#125;)  .catch((err) =&gt; &#123;    console.log(&#39;catch: &#39;, err)  &#125;)输出:then: Error: error!!!    at Promise.resolve.then (...)    at ...                             解释：.then 或者 .catch 中 return 一个 error 对象并不会抛出错误，所以不会被后续的 .catch 捕获，需要改成其中一种：                                                       </code></pre><pre><code class="javascript">7.const promise = Promise.resolve()  .then(() =&gt; &#123;    return promise  &#125;)promise.catch(console.error)输出:TypeError: Chaining cycle detected for promise #&lt;Promise&gt;    at &lt;anonymous&gt;    at process._tickCallback (internal/process/next_tick.js:188:7)    at Function.Module.runMain (module.js:667:11)    at startup (bootstrap_node.js:187:16)    at bootstrap_node.js:607:3解释：.then 或 .catch 返回的值不能是 promise 本身，否则会造成死循环。类似于：process.nextTick(function tick () &#123;  console.log(&#39;tick&#39;)  process.nextTick(tick)&#125;)</code></pre><pre><code class="javascript">8.Promise.resolve(1)  .then(2)  .then(Promise.resolve(3))  .then(console.log)输出: 1解释：.then 或者 .catch 的参数期望是函数，传入非函数则会发生值穿透。</code></pre><pre><code class="javascript">9.Promise.resolve()  .then(function success (res) &#123;    throw new Error(&#39;error&#39;)  &#125;, function fail1 (e) &#123;    console.error(&#39;fail1: &#39;, e)  &#125;)  .catch(function fail2 (e) &#123;    console.error(&#39;fail2: &#39;, e)  &#125;)输出:fail2: Error: error    at success (...)    at ...                解释：.then 可以接收两个参数，第一个是处理成功的函数，第二个是处理错误的函数。.catch 是 .then 第二个参数的简便写法，但是它们用法上有一点需要注意：.then 的第二个处理错误的函数捕获不了第一个处理成功的函数抛出的错误，而后续的 .catch 可以捕获之前的错误。当然以下代码也可以：            </code></pre><pre><code class="javascript">10.process.nextTick(() =&gt; &#123;  console.log(&#39;nextTick&#39;)&#125;)Promise.resolve()  .then(() =&gt; &#123;    console.log(&#39;then&#39;)  &#125;)setImmediate(() =&gt; &#123;  console.log(&#39;setImmediate&#39;)&#125;)console.log(&#39;end&#39;)输出:endnextTickthensetImmediate解释：process.nextTick 和 promise.then 都属于 microtask，而 setImmediate 属于 macrotask，在事件循环的 check 阶段执行。事件循环的每个阶段（macrotask）之间都会执行 microtask，事件循环的开始会先执行一次 microtask。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css性能优化篇</title>
      <link href="/performance-optimization/css%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AF%87/"/>
      <url>/performance-optimization/css%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="加载性能"><a href="#加载性能" class="headerlink" title="加载性能"></a>加载性能</h1><pre><code class="text">（1）合并和压缩 CSS 文件以减少文件大小。（2）css单一样式：当需要下边距和左边距的时候，很多时候选择:margin:top 0 bottom 0;但margin-bottom:bottom;margin-left:left;执行的效率更高。（3）减少使用@import,而建议使用link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。（4）延迟或异步加载 CSS 文件，特别是对于首屏渲染来说。（5）使用 CDN（内容分发网络）来加速 CSS 文件的加载。（6）利用浏览器缓存机制，设置适当的缓存头信息。</code></pre><h1 id="选择器性能"><a href="#选择器性能" class="headerlink" title="选择器性能"></a>选择器性能</h1><pre><code class="text">（1）关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）。CSS选择符是从右到左进行匹配的。当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素等等；（2）如果规则拥有ID选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）。（3）避免使用通配规则，如*&#123;&#125;计算次数惊人！只对需要用到的元素进行选择。（4）尽量少的去对标签进行选择，而是用class。（5）尽量少的去使用后代选择器，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素。（6）了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则。</code></pre><h1 id="渲染性能"><a href="#渲染性能" class="headerlink" title="渲染性能"></a>渲染性能</h1><pre><code class="text">（1）慎重使用高性能属性：浮动、定位。（2）最小化重绘和重排操作，尽量在一次渲染中完成所有样式的修改。（3）去除空规则：｛｝。空规则的产生原因一般来说是为了预留样式。去除这些空规则无疑能减少css文档体积。（4）属性值为0时，不加单位。（5）属性值为浮动小数0.**，可以省略小数点之前的0。（6）标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。（7）不使用@import前缀，它会影响css的加载速度。（8）选择器优化嵌套，尽量避免层级过深。（9）css雪碧图，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清楚，再使用。（10）正确使用display的属性，由于display的作用，某些样式组合会无效，徒增样式体积的同时也影响解析性能。（11）不滥用web字体。对于中文网站来说WebFonts可能很陌生，国外却很流行。web fonts通常体积庞大，而且一些浏览器在下载web fonts时会阻塞页面渲染损伤性能。（12）使用硬件加速特性（如 transform 和 opacity）来提高动画的性能。</code></pre><h1 id="可维护性、健壮性"><a href="#可维护性、健壮性" class="headerlink" title="可维护性、健壮性"></a>可维护性、健壮性</h1><pre><code class="text">（1）将具有相同属性的样式抽离出来，整合并通过class在页面中进行使用，提高css的可维护性。（2）样式与内容分离：将css代码定义到外部css中。（3）使用模块化的 CSS 结构，将样式分成独立的模块或组件。（4）使用注释和良好的命名规范，使样式易于理解和维护。（5）遵循代码风格指南和最佳实践，减少冗余和不必要的样式。（6）使用 CSS 预处理器（如 Sass 或 Less）来提高样式代码的可维护性和重用性。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> 前端性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web Worker</title>
      <link href="/performance-optimization/Web%20Worker/"/>
      <url>/performance-optimization/Web%20Worker/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是Web-Worker"><a href="#什么是Web-Worker" class="headerlink" title="什么是Web Worker"></a>什么是Web Worker</h1><p>Web Worker 是 HTML5 提供的一项技术，用于在后台运行 JavaScript 脚本，以提高页面的性能和响应能力。Web Worker 可以在独立的线程中执行代码，与主线程并行工作，从而不阻塞页面的渲染和用户交互。</p><h1 id="以下是-Web-Worker-的一些关键特点："><a href="#以下是-Web-Worker-的一些关键特点：" class="headerlink" title="以下是 Web Worker 的一些关键特点："></a>以下是 Web Worker 的一些关键特点：</h1><ol><li>独立线程：Web Worker 在后台运行，与主线程并行工作，由浏览器自动创建、管理和销毁。它不会阻塞主线程的执行，因此可以提高页面的响应速度。</li><li>无访问 DOM：由于 Web Worker 运行在独立的线程中，它不能直接访问页面的 DOM 元素，也不能操作界面。这样可以保证数据的安全性和线程之间的隔离。</li><li>通信机制：Web Worker 通过消息传递的方式与主线程进行通信。主线程可以向 Web Worker 发送消息，Web Worker 处理完任务后再将结果返回给主线程。</li><li>脚本外部化：Web Worker 的脚本文件必须是单独的外部文件，不能直接将代码写在 HTML 页面中。这样可以提高代码的可维护性和重用性。</li></ol><h1 id="使用-Web-Worker-可以实现以下功能："><a href="#使用-Web-Worker-可以实现以下功能：" class="headerlink" title="使用 Web Worker 可以实现以下功能："></a>使用 Web Worker 可以实现以下功能：</h1><ol><li>执行复杂计算：将一些耗时的计算任务放到 Web Worker 中执行，避免阻塞页面渲染和用户交互。</li><li>处理大量数据：当需要处理大量的数据或进行复杂的数据操作时，可以将这些操作放到 Web Worker 中进行并发处理。</li><li>后台加载资源：Web Worker 可以在后台加载数据、解析文件等操作，提前准备好数据，以便在需要时快速响应。</li><li>实时通信：Web Worker 与主线程之间可以进行实时的双向通信，例如传递消息、更新进度等。</li></ol><h1 id="需要注意的"><a href="#需要注意的" class="headerlink" title="需要注意的"></a>需要注意的</h1><ol><li>Web Worker 仅在支持 HTML5 的现代浏览器中可用。并且由于 Web Worker 运行在独立线程中，因此需要考虑线程安全和数据同步的问题。</li></ol><h1 id="vue3-使用Web-Worker"><a href="#vue3-使用Web-Worker" class="headerlink" title="vue3 使用Web Worker"></a>vue3 使用Web Worker</h1><pre><code class="vue">worker.vue 组件内容&lt;script setup&gt;import &#123; onMounted, reactive &#125; from &#39;vue&#39;;const sortedData = reactive([])onMounted(() =&gt; &#123;    // 创建 Web Worker    const code = `    self.onmessage = function(event) &#123;      const data = event.data;        // 在后台线程进行排序      const sortedData = data.sort();        // 将排序结果发送给主线程      self.postMessage(sortedData);    &#125;;  `;    const blob = new Blob([code], &#123; type: &#39;text/javascript&#39; &#125;);    const worker = new Worker(URL.createObjectURL(blob));   // 这里的worker 得用本地创建的文件    // 接收来自 Web Worker 的消息    worker.onmessage = (event) =&gt; &#123;        const sortedDataResult = event.data;        sortedData.length = 0; // 清空数组        sortedData.push(...sortedDataResult); // 更新排序结果到 sortedData    &#125;;    // 发送数据给 Web Worker    const data = [5, 2, 8, 4, 1, 9];    worker.postMessage(data);&#125;)&lt;/script&gt;&lt;template&gt;    &lt;ul&gt;        &lt;li v-for=&quot;number in sortedData&quot; :key=&quot;number&quot;&gt;&#123;&#123; number &#125;&#125;&lt;/li&gt;    &lt;/ul&gt;&lt;/template&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> 前端性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何渲染⼏万条数据并不卡住界⾯</title>
      <link href="/performance-optimization/%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%E2%BC%8F%E4%B8%87%E6%9D%A1%E6%95%B0%E6%8D%AE%E5%B9%B6%E4%B8%8D%E5%8D%A1%E4%BD%8F%E7%95%8C%E2%BE%AF/"/>
      <url>/performance-optimization/%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%E2%BC%8F%E4%B8%87%E6%9D%A1%E6%95%B0%E6%8D%AE%E5%B9%B6%E4%B8%8D%E5%8D%A1%E4%BD%8F%E7%95%8C%E2%BE%AF/</url>
      
        <content type="html"><![CDATA[<pre><code class="javascript">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;ul&gt;控件&lt;/ul&gt;    &lt;script&gt;        setTimeout(() =&gt; &#123;            // 插⼊⼗万条数据            const total = 100000            // ⼀次插⼊ 20 条，如果觉得性能不好就减少            const once = 20            // 渲染数据总共需要⼏次            const loopCount = total / once            let countOfRender = 0            let ul = document.querySelector(&quot;ul&quot;);            function add() &#123;                // 优化性能，插⼊不会造成回流                const fragment = document.createDocumentFragment();                for (let i = 0; i &lt; once; i++) &#123;                    const li = document.createElement(&quot;li&quot;);                    li.innerText = Math.floor(Math.random() * total);                    fragment.appendChild(li);                &#125;                ul.appendChild(fragment);                countOfRender += 1;                loop();            &#125;            function loop() &#123;                if (countOfRender &lt; loopCount) &#123;                    window.requestAnimationFrame(add);                &#125;            &#125;            loop();        &#125;, 0);    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><pre><code class="text">requestAnimationFrame 是一个在浏览器中用于执行动画的函数。它是浏览器提供的一个 API，用于优化动画的性能和流畅度。通常情况下，我们使用 setTimeout 或 setInterval 来创建动画效果。但是，这些方法存在一些问题：它们不会考虑浏览器的渲染过程，会导致动画在某些情况下出现卡顿或闪烁。相比之下，requestAnimationFrame 使用了浏览器的刷新率来决定何时执行回调函数。它会在下一次浏览器重绘之前调用回调函数，确保动画的更新与浏览器的渲染同步。使用 requestAnimationFrame 可以获得以下好处：性能优化：使用 requestAnimationFrame 可以让浏览器自行决定最佳的帧率来执行动画，避免了不必要的计算和绘制，提高了性能。节省资源：当页面被标签页或窗口最小化时，requestAnimationFrame 会自动停止执行，节省了 CPU 和电池的消耗。避免卡顿：requestAnimationFrame 可以与浏览器的垂直同步（vertical synchronization）协同工作，避免了卡顿和撕裂（tearing）等问题。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> 前端性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小程序首屏性能优化</title>
      <link href="/performance-optimization/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%A6%96%E5%B1%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/performance-optimization/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%A6%96%E5%B1%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="优化的核心"><a href="#优化的核心" class="headerlink" title="优化的核心"></a>优化的核心</h1><h2 id="关于耗时"><a href="#关于耗时" class="headerlink" title="关于耗时"></a>关于耗时</h2><ol><li>首屏耗时与用户设备、所在网络环境、程序代码有很大关系。线上环境有2&#x2F;3的运气成分。</li><li>理论上相同地域访问 https 比访问 ip 慢，但小程序要求必须使用 https。</li><li>小程序启动时由微信加载代码包，与服务域名无关，进入页面后才会发起首次网络请求，某些用户环境出现 ERR_CONNECTION_RESET，导致上报的 API 接口及首屏耗时因网络不通畅爆表</li></ol><h2 id="前端性能监控（RUM）-接入"><a href="#前端性能监控（RUM）-接入" class="headerlink" title="前端性能监控（RUM） 接入"></a>前端性能监控（RUM） 接入</h2><ol><li>RUM 是腾讯提供的一款前端监控方案，只需在控制台上创建业务系统和应用，获取上报 ID；通过安装 npm 依赖配置 JSON 就可以实现测速和日志的收集。</li><li>注意：在小程序中，要按照小程序规则开启 NPM 构建。<br>必须将  <span class="exturl" data-url="aHR0cHM6Ly9hZWdpcy5xcS5jb20v">https://aegis.qq.com</span>  添加到 request 合法域名中，否则 RUM 控制台中没有正式版本的数据。一般会在 devTools 中开启忽略合法域名校验，为了方便开发调试调用开发环境，而忽略这个配置。</li></ol><h2 id="图片资源"><a href="#图片资源" class="headerlink" title="图片资源"></a>图片资源</h2><ol><li>常见图片可以采用JPG、PNG、WEBP、雪碧图或字体图标实现，可搜索到的描述大概都是不同格式适用的不同场景，以及从占用带宽上的描述。</li></ol><p>1.首先要选择合适的图片格式<br>1.1照片图片使用 webP。<br>1.2复杂的图形使用 PNG 或 JPG，看哪个格式的文件小。<br>1.3有透明度的图形使用 PNG 或 webP。<br>1.4可能缩放的图形、图标等使用 SVG。<br>1.5动态图尽量不使用 GIF，无法使用 CSS 的用视频替代。</p><ol start="2"><li><p>在小程序中，只有网络图片且在基础库高于 2.9.0 的微信上可以使用 webp ，目前绝大多数的微信用户基础库以及高于 2.16.0版本库，因此<br>可以对互联网图片转换为 webp  格式，减小网络加载耗时。</p></li><li><p>目前没有查到关于这几种方式显示图片资源的页面渲染耗时分析。</p></li></ol><h2 id="JS-优化"><a href="#JS-优化" class="headerlink" title="JS 优化"></a>JS 优化</h2><ol><li>首先排查在主线程上不要使用同步方法，减小主线程阻塞。</li><li>开启小程序中的代码按需注入，避免没有使用的代码注入到小程序运行环境中，影响注入耗时和内存占用。</li><li>生产环境去掉不必要的日志打印</li></ol><h2 id="CSS-优化"><a href="#CSS-优化" class="headerlink" title="CSS 优化"></a>CSS 优化</h2><p>因为构建 CSSOM 树时会阻塞页面的解析，因此需要：</p><ol><li>删除没有使用的 CSS 代码</li><li>减小 CSS 文件大小，如 #FFFFFF -&gt; #FFF ， 0px -&gt; 0，不要使用 Base64 编码的图片。<br> 使用css检测工具PurgeCSS  Unused-CSS。</li></ol><h1 id="具体的优化方法"><a href="#具体的优化方法" class="headerlink" title="具体的优化方法"></a>具体的优化方法</h1><h2 id="资源优化"><a href="#资源优化" class="headerlink" title="资源优化"></a>资源优化</h2><ol><li>按照页面访问的频次，将图片资源分成常用的和不常用的，将常用的放入小程序代码包通过本地加载，将不常用的转换成 webp 放到服务器。</li><li>减小代码包体积：压缩代码包中的图片资源，对 PNG 格式的透明图设置更少的颜色数；通过依赖分析，更换体积更小的 markdown 渲染依赖。从 1M+下降到280K+</li></ol><h2 id="网络优化"><a href="#网络优化" class="headerlink" title="网络优化"></a>网络优化</h2><ol><li>由于只有一台华北地区的服务器，为解决不同地域和运营商的访问速度，开启全站动态加速。通过某测速网站看到可解析到70+个独立 IP，并且不同地区的用户会访问到同运营商较近的 IP，然后由 DCDN 通过内部线路转发用户到服务器的请求。</li><li>通过分析，首次请求时需要进行域名的解析和建连，后续的请求会复用该链路，解析和 SSL 等时间为0。通过某测速网站可看到平均响应时间在 0.3s，考虑到链路复用，网络请求时间会在 60ms 左右。</li><li>对不经常变更且频繁访问的接口，在 DCDN 中设置静态缓存，并触发接口预热，将接口的响应缓存到 DCDN 的二级节点上。这样用户发起这些请求时，直接由 DCDN 做出应答而不回源到真实服务器处理。</li><li>在服务端和客户端开启 http&#x2F;2 协议支持。由于小程序中无高并发请求，自测没有明显改善。</li><li>对超过 1kb 的响应体开启 gzip 压缩。</li><li>对服务端的图片等静态资源设置浏览器缓存。</li><li>由于小程序不像 BAT 这么大用户量和高频的访问，根据 DNS 的解析机制，各地运营商如果有缓存 DNS的解析结果就不会向跟 DNS 进行解析，利用网站测速提供的服务，发送 GET 测速，让各地运营商缓存 DNS 结果。</li><li>开启 OCSP Stapling，提高证书的校验性能。</li><li>小程序使用中，服务端会调用 api.weixin.qq.com 换取用户的 openid，通过调用微信公众平台接口获取该域名的各个 ip 地址，在服务器执行 ping 命令，找到最快的一个ip，写入host文件。从 40ms 降低到 28.8ms。</li></ol><h2 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h2><ol><li>代码中对图片标签开启懒加载。</li><li>减小冗余的 <view> 层次嵌套。</li><li>为 data 赋初始值，避免在网络请求结束后赋值引起页面元素的位置变动。</li><li>开启代码的按需注入</li><li>采用 DCDN 后，各地域各运营商的绝大部分网络请求会在 0.3s 内到达，因此删除了网络请求起止的 loading 浮层动画。</li><li>原来为了真机调试方便，把网络请求、自定义组件的响应等打印到了 vConsole 中。目前线上生产环境删除了所有的日志打印。</li><li>删除了部分无用的 css 代码。优化的部分 css 样式的选择器。</li><li>亲测使用骨架屏只会让人感觉页面非白屏了，但会增加首屏的时间。</li></ol><h2 id="业务逻辑"><a href="#业务逻辑" class="headerlink" title="业务逻辑"></a>业务逻辑</h2><ol><li>所有新用户（首次访问）最初进入小程序时，页面和 data 中的数据都是一样的。将这些数据作为 data 的默认值（这里是把请求数据放在vue(cteated) uniapp(onLoad) ），直接显示出来，网络请求到达后，由于 data 内容不变，不会发生页面的重新渲染。</li><li>用户使用程序后，将从网络请求中获取的用户数据存储到 storage 中。</li><li>对于长列表改为数据分页加载。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> 前端性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>支付宝小程序性能优化方案</title>
      <link href="/performance-optimization/%E6%94%AF%E4%BB%98%E5%AE%9D%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/"/>
      <url>/performance-optimization/%E6%94%AF%E4%BB%98%E5%AE%9D%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="支付宝小程序"><a href="#支付宝小程序" class="headerlink" title="支付宝小程序"></a>支付宝小程序</h1><h2 id="核心要优化的东西"><a href="#核心要优化的东西" class="headerlink" title="核心要优化的东西"></a>核心要优化的东西</h2><ol><li>由于网络问题存在，所以这点应该去减少包的加载大小</li></ol><ul><li>图片等一些文件的大小</li><li>最后是分包 ,但是2M以内，其实分包没有实际的意义</li></ul><ol start="2"><li>js 和 css 的优化</li></ol><h2 id="更多的优化渠道"><a href="#更多的优化渠道" class="headerlink" title="更多的优化渠道"></a>更多的优化渠道</h2><ol><li>支付宝小程序内有相关的检测能力工具</li><li>支付宝有性能研究群对接</li></ol><h2 id="可以研究的方向"><a href="#可以研究的方向" class="headerlink" title="可以研究的方向"></a>可以研究的方向</h2><ol><li>有些机型是存在打不开的情况的，并非所有的都是网络造成的问题</li><li>每个机型的启动首屏加载时间都是不同的， 可以认为中高端手机启动时间就是小于低端手机</li><li>小程序打开就涉及内存，平均每个页面需要的内存在250 - 450之间当前页面内存的大小，直接影响下一个页面打开的时间</li></ol><ul><li>某些手机的打开内存固定超过某个值 就会显示过高的</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> 前端性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssm整合</title>
      <link href="/rear-end/java/ssm%E6%95%B4%E5%90%88/"/>
      <url>/rear-end/java/ssm%E6%95%B4%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="SSM整合"><a href="#SSM整合" class="headerlink" title="SSM整合"></a>SSM整合</h1><h2 id="1-SSM整合"><a href="#1-SSM整合" class="headerlink" title="1.SSM整合"></a>1.SSM整合</h2><h3 id="1-0-步骤分析"><a href="#1-0-步骤分析" class="headerlink" title="1.0 步骤分析"></a>1.0 步骤分析</h3><p>​我们先来分析下如何把Spring,SpringMVC,Mybatis整合到一起。</p><h4 id="1-0-1-步骤"><a href="#1-0-1-步骤" class="headerlink" title="1.0.1 步骤"></a>1.0.1 步骤</h4><p>①Spring整合上Mybatis</p><p>​通过Service层Dao层都注入Spring容器中</p><p>②引入配置SpringMVC</p><p>​把Controller层注入SpringMVC容器中</p><p>③让web项目启动时自动读取Spring配置文件来创建Spring容器</p><p>​可以使用ContextLoaderListener来实现Spring容器的创建。</p><h4 id="1-0-2-常见疑惑"><a href="#1-0-2-常见疑惑" class="headerlink" title="1.0.2 常见疑惑"></a>1.0.2 常见疑惑</h4><ul><li><p>为什么要用两个容器？</p><p>因为Controller如果不放在MVC容器中会没有效果，无法处理请求。而Service如果不放在Spring容器中，声明式事务也无法使用。</p></li><li><p>SpringMVC容器中的Controller需要依赖Service，能从Spring容器中获取到所依赖的Service对象嘛？</p><p>Spring容器相当于是父容器，MVC容器相当于是子容器。子容器除了可以使用自己容器中的对象外还可以使用父容器中的对象。</p></li><li><p>是如何实现这样父子容器的关系的？</p><p>具体可以看源码解析阶段的视频。但是我们目前可以用代码模拟下。</p></li><li><p>是什么时候让两个容器产生这种父子容器的关系的？</p><p>在ContextLoaderListener中，会在创建好容器后把容器存入servletContext域。这样在DispatcherServlet启动时，创建完SpringMVC容器后会从servletContext域中获取到Spring容器对象，设置为其父容器,这样子容器就能获取到父容器中的bean了。详情请见源码解析视频。</p></li></ul><p>SpringMVC容器中的Controller需要依赖Service，能从Spring容器中获取到所依赖的Service对象嘛？</p><p>是如何实现这样父子容器的关系的？</p><h3 id="1-1-准备工作"><a href="#1-1-准备工作" class="headerlink" title="1.1 准备工作"></a>1.1 准备工作</h3><p>引入所有依赖</p><pre><code class="xml"> &lt;!--Spring-context--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--AOP相关依赖--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;            &lt;version&gt;1.8.13&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- spring-jdbc --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;            &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- mybatis整合到Spring的整合包 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;            &lt;version&gt;2.0.4&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--mybatis依赖--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;3.5.4&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--log4j依赖，打印mybatis日志--&gt;        &lt;dependency&gt;            &lt;groupId&gt;log4j&lt;/groupId&gt;            &lt;artifactId&gt;log4j&lt;/artifactId&gt;            &lt;version&gt;1.2.17&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--分页查询，pagehelper--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;            &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;            &lt;version&gt;4.0.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--mysql驱动--&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;5.1.47&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- druid数据源 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;            &lt;artifactId&gt;druid&lt;/artifactId&gt;            &lt;version&gt;1.1.16&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- junit --&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- spring整合junit的依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;            &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;version&gt;1.18.12&lt;/version&gt;            &lt;scope&gt;provided&lt;/scope&gt;        &lt;/dependency&gt;        &lt;!-- servlet依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;            &lt;version&gt;3.1.0&lt;/version&gt;            &lt;scope&gt;provided&lt;/scope&gt;        &lt;/dependency&gt;        &lt;!--jsp依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;            &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;            &lt;version&gt;2.1&lt;/version&gt;            &lt;scope&gt;provided&lt;/scope&gt;        &lt;/dependency&gt;        &lt;!--springmvc的依赖--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;            &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- jackson，帮助进行json转换--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;            &lt;version&gt;2.9.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--commons文件上传，如果需要文件上传功能，需要添加本依赖--&gt;        &lt;dependency&gt;            &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;            &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;            &lt;version&gt;1.4&lt;/version&gt;        &lt;/dependency&gt;</code></pre><p>数据库初始化语句</p><pre><code class="mysql">CREATE DATABASE /*!32312 IF NOT EXISTS*/`mybatis_db` /*!40100 DEFAULT CHARACTER SET utf8 */;USE `mybatis_db`;DROP TABLE IF EXISTS `user`;CREATE TABLE `user` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `username` varchar(50) DEFAULT NULL,  `age` int(11) DEFAULT NULL,  `address` varchar(50) DEFAULT NULL,  PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;insert  into `user`(`id`,`username`,`age`,`address`) values (1,&#39;UZI&#39;,19,&#39;上海&#39;),(2,&#39;PDD&#39;,25,&#39;上海&#39;);</code></pre><h3 id="1-2-相关配置"><a href="#1-2-相关配置" class="headerlink" title="1.2 相关配置"></a>1.2 相关配置</h3><h4 id="①整合Spring和Mybatis"><a href="#①整合Spring和Mybatis" class="headerlink" title="①整合Spring和Mybatis"></a>①整合Spring和Mybatis</h4><p>在resources目录下创建Spring核心配置文件： <strong>applicationContext.xml</strong> 内容如下</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;    &lt;!--组件扫描，排除controller--&gt;    &lt;context:component-scan base-package=&quot;com.sangeng&quot;&gt;        &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;&gt;&lt;/context:exclude-filter&gt;    &lt;/context:component-scan&gt;    &lt;!--读取properties文件--&gt;    &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;&gt;&lt;/context:property-placeholder&gt;    &lt;!--创建连接池注入容器--&gt;    &lt;bean class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; id=&quot;dataSource&quot;&gt;        &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--spring整合mybatis后控制的创建获取SqlSessionFactory的对象--&gt;    &lt;bean class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot; id=&quot;sessionFactory&quot;&gt;        &lt;!--配置连接池--&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;        &lt;!--配置mybatis配置文件的路径--&gt;        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--mapper扫描配置，扫描到的mapper对象会被注入Spring容器中--&gt;    &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot; id=&quot;mapperScannerConfigurer&quot;&gt;        &lt;property name=&quot;basePackage&quot; value=&quot;com.sangeng.dao&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--开启aop注解支持--&gt;    &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;    &lt;!--声明式事务相关配置--&gt;    &lt;bean class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot; id=&quot;transactionManager&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;&gt;&lt;/tx:annotation-driven&gt;&lt;/beans&gt;</code></pre><p>在resources目录下创建<strong>jdbc.properties</strong> 文件，内容如下：</p><pre><code class="properties">jdbc.url=jdbc:mysql://localhost:3306/mybatis_db?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTCjdbc.driver=com.mysql.jdbc.Driverjdbc.username=rootjdbc.password=root</code></pre><p>在resources目录下创建<strong>mybatis-config.xml</strong> ，内容如下：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;settings&gt;        &lt;!--指定使用log4j打印Mybatis日志--&gt;        &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt;    &lt;/settings&gt;    &lt;!--配置别名包--&gt;    &lt;typeAliases&gt;        &lt;package name=&quot;com.sangeng.domain&quot;&gt;&lt;/package&gt;    &lt;/typeAliases&gt;    &lt;plugins&gt;        &lt;!-- 注意：分页助手的插件，配置在通用mapper之前 --&gt;        &lt;plugin interceptor=&quot;com.github.pagehelper.PageHelper&quot;&gt;            &lt;!-- 指定方言 --&gt;            &lt;property name=&quot;dialect&quot; value=&quot;mysql&quot;/&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/configuration&gt;</code></pre><p>在resources目录下创建<strong>log4j.properties</strong> ，内容如下：</p><pre><code class="properties">### direct log messages to stdout ###log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target=System.outlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n### direct messages to file mylog.log ###log4j.appender.file=org.apache.log4j.FileAppenderlog4j.appender.file.File=c:/mylog.loglog4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n### set log levels - for more verbose logging change &#39;info&#39; to &#39;debug&#39; ###log4j.rootLogger=debug, stdout</code></pre><h4 id="②SpringMVC引入"><a href="#②SpringMVC引入" class="headerlink" title="②SpringMVC引入"></a>②SpringMVC引入</h4><p>在resources目录下创建<strong>spring-mvc.xml</strong> ，内容如下：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;    &lt;!--         SpringMVC只扫描controller包即可     --&gt;    &lt;context:component-scan base-package=&quot;com.sangeng.controller&quot;/&gt;    &lt;!-- 解决静态资源访问问题，如果不加mvc:annotation-driven会导致无法访问handler--&gt;    &lt;mvc:default-servlet-handler/&gt;    &lt;!--解决响应乱码--&gt;    &lt;mvc:annotation-driven&gt;        &lt;mvc:message-converters&gt;            &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;                &lt;constructor-arg value=&quot;utf-8&quot;/&gt;            &lt;/bean&gt;        &lt;/mvc:message-converters&gt;    &lt;/mvc:annotation-driven&gt;    &lt;!--配置视图解析器  前后端不分离项目使用--&gt;&lt;!--    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;viewResolver&quot;&gt;        &amp;lt;!&amp;ndash;要求拼接的前缀&amp;ndash;&amp;gt;        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/page/&quot;&gt;&lt;/property&gt;        &amp;lt;!&amp;ndash;要拼接的后缀&amp;ndash;&amp;gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;--&gt;    &lt;!--配置拦截器--&gt;&lt;!--    &lt;mvc:interceptors&gt;        &lt;mvc:interceptor&gt;            &amp;lt;!&amp;ndash;            &amp;ndash;&amp;gt;            &lt;mvc:mapping path=&quot;/**&quot;/&gt;            &amp;lt;!&amp;ndash;配置排除拦截的路径&amp;ndash;&amp;gt;            &lt;mvc:exclude-mapping path=&quot;/&quot;/&gt;            &amp;lt;!&amp;ndash;配置拦截器对象注入容器&amp;ndash;&amp;gt;            &lt;bean class=&quot;&quot;&gt;&lt;/bean&gt;        &lt;/mvc:interceptor&gt;    &lt;/mvc:interceptors&gt;--&gt;    &lt;!--          文件上传解析器          注意：id 必须为 multipartResolver          如果需要上传文件时可以放开相应配置      --&gt;    &lt;!--&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;--&gt;        &lt;!--&amp;lt;!&amp;ndash; 设置默认字符编码 &amp;ndash;&amp;gt;--&gt;        &lt;!--&lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot;/&gt;--&gt;        &lt;!--&amp;lt;!&amp;ndash; 一次请求上传的文件的总大小的最大值，单位是字节&amp;ndash;&amp;gt;--&gt;        &lt;!--&lt;property name=&quot;maxUploadSize&quot; value=&quot;#&#123;1024*1024*100&#125;&quot;/&gt;--&gt;        &lt;!--&amp;lt;!&amp;ndash; 每个上传文件大小的最大值，单位是字节&amp;ndash;&amp;gt;--&gt;        &lt;!--&lt;property name=&quot;maxUploadSizePerFile&quot; value=&quot;#&#123;1024*1024*50&#125;&quot;/&gt;--&gt;    &lt;!--&lt;/bean&gt;--&gt;&lt;/beans&gt;</code></pre><p>修改web.xml文件</p><pre><code class="xml"> &lt;servlet&gt;        &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;!--            为DispatcherServlet提供初始化参数的            设置springmvc配置文件的路径                name是固定的，必须是contextConfigLocation                value指的是SpringMVC配置文件的位置         --&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;            &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;!--            指定项目启动就初始化DispatcherServlet         --&gt;        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;        &lt;!--             /           表示当前servlet映射除jsp之外的所有请求（包含静态资源）             *.do        表示.do结尾的请求路径才能被SpringMVC处理(老项目会出现)             /*          表示当前servlet映射所有请求（包含静态资源,jsp），不应该使用其配置DispatcherServlet         --&gt;        &lt;url-pattern&gt;/&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;    &lt;!--乱码处理过滤器，由SpringMVC提供--&gt;    &lt;!-- 处理post请求乱码 --&gt;    &lt;filter&gt;        &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;        &lt;init-param&gt;            &lt;!-- name固定不变，value值根据需要设置 --&gt;            &lt;param-name&gt;encoding&lt;/param-name&gt;            &lt;param-value&gt;UTF-8&lt;/param-value&gt;        &lt;/init-param&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;        &lt;!-- 所有请求都设置utf-8的编码 --&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;</code></pre><h4 id="③Spring整合入web项目"><a href="#③Spring整合入web项目" class="headerlink" title="③Spring整合入web项目"></a>③Spring整合入web项目</h4><p>​让web项目启动的时候就能够创建Spring容器。可以使用Spring提供的监听器ContextLoaderListener，所以我们需要再web.xml中配置这个监听器,并且配置上Spring配置文件的路径。</p><pre><code class="xml">    &lt;!--配置spring的配置文件路径--&gt;    &lt;context-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;    &lt;/context-param&gt;    &lt;!--配置监听器，可以再应用被部署的时候创建spring容器--&gt;    &lt;listener&gt;        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;    &lt;/listener&gt;</code></pre><h3 id="1-3-编写Controller-Service，Dao"><a href="#1-3-编写Controller-Service，Dao" class="headerlink" title="1.3 编写Controller,Service，Dao"></a>1.3 编写Controller,Service，Dao</h3><p>​我们来编写根据id查询用户的接口来进行测试</p><pre><code class="java">@RestControllerpublic class UserController &#123;    @Autowired    private UserService userService;    @GetMapping(&quot;/user/&#123;id&#125;&quot;)    public User findById(@PathVariable(&quot;id&quot;) Integer id)&#123;        User user = userService.findById(id);        return user;    &#125;&#125;</code></pre><pre><code class="java">public interface UserService &#123;    User findById(Integer id);&#125;</code></pre><pre><code class="java">@Servicepublic class UserServiceImpl implements UserService &#123;    @Autowired    private UserDao userDao;    public User findById(Integer id) &#123;        return userDao.findById(id);    &#125;&#125;</code></pre><pre><code class="java">public interface UserDao &#123;    /**     * 根据id查询用户     * @param id     * @return     */    User findById(Integer id);&#125;</code></pre><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;com.sangeng.dao.UserDao&quot;&gt;    &lt;select id=&quot;findById&quot; resultType=&quot;com.sangeng.domain.User&quot;&gt;        select * from user where id = #&#123;id&#125;    &lt;/select&gt;&lt;/mapper&gt;</code></pre><h2 id="2-案例"><a href="#2-案例" class="headerlink" title="2.案例"></a>2.案例</h2><h3 id="2-0-响应格式统一"><a href="#2-0-响应格式统一" class="headerlink" title="2.0 响应格式统一"></a>2.0 响应格式统一</h3><p>​我们要保证一个项目中所有接口返回的数据格式的统一。这样无论是前端还是移动端开发获取到我们的数据后都能更方便的进行统一处理。</p><p>​所以我们定义以下结果封装类</p><pre><code class="java">@JsonInclude(JsonInclude.Include.NON_NULL)public class ResponseResult&lt;T&gt; &#123;    /**     * 状态码     */    private Integer code;    /**     * 提示信息，如果有错误时，前端可以获取该字段进行提示     */    private String msg;    /**     * 查询到的结果数据，     */    private T data;    public ResponseResult(Integer code, String msg) &#123;        this.code = code;        this.msg = msg;    &#125;    public ResponseResult(Integer code, T data) &#123;        this.code = code;        this.data = data;    &#125;    public Integer getCode() &#123;        return code;    &#125;    public void setCode(Integer code) &#123;        this.code = code;    &#125;    public String getMsg() &#123;        return msg;    &#125;    public void setMsg(String msg) &#123;        this.msg = msg;    &#125;    public T getData() &#123;        return data;    &#125;    public void setData(T data) &#123;        this.data = data;    &#125;    public ResponseResult(Integer code, String msg, T data) &#123;        this.code = code;        this.msg = msg;        this.data = data;    &#125;&#125;</code></pre><p>之前的接口修改为 ：</p><pre><code class="java">@RestControllerpublic class UserController &#123;    @Autowired    private UserService userService;    @GetMapping(&quot;/user/&#123;id&#125;&quot;)    public ResponseResult findById(@PathVariable(&quot;id&quot;) Integer id)&#123;        User user = userService.findById(id);        if(user==null)&#123;            //说明没有对应的用户            return new ResponseResult(500,&quot;没有该用户&quot;);        &#125;        return new ResponseResult(200,&quot;操作成功&quot;,user);    &#125;&#125;</code></pre><h3 id="2-1-查询所有用户"><a href="#2-1-查询所有用户" class="headerlink" title="2.1 查询所有用户"></a>2.1 查询所有用户</h3><pre><code class="java">@RestControllerpublic class UserController &#123;    @Autowired    private UserService userService;    //省略其他无关代码    @GetMapping(&quot;/user&quot;)    public ResponseResult findAll()&#123;        List&lt;User&gt; list = userService.findAll();        return new ResponseResult(200,&quot;操作成功&quot;,list);    &#125;&#125;</code></pre><pre><code class="java">public interface UserService &#123;    User findById(Integer id);    List&lt;User&gt; findAll();&#125;</code></pre><pre><code class="java">@Servicepublic class UserServiceImpl implements UserService &#123;    @Autowired    private UserDao userDao;    //省略其他无关代码    public List&lt;User&gt; findAll() &#123;        return userDao.findAll();    &#125;&#125;</code></pre><pre><code class="java">public interface UserDao &#123;    //省略其他无关代码    List&lt;User&gt; findAll();&#125;</code></pre><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;com.sangeng.dao.UserDao&quot;&gt;    &lt;select id=&quot;findAll&quot; resultType=&quot;com.sangeng.domain.User&quot;&gt;        select * from user    &lt;/select&gt;&lt;/mapper&gt;</code></pre><h3 id="2-2-分页查询用户"><a href="#2-2-分页查询用户" class="headerlink" title="2.2 分页查询用户"></a>2.2 分页查询用户</h3><p>​分页查询的结果除了要包含查到的用户数据外还要有当前页数，每页条数，总记录数这些分页数据。</p><p>分页数据封装类</p><pre><code class="java">public class PageResult&lt;T&gt; &#123;    private Integer currentPage;    private Integer pageSize;    private Integer total;        private List&lt;T&gt; data;    public PageResult(Integer currentPage, Integer pageSize, Integer total, List&lt;T&gt; data) &#123;        this.currentPage = currentPage;        this.pageSize = pageSize;        this.total = total;        this.data = data;    &#125;    public Integer getCurrentPage() &#123;        return currentPage;    &#125;    public void setCurrentPage(Integer currentPage) &#123;        this.currentPage = currentPage;    &#125;    public Integer getPageSize() &#123;        return pageSize;    &#125;    public void setPageSize(Integer pageSize) &#123;        this.pageSize = pageSize;    &#125;    public Integer getTotal() &#123;        return total;    &#125;    public void setTotal(Integer total) &#123;        this.total = total;    &#125;    public List&lt;T&gt; getData() &#123;        return data;    &#125;    public void setData(List&lt;T&gt; data) &#123;        this.data = data;    &#125;&#125;</code></pre><pre><code class="java">@RestControllerpublic class UserController &#123;    @Autowired    private UserService userService;    @GetMapping(&quot;/user/&#123;pageSize&#125;/&#123;pageNum&#125;&quot;)    public ResponseResult findByPage(@PathVariable(&quot;pageSize&quot;) Integer pageSize,@PathVariable(&quot;pageNum&quot;) Integer pageNum)&#123;        PageResult pageResult =  userService.findByPage(pageSize,pageNum);        return new ResponseResult(200,&quot;操作成功&quot;,pageResult);    &#125;&#125;</code></pre><pre><code class="java">@Servicepublic class UserServiceImpl implements UserService &#123;    @Autowired    private UserDao userDao;    public PageResult findByPage(Integer pageSize, Integer pageNum) &#123;        PageHelper.startPage(pageNum,pageSize);        List&lt;User&gt; list = userDao.findAll();        PageInfo pageInfo = new PageInfo(list);        PageResult pageResult = new PageResult(pageInfo.getPageNum(),pageInfo.getPageSize(), (int) pageInfo.getTotal(),list);        return pageResult;    &#125;&#125;</code></pre><h3 id="2-3-插入用户"><a href="#2-3-插入用户" class="headerlink" title="2.3 插入用户"></a>2.3 插入用户</h3><p>Controller层</p><pre><code class="java">    @PostMapping(&quot;/user&quot;)    public ResponseResult insertUser(@RequestBody User user)&#123;        userService.insertUser(user);        return new ResponseResult(200,&quot;操作成功&quot;);    &#125;</code></pre><p>Service层</p><p>在Service接口中增加方法定义</p><pre><code class="java">    void insertUser(User user);</code></pre><p>实现类中实现该方法:</p><pre><code class="java">  public void insertUser(User user) &#123;        userDao.insertUser(user);    &#125;</code></pre><p>Dao层</p><p>在接口中定义方法</p><pre><code class="java">    void insertUser(User user);</code></pre><p>在mapper映射文件中</p><pre><code class="xml">    &lt;insert id=&quot;insertUser&quot;&gt;        insert into user values(null,#&#123;username&#125;,#&#123;age&#125;,#&#123;address&#125;)    &lt;/insert&gt;</code></pre><p>测试</p><pre><code class="json">&#123;&quot;username&quot;:&quot;三更草堂&quot;,&quot;age&quot;:15,&quot;address&quot;:&quot;请问&quot;&#125;</code></pre><h3 id="2-4-删除用户"><a href="#2-4-删除用户" class="headerlink" title="2.4 删除用户"></a>2.4 删除用户</h3><p>Controller层</p><pre><code class="java">    @DeleteMapping(&quot;/user/&#123;id&#125;&quot;)    public ResponseResult deleteUser(@PathVariable(&quot;id&quot;) Integer id)&#123;        userService.deleteUser(id);        return new ResponseResult(200,&quot;操作成功&quot;);    &#125;</code></pre><p>Service层</p><p>在Service接口中增加方法定义</p><pre><code class="java">    void deleteUser(Integer id);</code></pre><p>实现类中实现该方法:</p><pre><code class="java">    public void deleteUser(Integer id) &#123;        userDao.deleteUser(id);    &#125;</code></pre><p>Dao层</p><p>在接口中定义方法</p><pre><code class="java">    void deleteUser(Integer id);</code></pre><p>在mapper映射文件中</p><pre><code class="xml">    &lt;delete id=&quot;deleteUser&quot;&gt;        delete from user where id = #&#123;id&#125;    &lt;/delete&gt;</code></pre><h3 id="2-5-更新用户"><a href="#2-5-更新用户" class="headerlink" title="2.5 更新用户"></a>2.5 更新用户</h3><p>Controller层</p><pre><code class="java">    @PutMapping(&quot;/user&quot;)    public ResponseResult updateUser(@RequestBody User user)&#123;        userService.updateUser(user);        return new ResponseResult(200,&quot;操作成功&quot;);    &#125;</code></pre><p>Service层</p><p>在Service接口中增加方法定义</p><pre><code class="java">    void updateUser(User user);</code></pre><p>实现类中实现该方法:</p><pre><code class="java">    public void updateUser(User user) &#123;        userDao.updateUser(user);    &#125;</code></pre><p>Dao层</p><p>在接口中定义方法</p><pre><code class="java">    void updateUser(User user);</code></pre><p>在mapper映射文件中</p><pre><code class="xml">    &lt;update id=&quot;updateUser&quot;&gt;        update user set username = #&#123;username&#125;,age = #&#123;age&#125;,address = #&#123;address&#125; where id = #&#123;id&#125;    &lt;/update&gt;</code></pre><h2 id="3-异常统一处理"><a href="#3-异常统一处理" class="headerlink" title="3.异常统一处理"></a>3.异常统一处理</h2><p>​我们可以使用@ControllerAdvice实现对异常的统一处理。让异常出现时也能返回响应一个JSON。</p><p>​代码如下：</p><pre><code class="java">@ControllerAdvicepublic class SGControllerAdvice &#123;    @ExceptionHandler(Exception.class)    @ResponseBody    public ResponseResult handleException(Exception e)&#123;        return new ResponseResult(500,e.getMessage());    &#125;&#125;</code></pre><h2 id="4-拦截器"><a href="#4-拦截器" class="headerlink" title="4.拦截器"></a>4.拦截器</h2><pre><code class="java">public class SGHandlerInterceptor implements HandlerInterceptor &#123;    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        System.out.println(&quot;preHandle&quot;);        return true;    &#125;    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;        System.out.println(&quot;postHandle&quot;);    &#125;    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;        System.out.println(&quot;afterCompletion&quot;);    &#125;&#125;</code></pre><pre><code class="xml">    &lt;!--配置拦截器--&gt;        &lt;mvc:interceptors&gt;            &lt;mvc:interceptor&gt;                &lt;!--                --&gt;                &lt;mvc:mapping path=&quot;/**&quot;/&gt;                &lt;!--配置排除拦截的路径--&gt;                &lt;!--&lt;mvc:exclude-mapping path=&quot;/&quot;/&gt;--&gt;                &lt;!--配置拦截器对象注入容器--&gt;                &lt;bean class=&quot;com.sangeng.interceptor.SGHandlerInterceptor&quot;&gt;&lt;/bean&gt;            &lt;/mvc:interceptor&gt;        &lt;/mvc:interceptors&gt;</code></pre><h2 id="5-声明式事务"><a href="#5-声明式事务" class="headerlink" title="5.声明式事务"></a>5.声明式事务</h2><p>​已经做好了相应的配置，只要在service方法上加上注解即可</p><pre><code class="java">    @Transactional    public void test() &#123;        userDao.insertUser(new User(null,&quot;test1&quot;,11,&quot;cc&quot;));//        System.out.println(1/0);        userDao.insertUser(new User(null,&quot;test2&quot;,12,&quot;cc2&quot;));    &#125;</code></pre><h2 id="6-AOP"><a href="#6-AOP" class="headerlink" title="6.AOP"></a>6.AOP</h2><p>​注意，自己去使用AOP进行增强时，应该是对Service进行增强。不能对Controller进行增强，因为切面类会被放入父容器，而我们的Controller是在子容器中的。父容器不能访问子容器。</p><p>​并且我们如果需要对Controller进行增强，使用拦截器也会更加的好用。</p><pre><code class="java">@Aspect@Componentpublic class SGAspect &#123;    //定义切点    @Pointcut(&quot;execution(* com.sangeng.service..*.*(..))&quot;)    public void pt()&#123;    &#125;    //进行增强    @Before(&quot;pt()&quot;)    public void before()&#123;        System.out.println(&quot;before&quot;);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 服务端开发 </category>
          
          <category> ssm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Step.16 彻底搞懂Vue中keep-alive的魔法-上</title>
      <link href="/computer-science/vueyuanma/dosc/16%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82Vue%E4%B8%ADkeep-alive%E7%9A%84%E9%AD%94%E6%B3%95-%E4%B8%8B/"/>
      <url>/computer-science/vueyuanma/dosc/16%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82Vue%E4%B8%ADkeep-alive%E7%9A%84%E9%AD%94%E6%B3%95-%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="23e83edc353565b58bd82938c7c2e621ed567ef69e9dfbd876d7fbea8b94e376">5808c6cbf3ac08533f2dffaad5e129c1f7677efb1b6b29d5c2835e6dc7760586dc49808bf7b02d6b14c21675aca8e14edbf4b22a797cd50456845c4848b45eb8084d5629c3d46715217019b448b59e4d0f2f7b1504909a9fcd98e1edaf4a4053e2736aa87469d2b63a38083fe7fa26e9b4082eda96ab9f2679aafbe272cd265ee12ee9866b3c5cbab762c83dd2dd8c7a242f6768ab4a0857b8422a2d9140ce8f7cd6563ae5275ad375727b33ac51fdc9be4ea64ccc87c200307ea4029e26f2f16801cd0c668fcaf1b52b9a42fe2f25f48cd8a9bc5c0220c111cb40619fd9e224e742156bd66219dbe06aca390a2d754029e872510066eccc4840223088a7f8beff0f52d3d8ef1f45e2a63e7918ec85b476b2677506a4b582903fb3a716665cc4a436ca6c6703a8cb26c90de747431926a1cab7b071c6b0443f74abef9347eb9011d958ac20ddba0010984053bfb0f5d16f673022ced69cf4d25997434cc3e3d12f581382ffe3776e39c71660d252da5b7ae1c22783fe4a888557a67eb6e1eb5a19947d3b0a47fa300833b3b8a38cbc813b807445afcf21c3b99bf2a9684e8c31fb6a37116c71cd88c2246cb9eb7311f7cd33de7821eea31a7a04e2af3fff408d88f7062891846394590cf1815eba23170d6d8285fe96c12149d23a25a7d3c42d164bda75fb6707653706f506cdd917daf8f39deb8a15cb0ccd0d21fe0e5a06185234085a45494d9b13f4d2d1346414e4dfbf7dc019909a228315c649b69cac0b9dbdce06270f31958c71c7ea45b6d00dd2751faf945a760aa04a25fb45ea8b15f38189694027bdc13627f4597949e3839ae3ab92970edb05de4d2cc456a40bc2661963da58ac444dc502572d0c19408137d2b0421c002b65fad7e349161049b2da8238de5f8deb823b21923a4f6279b39cbce12c5a518f7bbea3545d1d5a3c1f4ffa333329e0adb88a0d85692214a99533be4c370de60da16cd616098f66404f04adb0960dab264ef5dd3fd7ca59d8fe46e53030d66f443169d1cb6a68c2f597c243f456757ffca6471898f9ca73df914d300994ae545d90ab88c8d5e2eaf35e10d248f741bb51bc79d2611f0116b35e5ea24945511dcff319ecc01ad6618d5e7ebc917b67a578da838e7c953f680f4ac490a058716578865ce58cf2b7cf3cc277d4d4577027bdff58a641cb2d04b12dab0fdd6416d0e9f75439087ecacaacce088c5bee6888a64f6a3feb52c6764102666941d7bcf4bbc52fdb28c9e5677248bb7a20d90c8363110194b379b3c7d1438a529b6150f1c7702f989722b9dbd55f00e5e5a6019e6cf78d08c48eb7404da6b9132c0534312a3bebf434bfbf67a4d27446cb2c4c02d0e03ef9a5d6e492ee18583c59ad9649b7736923953f013efb249e1a756a31dc1c7d8da113a4e168d30b7c9f6f96703f478e5b7f02206278b9496b8842c3114fb535bafc48bf40b51afc1faa3c1e2cbdbb3cb988506c295830227ad9d440da8af42b73e51a195f5f7444e9eba94a4e8b4cdc9af912ef71f83ccaa9f52da86ed86e35031abde597e4a35ee7048256c7349bcb4da356dea94b0ba856c2156589fcd82074f8a333c82599495989abcbf5a0915d5bed9314f62f68b2baeb69f87ae99a526159a828fe0dbf23ddcda00bb53425ab043f03a1dee249cbd1904564252a4d4811334a755bce2e6fc22df35be6e295020a1b63801ae6d26de8d4b47707c57050535d1c283a64887350d13bdbfcb8eb1bcdd8749411746eb439414e846927cb1a0a02e17939ad9202e597127ad7cfea9ca67c75eafff87c0817080458920759f04b70baae7b4e259ba18cceb567cfcdef31764bf3e26972d63bdedaed2172bab3d1d199c8c668d87a60438eeaeebdf63aa1232a6f9a19424526ba121a8a1974b954035ff2e6b8bec7a42e2998f3b5047179fbeaa8109582bd44c559e8c78621316eb5e07551eddbb945d0b1f0143f78ce7adc0eee54edd3d9307077739fe9f2251d60aaebd217e85e42d966e26449edf3d3f67068fdd914b17de03a1e6345285d9fdb521d3065095cc4cca02abb01517743e762f2a0048b8be9305774de73b46f9e077cd104e9ee384b14c0cfe68a5ed9165e5a487e0cd9aa9bf1a19ed99a520a8af4ef889e08db68e000bd71f4e6a9a032685349693f1b0ff64173c03411fc2cc400e85c3cb1c497b6320d5c98283782f23cb4c68e330a2271e63041414c1990b042200e3c1cadec2afb740af6f00e6e95f793ba4ecc2b0200b0d1988062ebe2a2ecfc99f8dcbb4171e9bca1dda33c542fbd6ff75735c4e7d217469584fdcd06bb89c58835e0b9f3d9e0027219495bc6c3c331110928b240e8349dbaaa62c39b022d06749760b1d3cc465c5312575a69e6118fe80a0fc4a9aad225186019c14bc508e58ff36b55d2be4938dfd33d55c6abbc1405a6360b595279c46f2fd27768828e458a539721311382bd7d0a7156659107a7c65a39e55a6ecd0e4630a50b3c9044b1ee2c5e1b0425adb132eb5922718fd45b0c1d22ea69ac3488b7c3e703512d5ebd90d87225e3267ac390e8e84c3ae410af2e6a6b5975d4a660d5d1df42772fea6f7edc988284879956826280e6423dc1dad43f2d7c98ed0a5283cfeb050415a6687528ba3c18504e6d86d6380d575a4caedbf0bf47cc6f380b6950e6aa0b78974d2d4d288abfa1ceb2966ee6742b04db2a63619325ce2db43299386addfa9057e27d257b1df423e90a77c39f6aa3e3e863a2ed40a5e09452d96d91d8af62ed716b5f4106ac833ff3def00dbf01a2e8a98fa065fd6e80b1547e1b3d0896ecf6e1088fc4f00742854eec3f0183d53be7194f28f0a133e58a848871a15d75b0997ce4c81bfc42ab99eb4653879abee1995cdad015283f4daba09cdc9b6b4019971bc688d024654d770394dc5e4921b398f884de96f61bd96e82b188e6c5d101a2bfdc4c7f7c47ca5e66e035559e30b01260eb4dec72ba17e442b934f7f1357d7f1ea71423723ae68cbc2c742a78edfbe2d4bb499c5efd55644c64f57332fa8d832264188a419da1cd3b01991aec09048d8f3c5f59c8bdc31e5a568a2b22f0ac82ec15c9e4c2dc0cf7430f1b6c32b075b095b7e239fcacf21e61f919480b01fab4a949d92b1e0400dd958512f1a4ef5ed8ba1712099b0040805614782c9c6d58dcf6fb82f417801a2eebbfa1909c899f562ee76eb9f7ef2abb8aa2c6be5688cf752806a7c733cb256f82b8893db5fc0acf6ca80b02b1f54937087b6eb1eea21b9fd83fcbe49d50eff9f5405ab4cbaec07ceb82ec013059a5cf3f72f99a5daeaba6d31374ffe8109ccd3ef98d824fb1b6ad4a6cd88c9b69b6604a64602a9c558144b01bf58347a481bf307ba528bd35f51f3e11c8413f27239c76633e82641264f86d173edc5fe87258468e566b2b13cdf233f29da272d40f8693e5f6f3127c04575981c2648e27915eda024e2ddf88e23c70438cbb0a072a5bc6eef8dce18bc31d2433534162a3983876b52fde4214d792c0ed6b149e2e0b6fc8ffecc121765e5284d17eaf0bdd1aad65fbbf3ba15278181091c049147a706866e6af23274d4253cce1c0e876af22096ea30ba32808b2ca5977f344f582af506a813ba0f18bcd0ffa787a89dc6eebd1e8a60241454e5b80354e1df8fc66dac405f2ccd20c0856466517cc034315c270491aa1fdc92f1ac5713c0e8c46d3a5bd65dbfb77cc77077d4a00a6eff4a7877e402fd1b740ed8a4e811f28394ada61fe33deeddaf397565e518f4b905051dc470000db3f31019a70c74f66765c0fd27aeb9e27e9da0202c747fa9668af1e270ecf7932809553c248565d81f4fb2da2d6da907d7ba67a2859f1d667f2c485aa53ac5497336f0fc7c686c82e5b4fb044ee43e4a0af012723c693df22fc9e87bb0f610be7baeece4ba190ab78e2d2aaed95ba18e4a938d01ead79d2c0f6b5cac3156cea6116fa7fce8752ce50ce8ad51dd9a615b874d23ff1e8423be1ad3e7bb03c3f3d67c9d2d253a254e35447bdf751bb7d33273f0ea7f2a037c9300c0d9eff36b77e20ccfb445e00dce8bf298aa69fd62052fc74fa8adf23ee0da2cb7a4e997d13d9b081671f11142f3ea7956ec9a10f17ccffd9d5c6e67408140f346b83b36af0c5bc2bc500a0668e3851df0b0eecd824452e650f5c53267de1f6c39a5dd7bca0779e99633a9ba480847296a0548feb67059ac3aeac338ab479022f2e6c7c50e98d7ca2855d61e6e78ef7582b67fbdea07029fdaf50a273f3d52f79c42f21c4a7c509f9e276609f6df5c6f5a06a6f8a04045ae50f57aae53c0b4fa6b597936768189b30391fe4bc13aec36a60977b104614d50865263dad33b0831527dd77aa6fb6df27005e26e5e0ec8c1c8c6a7a8a02d6a88eeea92dde8b30e998bb16ebcffec6e914af43e0aa4359f872301e14c63c0c29ea0966229dfe72a71c6fa3e2eefdf806a2d090b5b4795265c42445c0c33088212994b190f6609c6413fe25f1acc3694f58c3798f602a3d88a13e2566ce0e2569abe72d4f3e921f257d98d651d07bd00ce24b7bf79478ac8f89ce3fa860ec4f0293f9fdefdf42f42f79b39613000e6c01833db457cfe846e897a62bce49514266f3b6361f688ee9f3155d51c47603169e6a3c69ebcf4137b9606fe65132574793abde85e04564cc9768070cb3a646f1d741a06ae89403b1d2ecf1154d09920922663cd1cc4c8b7d187eba3e496a8add2b16ae3f515731df44b106c269609be19671852168d81927372965d2cc7b0a00a7bae36f4d954e4716d8347572e35b0d9ccffa786176f06afe8d2c3a47393e5fb9e6e818ec52382ae4d3a80fd4dc649fe17cad199b2164ee0f925e2aca126efe2694d204d40fbefd1b058929b603b533005f0d3d4f8236f0120db223e3c95c7c5d115c509eb2b2b13dc196335ddb9ad6b112d7f038589eb671135b4fca9c52be5f44670620faf28964fefbf125a4247499fa43cec604a38abc5d1de15b4cf93a207a77c9f124361cb66e0d460b559547be273a2b3eb3b8770ff94dd29f53e5703da666e3bb51596d08f31696f600b3e400d09cd4d9a229abf851037437547b16632898aa8cc7e8e955b53db8f68220b64db47204af27d402b6d60f84a145a7f16f665bb05e13b0c673ff8dcae056ce104cd6bf0f650ff330662bf0c2f8ea0c9ab709b1c2a25c7b782ee5c34cd7f67051912363706eef1717f65a414b8d500456cd0570a245cc7ce1d2afa618278821b9aad950702d0c7ec9028165dee8969521ff6a000e2bfedfe969d86f8a776d3715182a66cb66b64491926126a891861d9d791f15948e6fe4f0eb4091eabf3d3e4a3b9bd08c8fe16a6eed9224c873ed2361c5068922670d520493ddb140fb200791626045857347cfc42915034113d55776f04f033b18c134a3fff0a0598c66aa4b505f40bd1a686d9686e8910f580d7dc27f722ae7530820fcb6165c379b32c7b69c0c668bc376ebfe9b9e626c7611e3e9c8f9f17a0a1f01ff4af5a9adaf6d602eae1f15ec08a79a028072e4eaf05edb2e672abda213770d6e9595435f8384f04b26474514b9f68f832d1a83e2059d49853571cd794a39f8a67fb0523c76bd537ebfa5334bbaea3372850c104e2aa5b749b8234c8fce2ae87da3ea3054609194268b5f930292a7da46b1b51b5bc3b937c5f521ff7b3202e41c9fc2715149ff1463a49a2e83a414b6d0093a15c933321e09c2c8dab53f5de42032ccd1e1337f8acedf96fb0152f97f70189981fbf29ec010da7785228db95d37d514a59b8a4fe1707970448b4dbf9276ec8065b5b12d351dfed270b589093080465cc52ab365e30879166ed8f3b20d73ac9ad4471c53578a3eaee58ccb013ffb5cccba02a6a3d437bfa6a435b97c16c0cd92183beac0410db3437aceaeab2971ed8201f0efa5308ec7422deeb856d35df7d06d831324da216fb55b56a03866306e38a3a98046b9e742b062ad506db8c4d1bea0f6369342a81fea2569e725fc17a7e38ff5a5f49417e88087c57ec42a1c60b3808f870429b84a196607a02e8ae1bc73a845384e8d5df9ca400c9111eb8ecdd78bfea9627dc91e84a9026769baa6bb772f5a2982e0f92a5afe25f5242041e7784378dced0af079ac023cc83af6df00ac17f215b925486420b334bebb34c90f84a55d8d9edb1b26d31b3796141ea48f3fe2787d85c05c2fc55578a51fe449262f7bcb32a92a0b0679bd6aaef2220a4a8965ff42c3c18519680813ee2798a89f33c250fed040181fd942d43b9b8887a2e9cd4b312a224113179f3280674cc33dd0126cf0e9f13c7ba01c0045b79ef3fa569dcd3476bf3396d98b32e4b97e5ba13a0f30e5d0c89357cd65c0bdd12177e23e234fde5667ef8f6d90f2ffa285defffe87b030545edb948c2608e5ec41c1d0047cf532e6d097b1f8c86c748d3d5da6b0bed624af43486eb377023af58964f4a01886b7554475bf4497b5d96d79d9fc9a7c35a5e9881fcfea44331c347223db0e5c22ab4df5a93f776ecd60bcc984bc5b4d34ac78b9a44fd790278d88a2162af91f973d586773642ba0a24b0281776cb49e5e846140452b800b842902bafb92fc9f7b10cf36490e33894fcd19d95ba6e3a1e80e13dae42ffcbe389876b7774aa51e0489daee25bca12fe5c098c28524f10c2de248b7e5dd93bc2bc122ad3c6c09076d3543c96380a98a595fa46811bf35811fd30503245fcbca0fda3719d3dab71c99559a5e786f9ce3623de7558b62cbecb481b66ddf43614256357450d969421c0ede166d78ad25a86da2011c2f980719592982fd5eb6b451369e43b06478c5181222030a284647b1c9b46a49169549ea5445682a2fc8852621229ce355827a006659148a1c8ec8250e18ad8ca31469bfd0b5cfe68f3d457bf5c47cbb0a83fa79636f49e879beae5a9b6087f13beb712f5ef2d3663fc2ad702be9710d963c2aaa092c55d7dac9ae7cb0d19f185f5942791f150a736d3b5101df4a1c8b72177f3dbfb3fac447f8c34bcfbbaa1296d8528867f0df1fb5cea3d7d322885de781b01563337e13ddfe40e39db5ca0d4b4e80e0b5f5a2b04939d729e5363f5ca1845d2ecaa566266beb0a318cc73871c5a74de9fac1af163c24a263a4b8d4b78056e95bf0d7015f1b39c2d3fa1916ff901b80596c757acb35b5bffe9818f02e5a01a753743b21e33ac4349c9731517177f6ca56ea2020fd59e5f32a3f93755483454a47e6a2fe987672bb5747c676f42105697d473bc7093fa676425220ad9c6f13507901260cdd563d527c33a145f737f7458c734499149f7984b61d3cf1dacc74e1ac4ccd8f0b4aaf7119d664ebb7f5cf48657637a8d3faf27f8d3942a453e8aaac8088c1a8e64f3e98e19da00e46d5b36656711115df8d5bb01ed221764830c229fb56562ccec9b3f1ccbdedd09c948e30ccadebe1e5aca34829076c2fa3fb55118ca669d2b5136555c34f384682f93e62a14b661fc91e32ce09148c9b05769f98152ea8aec731ee44b6eff0ec99bb45f4479cca8395a4d7ae009abc65dbedc92bafe5cb7bd6d79059198a4292ca78df61caaf705a0e856ea224c5af31eea1129c6e6bb19e6c9e7c71b675798ebca5d40d079b65c269bb99e0f910077c4ebeb8295f676782f9e705216a8c22ad54bda23a4842f8383a4f24b62e32caacde52962641f87dd8e90d8d068b7c643295dd58da5c25ea73177d790b907af6c2f64bb37575774a2cf874dd62d961b78547f4beeb1634bd887bea3622c28e8fb665f97dff6374d0a1ebffd1ad831f2d06d9b93a443216651578863c333620a9b28d73b6d1dad23226d5c3e2ff60513b40c2402ecfd2af54312d1ae4f2ee2f4a542e095dc1f61fafd81870231d59552028ca0d6f0939c80a665b75fbc743a86e24597dfc93e8cb9abcd4be2f615e3b7f421a8c000d69fb3ac1b0f94c51f3b0c05f5dddbb3cc8be92a6c2610c0a208b292f021d1e7658944b4de502f815cf23c21ed0717eca8befe8d88545bd356ebeff0108deaa7f8beecdaace0c4add94f79a750d6660ebf05ed393fdd29b6617237b28d18cbf08b2a5352dad9be83b68ca6f4afffb50f37f213613dedbb5a848ceece84a64e2fe6c784899e1b38c098fa411247f8f66766e9102f267e54c3c294b0f4f2ae00ab457cfc97c5accf98a0ecbee8e72ca05606295615b32b3908665e92fd0f19db4e2e268e1645c9b6bdc147d0431d4798a0833984ec3135087bd0b422a45986595dfcaab3eb439b8e78a74cb56f434728d7ebf12d78933df1426b7edfe0c223c8ba61edf5a69a1fb4f5f6ec8187b006b5ac63e24f34bda051e1d5661bfb6dbfc21b1edd731f613114e50eeb4c94fe731eb33a2c8858e7283b79e765dd1beee117eadb663ae7ba0a69e5007ac8b459118d97c7802bc3159439ee5ce89eed049e49c4b91fce6d55bc6d70705722f6927822255af5cb7969dfb61f0478f7bd1bc35b737338a52b3d6364e59f7bf08f701addcf9d53f3d01654681c6c9bf8ffcccdfcae994af4c72693bbbddb97f54c1b3a220576761804f312f641af41143acc5079c3f19bca3ee9ee8149c9889f80e913f811bcf07600153bd6cbe085e64cb39c41b8603bd1aed4049ed9d0f037f483b5595a2085b2da6147d6c5a2ae9700c1c76e3af43436760eb3d534e433cd194ad887688d7fab1f06caad3677c45424e30e11dc35c56b9822622d4d41c8582287ffeb50c711fb37b36ba403bec966e3deee1b073484d82b1381e34c24bbaadf22c382ab10e00f109bf2a60f0b8d8c3e349e4bc70846645d85c0d70254ed014c1624a59ee9c9a732e5645b311895cb6fa1604ecf4c1d3562b2b60e4fd962625dd64dab6e2c8c52c35051b90bfb38dbc70b9a5cbb3c6b80a8e9e9286a555c5e819f15c5b130186686b4aee95c2259d1ed4db94fae1f2a46d9c75114516c59ccdce469a71656ba62153bcb5d43a221c97ba9029bc7c82f029bfdff59fdca6b261e95ce81fbf31fcbff76bf3fd1e23a35ef6e8b2b6c5e9d0af985609fe988cbd357ecf65ec9d761fc4f5d255edfe315fb3c5118055688a67ac3acb38dbe34b3da348c006bcf81ad7c3d9d26431a1499fb3abd2f32a1e4e300af5ab96ba78ec15fd7aa98cac29c33b6570ed7e9ade681f3e54bb20ef4dc2ab84b6e933bcfbf089c4d92b2d2ed0b994bb2db3bda36d983ccd92aa4b27eb48190bba7d2480cc4ed36ae7c1434d16b4273aa95956eb6777581218094e1e600d55cd40524ae5dd01251e1690c0b12eaf6389910616b5cba9f3ea52c9ac94e817974f8f900a709ebaae03c1c06bd4fe5a4d70a640420cd23af1a8feaa44981d8ea3bc2a59597d38b91d9d085584e7d6967f40fbb91eadb14e21eaab8b793659bb1a33e6cf3260a79ad81656fea9ca6165ab56e0e7851a2fdb1c326ae024ccee2811e9457f202eaf0a1e4ab9295c78ca4957e190a376e7ace5304c826dd7af6c3981a41f979fe454534d2f4d709054fbc7dd4541614e05e11357c9828b485cdd14d4ab34c5533565eea1e5631ee9ca3f75c0f97f269f41f8bda1c6a8fdaf08be5a1cdf42c7549f82da0c6c849b56ac88b855aac15f31db4533369dc1fd4fa0609470fa48980129b75620d3fe32a9e6b6867b19c767ecaac7322396bddee5556af27def35db8972949f28e6793fe28c4bbdfcbf8ba6f1311d94f17a370bda8b254558d9766ded7593790d18fa7ce6188f6fe7d34afbb66a702725853b886f0003265600d7bdee68e14fdd8f27dc102f50ae37c9c4b6dbd8c535600ca1dfe143dd4d8495c200ca229116ad022ddf22951996aac91b135f970e395d4ab627d324375f8bdabd89d93fb748e3f2650ba4683f07ad878e2b2dba1a282c8b20cea8a0cf3c324acba59f1d6084038ffdc58e6bdebbe9ebde81e0ea2a868d4b956c3dd9789bf0ce6d0e3a14202448f1cdb172c7e15b48af9addf80a5e59bc61ae2b20aba98fb3e8d0f9c87c5c6c576694903e607552ea2ab752c4ed042f6227aea433232c4a2d55e0d36c278ad9d9806c78ebe663934443abe5c3b416464b1984aa04f7d862128a215be18e82301fc8043963c48c5bfd93c9bf74f2c3a30ef263003581897fc0fabcbf6255ef002c785b93ea0c565fe185bfcbe655cdb1e032251c6c699f533372c58d4bb7aefbd9966712819782f9b352534f5567997b9c28621580ba865da6ee2df9218822c80c953fc682c2e4973f99c2e1b2dda5d213ae1c31f6eceb59135cdcbf3c391e5d5889b8f1874305ef13d842ad22f420daf40575997b74521a5a4a20d76a6a910bbbe1de95082d6856ccac09d6dfea9b8ae5b07e76fce608053d6cf87caed9d0add4e6571b782112d42b5bc404bbb2484b11c294a6f5757848aa0f31137a7cbcebd7f06ffba9ec29c1fbd0b94970b5cf6dce2ef5ca12a1402d4890734972b90eaa37051b7414506ab5a0cddded578bda9c2f8971de8d22f12eab385c27b8a626e1b466f45293fd0c365020c299c72105aeca6ddb005c0259c264e3abe26e4bdd2aec307b740cf3e12e016144ba9af92af2c3ce1c664b02ba5cbe9695393270c757eb366ce057d4ddeb6bd058cdd003ba8bdcf4d42bea5324ceabbb11b804dffbcebe2e845eb51148609d5153b683ae159d0de6d2f02643b365a5bbd84f1e87f22045928f683747a0706dd51b4f356f1c39956da663714f7df3e92287a910302624905f37cfc1b10917c10e77a26c8591cf251a430f26ee35c96455e2063bb7fb699925f556304a77d08e789c3f17183dd0ea207240f11ba35e0d7b67f6982ffa64897414b1ea232cace073a976250485104281eadd7b254d1b8a19932f74841f8d99ead9d7879e8972edfcc5a1a685bf9b940235a5cc22b4b8f73fa6c05968ac4cde95378193bbf1c3dea88e1e46926194a6e460204c3a76cf99b9326bc57b5e82519492e7e6797c0502dface10f94baa5e0bcb4495b01c0a66bb459ff61481600b1848ddc3fc453d6510d0e39df9e6494e303aa07b05f9f4e4b196c75d376f7af8fad99681c74f5da1717ce13be74b0abf526302ede65b7cf7d6bff327185f97279c22bb62c4434d55253e0b29ae5efd8e0bdd17c3a338d10303c8b188bbedcd6a9f665fbe0c35f202c932743160ec79c79b5487d116cd06011c28dc2fb270082d8eccaf5765b2eea78a63c0a26d5214b9c5294adc6c8c78b2d37be60e52980fed07a5f0d3ff839848cbc6bf7d640212eff4de9604ee625bd7c1784761c7d593772a02da547342035a08741325d386c86853f37d4a08cce0eff0e94ef11c161aef7fd98d12274bb00b1b255f2a50fb77643fa371acd8434f33e6dc30a7a4cc922f237e85d9d42dcedd32e030b70057aa6ace871857ac6eaa8dd4fd03e914f4e120bf57e4faf264b0c9c6bf7f2ba9c6037c1f6c8d3bd438eb40dc70ffe917005491e5a28f75b5dd492fe5dc57e1c7134be5cecffa5eacad5320112afcd070cb98b3e8065cff35beaf8a9c46be4c8ade6c9cef5a513f6d080275599c14803496bb2115122264dbe270d182ca1e02babfa940c8d4acb4e17a6c430b2293dc5cdb4cf26f9ba48dc63429134d6d7248fa9abe62ffe169c50fce50598ea4a4b6980d3e0d98a46a7f83afddf77e3dcbc2d16447a77fb9148a518ba152060b0f6bca6e91d99abe8957104b96d86197c77d60f0878c068c6de4b6770ac8be8ee15c238c21ce2cec48aa3c13b9a32020ff1c3a0d5eab5bb9b824b1cba1a07292fab56c4f95de09b4c45e5466da42bee6d199b1b80ab802557bc8d79c0f5cb6ea8338ae51cb175a11ade1ddecc47a2b222d2a86f2c16e549cc903682173b6c138cf9d5e8ef767ce44cb0eab0a4644c3365c29f9237107a24b07e12c1283b31fab49e9ef13d5fbc70e4425e35b0af9ea6028f7b9d7fe6a2c6ae1ff4646b4eb0675ecaa85c6f01b98cd16782329f394f2f12680ed3b163698cb6c2687b5ad816ec0b26437aebd476ec0db9a521213b4b237a7fac8b22f53c4b899fdb83803016ac7a61ae126a67a18590297681c4f29e234ea7a3dad6ce0f3519e44fddfadbc97404d31e4d3c23eeaf99eda0474ed5472c94685d153258afa7a2b83bfa84b7cbd610fac6a594d55325e3cbb86c39b63aad45237474d60a443464f6e0716440cd844f1719a7b52dcf052a9b2825722d689884e274790a2854d6db5e0d65d57adec5e583cdadb0e501cc3b966285eb335c0ef2aa15c21436426efd52bb8a8a129dd24a95096b059cf39c4cbf1d01d847f118945e38e2a08dbc9c25954b17e244dc60c595855288ce85781614cce0c692239b19b6c36e13c2163af77a015a6544e30dbf768ebdbb99d97094d39f67f6ae954c668168590ed3de6aaf4d1baca2011fa67edbbc0ebc9dbbd34f637ac83e6aaeafb22b23ad3d166f2a6ee791100e8798f5bbaa209afe2cbbb9395d23c3a64031611d417d6ee1a4e1b5eea76a775a01b9eb387d94f80ac8892cbecc3490d5a2d37afdc6a3312280a73a1263f041ff39c6e6f367afd27f6890d31ab812d459e82a10651377fc369e877b37f36f89bfb1628c5a2f6aca0bafdee9e63cdba07f71d5300ea10f2bfcac70243c4527a1827a3bc860c7c77c10db41d0210c6ca69d993fa3fb3048003964744ae817268d09244e7e971516f9dcef38750d90883b7e887f8f089f02bae12d5ac37bb622cf998320a01a8b1ced4f66fe9a120450419068d90598b8b979566c62ac27e208ef784f74fb175373a7dea712998f005cfe218b85491ed764ce1535fee2b8cc2c856ec4bda73de14016a4cfa64a09c42a29981611113d43dfd487a8a5bb7c942050e0fd1b037526bdc9b7558c262a8d31e3d5a9276e3e7fdf1f21f8af254bd6feda46833aa0a4c9df134be2b8be639b62865330ba6cc7cb34fd7fec36b71c812aa6f21603cb6c91e26b9334194b9e30776756080febbd4be8be00fb5e0d6dabcf68fc37f41d75bd0e6846cc38aaa5461b4c7c79c124ee3415a211af79500569c4b2fbf21c0e41e520069c389e774ff4430f16a05d155f26bd066601e0f80f3963ae4df43784f703d0366f0300d5209494c896035c8553b57cff5b374187080c5ef79da4fefb5235c6c9077599f92875ad131d368e1e8caf24f46844734189aa7db0bb09358407beaea6d50335e94f913a6b95df52d6bb42a287d2286e574bdb0c723e17949992270eaed3825748e452b8fb0e5723e5aa856f60c16dfd012da368837384905cbd255e45f313e77748b188ba555b2e9931e3a52b5fb9d37b66e657177460f056deb921bbfda0ba6d4030dad78b27713cf4526d7771a5cfd91332b8845904dd67bb3eee8fb486f5f89b8f8c128d932ef22dc453cae9aa0cd7e1849c39725dd47ec5cc9f3a71487617ec0d8fe2701a842f58d1d518be9c497eaabd4086c89f7f835850e42665d028d17e698567271ce524c4e6936dace23f5d8dd5a66656e41ecd0a432b34fcc58d35071cb614dbd7aa59b62e71f3d9e7859b0627c8e8d2799d4c1f11afc3fe554d1e97e91b0ad512f9bde3d74a386dc2f9477cbfae22564bebf27ca8fdd5c7be7c1a39a6650baf64a9037553ec8c5abe0b7f9968c7afc433339bd37be03c52a242c054972f21f800e3a21ca1c7b19dc7d238542b28a28114e4227643d1cb6105b17f6baaa86109b6bf9d30fe2b45ce7767392e71427e3ca912849f140dcdfbc0ae3317a28606e3272820e9794a9f45b06b02752d88dbd829ac90eef0d8c1dda4ccc84662c5cade36a7302b53f40503deb4226311bf7c1c4922cdeccc90d9be3b605fa530e0c46776df6e7a21fec7783a06109ded92270f6c6f59945239459cf3c2b7f48e3e7a1fcbbf06e47c989cb391da456ef0b8bd12ef11b48ca2ec9506735ee36da7fb622e82536f163a019a03ebe7d0db186924bc227b56242d21a4428708bf2f445e8608fca4a7112fd12bcab022be58d21a011da579f971a69237c90a797717a6137a8359cf3500b7551b081ff94b2c52adc5100e0ed77b394ed1fd65c4fedcf97fa56aba0de082a6190485a444abec23da7d198c0460855bf6377f9929184ef6c2406858eaace834dec8f5fd84295851142baac93b0416231c91950dbae8fb9774b070719c83a4e331631a3b9a79ff7a65679c6ec00dbb872284980d7059f577b42898ae1d4812e1f24063987f67efff8eec4953c6d848e3d37598a4d05e1ca185c8d645ebd9d4af50beb3cc138974b8a7d1eb3c991138c3f527a35e0a5a4e064828d135323848dc648a837859c9cd6b7581374391c7c095e520a588dc843d821b31c30ca7274e4432769a6a82a761199b4add1293123d6dc09eb2bc150ba9a4f9eb7b41833cd63f6437e0fccf83ccc4c0d325c1641c412baab611f8b69edb3d1f9d673f41f8c1f67f1572c512a040c857a85cfee89a6e13cb5357a0c670577337ba40a5c55f3e48de9b5a59bd0f501793d7880e8db236c73cffc5df7e6cf2ecdfd1db0c147396298d08ee4669296a8deaf9579c745107b6a636fa62cb454815b9c94bd754f9d45f0b22dcabf18c3e78fb14d60e7bf1228c24a9e416973c2c2260cfc167297698ccb628546b83da0240105be29dba0ce0f2db9719db52dc83b3bb3f64582a134341ed6e214afbd2f5a36d8db244852f3517887b115ddc2555013c69a77c16aded6bcc21305081e6e81f3cfc8d26841be465ee338d03790e1b48cdaf98a88d530a58cfb4c828e1bcb7bb97009792b7f867957e73641fd23bb617507bdde3a667b9f495c7ba1e00366ad1b4e5d64005fb5b9c7e22a2596b59bf1a7976fb7a1693909ab3e7dd73f304bd2d97828d9770f102f7f4b62ffc7c295cc3262a38cf4e41ca912b0d8f6e85392cf85b0f5740dd4c93b5bad4781e4cedd61b8fed2ba0743b049bcf93d4ac12de8a6ac4f5707140df4076d31e103e8360835959032e3ea8a796b5affd809b9324dc21888b31d8de9a4e1fdb4f050ebad33f30948e7a81678af0b7dd357e3865f910147bc294c50803af3d924e2bf815252b89a9cb3636caf2ff0ce138b4bd5b5c1a8685a3b04fc82c955e216ab77139fe78d84b4f885f3622c668b4eb6cb26bc3cacc273f1b1d165cd3966d6cb5f23a29ab6ef6da41732bf88ea38427f7afcbb69ab5131d625a4a2c027b708b33050340d109a9b4fce68c7b7c6fdfec0d8121fe8b371b5ea63a4788bdac543ef52c5e521accc8056f42cf193a3f97ad6034be697fc607fa79be1aa9072e25ddd0b679a33b669bf00ad5d4d166f0786cb473fe02daeb261395bd139767a7afd711728e801638ad53a2d2c7cf9daabfd98281c9f792f45791a29b519cea9c317fa29754f50e184f5c2510542d51108c75701b06427aa8b8828bbc27b156d6dba52fbb24b9dade0f8db5fac5268b645299df9e4bf911a59572ae3c8f488676574900c5df0c0d040ef82ac0c795e90b670e3f2521678d6f2e2427da5d0a6ddd44137eb9b1f8314e29d9f54b21da89982172b9968d14743240b93b55780bdaa96487f1289b2f3475c20e67a0a001f57743d98e21e88012dd988da28e631538905ecca660f77aa446b8bbdb97bbc856f142231aca07cc7e56841f57be5f62762c459df602ac9a66ee1b3aebb03f723a00ac80c7f4e5a8ccfe7b2a8b5e06f4f4385e388da5c6ec33e78cc3ef65c7a2b9c4cb2ba4e4aff31fe53a8d489945c4265bc557afd6825cc8c38fd3659c1836e12fc73acc4a1a5868d94a50f0c2c04c9ab8e5372790f3a132a8b7ce46d5f1bf577e618590d3cba433c162cd191eec6871fe270603ad3229585516fdfafaae78650f5438c6ffd3f6b47826db6124980c9b660565a4195b1bae6719adc092f4b39ae0a09b18e55db5e26807831874ee697a4ca4a10c124f7e3dfe146a6da6f32453c44a91602ca0849dac8dbe4d3c922d75be313c88a9e19b757c601b05eb4e400529d0e9f2791bdd7447c416a3dbe12ab57523fd851b33b1a85e7c3a91194bf97d07988797e47a96fd64ae31c622ef3fb7629a0000cf71b518f70805460633b1cec14a66cab62e1e767fd6fb95bf58a8cc871e288d339ba80b10a2102bd69b0418be0082f2f8a49d6c5be4b0ac65a6121435d7ea041cc8d0e2ad1476d17f23936e6909616f520eb1a4fe07e0c0691117dff2380ec45da21dcc90862663a4027789e4e2ab81ae525585fc2657fe90cfbade349486e521050418bac935a9c44c6ddc3f47ba8d0e69f00c5bada1477185cbc025d9294e25ef9a91b6a2e4d815190cdcc3f8ca032c2b24bf1471443e77c38b16d2a79585c926dfe05c06b8e29c915ec337c8ded62f72a3ea3d4c3183ced8e5b6db711c1cd3a5ddcae40ad54685668421349c4eb6f9d28577b78e990711aaccf3751885036fbb51c78e0ccf3b9688e7b561ab2f192ac4d354c1c4ecffa0c61895cad1b074defc9b11f6b6a8fb49b3133d57917d5ceaedf993156637546105d8bec1eb980bceee3a6dfa7498db3d82059bf66417b7072658d4d797539eaefa814f8c8d9e685ca807ba77c2693f53cb62c65c1e8cf7b9b7e80b754a0723595d3cc4d667c31718a49b4a93a3d67661c6d74cfbdf4bc79edd2c51db72f91cad318ee8bef9d394f9c6cdd1a64e49ffcd14ad8921aea32431a7ed61893b959bb814c08192789a1116065f068d57fca2f6eba883a1623eb22a62888b95b32d70ac03fc14f1b115fc28144d11c8c374305ebe1fbf7b13f3c979ec8daeacd7547247131652a241c34b847332dc0b62515afc6e062e247961ebcd5d37eefd39aa60042505eeaf6f5b1b04af7e4ba609560b4eee2f0d4e9e45c847e85b66a92f8068e37efcc46661db3cd9740e175e5cb61291d72876896034ecdb077e446ccbbfbdba6fb09eaf7110b5c6cb8375a47f0cf38ab3965fc374f726c98c8d97a98e06fb551e9bb7788ec1223e140fc1e5afe65396e5745031c25f24dc155acbea5734eff358c30a95f1f7d536385a25b133d8b976bdd258e3e9b5612c9d8d27961231ced69092b5bdc54d1800a26eb9047cfee502934ec8f195c6d2cfd97a0c50bf15f3dfbfbcf686fff106d67a9049416e3ef0e33a6acbbce3864f11ca2e2ff395c156b4910fb990962ba0ee5bfb195bddddef1f593f06375708721ed23bf81038660d2bb64464b9c20fa107d4626c90e30c7277e126198698da1e1d531848010bdefa713b1b989ab24dfe4ca9c4e321d54705eb22e17538beee7370e724fcf527f72b0a1d3aa4256ff2fa322849ac3643113285d0fabd695be64b41e6901cf60391215b1afd73cea0a4d96e84ead566bf426bf6b85d85bb76a846281ca231d2293664bc852ce1695c90443f8249c9b7370e2e7fb2b40df5b53151a4535c474fbf82b2374ef681a6c7fb291fc85dc679fa81f83b3469b9ffab9dc48ee6f69c0896051439f020b652070a88ebc2c9b18383a460736a8ce4a0cd2bb595b9d76d34553e13f35198c131630418a4acabba39213b628b7deff1e087da45ceb2f4a3d17a6fb49251e2a0d4beb42ada384f3f5295467a8827b80f428b11f03995153f943245aa7b1f72a8317fc9f7b3698e414772deff38cce7e1d23e3c7a6208ffc45c879dbd03a2c1d0bdc192f4cc69296c9b0970168e77260ced2f043bdd4f7b07ad953d7bd7dcd682d592e4a22748936a30b57e6cd23b563540aa724341c8abae356a9d248860183d78227a54a170945e6d23933db7e02ba4d9284ccb6c08a747737dd455f51c0e25a562e97a000e9bafdbdf43224a0a7a5d85d39813c70f84094f28e7457c930472729d969601e1764d0371ed0ad373f37e93df217d4f834723c026a21bfce53a3c4bfe4b8127fe6581e6c123759d6db37402a0a0952b25c8ac7bc591df45bd3207477212be565ac928a8149e9542cc78da3cbae85f574bec88f1541b05894ce8e4300ce7364939ffd8b01ce8b787a5296429345dda3be6fbb6f4beb6335a7ecbba3431c5fe7884c81088c254fa411d7945880807972d64e75e820db5113427e6c5af7abdfe88e3a82b65899ebd58d5df0beee1f74de42a9ea158e801e943c93871016be30baaece7f735852e24c53e99ef3e7339a3083cb9e1408518837ee4835abafafb5eeabe43d0f8ccb0775ea47b9fcbe20202040f0cc7a209ccb082eb1fd2fc93c5dc74ac9a1c28b49114513c1ca8e73a08ea4c9dbc55bf7bd6da741948d8f6cedd69f69c8d1d91abbe4490e230a67ba1eed460ef262d62c98203557272c45cde6248bd6709dd0cb087a5de3a114e243bad545d2257f60f6a0a671477b40a48aaabfd3459a27622177b5b952629e43b6b3e00fded6d6b8d17413e43cf57752606681fc00db7027eac9f3e395dba03f303df90d0b56749ab0159f613a5308df21b31a5452c8e5e640a0f5db6374943c281bffb833d0fd57b86529eaa979e3b86dbb62bb9f319567761cb990139fff5258e3e8e01671d63fee17dbc1094a297e5fedbc003749fc7877c94098d551100f03f45b15f3cd722e3fa3995a44f9687206f0b35e060052fd8d6ea42796c84e4a30997b8d6149bbaa3d700db6a98459fe3b58575bf7e5c518b222df6465200437a199b6f64fb2d92bfb71600aa942737641b6c08590a41a7a9d1d3f353abb4b6d4b8c6c53a136fe18f4fc1a9a79075dbc083f1fe60e4b42c8ffeb8d319f67843542e35a39b7d663194fc2b8685326c2ac62c0817c29ff41844e079b4a16519353998ae8351973bbdf78ec1fd2a77b4e4bd51fe63914bd2a4e93fd2ba3e2149695895cc1c06db70af0b3cd68ed76013e4177db2cda6a856952bdda295e92e6341cfcc14d6b582b8dea79e517c4f7b8fc6356e5f46c7cfdf3766e5bf28bfea15463f130d74f29acce18b73a633f8f8519c7667c9a3acb917e844af00dee6bc98e70a5925acae1162bf55243d557d0ad964d6fca978f83acd340541a62194203f429aa0da7aa44f863b66398786104a348f356c6543fb288b3f92a881c2d6c8295d29fe25a0056e2bd02cf404949d39ddbf54a5fb300591a2daa0aafca7334d2de796c05d70afc35c892d3df262e46a2b1e65b8a8ebcc86f9ac2dec2814713954d59020dad43ea18201d4afdb669883e6a942ae9a7111c1c5e80c26293655ee83833dd68a036c903d13b57f2a8b81e1ed4a859dcbec3938675baa1e3204d95db6f806d28c2e34f86f7a5b378858cfe28f44b83cafdeb34996cad4259b09cd499fc1730c6d94f54050e4e270058b6e8e40d3fbd9304bbbfc0e200bdcbee6b092a771e6dee900139839ea9d007c4b75272074e9dcd910f8948a17efc3d7a38fdc5d8043be7e982310cee3c25119d8792165a43b185395ff8f6e2531ac762ef7bc91c2744165fa6d252f56defc9983303672cba707093374fed062b921035e44ae4e29e78a94a7e0e6c7a45fd001760c365e46668cd1b2e7b1cee579cd2838336edcc795b7f7b47fca2b3e49ab00cc691190fa4024281af639138775f3af65b3748adcd41ebe545ec95a8201f6f32bd65413a3e33a514b630d4797a97a350e76d3c77378acb279e0a6abb626ab7fbc1358ad325c7aa6438cb5f0cebf2cb9a56e4edffe0afce6cde9314d7afd69d1dfa2ff26f93d405e7658657d80bbc5c58df68e894a3a41210baa16a99e61ca824c62c594f0a776ecf8b17b0a90da243e839068e39c7aab353f2a0a7e2da65536ef872cfb899e7f4df860c7552481621114f36085b58127bf523677976690506e9d7895121c9b0d2500be9359ff7a48f7e0a2ee3c1a85835daa14e696d24342bba491079f1d915ae04475333d94a9eceaf248c02228de0719f93f5998f716bf71ac9d1edb446cbc1df10b7b3b9c5d2fdb7fcae9bb53c240024a5664c603354c164a0177ae2ee45667bbde7ebb5a890f8d216233f3ad7bb7d39ce776efebd646db4b805d2f60c44bce18b98e51616aa522de90ab58b1a4045b411a69473f4cedb54a354f74e95d29c8a34ba37e5d2be09c6ffa3c45f3d6619144d6c6ba758ba959cb18fa96e4cfd1d9be45902464a58acebe4ba401939164ef4d48fc067715e2788dc78766945c060f174869bdf12c6f8f44e8550f91a105d2a063e91af32c96f93f73cdd5d3bd6934b2fce04c97b91ca61d49de9946bf9828f8dd68e8c2164a7bd5a85737a94ad7e11101282756f7dc7e5c05acf22103112e376172fddf4274ddee72b5df651f3cda081dc42b002674e88d5684ed00ef42576c91775ac59efed1143c2fe56dd28ba727a81ad6d2a1a4f35202395362bf679ea7d91d0e03b270d9037477b8c562d2e5d5b171788d5d2d23038a0089f14ed143fe19bd63863502f5bab67427881f0fe102c844091fdd0076a7a485af64a35028c19c8be7e0d03bd48ee908e0193c3d53165f86cc30341747cbc4d6348c6fdb9412189d1b6da6218e7e888291a756ee98ac6d5a9dea8558f54e1c48fb1ea5842457b94d0202764e535409218923356b655dc1411c52944e9199fce876f2bd426e8e8567303316164d23e08355e6985a9decb8b4fcafa3b34d323a4da123f3103ea9ae6d53fce67c29e5bbbb13bc7b9b7d9d5f9a783ed7ada3ba6035d23e92ce0be22b76a486d16da5dd87c967331684362030fbbf3842b34f764cf27c39ead3bc706fed00949ef92e0a79b599c56f3b36902fd9a693c52f4ef03190ce840615f343818cd732326bb06a211a54afc0f2f636ee9fa59bf4c7c850733740cfc9eed9f1aa5c391d5b1f3e8bbc7f233aa8b9d18b948f77c1c711114dc7ce9a70d500447037bb8c25b83dd2ea219f3f1d02b2710605c99b6e47daa0aa0e5681785c0560dcac1c511e3c0654e9c4867851ac235ad7500de07bfe3a419252b89f0bcd512b9801f2447b69fb713c99cf87f752fa4357ed2b017b8d9fc7bc4e6b9e49dd7a503d8dda79f83e84288bdf2724121ccdfe1e92e3a3996463fef9a32e66d6076f4d39372b8b2bf1c8dd3a61f2cd4350cbe30ecd4561043d475ebb8716a91001749c4b430af2a252fefd5570d6697d4cbaf23830f846486db95bff0ffe3e68345c4b82ced2967b241ab2c9d189fc3018b8330c7d82a86a989e96cd369354c2c697d8fea0ea8db60bb0707ec100cb93508d8f87dd9c0057c9afbd91349012479447a764c978fc2a5e54fa11fbcaca51ebf51350d0ebd557f461e7531440760cc114ad8685ed34abb6c130638425ba3d059706b851c0b5bce4ad6d87d6144185671c50cfcadba5510219e0fcd95fe00d8bd3fa2b5d3b1079f6c7ac3b108765cbf703ea897b65f08c399ee935667b42c3e3de4311a58b0f6d673d73c98918232fc1849e76e8804fc807f8dc091db15c4bc599e7f7da6e75bc2031c1f8c9f0b729c8e8cbf98fd153ecbaf009932c63e7e8f06beeb0f2fcfa76d5ff5ad6614fec069e8922862b4a864eb617e0ff93f71f0929146cd9c3d7c511a218bd35a48879ed9fe51077ab9efdf7eba44c203d2b1887e9e3962069beff801456b4680b23410defdfc2103dfc85c87784e497b0dd74f4d0dd3e367f3e0a6ab02f73493de280bbf3a1ec8baa0390555ba2a46f9f2940949d3b92000cfb04ef7d9bd7824a43add9929868c3c5f26db1ab5d8283a16c60edffc583470606ae546dd043aca9a4f827146f9a4aa61a807696eb770eeafc3e49a18a261d332038a190c162eb68e5e45b8da679d441a674ee2467915933d41986a090b07f58c6a21c9a628fdef6d04e0e43419c33519f8e99e0f35ab94b8a982054af6f270cdaf802d4039f571b20da435ee9d75dd73a21a19146d4e4ca7fefacc729a7fdec6ab835cb5ee81543532530cbe339c3d690c28b95654e27cef8bbc47be70de964e94debbfa5ee9730e20f30cbf7d8cd1f465954ad52ffcee6f96a07f308d6900d1c128af4a8f7705bcfc68fd8c92b3571ba0bece74596bda111f0a99699d2f4339b1d964192d194c75d92a03acb78ceeaa795201e36bdb31335d1c265d82a380685fe3919617ce8e364becd70da918e8731bc2b63726bb2988c816438bea444de2ede7b7c78fba998a1889f9ae7b35d0740abd164facd4fba041f2ccf416f6ad93f3fdae38bbe87561ac85dac69d634c78aa5334d93842901dd4b91d1d371a68b5ccebaa2253d77a1d16c7983f78bbceb36d55709e3b387c3ed22a91835d025735dcfcb968fd9ee5f119a25dcb12d41a20f224279ebcb4f1b9f6896de8955d36f6e4ff83e7805e78defefb51c11ba241dcb22668d453c13856513d65a8f7f8c87040b9500dce7be1b99be1b049a2d3234c1485545476a9a21ca3a05b666e5c161720e8d50a4c1806b6f82ccd6334675eb392e6650bb53d4fff9f4949b1bf5c27aa1ec83dac9d4e8b0936e0f44de1509fcfe420958c176b7a21fe58b2f2bb95fe41d3855495c5908baa6e3284bd2a86247eca1a427542f33603fc6b785eda86c93339e4b8c70f9fc6558e38823fed9575fbb37d6dff1135551d9c1908c437669a83dd248238851cc519025df3b603879b7553f558763e85d47ba2bb860961c18869b72f596774efdd5dc80946952e73c575e980e54ead08df96fc59c1eb45a7a358350e3a1c9952e8cd8a721f4c20332c4b742481cd103b05600d35d261243346a4f3453581a342c0c1a94e2804bd52dbe0e81877d681ab2f66d9a1a5ed02537a5a7b71deeed97febd185294d4412217e3f00638115d4ad94d48586de5b0d346c1023289f75aadc80c89fb3837198b65a2c4dc4b52f31747dd213bd12d32bb8c570fc496a0cbf61351406a384d214e90827d4dccd5321013218c91c83322259a24f0c117c4945a8ecc5b0165a4280b41c9b9a449c944c559c9558b1eb92e1feb3f5f8820c287b2a6f24307dc269c6aa4bfbb3db17e72fe5588dd6f2c80f8e2cc81ebcd4af8cb3771819912576d255f9fbe200bf7178576764f2491dae0cf765b91538390eb300d96770aba46e06a0f2b67483f94f94205c4efa5b09d56871e27c41558f0a33ba991afd2b9285caa992c3f01e4326217a5c655ec19f6d469d779ab2d84e48a0c448d2460ad643910832cc36e1e0b9d82d4765bcef762ccfe8b1b0cf225ace45ebe67418575508b1e3824eca635fc5c36f764505889e83c98dce011c9079fe4594db3e174e9e3660164a0af43f465da3675d5e06467075f0847179f8264f6c5f679ccc39c3e93b1bf5846c09a89ad9f2b46f104ddf04ad2e1cb7239731f8d7a809602663fb0f5b6a7b962a58fcb8e30ae922deb375f761391865163a496ad8b2cff004108c81175bee1fc624643b32e6b809e4b8587a87df8af5fcb87b252d4a284ad4b4371f9900c02e14bc33213ed11d3e84517f1c65dc03dffdc53c276122897468573b5b9607823d41f5771e4b247b3da1509f8e608a2a754a4d70542d4b793d9a272e06f11d3520e9c8de6a303f58c650f6ca8965627e428abb3e1b9d2cc496bed6bae1d718a2e0608a477cf90fdff9e00bdeb1f0c916a720c34c1219026e0f49bee09472f704b2a2efe15c9a379e03ad0a3c2662444f9141b8175a605330327e89e381e58be9f67ba5eec68c3b475c213ad187a539ce641ab60c890534d62cc785c5f1e49661878c39ed46dff465829620561b55af137d3e3d186e7afd44d84ff842364c2916fd5e13a248974b1dce50b161af4438e618dcdd9a9c5a61bde21f2963438dbaa4fa17412c4817ac71c1b461305933e97ebc81d316dbb5316886b1c62936ea91c6c4ec9ba5b7b2dbdad92e4f177924e6c6313ac46bf07520183a944186618669318eb219f8ab58ab47e15ea9d38af4ab277ce65984dbb89be146e4b6d2f18163c7bfcd09a4b039c4ac1a790ebaff7105bcee1e429645fc40869405a71baf499ff334e70c3d31e178f069f635d70000612cd4c55dd360647fca15f015d93eae0ed9153fbd7637a6f893142e58b5330f1cea14f575c0a54ee2a66aef9ab38735613648510527f3b6357d9e51f0f303c402ad47108aadc38b05859add664c363a35d0aa4697ed79e7394938167320f5c211e2a1f7b5936367d061327381b3412536ebb142fdf0b091bb2b2de876590fe672a4cc17c3075af4b2f0351f19b2622e455e0d54d44f0404e75b74d5a8e2f9232b37750b7dad8482a4ab4059113eab6955614d095c56dcd3da2eef629b0d2ec521a376b3af6ef7bc58fb50992a337517751529155bea3df3ee6bc95cbd9cef1727b259f64e74893e5c9c99c79ef2978b1e7b755fcfc2ae80abb392922debeed8554f3ee49ea1876c2cdfd7db6ad1efb2fd571b5ee39e477161eeeeec4f2ee315e60cbd6a946ef067498be7b38e2da7a6d924d3077541f5697be2a20299ff4fbca05f86a592798876b8a1eff296e9c52a22825b8f74455cf06e52a1e2be7991786ada99efd34372bf3dd21d07d5c104e70ceeb952bf738aafef57687cf54a483cb0ab238a1180a973effe027bafc2f5233bf0c37db210d790bb1ef284f607865204fad11a96a2613b8fffe3ddcf9370f27280420f6fd580ae39eef912fbb13b301442de264710a4f9210de17415b43110a2d2fce8f5cfd3872b3e7820c1adaf25db80c73d9508fb65ce3382877f91e08d5eec06e9e0f2faaf11b7e12f5b3d582818f75d4373782788002557fb2551b2f7e19200e0204cbc19e39c5e86517cd01de6e7c740f555bf6bff8f9d6661ec50f1ae8134790d343ba17d371587c351576537a8e2883963ef998ad984783d0dacfff38a409f8e1a16005eafe94d55c18f4dd43dd1eb5d0bb84e55f126c704efe35e0f0b2643abe06420937d8fc734b64a2fb5b585018f9b60183bf25c5b81545472f8f0912be870489bc502bb952d924da9ea87a487319680836ce45e0ec0c6d2178bba2ca698c2f518514cb597b89f5edcae48b814baebcd619cf5a148e8e5d7a41d1606c8903af6659fb27970c30f7e281c90af17612d2f478a8ef58b85dcb5b7c3b0baa3ed925d6a95aa6e0dd3b656fb3a7abe4299b89513ed5768a7ea5c0dbf133e8fea564bcccff8e59f01c89416a90df11182590a09eed3e4f7a86ac7d3af4faf89a487ebe2db5c5befeb0d8f4d851f94ea3ce3ea0812749023660185ca218fd5199ae0efb291c1d1a536158cb957f9630fbddff9b8b2f2d7ba79b0662fdec13f50b4f42ab580e86e8b7aeaf7fb6172a76cc106890b4a1bc97a7f5b66d6c2d1ccba1b87dec42b0ffaf643aad706c8f104033792955bd71b82744721c39b04940be9347f939c8501ef34e733378f17727e63889cf27ae01e975729ad52443c877f9b632bc9be62d3480e52c41fff0d71bfa0f57f903f010a49968ccfdd2dcb82c9437b5084c1e54780680a9107db95ee19afee1a38bfe050e470f3024075238bff0ba4aa6388c530d18a2fe30cc1f7db578e92eb5cef4e0001b6b42114eeaf87956fb3697bfb913f2f69d716ce877b5bd79859d5eaf97206b5f6c6200deab804ce9d24b8b03671b692dfd45c18cdba707d8af640311ca2c10f9c962bb72691460a3f5cf6adc62a7e8014832265fcc2483cb69db51efd621f0a6d988927ce814e2249c5b460f87824bdf9126f2755b338a8dccb8f631776929d25347bf5eda7b1e2d5b4b8acc529627f714887141a5635ddcf6629acec63821d103d14f581bbb8f8f795cb6e0c82c442bde77f7a61bbccdc6c5a9f8c0905293c91531cbc75ea165dcd0012ccef471e353df6ae0a6861e492368d3f2d6db42ddebb2a2836875c5815f2f902fdc8cf1f42bd178e53a8adc616d73dfc5783497b824fae5d083f1ab8be199f36725fc87672eb9101d6b6e3f9fc6aed4917416a7fa415f8738450f63bd1d9a4df5c406636644f7ac78db2a972bd53b1a9edd3a9bb2eb476c93f36cfb7f3d027f3dba3b7dc61f31c063535f5724bf18bfe11a3e98729c2a795d28a13eb8abc9c88ef57355b63d942f018ddeb3b589bacb852601e7d127cce15013e53b7b4a5d6e9461de296ba720ddbc7db3e7bab61d9abb6dcd5e62382b4ded6224fd1b0ffbd5349542c2623cba5a54e2bc4398bd761376782005afdb01885f021cf8a681e21d64357b0b7465f9e44a9bd85a6395b9c8db14c9c6246bb65c7c1e05c81603aad327468aa5ee4dd98f7151fb2b600dd12d51a89ed2af063dfcf566527d50433e900a9154676a8dbcf52f1c503ab86b85b62ac5addfb9cebe2c36b0e394812c7cbc5c01558a01b3f51f82d6c162977809988e791024c4ca0733899e50d00eee9dab93817497d8ee6cc8c1eced9e28df706e892ad398f47d0e7a7659335e37d4dfe4dc0b71df2e1ac512a8649f07edc1283090b58e35c469b4662d7b24f75f56fb7acea65e51d239af150f95580449fb7dd971fee1b0479e7431430706d4173bda36f4390c412f080d46aa8845eb0e215bc902fec9d05f713fc7c39a241dd76e69be4bda9f1b5d23ca71eac860c0d54d6485786aec9f69dce5ba90b6055df742339f1159029c27db48731b2aba063ceac6266a1507c8436597666cfe38530be8a4b9e7ebdeb1d2f64c9453283a10197cd88e3af8b42de8f708b873d8a22e6f28f4f554f836c30a984ef73ad958f524ecacfd4cf46dab34bf4835e4c804a9adf4e616a0bbdd8b8241c801e8659ef4c7cf6cd28b0b67196d03cb69108a2c92c45d293871efe0b6e3a967ef29abb2b2e0af4d4eaaca6edd7ad8a735284e441a47004a7cbc852fe1d58b4f080a0b4eb869b45f46c05c5b0fa66afade76e13ced7079deb5a484633889ef9fe2a83f257f4be3218963b1cad413271e3b63e95c637d3a9dbaafc61fb6d450dc77de20b2aea6b285e0e427707d4e5fcef595645944d7df429dfc5ff012e77fc10dc8eabf02adb537081638b2d28f81be1df39ac510e4fa0e197bdc49c6016dc6e834051dcbf5c225be81b52df08c619303e0aff41a4747e79c81328a0ab3fdece57109bca09e8ee8f597fd06169686e1f10132a47dfc2df62375dd0a107a062afd6485e44bb842ae8b92a03ba3917103afce40ae03c1ce4a25b03fb5ba5f4269a65a79adbea104d2412cff2393d7c8c0f32ccddd2801438e934e182395ce97425f852fc3031afdd530639b1ef394db5b7cd2a319bc2804e7ed8886dc9fba3381403fd034b113c10e894eb3f6e0c66bbe40fe57b44109c1ad6fe835a4291d041fc76f7fcc288f6ff163245e2b777eb6574b7a140285e64a9ab74ba0e2f25264f4c68abc00131519cf683acd5584293f3fcf8df5093926f3b3c82ff4d9a82b65cc6d2f1fd6abf97b5e24a5422254e80bae55d268ef16185829511ecef7a3c631b67ecd2a0b09990cfc402af44d106392c4c1abe8b1475221f9381272d4067929189a11ad101ba5221ffaee30875158888458c76eeea949dc10406ea4e01b4d0697a6dc8ed99fc23fe4e152b2bc4b9cef9b5073fa8f8cc224801ae5e12b2ebc36a338323fdc71a2eb186f338cd85cfacb4a995231da28716601c3906becd5917b85c7bb6a3340f15771f7931aeb24cc176e603490d28967301a323bd5f2f38bf710fd017550b09b0a6ec39ab6b4884abd5991c6fc8a39ae6fca10673a490ac35ad9742df2c5b75d3279fba98a13b016035131b89bff3b84a14b332e0c2035bb81964e749ef01b08501f2d4cb6c5f7aedebe4e45ba6d7fc68614cc9917f7f8bb2b37929656ba061ace5a2587aefcff894515a930ec1c47837a7ca7db0dadcda938b5073906769edae53a63e60d27ab7cd97f2cf04a80867592e302f3aa1855e37eec1015ad360c16b699c0a87372db3955aca991999c81ce3d56745c1fda1d3699abdd4e901157c8bb1d9c5a5672582f07b5674a3bf39f5e23fc0286d5ddcfa08715cbe8337288a075f9d7c612deb73ba59d3ba5e207b66eb97e35fa719b88ca971a609a46a97b7633c56d08d336310121819c947f41b937bba1f96e0695b046cb362385b28d2c609e39e3d94518c0e9de69f9bbc60134684f6b2862528ddfebd93f6af7aebe3d0ec1d42e5f480e429d14936883a856ef006124eb8aa16b1d65d4ba3dee296a7cfb24cd64bb31c267f457bcc7bbe06919b57ed3707f3374c68a9773d2fd7f700e1826df0718eebd3e20f0741f3af0e468855ec81db96a3ff870966b6890a7dc641b5003860406c8bb189b1b33773182f9c9d106b219c8bfde71f9d8d3e273c191aeff6d728761b03ea0ccb53d8305de1e1ca4eba80fdb492a1a8f05d096339c487ec9400ea80c6585be0b21b0cbf51909e82b02410ebf714d1358f9349e963e6537ce644e2dc837633f583b7dacd2fbfe93f76127060a5e7acfe1699e369f2c6e1bb716e6d587315a0b4cd032dd617b1dcd63be76084e0c89bef88233d38376bf2e98ac14d17c3dac2cd28195d1ae2e070815bf032834c2b090881d1d4937b7851bd8e109aeec6bb1ace2e5b7e4ce61b0bf6658aa730e5fd2e1f545db0f036e604f9321f7aaad860299e4b3893bcf7a7a44a8de28b93e61dce090b8cfbd5ebacfe8387278ea43ef8569fb476018ed93f0882cf6ca870e73a3dfb3f5ddbb087d508ce3550d0901d791c2eff25026f1265acebe8c61b04c72dd87181bbe60ade0d9b974149e71b95b53374f31dbcc8e297f22f21a5b31fa6163d14f0f6b0a96a7b3b240dcb9847daecb5d1cc50a8fe1f675183d94d162c5d872761f5d7852a8f587e1349c8edb628fa01cded25313390decb7375d1f15f40fb54171f36d80377bf5770fcc3034534e7d76436eb23067d0043f16ae7dadb0dabed6da10f29ad90d95d0f8f0102eaf48f2d7d2b6f9a933a0b6c3b9b21d9499fc5ab3f986e957cfa31744159c75d6dd28b69b67c7189309f8a9d25e99353808054bdcff5335610a69e8255c5b7b5fed48029ead431c15684e6c61c6d8265ba804ea357dfc714a87f86f3d87c989f154dd6c2c02b228a6052c0074c79465533a389262aa9fc4f3344ee98b7bf167431ea1dc3a77a79d0f59d7afc3174328a8e10b99f44f17bb2d1bf94dbbc808ea2cb0e3a1ff6dc4e16fa5f53795ebce2ed8d5d130a332c20ed075fae9ba82cbdccf6d0a512866e8d6d00281e73dccaf4372c2600dc10ebd5dbcee1d1628cfe1eea01eb47409accb55bd08b06cc793a067234aaf27ec303a7745109994541a3fa064e5fa9dba283e47e115d879647a9ab59401d4c9ac13cc8f5f5523a27ed09787004cf9a246439d14299aa676b942ab7ee488c459b6700022ef7516577e197324ecca5727fa2c8bfbe54b7b9cc38174f6a4a90b8ed6c326120e53220377f784928cc70f60b962b4f0d438008c84e7c8cd964f5ff08984e536e5e3314be94a58f0365e03f60308a252ef88a405484b2b5ea765eec991839961a5beacb88dc18bfb342ced524f3729a6eec9946307fa5809c20db337818a7223b2b50fb13ab2db2346c0e0751a78c328415772dcd21d9d92b1ef80c95c4e69baa3b57460c64dfaa88c2cadeec22b3d04a2f8aab53ed2b42f7a9628be306a5c41f1cd5b1f0cca19e4fed7b142d0cd4f3f28ec99da15db46653707bb9c754bb1c5d4363e427302d561c71ac1c6630dc8bb5205f0c0776d49c6f1feb23512164984c1680e23aa6a7812794f472af685d2a7e68c3bfd21473b878da8db89038af8a789aecc72b4806dc9acc1b1e3b36b346f18dbd21adc1d893131d1724a080b8947f9bb5ca0fd1a91855df2e8e919f252a838a1d1cf86fe88f07535c3c2df4d355f30f047712ee1a655d3d1b79bb0efb6dddc5b652c3b845b0b9f1337fb9d765a238a136f88d1c287894c31b5cffdced7c635eea067cf3819d57b4782c9422669b0202d83f6b95ba549a93563211845a3c42d8ad53b999d487a01d606305f83e4198fdf58e4ce49828cf037a38f8ff2a941706c4de8e0eddbe73299d09ca80013e2fe061ae5483e51136c9b60a967a1a755d8085be6d8aba6cb2a80cbd679156b8b2daf9d3ad4d15cf2318de2860bfe2de6bf576b8f92e4e6a3790fff9f35f2210a6a26cd2b6d2043704ed922f764c2a3e72f1e6e567a3bd114bc1757b1ab3a8625981afec8356479d54f58f53432e33c58e23d548c1ddd2b76fc4af7d867a271bd543a03485d8acda65456cfd52546a7452192f2e849d2f68377ce43a3196cc21f4caf39db4f625c9c575f49e9787c4209c478e21791812f0d2793d516219f7c4c5d11763aa691f203c22c49f6322105bd7223ce74d88ee84de3bbe433f48996add2301781e9d11b27ebc37723ee3309a096fd270460aeae7d39b7c9cf2bb59aa6a01b90f2702b799191996a779dc939885f0343848da6aeab8239218378d26ea7daded9648f71579076fadc99377756b590ff4d3bbecdea25cdcb16049809affa37b2ccfb22df5925ba23fa7f7636aeb1ec92b956d322b2df37b8032f2668795b7bed45f02e0aeaab5d5c5bbaa1d8002af7f066ce35a04ffe869fbcf8ba39683cb47ee6b676902cc90956d91adec717069cd47374acd0b46eda8455e419d3ceb9f3c37a815a9870eaa48df9e699b086c52a83e517a1bfe40464a9ac8d5af22bf84e6cc78766b8a601810934b82ca1a85153a797444162779188b5ef9f47d153488c3fff9fc88e418a24c4ba58a502f915488f5e32644bd0fa50e05ddbe12af3de29df9ea1431771338910ae63ddabf668b9e78de084d4b9cb750b304453f075e3ed2617930d6a7cfe364eec9e2831a9372beb474141f603ee8d955e8e59d9098553027575ce5a071c1cd2675fb154220a23fcdd71d636a3d880c8ca0c3468803cab66bde0e5076290e698232240e6b07b1ad3c294209434775585db58aa466d930327904878ab2609f149555616c360aeb40c58588c4b5313893f6aa976b49ad72ea5cbffeb809956b53a1f3efd3cc38cd280c10623251a5bd8811e5428935f435f9f39deb87f204636bd4551dcd0c9b7acf9ded9d50bc80563af0f8b2950740e6b57b135e88cf4083f3f00fb6e0d7a4bc1852af7898691e28292faf988d4b25f8fae81e71e2242096abd4c5cd944cb8450b0fba6cf15817ddb6c23a7b8a9c28ee988b578d002e75175194bf862e79cc5e00986e82489864a4153e946804f229a7801ae927d8f61e075ad1431fb44984799c1b72819fe1f213cad31e8146017ade9522512c6b7b6b9fa3cf9316661f40acac6d9207c7232ea00e6c0d563ca4b829d76ab757df039925fc530741994e34f678760302b0c43b285c9bd0fb0299956cf7c0d733d0583e00512d4abdccc2826151f05479cdb859017fe5e6ecfc2d15ff50165bfbc38d7c1b6e6b75f89a70bbc3490580ccea614a3933ea793bcbf61de0a72c39bab67a148c3fe3f45fcf1a9d0af9ce3b4a608d72a0a1b604ff6b9a605ee9a62774ed8d0986faf140453bddb4e021b01011c7d3d93a5e7452d477dac06659136264b66ba813b354c5652a3f9bfd8bde20592592a54e8fb833702ae8f4a7088d3328694693b44dac4cc457b413f9b673c2cb525fb1ec56a5f1e2f132fa981acfd14a05da88875f26104efbb1f25f1026c558d316cab841f4af3cab9a074d43a8d4b8db184c3d1b900dee1a04e9f545ddcc23310a1e9969cab4476b73ed009c2c21a0e8170942c4e706a483c5ffe239756512c67232cdbbdc95fedd3eba23cd87ee3797ffea067566adcb8466d2acb330a42e41441968fe2b432aa34f9b78d0c76880c2508e313ce353f5a53e874202f3ba5207938b30b245accc93435a6cc7c391a8c468f2eaa194ba380d32ab34f413b043bbb1622a10b3429fb0a4a8a2a496482407cfae094c53367b774ecc3a87852661972065e3e44ad8f9849e3df84144d2cf4d30ba8f21fcc3ee6cc64cf0c41eed033d1828b84f5015d5e63c36a53ea899a7c913cd49ccd11e2e23ac0067d248ebcbaa10e013b8d1f10cabb92790407c64161e57dace7e977cc10ea06ad62c88949b1264dbe6a76d1edd7beb49b56d1fd9a404c9746327f22fdb603d64e7262ad65484fa1c706b0d3ed0bb4daf873c93dc4e34a37d86f04cd5ce83e059a1f2a87ed2ca95c7ac99880672b0aa012f3175be5c84d9bc7dcc710f5dd191f7a742b09a2fd9f0ca54a43696464da2636377e7ccc73500463186861f58477522d5e921470abc133c6ff44d70cfd8029153d6656639ec812f070d23547368c24936bc5cb72122f051277ab8cd79ff07bd63df8a2e01bd7972735a1507935000805bd0ae7f4c0fa04cfbe97172f133481066b5a99f5cf7f106e23dc1b9a3ed8efee2332b7510abb4cc76288b23685c7e0f7a828edce210d6f69005612bc721bb2255d1dc4bd900fcd26a80f110a97053af6b547ab244bd1a447e6482550edd18364b59c810fced5eb994cd8b6962b1518f80a3a6b6ab528140d359bd1fa85ca93d4bad0995b1d99e4f070bf5548d81a960ade8b7cc0fc204455e4f416fbf1b3ab3f2302780f25144cc7d5f10a2c4b8877b73c563278f00c931f51e3420178720634c60036516113096a6e150cb77b76a131ffa97945073763c736d06cb6a7e5960414bd18bae548a6e03b1a38755b77f77970a9f2310337ad73a8a38a2e59e4e1eada3a215bf81cfaa615f7bb6156615f754a0ef180c53889c4d9e5eee0d6c33b0a6d8119c6a8191b853d68ce5ce4a7734a9a0c59269af57c1691276753ef2a2e706c906196184e785f5058defcf1e2a0b4c7cd8113c3058835aecaab6d72b0f1738f9daea954dff518044ee97d6c819be3567a5dc6b284279918ba9cc8e5cbe4ac54c6ba967b0182631f882349a5d31e34c0ea91fbc53fa3043d8c04f4d2b85f38af6fd9ecf748fbbe439b56555fc03ff62bdb86a27f4586aebe7cc7e7a8b5a5581da92159c9ebcd97d0bff881c421d6d581fdc4d86b86fd5b38b5e3a3dabc2d6118ed524f341cfce7a041b9a3360b05886ea65752daa6b5e38316f168242525790ac4b8fc40b3e0247a09ce92a01c0b4f69d1f8b93f29a03e5a7f6c3408d8bddf0138934c88da22b2cca3184de3735f749d47c5dbb58e16af32c342cf9c9c20170178e16b4fbc4fad080fe7056db71a32c28d0cd67aae693c520e57f64261c1557537a730856fa3c144c298f26e404b6be98055c296ba0025d45401a047bc034bb975001aeed3223ab5aed1e6d73b59206fbeadff0f713fbad5e799b3b51e69bf51a80bc179d4bf5cae8e9b0549af2c60bdf72ed85a60304b076dda0f248b754e0125afa0e05e69c6a21bd16dad52b9994702de65b1a4b53272776721728c31318e57ab944098730cbede2d3c9bb99bec718992849d48f7d1d86ebb0effc006105f4ff2c6b0ead15e7d0ebf22bf7cee2eab7d7cea69a9eb1b60ac0cbf68c55c573ef8461703eb325d50735e43eeba744ee7ccc8efcead4e7481759e6b0f8fa90755a687cc9a0bd5bedc49e0d9598dda1a61077891e3669f4263b78edfcebcfe781fc1b887fff0ee9431f59625ae3f9c5e423a00c7da204e0c71eba848f62e0d7a410093d05ff22719b8ad854049fa7ce34e4710711be75b61aab4e55cbedd941bf5f426747227d38ca4d68556655b4f1c2ad70c1dbf01b76bed04c7fb6f2f7f5a80b4c39bda4428929213334615699ff5aaf11f2eacdbfeae94e2748624658a749fa87ebbbecaccc0d13833abfbe685d8b4ca1ba4b276e5e1431562b0be56eb8b222babb6a026d42df24ee6de0a5b3d95877cfc45a6a3634f4174c3f6316de7e45c158fa157471a33f30c283087c3992e9dc22bcb042d4e6a1c0cb592700041566c823397fe968fd9167afeb0ee30e36147e74b67f2c87b33f6eb5a4f19888b33328c1d216c106bfea55983f7b2656bb54489a32802a3dd3bcb9870e2a440c816dd145e149dbf331a5343187c6f504b9afdfa151eca4495a89e2be7991635b0a62b3d0329448e66caaac6b5a0061596f959ac09fcaa29aa4d7f9755ce97604412aeb1dfe0ef5275001b3ec8c3588bcd867bdc22e51759c0d2721b35a5db251889804d7a1fc775e769523bc8d41d437e9101af5cb716bcc76aab496277f3ac991a96b2d29ac4f7005bb8d36185e224a8f09936447e4e63561bb316f3ae24589c3a9b678e3b7bf1af769504b2b9dbaad688926952330567d25ec1fcea827e9b74ddd66326328a9fc0ceb1c1e50c854b3a3585ab00baf40dd061772147a8f2f991a2a22f3f0255e9957d0d13808e12b63a7047b7cbea708b92875d55a6cafde82d36f3ed928e8017c0fff02e4e6124ac7000891f5516f1ab0182fe17fb6f7d3d174ff819880989b75fdd020f4cab394b870c22318e4bcdb3e1d5c881521e642655a9b4acbad2b2486a7a05fad885b123b0ba7a841619bdb858c1609069ca8758122a112d1a182d575eea7d2751c6bd27cc7942f9a2d3cd58035cdff088c68a0f26badc3927682da3fef3a152e0901fe7c80b41c3ba3deebd024f2e78ee365a6350d6522b6f0424cba0cf57b48b9e33250c5f6baeabfd075aa6a78e5073e4687c51a197c2ce03c3c643596c5121831057a42e5930eb6b3795a632f91a894977a93854de148733b1cc68dd9d09e23b179f4497ecd5ad05d24e5d8de7786c42f8b1e41c30b0a3780d124428f2e2eeccae8ecf706bfe7ad04bbf8158e5c8cfcced66d14cab1acc5a02e20a08bae1f5b1f441035b3b39e9277678924711265ca4b240dbc2cd670251b994de415cb0106c903a30c5fed41de9ed389fb9dd0921b14bbbdf2ed9760c3c7e83b2c169f18d3d827e69eb72f199698c0dde87e84ab5c5583327434ee9bee2df7ffd9894b54d773ceb62632865d49e4e0f00d5480caa600317a2b7ce7c4c2d29b962b55651f80b22413a7d1d83437484bd0c7c9199180614dfc7cb899ea3bc5145488b9ba6d3f65806e64e07c17038ae513e7cbcb030fec4c61de3ff0dc4b9ad80918b61f040dae94d632e0d0794427185e38eab2ea0f5834db46a77783a90e78ec694780cf99e9b31f4652c05e870c57ffca46a63a42933700ff7b33019932adcf55fc8fad8920b36968299384661743a58e438e92beee0d45eb4baa08dbea4e12986b1b712caec7dcedc2f6b057b25673c441666e269a9a2b68f880e40d70fd0486fc64ad5f6913304d8e4299cfca2688849cb2f47b7a6b5514e4b8e70eda765443877f5e635972a1a6754e31199a9bb292e42b743262a1cf94b5694f4c247387a2a6a5f72c8c37b529e39aa2f543c224d03b0e9bdfddfe7c25676f5a834dee83d1c52f1e93ff141a5cb8ff2f4610cdc6629f5eea082ea8c6889ee08fb233079b7c0910321b0051dd2c74a7d84cdbe157d6f8d5cc6675d900c04da951c812b32dd582b4d34bec7bb7ed1f945ba9f3b729c15b939df0d74b4f91a2952cba83a7266b7c101b41af7bc9aa6125475254520aa4100ce4b63eee36617f436704d599f589048a049b4d1cb21d7479cc9bffd79e20aad7858636a9a1c2b4c9271cf4d54d06d30c23d10b6cd7ef7f74dab5103e42ee302733760147889c8f3aacf3a4c9aea2dc0286038203dcaf5e05e6ea684f9422fa913c791b549aaec13fd48fa0726e13eed1d77e1ccf0d3aba5917a1a4445fce9f9b6a10b5872cabdb2f00c11ba40b07056d50ec94fbade5e0021ac4a1d47d4a5dd3dad5e4be6acff94f4b4a0d8293c0381d21e78fdfbaf3e79cb099f69220cf28e37b195d6a5670019a0a8d49310272cb7e25f37488877109033e70c4a332fc65fa7564d308bd76a51211f21c6f745790ae4c046b8c5705f318b924590e1646c3fe39a1faff05f66002e3d46bfc1d7617fe737383b7ebe5e3195b6e841f4f2a7adf643f181c1737d8486e650e06e062c782b76fc599dd54cee1ab8f8464d6586cc9fa07b06e2e7e86d939ecc9c8c57bd7006edf58abb0fa75b7d0a77f5251806ed8078306db8c4cc00ba62c04ede11025aea5b93d033d650bfb070e7d596729a7b0850b9b68fe7085eb115e400ad70f2e1fa381fc3a9929a83f12b1f86abbecd0de689048a335452b58c2374d530a010ba7145225b1ebc2f2d115929fb6302b950eded17440586a15054ccbfc068d5c2223f7cdb776e0bda9c528d1645e693a6a18e6629bc43d3ceab99173b97ff098a224e6e70ea011b7b21379ab7934d30a7c9d459ba11fec7791111dd794c71c26b027da438e4cb351ac5035cab9a13e743816eed1835bb10772a892b78ffed1d5dd8ae455d59fbcb3ea56501c732ce3a7103d81ccd95d6aa9ab2a60812b00c0c16dba6492568490148fbd9eebc32a3e2042c9fcbc2cdbb97f8ae716fe491872ef0012ee8019824133fa19dc0b0d2626d94169222bee9c36100568fe3c13045e99db69d757a8f832c1f40aa7a994237b7d4c4ecd72f6e5c7fc1c26e5ded5fd40568335f5296acd8862fb73045fa9d5943394feb6d18d548639e1017af4018ea181a5d3b44105998c69ea7d2ffb335a833c61c7665afe434057f6599717324d25ad3f71220a6ec0d2a0a53cc9ee290b6b5daaf5fa5b913fd8daba52bdac8e73e3de5e89d34e0ac3ee95159f482343cb884ec15f2692fa340265ede65399e19d2a9fdb6a63bc7efac1a4572ac0ca95e3544c92fa2bd06208254961d3a9ade5a37e075ca3c573aa3ec04020072ffc576821ab918014be1f4c759f9e1934a1ff87baf05fda2a4c46e0cc5721b5e0fc2a59b1904a87bd00ce4277ca6a5f01c10e7f07f7e6a5e03d43aecf3e5088ac11a3aed379e930a0fdc0506038a0340c4c3d8af53d70370932fce80e32ca61baa1c228c8b310ccce5dfda5816927a21eed22c44b04f8da357ae92130f3c3922e7d20cf66e29c7ef187b8c59e393cc769f4944b35ec12596fae41e9799e1718466fed1d92ac80024b2d88f0222ff31891a85a89903a0134dcbdd577fd7f326b01305eab934a8cdbc029a2bca3453ea30ecdd42f678d61e355bf987aa4f4d733b0b65ec4e27bf501f0e6f4d2a6791c601c5c1389b1471797a4bb781dd22965ab6ec1b0aa4db708adcacf36a7d9c0ac9b7dc183197599ae740146caaea30cc60c9c98f49cce8e6cc342c8a80e33649a526fd95457e373cd33b0fd355b40a3d2557b3f3f9180d5a69009ee97bde398ac8e547dc5e392b488b186810d84d2761a71b2d381772f01b333086bf02582cff4871e6522967a141a81d854c5c1f768f68346e70270450c0915a850be01cb46b66b3fa01a330935402cfc0110d9a782b4fa89de2e066c2658b6185a6762b5bb39fe5abc1f7a6b019a5d3bc99b21e920c3548cc85b3bb98558eb37d058550a2b24a830090319e86295b32f2c1ad93d1fecc261c18501b8a5efd8dcba6608ec77f223f09c9910e457e9f798cd9639a32baa5e45ea96e0bbb0e0f6e85bd3d916d9fc9404df9c5f69b25ee438c929bfce61b8dc05b6f1f6ca0c76716f34874dab3a434540d822bd75fa4d907f3eb1ed01ce314dcbaaff5b0b0f597e43114d311078b77f7bd8956f00aa977023cf4edd57aadaa0896edafc76b9e9e8bf1a45448a007f70983e7b2e3949b5ed34764ff59f3104755cf21fe3ea6253c97e9ceb051eefb6f53116834c867093af96b86fd4abfda631af7839cb1b5a5e5dbf4d829d94c37071ffc88270c2cb442981c8ac1bc4a2979f44cc1787a6de61faa7a25dcbb6b016b9f31a361705697a8efbcef0804bbbb460b8ae83e773d4f557e94823adedfa2af8f1a79e1e04d1d3bcf5cb932c78cc4289edf3e29bcadd08a30f6350e371638059f51f650e9e56666cbf3163698fc66c1d23856f3761d2e09298695807f7b3eb770469f89b107b1f320eddce918b3c5e5bcc163d5e1cd21f563fcdd72509a93c14e919b1d9ca8b1945e90addfb9c46c041d7aa5ae31bf72b9693498f7f8dc29105fcc16a21b73ed83e3bb1a7316b0988263006331c92a26903842b43e3d4bce09f68b6a3020af84e2fe1dc9c451bf0114f4f44e4885a16af4a4fd63c2da6acacce05db6862f6415cf5bdca0ed2b733db8b14c7e2c35a5ead4bb2cad5ab6c08b9e854b9ea32c6e44857073c2c43263f202f8c78c95cdbaec9d1bcf31da688582a198a2d4e3a8a009002af9d001e2594c37f5e0d0af7e773ea6224c9711be3002b8ebf32c44df746a6a7cc4f11cb68dcbdf5a</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Vue </category>
          
          <category> vue2.x源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Step.15 彻底搞懂Vue中keep-alive的魔法-上</title>
      <link href="/computer-science/vueyuanma/dosc/15%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82Vue%E4%B8%ADkeep-alive%E7%9A%84%E9%AD%94%E6%B3%95-%E4%B8%8A/"/>
      <url>/computer-science/vueyuanma/dosc/15%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82Vue%E4%B8%ADkeep-alive%E7%9A%84%E9%AD%94%E6%B3%95-%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="49ccb1d8cddba3bb0df2950ca2bd417e7c93f639088677986d9a9237811b0d2f">5808c6cbf3ac08533f2dffaad5e129c1f7677efb1b6b29d5c2835e6dc7760586912c12e71e7f20a237cebf323e2b0a3ddf144e185c2f167967be943950fbeeabae8a204c8566284bb4480041f9911ddd4ca7c05e40f4a56f339f6d4b2cffb0f50ee437a75b6e14aac7a1f482fc23e5ef3dbc3c628621384d6f0f7942494dd72cd697afab14c557ed4bc9fefe40ccb323f6c63426ca5fa8664d75efcd9ea90d8f4d8002f3fc36239abad48a00636f1f946627d11d4b9d0cdb5626a522750ef58764a0dbbb3103dc3ec95af1f96ff4b39ad75be4b8fbb5adb7d0c2219449228ce855ed39593549fc65702d82afd6f5b2882c4424e5512cb1deccc2aada82c4ebbb65668d7f33fe34904800c064ce995cc64fb36ca4bf59392bfc634d2760847178655f38ac8e5cccd1f0b17626e96843088a93af97986bbe7436c00eb125694cf356a7d76c3928d80c93f761c2f3c6348eddf03aef5592ca0a06c0e295d5096ce83a3ae184fde294571b66cb373a2c97cf4dd4de9969d016f07a265b00f1ce99e01c86f46818ad4400c072ccdbcdfa26c6e82f565d812e25179b5d3b287e8badcec074e26ca574a0a5975bc8d4f64ca9ec75d5b079e616d3fe70a1629fdf5106a5eac004649cf1804e9aab2eac12d60141c8c008467cb92cca32519819d0f0693baac1cc9992d2d92645fcb77e93c5f226d28c6f143a7399d33f78c9d02f815dab71e1e6cf2c757b20fa0b877008341c83ead539e10342b10a82b23a290fced994089874143325f6397dbff72049130ba6cc629781be1d9426db240b2b18b4963b4012b55d1939f11a5517a9344d1fc3aad8b0860e82070b58611c4a62d8128a3dc095eb90208cc9509173871a5310030f9f6aaa7bff2ae9d798ca2b9d6ec378865e706c1724c1daadc6b5e4806835f12cd01e372707f25f3ba2e46ca85230d60abbbbe2247ff186a9964e7a4fa9a464755eae8c8c48481adb6ff96840907eb5c642b9fe727fd6183b6f935b5dc9c2bb286ca243e9bf3da867b2c4c0effa3e759dec642be29eeb45fca1cefbe28e89c14c0af5deefc602b0f7256babc713fc00aa2edf1e0abcfafceec7f9e7602514abe53b0aae5d49358fdb041207aa34de51a6dedef7698aa6141fbac33af3d014dde661d73fdc76cd0bc487034407568b57a5f08c4ba1fc9950f3ec36a57bd2f8f0db9212b7a507ca0c55e0929411e4b06ac0fc971cf97a476d173925ff86c02263e3695033f005c89c8c0dbe638ac118372c4a5b4a13d4af8eac7a95285c7dfd3c518e60fe2043c9cf65bb3499915451f9539b76515aba6746c262ac6a7441efb17374c047a0df2e29f1b08be029836bd560c14c440f53200cc4225ff6cc410559bf45032f0c2f6a1c6dc6b05664d5d6a8fe1c57948a0bece2bf6352574bf2ad5d04786970ed60fb73ff5a59df225ee3229df6ac6e84a573ab348439b1faf390698934a86f6583228b3aa4ee4802cb97b0c6b015de9d2c85ef874f369993a07fb8855377c0f33cdf71ad3462b588bbfb7eb826313feeb7db9fb7393771d3ab0ef9f9fc32f777d0d6f7ae3a23f03824523cd7ad47cdc1ed68761aa8b6cb7ce46020d9ac3ce3712f71ab0a15732b342117e8fce7e890af40f0e1fcfcea86700ffd770645cba7b0ef8f7fd65b61a35430b9df651cfff72321df6188b3ffd95596df83bc140e4919e5e124669e53aa431f729fa7b47c9e0f52b35b5816731e75edb2e0ed686744ab5cb14505b46b2296ea20e5d8ad47f72e864db5cca67941cd400a14d7864f637059e880ed901bc24b7110d9c3f707e8c0763b734ab4a6ec349a9fb1a99470a70e9638eb5ac58f2b508d5442de04a57ed4dd6e7207535fd66699a3206bb21bc8e926e18892dc400cf6427fa63f148a9d25c3003d145910a542d59b218578fe4ae504b2296543186b85eff712a4218cef07b1716171f51c0e1ea45cc8f90ad15580fd4e115f02354ea10a5a01dde25b68ab9308f10020c3057b5654330291ec47ac83ca42937d4eb74642e9f875ec46a735362ac79ad8b7622370bcec72158f223ef5a35287bd2616afae387f19ede72dba8d0da970a323906e3e716212068aa487dbafdce04784642be2edcc670d582a5e770b8d85e67eebca4e0ad63d88db0d3480e055341691405869301ef1e568a6be81f6b75ea6d357ca82c24fd6fcdf449e5b703fa3401c04c6fafd5600f2637ca27c3d1252611202fc24eea1807ba1ca67ef0b344a175fcb3697ae960f2992f4285472913d0817e2be2365f8fc94d0ec719771f88eda84ec5d46c6ea9ee028eefb9996d2aaa99f7ead4c6a43c52b63d56f4947aadd8fa05370f9c0ea77df88b9e97a3464f0abd02d6fa9eb87cab4ba960f8e37fa2a954005aecf2af2bf107fa4bc3bdbc9c8bcc8e67c25b679875ca5c787bfe1304b90bee196cea31028dbaf3e6ea23ef8b334f4805a76095c4ece3d14f593f91699986a3401d3cff0ae67432ee2e29685199f1f6fa4deff151ec616db71035b825218a85bbb02d56ee3965032913ae6cb3936c3ac2c67c0825c36c96c95c6adbc8592eb40f902e41e646f442311f150b70eb1f25ea1d124cbde3ceac0da2c4b2e4ac03ad7f1712a0ad839359f9cd2865e1ef3e25c7c86ae9437a5d18f05dbeb2e7da7a9cdeabf33afd03d8a87ad64cc8e87b5cc203d21b747331747c377e3125e174d3987605ee34ca0697f0c489de6a553559c999940ff4860c0d1f04587ea09a156bf74ea3189a241f07e75460c3b00661490c1d8e42c81b886f0109126e1b8777683370141e3ced0572ffb712bee4062d71f18c86a2c04d0e04ee573f16ef7c36f85f57f0af68094515b8867b82e30043cfd1d3e852cf04b437fa149e201c30d056932b2ee77b1b702d22a88ea3c1afc05ce1ecb9d9095150e5aa23e2cc930af3e7ba84603f7e7b216821b11652552a4dbf79c4a4f81d0e22d8d46137010eda21a576306840c1887fd747bca9bc9670e2a093ded6b71af7f425ae612e79c29ca4347133226204145f394aa5ca2ece7ed4b3d29bb5d7381786248a9410cbb11f6e47253e311c23f19030a5c76f167476e6e5a3be3828618d7923291d390ee9c4d01b0ed4f14e29361eb7358cb830deef044888d2d0fb04308213b0c6e5000c8ee7cd33ff5993960b183bfe3112ebafb3c447bba1cb11b6c558d1695967719e4ff70335010bef42788bc4e989973f2993c8b65de3e63b30fee880ea43716f28ff8f856c63fc751657f70445ac109cb4f69a690d201989ee68d5375260022e0787688909bdce3b3aeccfe32fde8fadb95ac8c6bd67a4be6bdf879283b2a52d0ac28438b7fdac7ccdbc29b4511a21f305a25b01982e67e21cdbac9161aef7d71a70133cade6fca91048d9bd7ec66a5a42723ab8b4fa281c05b64c7df6b394711d9c9e85508cf6ac86a140e6ac7042982a4241ed2ee7cbb09b698edf8bf705eeedf97a3d3602169532f19c91fcc68b3035c0b324a6de536011cb1a5ec61ba072fd119aee541ad3b54b6e88ddd76085d89d94c760f24b421943db052678f3602ede65c30a0933c8c9e9cfeefc9e56add450e3d2c1862dfdb24b61b82051f55f900122888b8c17a0c687e1f80fb60c6ece11623c3ec3e4a6df9c13a8030211718d97ed62fc9d481df19b212da3c2cc87d917721a95aaff2a5c6034c14c6e5c5f0a8b599c2969e6c0893b6a2cf6d348d6de098d1ade193b4f6b6c1489baadbe504f06fb24b28bbbb0acdc287ca886324a2a813ecca14338f4218849d0fd009b817d32c5b93de84f724e4c4140980c32da10b4367916c84770f97769778638070caa2d8b0633ef394d8d2b441f9cf1ed915b6a51bfe0f9047aca5dafed5e239f5f2f5acf23ea675dea9e97dd0dac6c078385f6cd23eeb4c987159d029705c7e3a3b351fa3fe14db8406b16babe4c8e25a418a3a91c3af9e9e3505e98878e3f9ccd4519da22a7bb1c4c61a65edf815ca85ea3d52d73144fd18243d65fa36f7189fb9d3f795380352db93682ade29079fc5b6fd9e72b6375b9548fc1eb4c22da07c3bc51419fdd615c6af76220ee7dc80009b70214cb96bc7ede377821b786312137bc8a0a101f5a693462ae6075f4e96307d137354ed74f71625c7ef3b863c6227f8674b24e4d4ba2e72d6ec2ff13589080acaa096744fc21a7847e933d3b3748e7fc496e4d9de50c6df050d54456739f523d08d75a83efa32092d81d08ee879ea9de956b684ffeb38a881d3ea40c95e72114b11feabc8cc9db709a575d31f34bdcd668663cec732e7da51af5c46b6aa2c4cf7092cd788646652e3003bcb9917b77dceec0106c33b80d86cc6554a39d1f4fe3d8408bdab921f327dc8ae24a279c62171369ce042d0dff1ab1e81975d158875691f4097361cd5f0422bc38d471d5194bf1c6d9abd0bcf8147b6a9924a6c0b7114c37f6db000bb5b3f693ec621111b237ada1c801ba1500e245a54e71b37e65c7cfd5baf26654fafe52e714ca479499441578ff61026867f750188d310c5d52a83b807c9d71f00e6b61883043552b619549a62455d00b4ad1e2e6c3118cb317e46233cb23cc3e2a38f6020771fd1328438a769ad9a849cddecf10a3fa0cde083af8c2673b559134be0f90097ab9d1c9836d11ce3b249b943c224366245534a172a71a7d1fb49a5a02860af1481b3f4b807b4ebf854a1a2b32f53e477f45028c37a5f8c135bae4c7802de511f02f45191145eebf84fe9a3bb14159867dce40d1f718235631f0b64349f7550aa6159a8cf94ee761577920bf0b9be7a58129b08e7f3f514a6648a5579b5b8913400d6b99b3d685f9fb481c01acb7e254060560bea88493292d47e665812fa7018866c111e19ce1f75ea1740e80280d158de061d2e20d5605dd8a77dc53d0c0797d442ba8cc48c9963ac9a34b167b506297d9ed400d366b3499abd0b072fd9a2421336a00df7883a5b73c8ddd2fe2679ff3832b42e9e2985ad5780868839841e7fc00d05d666c0641b0f60faabd4f83f5c0cbb10ac2af828968cca00c049420f3f67834c9cb8b514622c59498ad5eef905b54ecbf0b0214147684b8262802f2c7faa2c5cec9ee5c91e47ff6e9e7af4926ac3a175a4c7f94d5614f4e855dae1e5b7c45f759adc221d1dfb3c78847098cb6f9a8c644785cd25a095a5d5559ec35f9f4ba6287cc00c889ee817ec39ba2e011ac02ec5725702b1ed16ba0dbba6e4049cd82672bc531b168c5a91656be80e21ec401294e42dec7d045a46421b9f07c74909813325e05792faf3a73a4ea15933010add6954cbeb03e6dc06ac57ccf55082e746b38510bc40f29e35cb8a0332b09c531ce3fb3b2a7e3af5ba7bbc3ab576a9d4da588e090258bc250d40e6ec8ab35732ebe94d33df1d1676c5a22a51d443a0a92ad49465f493a24448422a054bad64f72205ddeffc878490ddfe72e8f9c05f626e924f98ebf1afe17f48de7308fbdb5e440e5ed63148bf00082f3289d77dc616585402078bc874f6b15ff2cb6cba415c7fd944e05b1044f96092a96140e0e351ccdabbc7163e3afa761f8af849399b2882c585fa71b07261b9bd1d20701bff0931d80da1189ad0037beffed003d191b0d35709fb21f05e892aca76a9c0e0443d9e19c259bb48e88180debf1c3b4e41aa7f247bacb79f0880e0d427b752e14662bfb0873d98f91ae7f126ab72a43def3602ae2f123e41af29bd65dbc718698df4e06d295c3a41eabac4c96d5356c0e7f786c9b0958a91cfc248c6581c6e7726bd7b6edd2d9b1bbacf0468e0ff42ec3c3a1be09c583e15a5f1637dab7fbce0cd82db2aaf30b415640fc4d2505b32214f2f358f410c8c35a81ad93ca59f3de52725e5832217aec3c90e89b3b6ed938febc3004d4344e9635c4035d28e9111519017a0a655f4b1770a07bbe4a0a3ff1499f812e3b2152e51783f0741e8f408609f200524ee9ad04027922a0ca685493de27bc82b4093f9de1b5081973c1a6a6227254f5b756e123a3fa406e9f6e698efb1486c9c1980e39b8807992301739b995b63ccbcd5fbf2e095524014e535ea9f459988e5ec75140472e4592f4fa58d24ae748b98225fb260b805008fb69bb5444507d6514fedb10218987072846fa49fa357de2d4e97cf6717ece26903249d0e1587324384f2473a305908855a3004f356f2f1f2802e21ffce96f21ca4698042b5942cef67f01837f4665ecd25705f0103bb1580961915a2f2656ecd6bbc342dd50d6795f41c68723898fc64112f73e898750e9cd55429bff8acc1d40a5f0500aafd60875ee1d316204470b692eaa772df5d5003411351294830afcddca35115867ce8913a7d2facfee1bf367277272b7668a9958e1c3fa2eebbc59bc0d92569a1a19f8173eca49fd370ad6795eca93401019b52d87f2242d4c05d49048e2add7d72c65d210920cbfbdfc8d448b205db3cfe319bb5d5e6fb6c2e9fc0cce64c6b5ae51d5d3482f670128632a0647ea50bc4c99f114efffad93875b65dcb09cbc4aaa7385ecc5da39272b9129c50b3deef7f6fbfb0fa8d5b4303c119a93ef8be04d4f771e4af6f823f4a72c9ee750f6b9cee1abf50a0706b60bae246e67bce77902352d0d43c36f2493ff27a2566678193e52f7da900ad89463829864fc0fe7e1b676ed44134f4e2660ed54ed8d96de79fa40824f1169ea186793602defb69f7196da24e784d1047f7935018682deebca275afd14babf9bf86a5c99cf86559bb3c7c49d03dbd6b10dda781f7412b932a3acb4c7a54ae6ca56202e11c9837fa6b03ac7ae8bac98c0a016a385c6457b02dadc16df907adfd00e7cc74a80ae644cfb58e4f4d55355a2850154225df26c4ffbf88dd729483c8ed2b59aa49848017ba879e8780aae1126f48610ad443732d848e77d23904c494866c76d64e38c115c6e3fcc0c8064f4fbfa7f6110b0425bd1a4736c4464a3f171ac8c7d77a257ba49163643cf95f7cbaa9d05c0d38ed325417e8f3bf868276c2577f37af3272a2ef8cd523248146b7368c1b4b3eac9ad155b6f56dae539340af138bd7bb22646dcbe857148318c5f0930153adfc1b89e3c45d2448997bc852c1b09d0049e3122a7af09a5ac4e11b73737c7bb8c0949ba5ebf101b77869abd8a3da00fcd70c4a3db6c0c4d201a102ab517c75c165576f2dbb8097d989b52143b44065b780e1693b03ead5c5c3526ddd4ac420e45ae6a87cfd31f38dd2f6a720df228663f80b271709f8cf36a978683a412239d396d3c0d1cd6aa4bad8ab3a48223357822490edf157d98a899a657126ca7ef025089cdeae901f78a60ff77abbf9f709375d2625a05a757d53d69d22b4dc21ab86da1468c0e7ecc1ac5cdc06e9a23477dbb200053af26dd66f8c28cd67bdd4aa5dd939f51b671f4e4f7d45ce6db41b49843cd6ca0a8c3f010976c8aa7f1c8bf56dc4b5ad94c734456ed7ccc696e6d37b5285430f752781cfd3adda8c1d23a14b58ba74cb5b61afc251210bec2da4ea8879ab705984e190fda0f99b92e89e6b94e87f0a97b60e709220db0be60e43fda9164f09731531caa3a65ce7d0ff0c4a64a7c7748a056b8d16c81e4a086e88d2f0cfefdbd167b9fd26a088038847ec14eb0203f4794f411823774a011a5ad483768c86ca3f05304e237605c76972ddc8152f52cf817a15ffd256d781d72b1486e36ca70cdae258ce719a863c53569e27865eaa76b00abd64f803f9a5926d44608e35f94c79e90b715356031a443cb61a922fc2ea4845d5b57d229a7940bc9e278d6ed1321413904d52fa089a316c662eb23bf12920df6fbcd37bdb2fdd42367f328e5c34bfec62729b69cc44f4c30de39ce2a858c2252973a51f123fef7dbf4989d7148b549394e8adc7cadd75d2212dad61c86ca4e2e71aa0d0e0fae6c29fca96727a93d2a6bb48aeb43c5cc158ec6e7058e123169cb426be33c24122ec29677110cfa0cea9440c4abd1cd2cca354a1ab4af6a1efc7cd667c51498df63c9c02e81249764de508aebb506468977a673deda66e344ca5001bb599b07ef8c8e52f8f2932f50951097c3b5f811cb33c7b5ee55f688e6a162d524b2650d18b48fd0f64e6e88e2d9d636856b1d907f13c9bfdcba797b71e6f7e12cc044ae91462a137c2c687fbea03c9fd8daa958c623fb1e0e12fff9b7dbeff4abdd6df7741a44bb302f36dc434294b5574efb5e86837f9afd4f9d1a52296944347c17d0b9f58fa61610a11bcaeb03593b8b006fd2034d7594e1d9af96e6da63edec475baaf3044e9a47d26019df431e2508556b1b50641114623bd92c6a06d149a9a072bc5a897b3e071aa869eb5757db1233af504be3d9be0ea89ca4c4c377f2017aff808f6b2b67a6e3a8d74bb25c3fbccdf2d8e5a9a6aef3bb6a4b1b5bcca8a39044510f244036d94c66f6e6e5095823ba0ff30f5af1d7db16e567b516b96d2578853df9c1f9979e9732e6a351a8559d9368a67671bdb7243d284cefd0f2759ba607ef653a3403b311c6906f4685522bad1921a856de28a4752b3b44a6915f2ba094017a2269551d0f28641ec1f059a55ad72eef4057424ff292bf3e81b99f3d503dbbf2784a94ba2648b707636edd3caa7294f6215824b09d95023cdbd856bfd1f8a2dd6b2e75521a284b87eeedc7ccd0e051928dc8c487eb28721b8615e9bba3f541d3cb26d365d497c22cdd0be87427b2c96de91388dab7f76ddefc3514dc69995da6229b038ddba9190448e3c9d89d9ed394ad9e1e695f6de0f77b53c0940b66df81a17551d7539e1fbe4cb038cfdcc3ceb8aa0465b5dc27a019e137cb5e1a0b5eef604035d2b127fb962708eb0d5772aef4691d540a1abcee4fd9620a2240db4923e43b604b9d40492909838346fef1c11151246fd2b05888482dcb9562d711b1f0eb400703cc668cfedc39d03d99bfb7b406003029b03b59db40bdb96f511d65f6b8a8a7a41dd38665953a7a927db3674ca65dce8a928d005ef07533f0271698ba9289698050875c1927814e241ce909347b108ba1086ef6ca0e4cb3b3e14a68ef83fcaf3c1222051c1652da1e6af26b6095a38c8d481c531d4f6879a5db06d796a35150c61cab733eb0076ced16c00122efd5d3457a0286b5c20d4ab6c2555e12950acdef7c5dafa83e137b4d6848a05bf4d92fd8420be56a4a826152f1c1254258a46020d5991dff7f3416ae586bdde0ce39d80a02692fae3f129bea7d207275a6c9138d977d7feaf247cd9f2ecf78eea4c3781df4bda9436652b0b2c9dcd21effb7bd83c0192901f9252b3f1e792dac0ae9e5e278bb6b6470b2f06cd417665d12d4986b0fa9fb4260272a051639edc3f66e0eea88be960329dc7c7dc39bc23f429372102c8db16a8d57532306d6c72356e621db2c251e12f677a7bd53a7373ff74ea0d6465b075085f366f2e6ffcf3791e15ce779a8164cee09edece0097a19c38e27b3b471eff29efb86ed4cf68340558111abf80a6d6eb22b4de1d3475c57673f1513555b543dd23789fcc48212769f4a4652843cd7ef8444523c78ce68c3cb13e6ed49f3fe380731cb0c8b5a66c065cefd8fc2304bc8492b6fcd267e35c9a82d643438977273637b5616a238a641f7eb3ea01b097cc25ea92e0dadbd2e0213edd37971b9d384f260557bf48440d87243f508b62b410dd61bd17b150786b9a447be7a34ef31c5b3aa6043da733bf6f2fc4282ef780a81743c579034fceaa06ecc3cf7850562c4b1442c420d9b3b12dd8949e7f3e260ea5664165b14acef9889ee670ca4bc3d709513e56916dbe1c64d948a9fa488044a9da6e9014606203a490104bcf61b8bbcbc315ddfce737cb46d0bce6e37b4270ebe52846beb74be1b478b983fad3d7353596e7c3baeb3e6ae89099becbd66e5342d9c8e39fa04794a9ec7c33b778d896b362cce27b65f0aca9f85f8955e730bc3af249c07f4ea9c0c20120eba06b1faa5aa8a30c3a87c3109af83c21b15100cf5e3463d9cf1f62ed87c87a3a736c03117a6abf6ee48c5f12d614b2fda9d0ba4876a33edaeacc7ef235a6dd40d70ff15550df8261a49a73f5f2044f33a141440adb96d17248f380920af49179892296f12190b3f725f23c647f2759760d32c2e97f4a709bc4bd288800ce84f591340b6555799c13646680cee06b2d58434b4369650a4fc6e0bf565967ab998137967dc6209f01bdadd0d3ea117ea19578889178455c542f6210ce22f948b91b8bccf72aa9adb507fa3ddd44d0d3dfb2d227b44a73f8fa93ed3669e2d04a1914871e2d9e47d95fcf8deb16ce1f4132a0f2eaa30617f5b113e7c725fc6067780d4c661a5a773745b95175fcca66dd4e9051c37501c7dd396d5afb81504a5c15f2016954764c34439fc1b23dd6bf140941d8f3dad3b15803f75ddce7513312ad97e23a178a60829234eb6676faa35448b69c93b03011ebb54bb9ebffd96ae2893c18ef0317faed3515138dff30a01f2bfba3a42f41052f93ef3ddf998123f62298897e474cde7dc3d7c964e65cd9a282ed51080e4b7facc3dba7c4f8402f764ff8e0f79dba413e09faf8655dac1a31866e10302027fb2c10163307d4a7ccc1b1a0f7112da445b4c97108d9b7f3d153a8a535b3817d8800019123e851663e0e0807b164c4a82011d4af982b40aeacf6fe906990cd125515195f0873513af792b27d2a18655466e1b7ee80805e12f19c645b506a79bc53b0563ce46117f1bf519fbfadf9d7c4504d0fc2e0f657d429f2ca588a6a1aeb3ed55b43d4ba0436125e2a96a153c0e7126004bbdc72313a96cdb572bd3edf573421b49a1eb71dbfe908008693bf5ea18d16f7745372949b13ad720783442623e310b986ac79712acaba2a57c56d4f8aebdff60adce3050dbcd9b7c92cad3c5971908f501602b8c774fab2392cc1c45a8a637755e392690d7d18eb6aff257c447a873a317c62e835907c5a3ffd5ddd9cb704f335b614f267e49e12a6c4442539dadfaf0ade668723f3d44fc60c7de2cb52cce68eb98628cb339adee1ff3507a3cac0f37100c651e9a6b37fe1160d6bc58274ab44f5645bfcc98ae5669a450a12978ce02864165d5f0588b85154f442815a6f97a7b5725893bea04f17338e56ac642c94f851a10bb1351ed39073090d27a8328f27334ed4b1ecfb3585b7f7e29c065cfac6562fc509753947e9ee83f62063017d97dc7e9989729a03f72010152076a8a96ef49e04d307a64a0f824dfa1bf505e8a2b2e37d69f53004063b0a1ded8a6390a96585f6fc2743e46226cba0362d8023efe707f6b1379ed26e691eba07e741897ec3453d63d3342314222dbbf9e3eeb3101acaaf5ff7fb2d513b44c50faee80a95eb6c7a20f4701a70dc1f16afdb70932f10a7b7d2712e58bed1b691086f9d0f9452a01e3dda53afe8b0dbe78bdd207c6fc7381be43bb2aa21905dce92e69eed0376f407058817aa9f761da09c0b38a925bfb28ac4072f024d0d376aac70f616bae03413ce2fd9ab727935524a33030c222326f3765fd996dfe25e2093e099f64f1c6f29f8049728d53181b7b90b7fb99dbf719219fa15e3879e01b906d6c76ea77f581e1eabe2cbb2ea746c6dcc050bf08d26a4d82bf5b009ebe57ddb370a44b464e09e142bc1ca49eebb008f2d3d86f98173f49bd3373b4a7c44daff852696b8e5a3fee26dd2547a0c3100182ed4a8281259fac924c920067fea38d881f43e535f8ed62de21ff3876f9e272776f6c1716eec75e6b9fc5d1ccd3c3894d4d471fa782eedc14fa969260e1f3486a7c71ea45000826684ae32e898e955e0835057566079ee000b8d304af3172c89cc4316574178806f65274ed9b31ed43da9e24703d0cdbe12741d9031b507e63d9ddb626e68a91b5aed3ed6d514350e16a6eb3748c45aafc1652cd8a3715819ea56596919d643c1438eb4fb103a5f6befc313982180bcf465d6144cc7385e6c2e1c2d5aaac6e80cab389e98bf76aca3277c5516cafa7ac3d27a6b461132bbc03ef063dfb75bf8b4380439ffc6f6c229b56321b6f06eebfe6e3d371422874cbbedb847cd8c9dfeddefc7adc3b4955d7a16c64cfc4face374dc4985384eadfc198d67b06ac4ed1b51dba1bc8eee0caaa62893d996908b29f58fb9d2f5711620d296fd41e45f5414e5004854589fcf5f119bde114c6158dc8b9055b022493fcaeef4f9f0a2bc365c09f70b20ad4dda614e7635bfc5280bb0edb662e3ab482d70794db9d2f8f2f3098c4a9136f8c9207bb1cd29a5c490bfe9efc332b68f4ef78e63b51f1957b7ca1d8a18cd390eab917bef3c26c26166409c39380e9839528c04db29986b31ba1b3c85281e5df68752fb7274e8d5e27314a8f474bbee8e70afb0287308ba47bb7bbc3f7070b4093f5b148b851c45dcf76ab35c9a2fae277b3d9d310727dae1fe7b7693a77d3505bce95ca48ad962370b8cccb2711d52472b6cd90d10ab0fd87d8fd281263dc7ecdb66bd6a90d17587a1bab394a7c32ce3e7f72c6864ea2ee2a93514d1f7452fd9e8249a206d95cc9ecc3aaef1612b0a043d5570658db3f47f897e2b1343cbb90b311d08c6b240e398a133434fc4d186d2317c3a5defa0c13d13256e556c1c5a056f56656f0c4e81d09fb85fdca3d8ebff4da84a533202be8f41bafe83b4af7153be08f95eb44f73694f7db00d2b6bc353c251d622d029eff063268db2d77dd616feb4c71d8152f095939accb7fe2a86560a454eb5203bdc3a6964af31727e7b1d68b5ff0669467a4138ea9e9d91f2256700947a17ebf994cb1e3fbba20fd4b97c04fee199cd85fad7ee6bfc5d814b2dd4426993968c61cc877b0080fa34b9e6a4411b8573423f2f08a77f54b9dc34cf6162b57b020519dac8cc06f49fc455599e78feaed635e5a852a35d4483f69e7e97687ba20862146ccc98d39270b08393fbb1c8754a8f65278486df8f158e02ae3af95f06fc9b7a74d9ed0f9940a7eb5eed0e4c359b0f597a805412d185877d40ed0f68739c0da2f1f2b9698d6e78e9a104e67d0d1726d2688adcfd3cb67d52744ea5b4ce0f17b813cb2bc1b6ed908d68a65d931d2a69b2d18cb1b2db021acb842da9e895c236bf75ed14e08bbb306c56cf891f1abd43710ebd59c0f00d2adf39678c7fcc5d14a7b6baec54164d783fe5bc4563e4cb0ba4ed1af686bb9092e03b9acf27e730f47dcf5a086e08c943310de98df6ad7129eb9a8e5a6431b516ad0ac0e6e6be048152e38a67286318ef3c5523cbb6a712b2e30b3af98656f2aae52df60b33bd9f0fd3f9dd74191d1215a22a55eb917843047b66cb5d1b70b7bc86baf14d614b794d582286726e0f2999642f826c813c9facbf11d8c836ec914ee41b7bb2ad399f90bf9110286a0b6b350aba00a41d044d4956523703d9a5759a4d70adac18be38f426530be222005b4d875bbd693c6811fd8aa30110e8f60d2d225e6e855861202161516ab72d74740ab51ec1bc9a87dc246d7346c91dd8b1b159e03b4582d9fa08bb206db055c4fd1c365db6694b37d863863f4dbd537d0fc41ed795d6905c3e74f7867f3b06512d5468e995ab6932839368443994c52dfcac82cd3440177b9266ec2f708bedfa20eab1a5c5d5b928cdce07ec699a8904ed9c4e482d996bd5fbc65e9c88d7320641c8ab19acc9c887bb90168883cd7025a503a3691d5a12efe8d575b0b852e07e7da553fd4b37acd8aa868894a4b9e04075638dde49a2bbac1ce57c97e1b4306bd598eb77738bd73dd6522ed313b56346e6571e12381e65d5dba25a8290dfb7a23dc85766299a1a10ca8081ee5ec2fc1cfa52f3ea4cdb3802842f90ea2d2b2fb69af483451a11e563262c245dad95362a6d89b90d7d0b600cfc296b2139950400b9b7772a0740e87befa17df1175df2e1ce279cf816324d58b8a63ef70c1491fece6f25005f6be3ba9cf9e8f476071514ea6b4df60a901ed4bce4a8477073934c7172ce0b2cb8b3e6c9944997e00177ff15ce2c2e3e2ec98929500385b57d369ae38985b0a03879405c12239c17086e8e718c596b8f6576a7d8aa802a070fba74edbbdc557823e0b70bbe4af28f91e1bd37b172a2d4b088afc11667d5f54d7802e39c7ddfff9e896627f549630fe45e296bb65cbe685ab7eef0ca08e28b5cfae5cedb0e4e1539cd52c0393d8ef967eb6f854a14d1b604e1dee82c426d8f9b5d7823c76e74fd96e60627284e7ac571d595f2bbb15ec0d17e40d3ab76d8ed6e88110937944a31b3915b97529be114472746b319bce842ffb24b76bce1238c842fb85669fb43ab30badbe27537a2ff74978918c680b1b400492748a9b12c729852e20991bbdc88961983f0583d2f8921d1e6e9c29a5e84f73501be963f78b0d2b75c04c489666e06343d157acf32035f383e52a693a8baba8744e7d65ec2faedbeb77c26411f0958d879ac23d64039aef1fb10bafab44f5a0491e5702c4a7913251a6e55b2c7a623e91adb6331c6e3a5a17f9e6d6d2476d8b4c22f94df00ba1f1465afddc25e07b65176f7b05f0d47a6258e66c4121242a53233242e7d2cf2f8e0e3e9af121fb597506109c878eb0bd8edf1d268362a1b80c55ed35990fdccd61f420bd1f876d636ebc8b3e3ab3d05e3f4f29664988661d258adf3e17198f208c988f5f105036416c07b869ec30cf843fcf9627f2902be2c352b326a3311a7154e0ab9b0d4d5f37feef25fc4d54c11bbdce1d667d52c575c35c20e26df78efd6d117bbabac00808008a9c2ef76821c48f1035b52813fd7b4fa527c655e64110c8a766683e06ec33fbc2c2c7b0aad3d834bfbbd73a853db1c005cc559d55951b59eb89ae08ab103bfa410a0f2f051759157d8e24e394b17c5a5ee9149abf199ec78ea0942bcac48c8597f74a52cbb31849172263043f3e8c94431480122b7472e29d3b74cb6fdbeab9d14b8f6f233681e48597e28e7bf6553120db306cf9f2c6f756f31a98f393027b1755be838744c8bdca3a856a39c5b9e7883b948744ad3b5d5d5b916a160880753f0910b4ebad23af64ed547fbd24c0a7efaf57bedf0e69b3ac6f80df71750487e867f429bd6138966c7fdd5f27042b2f84e34b26eeb5e6ce98a678d5e3ed52c539e3f7b5391e6829d8a1ec0b4401020b91951a4e0f3ecfb2e92657e940042ed1d02beb47bccd32761666baaeb20e908bade94fb7addc229510cf4757ffb944fd9916df2ec082131dc574239e302988532337d109359d6c9c0e7dd10e0cbcde20bcbc00cb4635546c5ffbf2124ed9cfd3c888f2cc00164470abb37e80ef92e9807cb8a1e69cc944d3acf66046783a36b76435206b4092837e800054d28c473fba319f7701e9fa491be16bd9828ed4b0cc45a3f698a0f011f12a1f99828260e1143a0a5416716ebe67cdb88633c85fd0bd4373e12a72e81d5e9e033696d6ed83a53ca0a44c2a5c306b084f911c2e5dbc79743fc595c943f88b252687f709e1f92007494dd39b5d4f913c490995cd4a34e66a3d491d756dea51f05742631da05719e14cacc4dde36f2c6a64419d2b246cc71cbb7423ae494ce5e76e5c64475deddb017d184fea6719d004450972dbe1a0a152f60fd0774d72cebf89b6ca9082ff19ea1a02f10d362ac96e758387179af1110aa83e98af3c10b0943e1097c028b0cabf1b00d45603c1df03030fc5c74636e704df235b483624dbabe3a8535842eb234e873d38777f25cf3c0d65dcd950ea0958ad457599100044e0738ba15810f4d265ee12bbb1e279b05a866187c940e7f60120af7d6fccc61b1da288ddf152312be749315d03218a8eb0c0b5703f657d2b207d4e1b8a56553fe1301e9507139cb2ceec6026f93d34dadc600f6f69387475d3f9cf78eceebe26386fe4b9c5b08ff02152abf1642df6f7aeedd3f3cbe7fa549c0b17827db881779353f8e88227a0c241ae05a7c1d6f50a94721e20801814b4ac45d51296b4e8b82095344119eba743b17551024badcf0ae3ac7c47d9913f4d0f58105f410c21b096579edfa5a4d30c84f79a6c5798345b93c14c5238b9017ec76210a0b833a9421c12741cc9d7c01ce98b4f931b2e84235df49b664efc8d240e1f1065d02da94a561d5783e3cd0d333a36526071961740b21e3132677d1343c86c0621da00c150d96db3406d0faadda4fa5e981d74614626a2a2e92f0935056f97574d79165f5a6887a35b086705ec67c4c8f5318d7c3ea85a64e206b94212f6de57b31b86480fed49ef13ca7a18d21c6d15e2f9e1bd5d69b77ad62c896f8240185bdd339ab48c600b64b2a4a032f8f3561a98b8c61f6e3ae78c2aa35cb8d53dc005c6cb2f68711ec73c204bc64f23c933b7f4b931efb4aad3027044b4a50e056d42b44a15d99e9d10f1e7285df70c7d6635989b259121ff433987d2e7efd340f1505f08e667bd5a792e92f89992c016abd754c6c35287da33cc07ef2db70e5a824e5efcd76a80c6b60d6f5952dd2bc4ccd4c15eccb2e856bff08d8075125cb119a485fc87edc66dffc061d6bbd5d6fc1f76fc344eefda9b28dee82efcc4cbf09b480354042c15a7066ef4e434ca500c8aad750f2ce99addc34846888fbb4593435d35d2e7d7dcf03fcb60b85c3e7bce99611bb1f0373b7bc2f2ba1fe3f8bad160a29f6c4596cc539961169d88da8554c5adca097df660b4e61f7ee403c799866ae7fc804dbc13012941fbff2793c1a016a0821fa4de1656aaedab0910a0cccce1e92983002e34f97694196a7fd907f49593746c65ae55c17121a88149a19c7f116d476fdfa7c08075946ff75698bd85a953b736b653def47e412981f132304be8a374185e232a771eb635ec081d44248ec73f6486b65b63304ce4b6083f41c94d6fc3f65d4ff94a23a8b4253a61e73cb187c5b401daf7e3f3091f735bc32d95d542f166c2feeb1c99c688de062406ed0e3bbaa0d4e4b4e78a8bb8ef4a5224d0c1e0667f4319442c76f5ebf2caf7fa4f97b9934c4c247c0cc8571114466e4e78edd398cec35d9692fbd96356bae68e6331bc11b98c0ac087862d1ce9812f5659f2022c87bce51e44113eeef3c37a6f8f80d9cb9d020c43ef6e53a022a84c52f72a15fc8032a81763283d73ff7b90131f6c3550c4d3ffb993df77d9985d551100f7943adf445f9c5c3f4718acab64843ed3e08cc9cc9a20c3b2733b7a9ec5535f4369d8c9511e6ad225a86388f8b6add5cdd4f9beb6b7899beebcbcdcde7487c499bd5d9fb5071042a7ae5e173b9b114a70b967b3bf22b6dc47b4bb6ef89b0f2a80761760576a456d30d783e0676966b7a8b8fe8e5cb7f75361be3cb8f113ed7c00ead0e423dab681025408b467804c70def02fa96112b92bd9c4b10fb60d9eed9ac651abd66bacf61a4b254f2029d73e25cb1d970fbc64f3e9480a3dbb24378668ecfd539db063127d711274d035bbaa34ac33d54a3825dbde9ab86b1add09c6430282f7879c51a88be101d98570c4808526fb108d45b5e1e1b61af085298490881b788174d66e7723eda53a53d2d4c89bd393f994c97590efd3d1babfd69c1903868eac6ac7d812589fbb0cdaa92e2ba068f0b0652e3b92c587ba1ecfba72abba9ec5f8190aa6682de38d5dc95f397d757e03f6d42c5c5a4df5841ebc119f40b92fe098599c24a8d5841a2d1c5eb1612ea0326dd8491fd6b8401b61aaf509e7d62be8699094207a33f08979cdaacd79d1a25ad1cc820293bd73241838ab9dd08b48412bf9151ed0e5f498a02b631d89c3c50989f46eac11fe2b4bd4c326cd8c91643e5188be01fe80ad7c03494058ab9f5b6798de0f207367b2f4d255cd7c7ead398fe5827ce7d892d897822f659a3a3e7e52d752f4b5f0aefac3ec3964690daf59af04835a20e9da9976540f0944ef66d5a55d117c9da6a148b133b39e19c9ffeaef2a01487e969c88d9c5a3340683770ca8ed5093ec19c2194081fc8061d8e15e6acac3edd5c8e14205c8442c5b95ccc05e85fe13534a2b884f4ec1a46b03ace0dfd734a9ef0261b42f0d2ffb17afa1011adcf94214a18d3b208665d72e66195d12111641978ca7dbc649e7848d556a8d42e0cba80cbaa3434555bff2dcebf5c4669df898aaac9f4735427f15356410134ccde29e64b2a5f0d7b1506591734817365994ebb6508bfb7652d218aa1c1a2316dd06f7d943d3ac2fcaf2b6f2710f568890bb8db740a9d3d17abacab14f6e34f565805316b83699792723096f7143789e5785196d87b9db507c6f65e0a8c8a51bf90defc5f266e0267a565a344c0633f1efae68b255ba14185f73622107387f34e5472d50b5dc52bec13d6d7a99d796191e46cb9508de39087b81f866da8fbf0dbdee1e1eed469c63ab5e8f4fba3d582e91898186d5d5003176b85785ce53b2e3b1af0663e02e3dba4a25c484d298ba7def257557bca69c54834b3aba28ce0001ebae275dace0f65530bb058eb9007adc59f182ca140327dcdf74b147350bbcddf1357bf6767b3a235f70243c3e103161f803247628d4ab819aa80dcf8bcdb9c0bfd9f464a79e6e46dd73ec077512bcc9f01c697b7bc3b21621892daf47ff032a0324d9bba60abf71040c5af03b99cf3a6a7d83931815724ac5f8d892cbd0cdd2f23ad9c04feef39386acad3d65056b636e75a216fde331d08deb0b9d670e1de64b3910c1df987d83eb21206b7f3ed01fffb7416d1578e1a4d2a665e625cc2afbc8ef7374f272e7e92970913bbe5e0aedb3f27aade3835c69e795f196fd4e1478f0ee38b6c4786a4a05501f794c12291b11c5b67c8bb53e1ad0850daca11d06ec2a200c500b962f255b93f8c9f2984db9f2f51d875013562add3243c606abe97eb8071e2953bc8f6a770c0e81bcf8fd99749fb46f128eebc1143a47a68ec00c2ff1a4ebc47bec2b94c819db537d7307e017a88daec8e7e72a333d9555689e09e4c44d9671af02eb2d4bc7ba0b541ed80795b11daac2e8b3c5769d3b2e1813f982536776bffe19e88face18a5e63ec738af04908a660419b1c27b331e05218130c300171d1218c900f7f60f167acaa631a7844ddc56f6e187480562076c36e35e7b4786caebecf0f640ef0846b9d47583f4cc51637533afa45416f83c73d47f0b739d8b3bda80478e7b5b2b91d3e0a0b2983dd347af06544f4af3fc9de5d5bb0565a049be14b9312305de828b09b027a9cfcdbda4448d8934779bf7a56abda398e93aa98fc3161ff4003b98871cb61cfcc59e535f5c8e49b6aca56f394767e6e67647e5a94a4e5123e888944ca52f528c5f7c5876c216bf46cc8799a17028758573a639d4940d166d03b756c8a6a00fd35df743737f27d3505f2ae50d9d56cc43fa5d1e756fc0ee09f687e4f798dc049c6a2c5697b8a2c04a523c7cbf4c8c94d795c51a218f36c3dbd341e8a6480bf2ef59ff1ed5563c78ffce77e16d28ecf8c5419b34b403d0d47f88510e928a2c80c5173185616c27edb3517c8833d6ab5ea966caf8dc14a5344543cee0f3db3d12f836fb3cfc0bf824251f297c5e8f7b3a4a308450ac987be7bf807531a56495bebc2701ae3e98de017da98163d994b8218cf0e4ab9ab7c57402c8db2edf2aa557407768ff97e518fa43fda9fceb778ee838f231e61ebdec1bcaaa439c9363920042b9a72f5b2b08c6b56e3304dcba148db128f37a269002b5fe8fc46142a695565f20cd04a6a6068cf0347963f53a409046f399d44e879a7196d34d57e251db5d43241ee265fd7ad8dbdb78913456e7188a3b0a9b09b5567eb5ef0d8c145e7df3248a82e9a98ed6bec3d4c325347e5d9179bf79e858b13adfc16f0ecfa84bb2d545f5b20e20fcb5992bdb029ccb5da841a65652a7ff1e6eb86d2afa48457ecb8c2d894ca3fb379a5773e75a35bf85ec2d913f75b01f3f982fe78945a1a2c26141efe07eabe61dd542e251ef2dc6e5d7770ad3ca4cec922a1e17f617ba8445e161528325d47bc53869f7ab99082944f0aace9cbe716dbaa31f1070ce4852defe6b73d269a8c5ee722b03a542377bb7feaa4cf03bf26d96f6f9602787d566af1badc0c7debaad3bc3e1e9a498d13e7ecbe781990dc8205bd145037fb59e1c49b36d2625c8702b9e302c65dee44f96775905ddd301519056c6ca1cde4a46a4012561df69d0350686e526a1cd2de2d38fc4d4b0c8e062929ab7861542dcb51322f7bff900979ab81dd70dc71fba64e36442911588d1705225d18993475ba43582c379d6025e918cf6d46176573ba89873c30fcd88470c2555e33d89fca79ea2ea2506aeaf6ef41717b55c27fcf04e0944b4d50688af19470294a2f2d47f98e1c865aa02ee2a4110513adac8c33ad4cdb3f3f6a6de22337fe5a9d20bb04a9e005d48410c7176debb7ae96aa9aef4d42645f0ae73b4b5692656c993dee9f375b14076206cae8e6725573f5a6f595a82569045036fb174b589d2a1fa3f7ee5c887164d80d373c2cc5624d111e3be2280138f15388af070c45d86ced01a0ed237cb6d466a117eaa9e432cb99ec82093a81254462c9dcb006384ed40cad3b3e95cae1877141a345273b25b1c93dec3ff736d61546bbb9e9832158d0a2c6ead6512b38399c993c191f85a8d5e9ca802b5b5973b0a76128855ff9d44f70c81e6990b10bff5e4a3d2adb38ea91dc529dce5fcfc7e365ce84f7a30289325baf5499ed69ced65657d728860b1b117d2b9b8281faff95c616c9da5790414ce2de27a81140dfceda3602144248cf021d4aeeef8d3ca010461f544e5db54ecf55cea24b1a46f04c69c9de758ae4f8778b708bbf13f946568a4ca0156c5ff5c2ceb463ff3a6164adebe586f7f2d6092eca4cf41d8f55cc239ebfdd2de2c470a4877bff3b1499c64baf526ca884427aa9c0ffa16ff21401fe701b539ae575e45d889108d00ac95f25e78549ecbafa3ee0be8f50cbe4ce6bd2290d1cd1a9fbf0e29babfa04d3c09aba00353024409bb2c95de6183d9796d9be1df3810374657b4151896fda2e85ca0887a4bd7148f84b44c5961a7ff78ca7b26ae6ac73aa1d58fae01330d815b49d6471392eba9de3d1fd3cfbc508e5c153c874fc25b056e2aae46994bb6cd82feaf47bbe5b825b5f720459375205396a7dd3a6cd866d8975a5af776ff4a34eae7a869ba90e3e0a6ee874a99373dcb8a6c6707c0c0c461710d17c529a824888b6b059fca9c4279dd12fd632b439a2ae24415ebe81dc775b5d5e56eae1ab1a0c64e96e3fa80170973d111d3672b8c968256e49122c168e8eb665f4ebb9cf85ee78939b4fa6e618f71acb3c68d2e100f3ddecdc0fe57d170668d2a73973f186899384ebd16d23cf77d61145499c01334f7c3aaafd2def4a4b821e0169e8baf45c3f45403c1ca1c3f835abbbcebacc5e7bf73e1fa207a2cc8a9f35a291ab876b0291d720bccf2c2a50d31d6db791483dc8cb7aadac6dd9996050df4a8b1c68e4f3080201060b55014c7f728bf92de6e3436981a2a5c80b15e811dd582e6176f6682d663122a3ad6817296d142076a93f237a1408901854ff9a0af66efdcc06fd56a9511b10eb4e678b01d0bd30ae42af3437d40d023633271ddaef0771064b1cbc9a85dae57489799b2237c1b5e131a6db2b972edb7887d4f7cfae7bbd0539ce6ded4793ed94896368d1577d3c0969e067fb0f8a71c30755d0692acfff5837b9f904a3751ff27b990e04537bbe50a000fdcb73d61dd3192577f1b8848f266dd1bf7e7e8b6a7ec327558c15bd534c2147701535eb3d3994ff2734424d47bb723793b3a85eac799a76a3b946c9e2faf17e698b6833fa52a82c038c59247bf4be957b8e42d2211a32c25312a2873bb3a715b18eb4b8a1834a0bc9ac28132b3becb5652d364b9f2e210ca501a4155f29e80ac806100a24c58b359752b8bfe71ddf59477867b683ada210aeadb33db77dcced1bc5c93947d6df11902b42f6a8476175ea600e3654e7fcb08f8526abc5beae92ab444dfe76cf7393c51952c802e8e3b7bc1268c4915822125e6a5dff3b9db17c9048e57256cce798b83c7409efbbfc07c864b2f47f603679019d9f7a1a653e0b492f86b2b65ebdc5b3bbc8d05dc521b0fbe73494890fd8cb9e5b3a07eb177827215afea73d35efc89215e0511cd84c513731b96113cbfd52f82e471328eec27999d3dc7f12ce886325fa079a2799ca59f824591718019de7b629b011a15ebccfafc8644fda4baf5c90190d88e1b696483ba381c01213430aea1de9a225c4f10ff906c858fb03649c84fa9df42ecd3e7be0255c67ac23812a2b0af15d59e89ef34b80da80e5e5ad8fe02432519298d9bfc7b3b7a42da50ba549736797b7e36db56ee6deb73e63a70e23682205c235b24845e47fe8e9eaf7f26ece54bb853b86e54eb636d2df89b47c6f75ae549b62cfe4bf1933126018771f7ca1015f465d131654199645552beb4c2215ee6e51b467cae07103fdb2749e7812a9f459994713894760e19ff2cb4f33788e93e8a998f817ff8676e02de2ad028b04bd8e4e7cf9d0027caa8131d5e9ac17b1ec08eb369805f5d837acb990511ec65522e3070d9876b7bde219a3d2aa50d2cb3fa3c1f84aeec1c0ec49da38d08dcd10faf83b71c4e9311dcacdd810903979a4c8bc54c8e383df9d529e3602e0cb3a3a19666eab684e3286aa8213612387c6014acb6c391a4a4b385dfac21da015e17a6da1f748b1fda10ad5d3b26838d73fc1c087fb3240d3249cff3a244430dde53c53f6f4f4bba58a22eff0cab09aa47ad5f4ef8326b801497f6a8e1bccb773ddba5a8a349ed60e5df5118f8698e1615e07112e1f76654f824f32c1785a26d0772274606eec1c87fe5872bfd6f140cc94d4482ad39918ea119a976042efb84fd9a26346cf550591d935099b781b63c174b1bf38b58ef1b5a23e259f7eea9a90412580c8f7776b25de2259a09d8a53a973c186866966dea12c53a32d2a7b6c6fcab23edcea67cec75ad2f94e96e1e028700ab372d32e0358b7d765ffd197c7d26900a1a192b6a409020f9e90f06018c30f4f5ded868af5407233ff15e559552f7fd78079eaa1a4f39d140f3e076d25e3bf86e6d64001fcd0dc8527ae5d45a0decc6a756eb5f9c0f2a1eb42e614c2e4cd55306bfa505b916c6d0f70e1b58da06d2f816ac7c1261f124443eef8ae931fab2613467f6b7224a232242b5b18d19eb538d257f0d0bb76f8900692deaa448dddf018ef6c83b29d7bc63bec48663639f3ad158b33dfb31fe6a914610a81e7365ea5f2b3918f47734ad1a57dd094129ff61935b98688233b093faca0db608365cad5c37ef0053d2fba0882687a4c56f7757227e5b85c8030deea546f016db14bf464cb28505a5356b4a4ad8f4d4a3cab6d284b60a411246dff8d765c95fd05c47e583961b3e7dc52751732f3b942340726a7ec465bf64d8af0ac9df4a97e36fbc9ac3d6e7990ba2f9d99af9019037cbbc9303f490838c751f18a39247568cce777461c45f454ec6c71dbafb2a59bc9b1b4a698f8472b780287db78bb260143daf91c7237e5eb66c17e38645061b9de714737a472c2af3ca29d4aa5d8848f0ed7fb790c807cdd3a1e1a2ddbfea67bcbd4d1266b05979f42651a1114479e7b83c744f39c511465c8a33463034f8725bc9a67702f4736affa46e012b8d74752d4dddc4e0defff5c9f4f3f81948ae120eb3618ed08f39579c06c8c6bc567e31616213643f0a25051d17a0ce14a90effca68468ebc4b6f7db8375637f5323eeae245d32e251f62c2b909cf477a20e0c092aaa84c2dc3f02cc0ba58105e5f616ae0431327ad96ed488e68b6bfbd1508ba6d440122a5862ff7ca8f69c9551e4115dfbed1baf9f8c7b3a7723dc771f2d7cba091f56a85e214193cb7762a7cef6e7ee7cd92970d4875775c8bfc61c3821bd2068fe60a843306dbffda35f22a97a0c64f906a1e78d2fbaf10560dcd4706f54db6265eda52c6a923b36bd2c9b6dc75b4f68d6458a94af620e664a5bb0aa7909c7ea2661830018453d78947e3eb7c89845bbd32bdd79745720614bcd66493328b1b9d5e1707ba1b3b797dd847855058dc8234e6192d852cea13c756072be03c9e9c8c38ed3514be7661fdb2d9f662c37e723f46bbdbba6f75c75a6c31f2e8b6251375d9d1f040a8c42aef63e57afcba5b67706548a9b5e53f0d264606eddb6c0e57b8c8dc8fd6c2e57a38ef634427edf882fcbef943ddba9676bd277b4a2a442d32127b70e1eb8c4efce65cef579792cb89555b907b446e849eec9212103c0da6d428c49f2f5405128fefca1b4645f1a40d0653fe79d843ee0e8dd307ff77cf169cb44b288c8faaf9625d1fd42e66ffa6a2578b336e5bd9e2bd5053d49cc41db2248b91e7616328ab54abb53b5ea93b8892380dc3bfe7e8427ec5a966b0320c163db6edf4a39b2f493fbd4e737c12420e4cef2e9628a87e7b6098ebc7a28ac7899af12c8c801bb1a6875c72c4577c5f03349d630ff8aba66c67afb446521c2d0dd8eb8163a0e920b71d40c330e587d5771bc389e82680f4e66c339d3f2bbcea8b076ba27cca5d50ddaa631d87642c55459f6b12433c286c796b38d7ab6ef7a26ed47a665f993b6262487e50914092c8a1f0212c23117a1df740a46447813c62bd38f29f7c5399a4ce6aed1733487175c2c4c3d7982edcbb2622662580b210903d76a4df77064300890f2fb38d566eb66b6d7a00a4d8c3a23a8adc2f673177ec79202328dfceca648967355583bfc725bda920927b34a35f334af5a6046c84ad6bed00631a52e285e95204e15e3bd42052cf4836fe42983c6e4f96a10d1aaf77538aba1dd0c66db9f9562ce8183f2c5d34a530537b343a36571fb885789eb41103d31327b77b125ab73e3d8fdb618f6ad53ffc71ae2f48185d731f0fb1c1e37a7af4f39f4253cde147d07ef787862b669a77793a4fbb68cc4c805c01028de227df041c4c79a6074ee6c64ac2004eea9e8b1e57092315b6fc5d9147b8c19690fa86a0905c727cec0b0f46130a1081c330e7b08a7bc62f26e0b355a9e91ce9a5278b821057dd96999a049ed992d5a89b16e68fa67e4fa0b2f924c69565ae42a7bb4095ed723b266af60cd3df2fdb068dd40fa4aaae049915d581e33457aec74baa5fd0856165784e12124e0000ad82a278078397dbcb6c7c7f42e03888db0313fb7c9312b861b10e1476e4bb6dcfdd0a6defdc4135361439748c1c88cf7aacf14f252e1f510e3fbbf9384e7d970dcd3c39cd79e2a31113fc50b18dd75eaae919d6a153d0ca50e97d382cff6a1f9ae98097d2a5714b40968665a0264f3a5696383ea3411373d5e3bc7f0b39658f3cb53bcfdcaf51d1c5fff0bba3576714847987d55ff8eebbcde931362e1df27b5dd75c7ee37430c38cca1eb41825e4d2078c6b1faa6bc69383ec0d856252eab13268a5025703ba88d0e329446e96465c266c36ad771c67ed704dd1e8b946503df4ef4aecc95acbfd221fa64ecc0e082657303d97be11b1914bbf956c496f2176c3325a49c695c91694d1ed168e7fe77027cf1561b8e2de4fdaa259e9ba9201e4d5962aa1e6a204f1c28a64e7d4a19458dd89a80584f6dddc954738c3fd710a7036508c9040a4616b7e99f3473586a6d459f076ff7db9132e3ea5263e1a2d24689576ebe17e624c5dd8b7f9144b4886a71c66878161ac9f9fcae9d2a863eb072a689ef4aab77715461329daafbdcf87a5d79ce0da22005c817061cf9195569fe8d2ff5efe86753448242e5ae7689df6974d517a97615fc925601def644dd16f58cf8a4aaf6b1dcc7340d05385b0d69d70d9119cf3fc62f17ca241c9048fccccd212cdb0fac92c0cb5122616ece6ba0c7310df3af9293c36b2b6f8f9a202625ad38dd4518581f62d30fb369672f99aa4e5b59b35115d6a9b8bdcc92473d53b4435fc728662e2f21266efad9015f5fd5e9fa874c1d93d13022ac91805a35d0fe8e1e65317ca6a69f7670ce2781b07c3e0aa638b020f646bcbb01e83b345d367f28993766e58219c714e233c79781509d57239d8ff7f1fde51907a404f9e844eb8c380f4908558163aacf40fa1d175a6dbfaa51474692d60a80421eeaf60647fe5b92c1bbc6a71fe36f89e4443b7450e45aea021603e92a19293d05e98e9381ce0b65b6c0951f344f318de21b5998669c0d2cf36e6f8ca7fe9acbac6cd19a4d9c38f2515d0127dab0440f13191f1f8862f0ad863203f3d2200da7fa87d7d7256e075e16076407981341e660ee91beddefa5f94b82964c890c87ec1d3dfc09486cfa9685e2fed84241309f706e4e48643efae626947f7d4b54b342d302a46820d90489a01e9852e02e74e4d22f69f7123bf1823f8d2064f73153064f041df45c8c1285555bf90562338c09a0feaabb565cc40895bdf087d424d07c07dd2c4c6e439cb43975dc23724e511e10125cdb3f1a69ed39c2ca33c3ffd027d47e956f6bd0f500e6e2ffb7b1eee323751a17392f67f1de3e9d8a567f57a6a20ea1588cfb7294e835d31e861b1151b914d37f567ade77747fd45f87a4d24e71ed697f11d2ecf9ca005219508bbb674e6c2df7a377c84ca88b029aa1f700fd1f692ed8c88af844889cb41d49fc59d77c4472573fe583f8fdcd19e500083118612d4f20254500c01c77907fe90ff44b95ada58f62b13d7a728372d5e177ba0987568804369f5d6d360f45c4f3aedb18f3ae9df74f9f7f1ac1b22c2b9139d3e1c203b26398c721fbdaf81ba28a05612966c4495517aba48ecda7cacc80eefed00cc81f2b59c65186b811f844d88d9f9e44ee3cdd01722932b3e504c98b1caacaf454c240ed13ce28ac35cba52c4ebd7df22123477199931dcffb59f160c98ae68a5c4375f8cbfd74d93b6b38dcecbf243193639140602e0efe693c63558d197100fd720a107c730bc56357d0c8e980096a6f23ee858990193aeb99584b330a1e70644d8a4dba61725855e6e8c6ce289699aca116b2c5ed8a58305c97a031565b306c5713e794fdab7949ee0586c24d0e3c467cf3f0ed1cdf4488624c2760fb071335dcf12cc50eb49e57e364d694ba974dad50b5cb6f6b9fcde55433441f34b5175dc8ac9056de0a5ed87d8ee27fe88ed9432f4b9f15fbea92bffa01a532924c95fc6f418fefde705269f9055a85a1c1b99ddee2390fca9f435fc06b9fa7c2d5c6bd7641dafe751ad237c1390ef30c9c57261ca53574cc609af3706aa0b6d9023999244a170f63175abd3b368025ce148468fa9e464a4851f897537de1e0d32b4155e4e40279861047867ce7f4e443a3beac13ed88301652e3651e5667787efe60f103fdff5ec29cc3b3f58d9005dca23176290842d426a3a150e644be6812c9893d64048d00b04264e872fe7d44621177d000ab86f132bfea9984db2a13edd1ca64567f8850056071a45f057829e141586f13d293c5e5ec1b84e64cbb11f4cd0576bd62d32bdcae5516e6b050cf8dd4cc41bd46cc3f8e0ad29ebe5deb7e7f071e3111a7ddd6ca90b2c5abf0734159b896431ac62963fdb001e72370e5869ca5b72837758611ae5bb19d1293674a2b82ecf9118c646dcd43052201d5fd9742e2405cf6e62d11ad4cf6bc7971ef34225e4ffe76c095b4f3a17dac0a263d470fb577b87b34fd27bfd2f23d4f76879a8376793f3b684ff9045d7637d8dce217b1197e18a0568346f5ab4e2f1eaf0e75f3dffcf2782286806891fa1c21ad9b101dfb006a2f344a64487ea8e92aadd42d85789a674bd4a30165a9426dafbbafed5f740560982089a1bcc7315834d5e1bc1460c0cb43e0968440f14446a464320845c5222e0a3bb427b4bd8a8fe0503613528cb2cae59e8bf7c6bc936e54af93f986fc5ec4649f8756054b45a8c6522cf34a8a95e908fb59b6b5d3b48d6e11a9e6a5e1fcc616143c3d1905a96101b15b4b5bfe8deb0bfd8932f48c52d3dd527746c15b0b1eb90b8f6be2c3118e8dff311642ae925e9e51ddc4f5be2085ad8a04aa84e77212edd82161b104fabf5fd226102537a2a65d3c9df3f25fea617f5973b016db0cce7406ddc865d1aac77e9c22c673396b0572612ab6eb3ddf11e0ae74fc54b757dc886cf8b0221f11a6d27be26d2372ab3674fc687490c27f2ca748f7970ec9cb577a07d07698e477e5c7097c5d6aa51882d334b1cb8182f08526ab8249fe0c4e10929fb6acf58af91c8c5a3eb734f2b2b0758bba8cef382d805de93f571fd14a5b1565cf9a38f0dd63a5cd31b8a2377205f3b8b194d08cb2c83f7ea67c2138e617cf81513379257502b5ae0489cef9836075ae65d0a4136a2fd292e4de1523a78638a76e441833121772fbe5cbb1891afa08455d2323268c26e2238271d036229198d7b674341465f124b7c5134e8987c4518cd63a832fb373edfc6ba1966432104a68f62ae4c998abb54f1b9692e6561b2402653e5a2bf62007b0f528f53eb730d38b7d05d7d2863787c82d4daaec810e1340b1694a8d4506e488e9ac3393e8ab4fcc361e69145172505ba1b59021006f01cce71265f67488b897b6dcda9096848c1213ff42d42a3a3911c955ea821fb53d773a07ea815d16829f6e1673e43ed7863c7b6d52433f163a048db4a433c89d34e64f6b43251599d86c2269b0dd51394901f88a97097ce88d3a92617ab6f18307aed1fba33659e2c929b37f7df6f4f3f87baaa1532ae0f804e38265d1db17264800247ae476a12ea6eeb69177fd8475b7fba0bc846c23fe4c17c3b5e1871ecc6de1f613263dd07e6eb3072f28a2161c3040cc0f3d7b99933c86e06feba50ce68fa8a122ed7e1da2b137f351bd3a6536fea7e9ea972f8bd593f3764d639b38948042983cd29a6000ad38cf5409af900f8feb7c39627a95a095c49b62cd65fbe9d486c3af87aec7cb39feaaea09c238131de059c4af7f8d99153c02156e0c49384bf4cd2b1a11248ded894d149634434f0c4236cab455bb88b2591ab886db11577639ff05bd546030f4f007644cb7e2ac707099a2029bed6e8f8da11840138719f2dc1c2967d752736584c6b727bdb9e3b460f85c14b48e6a65dfeb26daa298d8248aa51463fce64fa9690087da563be52a6ee73af8e458b01902558f0e3cd92c81df65ab86d827ff16d443288e5a781974d7901ade2ef06ef90e2d457733e068c6658405fcbd8195dbcb1fcb0117b6ce0ffc86469a4254beb7d146ea86d9a640d87583ae256bc0cbdf12bdd091256b0bcbd69f5e5b2c413b90f1c17b8c937590aa331fd6cd6eead1a26eeb8a054ca4d1b3e594601512f8c60a9fffb5cc01552b5e5457e758762de87b4f63e63d9fdc4b1bf931ee288ac2f8df47472cb358ea16c4772b5472daedba7b222cf143e7ba4d1abb70829edee239f6c102e31f06a7d604ef734ae5bedcba7fa7ddcbf5dcd969379d32dd262774524a67ca459de79a2a128512fdfc74e1d3095fa8a80b670d86680f17dee0ccb50636c119dacedb1e55922a1e64fb4b559d52c8c0f6b3f379c32660cc2f104e2fc9efe5df577be19a1b77b2679e37a695b63965059a065917ad121661a5704a16d759cf682e839cad014aef1d35dd597962b030a543598c51d4bf7d9e22201eea40f1752e50a5336ac0fa6a5b4b9a8bcaacf15de33fb4e4b8c27c3f580f0bb8f5b3e6568816407eda27d816856d53a9190a80d2b3c25dd904ab6cdab6b000ad0c5da324ff732cef6454efed77bd78f9e2ffc17edce55a6367ca78f0a4a6498ad46182673c2aab13d607b4e57fb5ad2ced55ae108a45af030aafb51d4b88220ff66bc6132ce8dbd41016947c3cfab924b29038c3e50a2b809d747c5850db68f549b99f156f7bd1b8078704148121d85ff80e85d5a6ced20cdca57d797c06f709ff1ee36b1e9bd28ae160466dc7292c4294ed4c8f3f70ecb89870ac7631f513b9dba3257566a3be25066777a691f3a1f951cc5f33e26e07445949c2392f6816d4f50c00b9f30ee99add15013ed4dccdc1b630910dba963e099e804a8547ec1d295df7343310330e0f3bcd147cfce8dc3838cfad9040a4a893ab3c8e1666a9a0dcb70f41ee6402d290150e501a30594a8e04dd0124711cf2e763a26dcebfbf90586e07f190a731f4793ab297b5b0e43594342f011b0ab0634d5fedc0a5fd94d00e15d7b1f1547aa9ddb49af14d5ed776713d7670bffbe5d0d4e12dd74e2d476f6ac2875a237d5f94ed2343c78166344cf01514c78c7eb578ef922b0aaee33ec0fcf7163f75c2038ab4ce82d38db3771b60bba02dd81e08668fa3ae858f5e76d3aac31be152c52c03a02fa974b692d449ab4513e7f40f180a9aded8b38423e39747b9fff0d44bad451046f290823968eb536905cc641c22b064a401255f565437add28814fa3ec6f92d03cacecf21454e6fbbaf0ac1ca3892cfe8e1d00e1c1cd150f899e36880c9306b541971722c0496cd3176b55062a3b6b63f8dd0f5e71b7bd594aab86df08f5046f8b4c8a0c8f0d0bab94d2e4468c2e56b519e458edc30519fb529179478e5f48c79dbc7fcb044be28abaf895338b60b58dc41ea8f61698ca978d72045e9c8c12fe3041c1be21ee385d34ae3d0f22171042b30167883ceb27a668fb1d22b9cd9848eee6503913c59cfff851ff30148057fdc538654c9ac46ec7904da107197f838416d26df73722c6b7b0f341ab3c89c5cb366f066cc58448405f53ab6417dfb867dc0c0436f9939f90f5470e936be1dc63670b65b7d7af3e088b95581042199cd0c66e249c69bfe1d3438812272cc749928eb4b903fe34104cfd1b91ae15144c9379a32c1ffcba27c179dec5d8202a4e80e18e9bd8e2a5165651a66a8e8d2d2797df9d0ef6b78df00c6a31ac8ddf632b02df3f79a15d823e4e2e3cd8bb5e3290553c73f1f5875893f2898deb5706dde098e0fcfa04f30aea739fbe32c3c54e780f1f3592dc1e0c434af400e3d24c9aae98127e2deb05aad9c275c9d262db7f1c0f1a66f2702d789813c771874eda9f4bd4569d424530fb84063d410227d993f8f07f4d87c3b338cf139720b6f886fa5edf04e5e798143fbc2fb71d29a97410190a1e1f139ac78876a4dbee6d94bc210495e49b902f9a20eb482a33f8d48c44c210f0f9e5fd14c5875b5241c66640f839071ef843eca9a6c119442a3bac31f0b57ef6485e50e86d935297eff61847ad87dd2061bbc9d32bbd2d9e65898333f61331be433766b351d918ace6d899eba549a8606fb9a7e5a0c7ab26a790ec885ac6126a0aefb83e808f6f102abd82e33febb4b8ee4e03fd71afa732e4a5c06f68a81b3c09d39252335d3ec30f962f214160f0f01ef8b356eae714d6963d8bd733ad0dd3825a77e7de14246136346c9dad8811e1f95d31556d5f123440f4b791b6d9263cf088341f1d784840aeb8910fcbafc0ea5a4799c480637ae08e8f46938fde7dd8509ed023e003119c4084a9a19cd789a21e8a15e63c866e917477eeddc68d8ede68f48a40f5c407152da18dd9b93f6d7cc85af597000fd75c8077093abed4d48ec9745c6458de647ef791a6068195c7a1999ec9489c48d190b6e37cc33f630ea2af3f8303311acf139a967f6d4123a514dc2b1f9aafed0b84a719eeee8a3e1b9e4ec74e28ea98fd14ec3acd11b7871d35e01de05b35f60f3e2c09c93460defdf9f8b993a90ce4c774cffa2e1b81e6ff86e57b0fedf988519171252c3c4888dd87fff2b10cd8abbd24ba719e1172ac786b37320440b7f220ece8984102fd733ce2ac50f823996fa5a376d5e2a84d8b58281acf5569a3b2bf3012f7f9b61a674e6829c99e100c64f3a51f6f13ff037761e03b5c0c8f725b546d708b06ea11c1f5e0573df967244b753f48ffd848e6dcae3d1d7f</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Vue </category>
          
          <category> vue2.x源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Step.14 动态组件的深入分析</title>
      <link href="/computer-science/vueyuanma/dosc/14%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E7%9A%84%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/"/>
      <url>/computer-science/vueyuanma/dosc/14%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E7%9A%84%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="568c28f6244d65bf9ab8f91bca7ab8dd65179067f79d43ec6422efbb383339ce">5808c6cbf3ac08533f2dffaad5e129c1f7677efb1b6b29d5c2835e6dc77605868babf8e6d233f3e535c02be104f9d204982d05f13b6e4c75f4566337bba4935c31f7cb4ff9cc80df593d8559ea6dbe159f95883fd540be7a2d7e80a138145882ef0b81d0e4e28427247e0f094579bb849c540ea536dfa4e64aa6ea5ec218f2e3806be5377b86225062da23931f6898b64bb4eea9c45e301a6dfcb89243eb466657d9f86bbc9b11f1541aded6535323112423920d5b5699d790cfb607e76688945a0bdd5a97522d04b4d7eae491c0ad8ebc5d9357a6fa0bdd25229335614b2d2a47ffc3d593542496da3e0089a874419aa96defe05d11d11666d0eeff07f5f034ab88d21e0b1d08dcfdb4225c09a315784dfb989c5f6dc5c02828f1d8009e506dff6e29ed64a18ea49e74ca78c724334a4d12483bfb050aca70d808c4fc02008648d43e1055d53b02532eb5cc8960597994e0ccb1a628b31638e867ef4403931c41de8d4d470d6e852b6b4e69c70a4e79e558b8ed35011a867488346d6c351ecfdd68de569bd37197b39378a028b4cf90806bb69f4ae42a4d94cd28aad9af28d9c31bd3c285ab3d357953f8b6dd60a65ece96d16ffd3c5d17bb66f67ac4e956cc08d8eab4c74207c79bc74c78966e7e6950b0491cd1b7bc9c3bbf3f95ca2329ac22d5eeb4d9b76025b44aff63cc2e0c9fc8d2a8ba1a08990cb4ed054d6eed989f14256902eba1b692a73781d1700d5bf85d8a2cc70a2e7508e1a88dd465bbb5072f2b8701a0682d37baa16ac3eb5ca5c6fdc70abfbb47b79cda342fef51ae09dce7e60ce131335bd698c7cac6e76dad493d54c4902ba4247dfd426e2bc0f0e4aa7009c1a5357175f1b994f91aea900deb63bed764d11e1e7411d00e1951d72c7fced571bedacfea225860fb5daf224d5998f47cc948d33a0ffe71ad50f8421ac60b8f9612d0b7363b43eda6c886f2409a4ef8c1ae4d7df9dba80e4c0e3a1c9f2aaf346982461eac765850a4e6a5624cc540bfe9f19f46c1c7387905f5762d1aeb68fdce0ea261a45987731baf7af0bcc28ffea9bf36b7a3e69dd8ad92f5b94c467f1a70fbcdceaaee9ef18a4e8d05dcccc6f0b0063ef0fba7c78321c731e86e4350920ebdf54d819acd69d7e408b8a90f36a19d60a0d9094bd61493fecf48c0275261f9fad45ea04fe8a21261cef856f70340fc207a2c65597b4efb777379e2af0a28fa3258fe18c37e64def84cfe767b4f17b0006952b9146454bc758311cd64f101bbe0cefd3d1432ca7a5226a6c9dd475d9a2bb47979a7f788aaa7ec815bfc1c0247aa4459ebdd6af030ab1c9a77e23b2e66497251b0cfc1e9627c08fbf27f052e250a573128e0fcdd5840b51b9723093824aa2fcc6eb8efb22f82c9b2fb9b5045d32c231b1ced6b1b408105613a5654c6ea9798fc31ed28df8e22ada2519feb6d7f8a4e6ce8618eafec3ff16d643bad997af479d6182b68495234a4412d050fd97192555ee96303a2516ea7f4df430f8e8df721fe51eb9607dbf947602efa8dc0f4eba2931930a671208bc40e69d0bd2fb45f8d9508f3c37854e82fe6d9ac5c3a004de1b465052426c6024a2a5deb6d7ae126d5e2e6b1fb9c7de627584fe2b375702c7f48b58ab5892b190c8b23d71a7091eb80b32e483f0ac23da6981da11f46607e52add520b709b2ce1862a1fa18803fb5b4103f2166c774dcf1631a49ecdc43f137541bd21eeb74b3a754d3c0528dcfe40656f1e804229dfe38238f607f630dc27f137b2d06309a9fff9b19dce471635ccf49f82f5b57aaac72c13f62eae20ea0b391221fdf9a7b2e953189bd6e95e50507357c1ca53d8bea39ac10fe367d9edfaac90e521930366e2f40841d70c46cbded49b53b54188cfd78776fa77fca5cea90ea7c19bd2fe586d22229a7a53e0c65e11175184a16c7c2b68ef4952a68dd9ae7798dfd2958b48fc5e58d44898dbbc21f78bd4937b770d30554b87e3a858d1c734c4fc9c3bfa7658af967a23b83c5312bd7b41df45ee5991aabb5796e00f8f1f7cfc17f01e26d9c5a3dc92613b572d75c495b29937a2bbb4250a9bf4189a2e804b9d4fe666b47bfacdb3406fb519177b4d4121c671a78f70604e0335dcf799d6ed3a48544ba2173bb37b9334f2ea2525fe452f70d22dd29d82b1713bf302ca72de57b6fd76b66e396f3ed601d6cb8a1bc2bc4629a3fe31822a08b80cd7753ac631e8231d2662db7e9cc7b6703bb4e416e6f8028492518e58c0ad8337aae8598b8bb91d1cf45d7b3a5d352e8ed81c51090be877ec86e907353254ba2267c4705a18daedf3de5c0033143deed9f7110826a76d956f6e89ef115cf2c3f60da56901b8823f190c814f153f81da7ffe7733202d26550ffdf589023317c5d4e8eaad02e1c1e6eb924382a8c19a8aeb6c524e35b3767a5dd19fc131294922480222b68c1276fc03137f20b7901626ba6e6e6559a07f0511eda2f5dd66cdcceed496912501ae9836e45f19168fe3f4d14e8ad1b8f9daff7e57ea768bddfbd520bb64f3a81b8116876ae95e7210dcfa648d783942a91bfb79ca0e5443c52aa8b855e668fcb37ca8669d7e40b51eb02afc91377b633691c4de934408ca0a33db9de6b0a703e0f24aa76a7a457bc0cbeea8ede73e397bdc9f2574cf6a0ab3a0b611c7e3ee159d22f3216bab73eb9c56a552dff4f9fb75d41787d45e2c1dd60dbeecc15b14c3e714cfeb38242e29ff3bdb03af974c0b275b4a2b27c4e4497912c478d466e8eda81fd6d62d1f9fe26600a71bb464fbf10743894d67e4a27296ab0a2f7c71264b20b4645bc9294863d69dc265c29614e6cb5cb9c5154449098ad023d2e290f1fd165da641a2d1fe57ddcc5d4a47f125d6f0580cae1142359b9eeb31ea1353462b808fd6f504ff57bfe760ab6f378ed9f240af9d911d03998a9c4e7065a07791ca8a5ff649ebeec6a27d991bc8621354e0503757a074b143cce6de78b495f0b38567a0b18746310adbc678360970a922ce1d5161e0d8bbbab9d970fe4f837e55b97ce36342fdb0dc523ca8679ad06bf0e2f4b4bae96c63677fd334ece26ed79eac5ed29294bcc1c275baf70c32247d7a43afcb56272f3ea5d3056706e6b99a53c2384203d1a78c7ac9b0c3fd58f2a1e9c1a7f221f37003984eced914e22bd0fb5349fead3b4c9a646046b167cfe52d74c431af2dfe988c5128901fdd433003af595893428295b9610cb943bd79ab2bdcf6bfc1df5e2c8fc27557eda847669d0f718f1ef208e5f9d24a9fae71c38930badd5a7bfcffa3870c6441a74e0145c5cd0ff759cc9c75dc232ff58a3d32ae34f7b06bef5b6058641bc363edadce4ec2cf2428f38f03a07c0d27feea3bae8cb0148b4b9aa88b39b9835caa527cbafc9af486a37633c7ac8616cd92a364563f45d54ae9d32fb4b99ff00c47c0821e7e580440277c7a2243e00b601f188a21ac0854abfc808041fe4f9727eda93d1a95e94cc7d7c44783140987c1bf623dcdbafad637675b0dec9ac7c878a0551a02c7b982258034f9d9d441a0c3918fbe26446582c79c75f464240644c52394ad93ecb9f8c29c020f6332c1284dc006167a6cd0ebba572677686bd8ee03bc8ef19dae7c5e2c526367ce82f0760a29e6002167498af7c982a6a14a54a6c679e9a46c8f042c41770d6cb167ca2afc2893ec485f4fc2cf0f1f2e67cdb38f78ae5fa5728c9d793d6cbe80845de424735006d8b25ce19b93303a4b95657c64e182f32e14c8fedc70214674ac8966c1c46e770355fd0f45d58fd23a8559ce3589c0391898e1cf77d23b884c46bd78a1be43ccdf826ba2571321f04a2f4b079d168b5376878e14b26d001edf321b67bb5615a73c6a20c0c92056d0bed635f816332534561ecdcade6734738a335221a3826859a812c017820e9b5face9c33e632f79b37fb97822082fc3e3e4a560709333aa3cb2cd93e650309b72bb88435fd4fb80886adf414feb7c5edf1ea9630936fceef0644f6e60027ea1b15a972738ae17fba806df4aea44b9b463e44c6387350ffff6d2cda6b465139b2ed6b8d47af530c07430648aaada803bf4f5c4cbabdbf3a7d516fad38dc6abda791cb0c6cb5e9a538c3b1b84cad1004bd858cbca40321e9c4993843efcd6c619f8d92c1c63a7ae8cade9220d622b2681ab52fd2210542ef43d26548d7a5828040b84b660d020dce4a56c5e19f8caddd33096857819a7ede7324e202935da04e7bf95fdd5538d0b6b5526cd410573298dd4da1fd80f0ff9be905fc9d2ea0c84ecd274e5d388d9371842ede50db714138154c49c1d79c1a3f142021f20a2b0e64a43b1ed7e0dbdad561387aaef706bc2689d1f2aa06ca770008e3b63c3274fff0c145b6da2afb4d6debd1b0371c1452c08cffa67d110c2fe3118c58f99e51ed22b36b43a0b0f87feaedb5a1da98fe94cb176a2fec5edc4c016f802c144282c0883913a998982594de866ad50726d372aa34355c58a70cb66b32c18922102ef9bcdf9fd0b571434ec2bd8c40a16c3202019c35e0bced1a36fbd645ba9bcf775460af6799662f2bc9117eebc251823e68d2e6de4308cf8afb73493cf4b99d5d4cb8b69c2fefcb29a3d12613c6f672e1c1ab11331b8aadbf01c48a45848889fa07067d9fd8aa30c7af8e96f3400549efccbc2d7d7597d8948fdf4c673eec354c462429064d07679f5f54e5a272832506f339341d81a0c897489bfb569d482d3f31b76c653066cbb0474a0d14f95b5bb0cf1f3ed3956a6b3471e4cfd2d7ad47bbef935ef627330155046cc7604eb3513a2cb40a0bd56d31bcb10aa58fae7f67cac5e482b6eae98fce8e90469902d526737d7f1772a2e8bd2c6b599a081edb5fd83e6bdbbb319ed3f9de7c6e872afe019aaeb4d4be79579e163125e0758010ac5eed46b11be5aeb4963bb677691b32af9ff465661ed58f5fc1fe763207117719a9fb71913d1ccce2f40dfda488215fe8708789ffd4d1fba2e8765c88187bab785bc2da3abac822bfac086a5e9ee452a63b1d760c044ae58f3aef37236532f461e5212a9b6640d81d9de3836355b41c8ac9ca2bd9c70049f6223839b2770159bfb203f05b8da4638e10874c83a91157de9c58c02ee1a65ae36b429ef627dfeb4383dbc8264f7df3a8152dd0c366caea1984d04f4d2079355d784025f64c74ebab29d93a925daf963013cac249320d947e12f0cc89ddcfa1167dabaf71f3fe6c9a05d4432e2edad5d056949d77ab521c01017e37e147a9d28eef0f25ab018c529e4ab96dec6eed9ec9c26f11cdd4a220708d911038367804fabfd80e68219ebe063cb7ed7a4c25aa9ef9f88b545527fd929bd5922f6a4ec4bc03aa2d7a1e0a59ce505a4d606b7206b6ed732002be5e86a960e2a012acda1f44906afb851b8eb3eb45bf86f64b37db783b27b035a7f2fec2b0099383184f1611a9668a271a1d07c32726f64e16ad63cedad831463c572a6e4e2be2aef3512778111ecead809188528a0b290e3ae236bf10f8f9e2f103d4ef3ad37950e13ed1a27bf5d8f79dc0edca0b014768b4e34c346e172fc03dde8670ec8fbffbef30916acefaa8f17b3a2845f9376625c10256ceb51e9896933acfe8dac37aaab8b4bd27abfc58f4b370dee92ff595336b7cc8ae31fabfefd389faf5d6fafc56f80190ea87deb9a746d90bed6684b4731b0c6657f48ba1b559dc34ab9748b0c994cf35fad826a9b6e16719b26914174924203f0fc422dca29bd06a2aa91c69d3e62f39c1fe92e0cacb052c70fe8a5069a2a6672d304e506ad1a0675a44797a840b1316eb71f200653228fe29834e27984ee30c496e1013bea26410052ec6c0d95c03abc27859a6abdecb5b76c3c620254d6cfa133028bfe9743017320baa24902d02c756a8629a2904ba30ddd7f4980927d085b83c44a9cae6703df7366adc311c0637495ec75ec446f7f2a16b696fd1eb6059534cb306cf2072669094ce345517cec94ea7ddfb02d31c9dc1df89582673b4e5b74e417f8330e5a80f118591ebe6cfac03400b0c784119b16a091d41700c3208626e301940afa6fcb722502607b5c2404d8d8fa90758bab57604235782000300480b52dc31701f8125104c6d224fdd4be99cd027e28880e195d2ee99e47d92e0fc8236a9827a506821857ddd012b1a5027f229f886e107fa811b0dfa98e61b53082ff1bf7eb54262ef911418d1b7f9406c1e7fcad234d65d5c12395859fc82d0ff75d7790669bc61bf346480bd9c5476d94c5d84c99ae58f4972cbf4378968b549e01727b23a2e5477f04497889ed8026d9f77d07477665eb25606c43b826e6a12e3aa4bd460d6d5b3ac9ece8c2645c92949116bbdb6dbd1b5566e1cd7e57237526837b91c060f2797027a7bc3d5e8eaff23e0675406cc31ccebd178ec86441c894d9498b60aaf6950429f0560df9ed28854620a3c10c8be956eb575e1570b2c278ea97a61dcfae921770c04af02a1259ac1eee4186033a3bfbef513e0688dbfe48a3b41ad5e12ab87a0e2a4163df8ca11634ac99a4e2ac5ef9d71041534a53eb77ea57279c4dbaa9c52d54e9038518b726f19303dff32970d65634126e881a9f3d168b1241a665e6d77f42914aa1c539b2c08625da544e97c3b41966a5ed704580f4bcc301a1c7ddb020d7b150201694b83b385b83324edfbe2198698573f592dbe55f03874deeae2be80d76ce41c1fbc7b53c4d0bbb8879d0c3511fd5d2203b4b3aacd01cc51abcf6398902aa9e0a6f7949dfd6d2dd50ab5839fcece5318537115a64f7685dc273ff4617c35453fe55401baaf712dd191311bc348bb2728d5f3b3e5791cf9e49183161231fc3978f892d4d65f374a3ba6a4f90565e81883265a707aba7d1784309c062537f1217b22822527816044e1df1f78800d905b0f4e4195d3ba6b8b586a9124f1491a8bffc355c12e29eb212219dd6e6dd6beb5f6fb45e7c722fa59820d3015b26661e48f930c9c607fe1105d19c4ebdd07ca9064a2f6dd2d30ea3a9567e854abb501007fde988fda897bd72064a60d4f2cf5e2ebd6bce1d36d7ccc84abee282084e4c59e590459982c1b4a3ab3a22e5061be443b5cd272050b3291b71ee4c8135121564e5c7c7c2d8a4f2ce14c41f5cabb208481946ecd620978a9924f70703e051a85d39d8840453a1bb3e1f2cc389e231b1e5f01f3b8ab2eb8ed08c10bf6f45d0060e616b6845d7a164f26fa8231e322cd57d61b8b2edf5e875bf27c4c23e1ad6ad677a7769dffb44269390ae616419bbf9de1c962db5079f40bcedb56ae7cc18f571ea9306e13e172cda73e3aa2eb85328591534ecb32d0ba4278deccc9bb9cded3476b17a1809a79c4d54994bfa5827f32fbd16c3dc1a55d2e51387b0909f11b0cba7b91d15c2b69fc95a0957b7ae4a466d2c93e5fa02562ee613fad521f0298bf76d1ad039bfa77b112634a046ccf9cec44ff0496a267350b59205f58ec3e79f50b8f7d7e1bd522ae3e3c35f4ced9599baed9f6c994c89c5205ec615c6be922bf27fd8721b6a71187e892c8323176ae9bacbb503560f17305470648041824c3a6d62e283dbce54a66557a33eb0cd9431309703f00bf51d83e3a91e572d3f13bf7d28769ced0ad3240a132d63ebb6edb799b9f9324ea2daa4cc692d648d20756373883c46e0c3bafd649a5e0af22bd49e47ec7196ed3b7344dd1cff7e472ad5799fa3d4281e079269326fb32ee81efcbce20aa58fbca2fd4c36d4b79f1f0a83f6ffcd81c9942337067f6ead74e51a014fbee64d0f08f76fa8cd9a8512c6fa5491e754978d90e6963dc7ee4aaf65c0add94a56ba90ef7c43172d01c68a2359705d3d1c35d7dd08d98d59fe60c7beef2bca8a927a0e4efbd18bd205d2f0fa0f24482f4356d6836befa40c8e09845b0a447d964604940cffda0b1d4eb0819fe7a06cf64e393df532fe603c03cd92281ae6c0c8944e32ac5f1b7dda713d56a7b0cff7a31f90df8ccc0a06d76af0daf607226d2c3330f43641d6a8bd450b9e77e5d3ac1049158aad7a3fd05c00d1bf28df90a28843b41b188499caf169f258ee2aeb97a7832e92dee498ddedc6bc94401fecef1d87d4adfbee01e5b9742b16b585a56308593ccfc116735ed13f00f0eb915ec46a84fbd9b332b03dfbda67ab50821bd6b1e6bfe0850c1cd8786a2840bcd3c895cec05d143be80ab35b9dcd7f6309cb9d5389f49fcd260da622a3c638cdca1b2095b503fbd34d4c3565169bfe8a6c62b33f0ecf125c42b582296fc4474c753c371177244741ef9327e24d1fea78def8e81dbd076faf0eda88d4d6038107236c4f41aca6bd5a82a6ed53ebe9308a2f0f9cb24b32439976858c1901931342e60df40a26aba81dba8786a09af03cb031d01c8a656d270f9e57a2f547e051be5140a17660ada1337630a141dff1fcd75f16d8c79f1ac8dee15b47049928513357db56d98c51ef7f9809d0d1aa425f461fa9526f929c0a125223a23b2dd850f9135abb79c09a0a8b5b928db32b4feaf3c52b21c9b6eb1f64f2df9d47e69f76458856ed7a4a1e54035af4ef053935e7917f0666fcb6ae863cf09981e2b10db9465716c1c5d54803cc363e6fcbed4c09f61ecfe2b4ce393c55d500c29bcc3bc3a5ba954e6165b19306355a9a27033ff405944ed50723fc609e441131f3e9b3b17fdffc86edc4b4f48e6a3d3e051cb1b4420ced84421baf3b0b8566c278929acfb582ef1a8c015ae127ac9b68c77a61c0ff65820e7667d60cc2346e55f6c179602b55c35b58aa934e7c9b79300755f8b2ec0ce3f574d26f9d8c4c46d8d5b8145893cb5d093174957f27a94de128178bf9474b0cf3cb05875fddb7ed89abfa5f3209057514a2d6a4cf6ba43edf32d5d0e2f66727bf3f157b22c359abb37465510ceb74682131439241077f6878579535938ff549de4d7635d764e15aba8519ddabbc6fb66369ddda629f8e109daf863950f2c8c2e1dbccf4b58e773466133841bcd2137a55a56453bd3d1a3d4524999757aee9a3abf23280001c25dfd8a382eb9a73819256c2124d5e0e31bcbf03150934d0181c741df852dcd5dc81be4fcfcca2c1468c3e545a3dbe4370a50e9cb2bc82c7c49e39a783cd23afb5c9efafb7789821e34503cebff546f0a5f474e3ea917789c2b84aefca5a8f9634173e3bccbc9f3ff00704a0916dc81aacebc19330bb82dfca785b1f4091518270ceb5e8802b2ceae30de4afc8ab1ba92420f399c03fe4e20def98b294749c722327d8c49a09eece35a2c2d087e7a9170fac7a2ca6d5b027bc5756308a474c9dcf837482e16f82af5faecc8ed4022e9764044e46a9aebe80d6db0f901c908b0d69538016dff72aea72a4cf4d96b208a200ce1e998a1dd5377b6013551f299bedee33531884dd38d66f0d06c29ad5958018b15e2a79c4e6c60097be496f59dbae63c799823a8ff71aed09ff0b3757cb3558e8f3e2a689c2dec005a183976fd4495b9f135d847171af87eb817104d149092894f0ee36cf2464cfae58134c3de791cc16187c1654a82a80dd91b7a898c96ee37504c73036b475e978255731cce0456d11f025ace8096ac32d57efd5bc92b00b603138ec2ece0176b88b6de74e022c746f6dab11152667f923b835d1783eda0f30290374f5b84033f33eef038cd37f0bee3ea2c0b1b773feccd7508ca1ad8008201f9ebe9bc18007649425780dc1664845ebee66595a7fb80ecf42a889402a36ddf57237c08d45b95aab5835ddade0ef22352f014c0654290ad6bce3d73898d95fa4086f8c5238dcc05d1bb1b7a4fb1ddc2e42ac259c17d9a5215ad4cf4701acb90f9b6a1050acec3631e831f7c60fcf655d326ef3b21968d3028efc4acf312d1d5d9882b4b1b221e68a9521aab7450e0aa3e1122a74d7a8748039953fc8215cf3da50430cce958ba65e3f1c711525f20503145183472598dc4c68f6b6c3fc251c896862a99c0e7b3b736f2d2f65d37613da2a9dbf2946fd8deb1570e9f08aa3fb5ec722ac6101e4722ae55b7ff67f786bdc5dc3b40c179d20698d141d5ea8832091afca1f1d6b0fd4ccbe7c8f54911d522eb1fe37e51e48b903ca0a63e6e69dc70906332fc67df6bd57c584a8c6b2318f20f9d56ae0794767406660516c2091f9485a4b433929560629d1f9b232ec430603274fbbe366f56bf2029d5fe5ee9ade191d1607e2b6696d0721dd118dd279346ad0284e40582ce46ae1f35dfdec05e09c8703553b00a03fce1c33088db0088a52e10f07f21a52aa714063ab5d05be2374ddd192cac50680e16eb148c5b99b8a4baa07a96f27a503d72ab8c79514073aa04ca90384815702155ef7f995e099dc64ad24bec027aa6016c20f8a0974eafe4595872c5343ce59476b8ad4ab7701d6e72ed10cd6fa5ce6ad15143465d626d196e8babbe058fc109cb976bf77f202b75914a886cf14ee8292107dc75c9a4779aac2477b5c5c97baa9838cc23dc07dd3595a41f69d3ac44c364462583d105c087b1a93249263d5f5e5950da7fe17cb21d0da895abd749d277190e3ef3f12dcf1efca9a4177fc4dec3d764869860775713704752bc855f832a45f119b05f9d9cf674df494fa230ad146f55d606400aab7df5517e9b02f26432fe7fd3ab94b11f9486c00058176ef8b14bb211eee54f0b77b82cfd9bb855decc8f7ddee2945657c6cb59b0a2392ad996b0988871ee599b17eea661225b8d37c0aafadc76843919956431ed0acf4dcce39e8958c8160748a4e5595c57db2482c5290ee59e06f672bde5f84219665987ba607de5d73bfd03100e1e8268f0a5547a1ed9edf6edb1373735277188ad2311f441f5933bdc872f931e46c96f82a871f89320e0fc658cb69567022e25dded2c2a2825674d92e187e30c691261eb7f2594db2eae1c40f8afac6be6e5b35690df90d4fb9a5a6823418187a4d6605639c0676d3f879faf17098afc37dd534dc780fdb174e8672469ca65817d3cfbea7b989606a6a5410dfdaa57509134ff26ce72075c24c78e46758b3e75e4cfeeb712b99b12330be6e1ae1ca2ec46ccd1f4fb1109a2d58d1159e6c2438e8ea8b1657fc0ee6495c77b266d9220786bc5b4ec87ddbe31da760ee80a5005907600897b81717e2d2059aac3dd8e4e9ef926f1d2c6b12e30a361b361ce1f8a9c4fe542dd0e440591d719b341d9b57e40de94dee381c11447cd7d9fef8f6accc2d568cb6902757911593c986aa94b1f2d883cc039428c50d80b8384ee5c13e71bb4952bdad7dfc25a3e26270e62e246c910d5a7a9284d287a6cae39e3bd406234b1eb21488e4336d878998ea0f04dbb591347c23cfd320bb089dafa7682dbc10d39c8865f79434dfc385913d83e4ee4747429a8cb1a0993711a57ecbf8303797cbd9326a3b497161f261072d31a65fdb84e52613f90083517af03e0a06d98b2949a639d2177528fae87f13ed48415903391627a4f94a94ca747425dfa423eada4f408d3341b7b816158f2af2b563bf99d7fe83788b1cd3cbe973cde59298d0e190a8b85424af24f4139b765484c651ba66687722b5527f2b04d2a30be31f5cfb2398013314ed8bd51fa006355ec60cbb55028a4206a5b4c49c346fc94e4501b1b35ca807c4ad26c6b81958ea2666c33ae1cc483c77f794a501b3d8b01085f1e169fa4eeef39c5afb541a0756e8c4195e703affe5b47f49db75dac954f57f61d95f05adafe81c03429f2615aeb530d3641d1635d16163ee087f163d3e4ec2905742ca735c45cfa9e87a893e369af471aef6b50095d9bae2177ad4aa4b029748b401787eef2690da5aaeedbcc3980d1ad224afcd788f2c7c14a480c93ddd8eb6c624a2e6417aece5b4f18a6f511d59ca1d965f689b2c77a386598272e53c6f8fcabd32f9d418ccdbe4c89aea3690fa74e9fd3310c6927383318f887c7e3f60581d32e000a669a777f24e47aaa948c99c168e483032fa060a5a64512979e481098a0a097486c3d58d8e9cba305324489c658dbb22af49d0cf06d52f198a4dfe73a6c75ffee11dba5f1948287224b26a75f6c38ceeafde6d10eca62b794afc2ff2b933a9e1f20ccebfaeaf0d2e309a9579562f10e72fb5dca58d1a7ff4d3ca8c1260df22a8e820cceb1935f5e13d3c9f277e23fd289c849071cec9d0b2fa72157c2b4ed37b887743d13abfb9d050fa1f6a00a337c5e2003171684a7c5d34e2ff0f03a07a2b29306af0b05f358e1db0809bcc5545c2225aed4b8ee8518069105d0f07fa3ef50e558ab80b9966d2ddb1515e7e32f02967d53fdd3e57ba5a4e0edfebf6e7d1866dc392de9c816db04a44915642e19a7e6685027cad23ef78e0ec439f856ce65b8ca4d1b894fdca66aba9ba9a6998838d7e6425110523bd4c496185576302dc2dd73f1e4b41f40231c29e3779176afc81cf12c0f6cbb2f134e727570179b6898ff3d29f107d2d64c0f845c36d544200beec4aec80535a81eae6d671608a806dfd71f535182a29d3e658ac0ecc3dab9a6d7b63021c27be44b8cce2fef1349403440f6ea6b60cc145e4dda91be5c5ff5ee875c44486179c47c6d21098b6999a44901efa936594998b98c16dd1e621b202bba1d60007dd450d848cb6b319f91e2f57a8856072459fb9d3f8fd71015294c3db7605102eadb39a635d1776076164b24701983fb86b30760d028e67934409eb1a8c9d84a36c1b8c66d7d156fb0f81546c867203097b1d5ac9bee975c2019479d19eca5ef4eb942ffdeb66d78b34e16172f0203056e245e10992da71099bce8dce2ca533bb45ae87b8db404bcd4d1d83110b1719cc5d8977e44c9d676bc2f14040d80ccaf81917fba98d5a7ce193c7d3b6a56f9d1aab3ffdb47c37dbd61a4ba563528fe61408edfd741cc8c751a58240e0041769c4fbfd83db4b645df4e44e9169f9ee6326cacfd2f00d97e9aa9c56540b70f8176fa3e11eb365d493849ae866f9dc3cf8bbfc7d7b0602bd92e625306451e4eea9fea1e6e588d94889b989690144d11702ef9a1fa8ebaf5b0418b58beb3c15ad6f4e30d5198d766fc9caad10d94e1a1f18040aa4211c7f7c1eb13e83a8f157f063654d1b246064cef059fceb2e26bf6a9f556dfb3e7709829a6842d051920f638f19bab35bfd5d1aee20ffff6e5ccb4321cbf1d1c28367373e20d2f4c932828c10539ea8446a6b519077449813b7c886685a579edbf75da24d7b3e2d8f6e57b11802743fe06ff4ec3fe886834d3536032331bd52e55e2ca580a6db6d6933308231883a2a19d450845e93c72a36b6cbdc94e96777fa4c14d5d52e79da7fc7ff07f109248dcc952080775b6a2f5f7a6269cfcbe352b69a35d494a07e4fc41f88d30b514f500f8da9478ab09f4daec3c8e5e39c24782a40ede65188ccb30dbdb53e340c181a879ceaceeb3f38ff5e93e2505640cff4276916774056a91d7798d73c7dad0fdc269a2dbce937291cef4352ddf69cda3c9a6c4b1ec6b910ed357a1d20a4effbc7a44153255841d6311c48c48aa15fa6d4f9a50607b4e600a6f0c0cfa1088a692141d10f65250416fe8b4f061278fc0c826000165f738c276a21b8267e02586279969027826985769d149e5a1ea5c8ee2108214f1992377f7b755447dbd558b8a9fba720beae3e2385d4cf3c76aa5b3ec597e2ca735351c3c91705f805d3119cd45fc2bca9b4488769268edab3438f3cec391ed418b3f4b6f6ab8c997434d08dbac9d3b68b6607a1c55f1f992cb3836d7921c099dd42b6328c5732fefd50415a37558484c2be31b8a07f6d0b78f47f4b2eb2371805e83f5e2313413f318405681247b8e6b0f630af79e5f58eac2453fe20e5f1d5849c9c502eb6cdd77b721cd01479e9963005e39a8d1e3da7f079aef1d21d82cf7436950417672f955c64287301a1fcfb171e2d256c9e24b3a9c9cc9a770677c1b7acfc859810d8a0a71352b7326b93910add2d8e7ff8133abe6d128db436051ce094fc5522c5063e5978dd7bf49569dc0f0b1622360fa930b0d046973f063a75c2a8127e6a2d7a8ef75fba0eb254772b0604532bdb99787806a48671de7b94414e82f64f4e5d3a4aa64383c00bae90e9b1062e274eb5ef7c253241c3e05f04f025a0acd0e378f906a759a34e104b98deed3c1832291a2ba1a1a331f831f5c6dc03fb11c466fcca3f90dfd4c228be980b992d315551e70ca122ed3bdc89201dddb353a322047803d5bfc9c636e8873f4c5e7293dc34572e92e0d3b7fc2593cb98d4667cf02cb27cae71c6db4061f26de372121cfbb611d522887d8271195eb495dc7d0879da2e7817cb522ec3aa6b83130bdbd6dfd219c2ab072735729f9005b523d5b983d49dab9b571caf3078692bd670a38ebeb61a39a8d2d9c2a6dda6e79e29d83bd70b11adfe751865903b6e2efdbfa2cec2d18d35399cd28ba5e8d6215b29cf9c67d9ea3ba5cca3c494a7d4978edc3b616291bc02db27bf94f57e9c5dadef729dacd3bea8e1409a5f936304b0a003e24458a99652c897fb96a535537f7728b3908f85eac52da028bd379b5cc60edf2c36f9872a9aabc1e0d14dc8dacd38ba7f38944edc377a215ef218bacd27e64dc1712bca5885941f3f97284673ea9dac958e2b3762cd38299da4df70008ed5fddc6924ed2b3519aa28847f7fb3f97011e41288ea094b8122beebfaebfec1ac0511adcb332b8150dadd13b48ae6a5337a24ec44a1c8e1800134a15d4bed52a92db84723f413b8d696a2a0c048c6ac7cf8b1b45f9bf5d56000ded2db5be71fddbb028fde27fb65295066271f9943dcf23dfb3da357cb2f921f7ba6a2f8ce17ad076bcf935e221cc3eea9f764ff0b71fcdb479d237bedaa549be57f76dbbce5be97d3647756dc798a3873b734c73ac19213d189f658734239c808ca0f4f5cceeec8478572f8511d1473abd72acc78148b023b07f57c893ce591b32dec307b1cc1bf15b2ae17fd9d6e817263e890a0dc4eabd27c515337efc3eeccaeb7da3e8660bc7bae776f0bd15cc54429e63dabe0ea33ea50dc213b0fea09ef957f33444f68c50e6bc3088163dca141e3a53e2e00441a424b345f5b42be87fde0796ac7ca7e9cf2332d2914e3674082c88b67ecbfe945234bc8df95c1f5c4136a00cd754af7baa575d48778c5df4f5cc988f1de9db42a320f13110295925bb24405ce4c90fc5fd339d9d6a903b59a67760840160b4d732c36471814967bfaebc09df7ed75674652f5a66adc9e2765ccea6b0ac570fb24b88ae5b64e3a91ed994bf4c17b62af712a15a1807fcf808b6a6c99e5fbc593a84e89960224155d0f71595aab010bd14fd7acd8160af78fe059a6ebd7e19507f2074dd84f021fa173c00680209b35dd4fa30b985b0a5c2d66c1cf7043a7d9e4aae5a01e48973c2b311c81074fa93110670e20eee23cc4356527e30174390ab7b5894dc205ea7e9dde82e7be72ba1808b9d3e24d03ac03b30a4d49216e28b30c6f12c1cfc8241740be9c9fb5382693f0906d91b5557e610139e4e36958ca80fbb0b6fade50b40d65fceb415c6dc1dfbf477190579f6cacf9253ba7b9addda2d6a9e46a82df715603c2ad4e8d54615d3c1713dd67bc9c65ddba1a2ce25f130e10ef396adee4ca85f6ba1b35afd0fcdf0171bbbc0b947360905c9589dfc4d72ec14024e0b1ffd5b2e0e0f3f7dc1401eedade0f60d604e0d1942c8c2d8e86a49d68e01f588710b21496ad20e7df32e523edcdacf245b29b16255f4b83a23e6a364104f486a56bd40e9b3b9b3d84ab676dd39bf3ec596f85ed6367c0ce44e054f044dc8cc134fd3d654be483b3aeb1c5d8aee774e2ee51321422a17cd32b37fe4cc0b5340e80d162d45a89cf3472f05287424c0823e6507ba20d1126c9f811fa2fdcba46bde96ecffc7dcd28ec89e045e4755d1d37a180677c2066213f8c8ebc6945f7fe8076e2a972b84fcf5dcc66e70d121d27f3e8f64f0ccec6f8ecdf109280ff150c91b68c3cde075dbcc1b784f83766a940917942bddc068c0cf95713dbc520610903829faaa451fcc5ba9a00f94b65b14364e7909849087c1435c6b938f591c21d3db6e621e6d3ca6e6aba62f54776b783f35dbebf810295021d106da2bfdb9c01586a67177241e4e848e02d516a77747947aca65fffabb6b71bc9b0aeab365c51bea2188b5e58eb7d281e324a614f3f56532472eb2e45bb3ed9bb476461e10205ba7d07dca2da7869bc9d20c05bbd90cfe960b8b3e876cdf4772194a43b246e1c238fa42496178b8ca73c8fd341974049f265eb7bf485722d76a5b8b3dc6ec502aaa8ad5adcc6230f47a2f89fc0127aae2a5e0d6deed2f980bd7dbdf0f2494e50921a19fe84cdcd9926eb075a4fd70698cf81600f790565ca4b314892b7357b6797e2605c188a0e285f6337a519e3ac2f357f10e48e62a1c578559eb8b90bbca880f45c9ce22d9649875619e4dd939655fc544e6b645b95df0d77bc6025a371398157209a22cd06067e227bb58f130bdb89ceb5d9645a1beca909eb1d6a1cde1183a4d48130772029285c23f5c43b2f87d432a2fe491e4965ccd136105b7345291e4f5c0e3ae872362129670fadcb60fab065aab04481e69d02a84c9129f2adde468ce96a3036bf4d72bcd88e937d5967f8ef7b1d6b3b68fcccb236475d68212dea797b9e458dc7fa2775509fc3385c2031586ac8e939574d91d961478af79bfd82c2ec97a892e42ac6199d74bb46531846fe2f42f94753a40b4ce6021fdddca589c7e87aa6a2ad2d597197c0833ed378ce73ea66cbaa36d9948cbf565f6a249031dd4510ad194d126c303a8c0f0d942e30abd43c3ddfb31b592ceef246623d4630154b2442211a886189441ffc3905135951cf964d975451dd6340db462069c0f95894f97c3946f36f9300d6388ef6e14926985d118740b39d25de947790bccdfe30d7e9eb1956a9e10383a83ea9f9aa8bf029162b9382fb49058afb17eecf22e3843935346cea35160c55c13e3b5668ab30feeb1a988f29bd12d149883e44a73616b991f5af0cbc7c51a6bf5ab1aa95df1dffd2a4313389be49d403b2357c1d0676d5c25e9747b1a1744b864c00ea3dd5d6c603d683c154040aa1c7895f074512bf1e9eeceeec55dd1f5933358ae941cc2f722e6cfc925faa02dd77d8f77ae47bae5648b9bcdc641ff50be6c792deeb5e4a70afa5ee381e61df3a04963b8b504b5543e79cc629552e0efe052c9114e32742a87fa0fdc3a577069eb2d6c5f0b811eb5054bf1d2b42b1494e337af3e581ea38f49a29a94491a88afedf0e1228b34977f0dde41580d05862f3628a33e0a68b30b48362b746be3ae56c10747951db0122c85438fa251e66905a92667f88730efa95b0b1c8f0116e26186aefa7211c46e87726f3601e4238d2a7e0eb0cba1ea3c49ccdcf56776ebf21a02d0aa81f880c0e009ea3030d96bdc0ca3ff48a81aa44e85e58d460595ad719ce63b1ffc611236e8e2b282d2358c9ac99ab60463e31a98476a3870aaf91b3b2e6fe93007d3e865302abdf98e5d3466b49e5dabf8488d5ef7ffb635dc0eb313764ab62fd194e5284f72351c068920754ceb574ca667150d7dd3318a8de6b6e28001a8d4bc48bb9226022ef74267cfc444bd452416ac0432fc69d811c4a755c712d870045288f5676a51dc92de7c06a9684ee2bacf70dc2d07c8b861751a203a9e08422a7fca687fdf66caf4ca4021a0b7d230d501bcc79cb4c2338c2352ccfc8403d8fcb79dbd1412eea9e3dec4b3cedf6a3b9ddf4a793fe54a739798179e13cc62789506f28c08b83182115ade5d730e04e423d732b3eacf0220e709975f9c69a480f167b8669fe314efdc0695701cfdffe19861d390b2e83a78c0e7ea6dc1a18a78ce22bc63682149fd879d07e910734112e3938304c993c48faf3e2efb24c55764d6cd90bd9b6ef104acf2d12a5f7075128784fdbc99559598d8cd2ff23f7d12a8644705d64cd9669d453fdbb7bf6fb2754de5d3d9234cc1eb3e37c506d3dd37dfbff7bcc9c092e487167c29ff9d98c7afa503b41fe8065735de54873fb791212e108435f3d9ef82a47612a6de21f9e9bde95ead62a79a4f2101e69d054e25490434e30380082b90381d0aa8ae21d0efc32fde66c1de4e8e3fe46d0ca77d47492dfc69457372032c21105407ad1aec6446f82790950e718439985f3efe9d74c5955a287cfd02f6e8495713c71645007a1210db5e033e9875d0e02320173462011213ee289cc63096296167a683707a90da614b2034c0ff132d5d50bdde0d96f89ad29d17600459ed227180e89e122a154d63adf5ec325370d52a1e182d9c54cdefe1ae7b75d403139b1c131a80f8430a583aa4bc5d8298c2ba699cd93b3f23f2f1adbea2cb13798522789018a15cb4ed493c10cf6d2e2f038a7a7e852e4e47f1bd874d4a11c3679d8e09f066c8af99de5cda244d2877be78b0220d8915edf09b8824f8e6e71d78447f9296e89494b8598f57e0f365807dd7c4edbd197ccc8af479d890619b5a51064f16e286415b5bfdf591df42092e1ef0966df02b8121b07f4eec5506ac70c1292bc833d6e6b57ec35453968c3d63cb55243e56f7865c41b61ef56236f41283325e3f9854286077958806485228ddad8d0f3278679c8ad408eaaa81103960895535026f3fe2184c2d8d5784dd1aed5e257a2c2c3547757c4fb1052389d568522182497d8d571d25c4af37caa4382ef6aec2610d73f66fa2c448bf7d601e25399803249e2dcf86f35d5f8d8e55678a4b9fbfe69fb9e3750fda61e71847e21f099fa01a02e9cb3c43c503b555782e65e36eff9b371af11b7b62607cd27a036fe3dd021ead6358aa6ad5bfcb433346d46eae35d2039642b9ce0c52785cfc7ace80fcb265b99aa97976a3a57436afa448eea4f0fe79bc7400c0d4d7fa386632b33876ed6d804573036634d94efebd33e6498ee4f4b1a85aa155ca501061f0df3d7b877b0f24efb14e694723f920ba3c7a1320b6c2bfd9c3d22b735b0de497127a1680c81f8d97d747a746e8fa36118b881ce5749bc976520a7c7d7cbdb6f656760215701736efcc41388d3fb52c6b6737c2c8b3eb24a54db22bc5601e17feef2c203a387a68bc814dfdf01c96d0579b738edf616e717ff3421b43746e6373eb92759e80777ac52880495f7314d9f690c8fe6d3b3840396df37727660ea95a3f429723cded6085fba321d670668a6a9d6db57892c742ead2c35a01993ab36ea75285a078240fb17c9d7df3232fa4f0b6192987be28fb6cb199137ffa0294fb6563de2f0f1bf9e2aa11a1a8c1fa4c46afcb9d658ac589067dc33f4a53e047a9d220da31ac8409f3b2978acd3bcb61bcbf93ef7428a52a1359db27d5a3c2e0a205d7a21f2a71fb6d60a44b82c0861849ab7eab1186e24a740440bac7a89abcf898096dac182db245e6d8ba59a6e456a6632a590a1d760a762525b3abdd9b3328e2edc007b7b399b084134eff9ba0441aaba82d0c194f1963cd5fceadce24cfb18cfacc28b7f6119c0bc72a21f246548bbb7d2dadc817cdee2dd6280de734b8cf670ef23f54de7802ddd5e5b913ab194d41e7d4aa7596fbfc2424cf089c4d0dd119df4749350fa1db3ac8264f3039e01c410f58985feabf7927e1770da92f15cc1a5fccde9af21ca5258824182664c1db9a9857efd51488dbc630a2e5153ac1f23cdc7b26d5e75d699c62de231697878b06a51ef889b5eacbcc6d67d89c8ee9c5a95b944a7d21ca6e91a424ab231562e3de901bb0923f0527fd780b5f770974c56b86b8920e3944bae30e0b61c3ea06f82fac82122fbc023743f33bb388c038c1ef2bdd776aaedb9416e18afb05c83e321a4d1fe9e9ec66e42385b44e77605f93edcca46480a05dbc64de226fc5fdf2a23cc6b891e11489589416f4d486f238d71b064762251760ebbaa1d5aaed526d04ca37a4e764d9f79b563ba46656bf7316bd17c56df794ce0aabb8b8cf76d87a7fa71f086b30d4faf2a93b0e689f762b49810a631fd4e4abd7855d6120683ef338901a9745bd9d14ed780725512f5e26a7c442ed71d33019813ccd5cf7542fb83cb405814bf237e3f4e51e45c9ba182c0eeb7db78119d52c394010ae29e4276c7fcb4146f153adcb58a11495785203956691530c8c5416c3b2b4811e769e6b74e62f33aa39dc60d19efb24c3362644f8305f6d7fb362c70c1a02341bf8754eb9691b3e09e1a0872f9647e4e168b6fd38c70374452f40ba3a3677620283be73911c7c036733c01d2b512ebf5706036fe8b68bb0fad1075c51c0ac2da5012296ee9c3fe8dbd01282883ef3efaa5d6b499bd040c9e400fe8ca67ad75baba5547cfe4e218b0132ed5df632d48e6af722da56b25e10ed3b426399181030db2b0f85a3681690a75f7b20505eb9617d68d6d34d131ae5be2e4aec41f801942b0ac9fad0aef3a6c3ae1bd14d05704a2a004b98b35e62f49ffe2a691b8a9e9d31dd4a91c6023c274a1679f7de20a7a1feb583c4d5c44c7f76612fec568038860353b1a40b2fffe058bfc521f0007be37a2c28a3ff036fc85f162899ef78f2e1555b5094bb700a0233cb55e30512dbdb317b5fa6a4e656fb7723d52a9aeba501b0a7b43f73c19b85d0b6f2adee6063392e73460b6a3cad89612bbc28eab46fe7a4c58577241ec8626f810a3c4bfe781658fb341123a70a72642012658a0426769eff1225ab7b136e0fcbd46b6a9379443c92cfec69456e597ab5fdbe6308a2c05e1eaf97f03f3f025e3fe2dd2cb861cf28f8360b434d5370ae88e7a0880731d00d2677b03f3350408697d5efd67e252bb058491e19c7115c123547738e0b0bba148fd1ee3317cfe61f3751a11e509ba8d72c5aae9d17c826d8d75424dda1ba453fb6e0ca3036c01f8d835ea631bbbe456614f67643d6f56b29c410eb29b933a0e4040d4f2e78b97446014711b6e2651e0592a362a28b248bc4a26a6661b279f65761afe98a858baea4f513d4504e61a7e46f257d3fe90e4ca8d60bd631323e8ab1f375d2576e84a0c7e6c7dff3e41dd4fc8cd0644001d97dda6e71938fcc831ef8990dab12bd7e06e5387c4db18cd06a35595f91a79b0e1be316a00e9f5e9f05850d080996f66c849241c4b0778b4386232c5ee80e490c5f6bfe16fea724bced38025627ba6c4487c778d7ff760c4948e46f90bde742419ab43daf722b979724260127ef1edff15619f8868c96067d2dbcc563448c7fbbb6c6e2b9b21d1705cbbee5987d330d6b320ce1ac128b6f15b8017d9d7867d679853dd4f4be4531f5bb62816d7fe3334abee0469a99cee630e6565b220c70ffd76b3cb0e5e5923402f40c9589ba994952c7b3b05e9bea66ef4fc3bd7140ad93ce8abdf3875db50707d3949b5585cc5ab398b4640b7e39d4244bc3360e4a75552fc2c41acc0a3c88f72ab903285c3a6687f82da1df0cc624934fe37260176883086c2fa1e28ab5b7254fcd14e5e176cb5ce91e1c6b810c505767e0290bb30bd5379fda63d6a3c9f82da8ff7dced507e2d68213219ccd8988ba7e5835c96aa4c2a653ddf335e5a1c1a3438c2a6a5bda23ec5db0d2ce9068063e6236969a2f434d9b1601f30ccfde9f5acaf20654ddf935568a18fbbfe265edc0b1a5f6f6b143dbae7a69773d05d742bafd69c46588462597483528313b08dc9cc1c7479a0039f2179a7c9767a14389129461f2c6e34db2d018f954eb5bf3b5a420dfaa17f636050ab25d5de776aeb77c84b600cde6b84608e442ed9a48ab045014b4eda12529346ba8a06e388e6268b4a1a75986a183f5a604b7d189a7cf3b082a060b98dfb037838651c2594af0e54e6459bde54c906ff0d4bb766e96cbe5b4597bc93a8b8fbbc4c80a8cdcf5d8df3efc5bb1006e168f084d42854a48684453a78db0af66f3e6f7d4232a0b87243e3ef3166c201664b68cbbf82a883c35bb612bb5df44f429812616c6e9c422b322d07aab4502d078a97cf782ed24716e4d35def998efef26b63cc4838ca435aec9c31ed34dc7949c2a7fd98d0d2f1176a18631bdf0369e9253c171816ffde19b865a8002eea96485875eb5a3759ce5f973ec64f49045fa7ea3445835925036b524fa3227a79e28f1d988680dffe0acb41c3ea040487930a9cf160c5d37d3439e48bd666020204b3a26e0d72957bc72c696a51320523d3762ad49e155296018824f2f0b9be2fe42c3ce2e40ffa9c7ee132b7a4b92ccafbf59ace99765c26fa24245a64c5021e00614b02972e2d65a365efa4bf9ea411e9a11bdbd463f0e274da74f864ddbc16fad2a4bc5df42ac35b332638522520f57f39b7d3dbf168e9124ddc20e79dc51cc2a40aae51066711f616c11994bc154a3410e87ffc462cbb6a4524a7c629ce177fe23e42fc70a92eedf2fa4ce33e94608c61d5cf6c6613e60452bbb6b0911c07b9026f60c4179280d646b4f369dd6deb9421773928aa3359f3a2a3c7fa663db4f9c46137136d8a17f73aa09668f1c881c6e92feceaf8788afc4f7850a4a85ff449925d66f00c56933553efc3c51e10d14e1f34c3b45a0298e0ebd9bf16a613e6ebb32b9767810d4ecc3e02cc4d7b32362c74b02b63b165952dc7c796643ce216c933d9c31a26559fa6ecdc6e4258b420044da7831164d9d6ef9f3e504c8ce0fa34e869a2c04b15caae5ecefbfa4cb1fb4a375322d66fa703d7d0772aa11b262337380c5b36551fb55c6cb82eb500bc1d381ad7948fe25348d5f72113ac4c37995a182a3b838d75e2c0432837594cb760c72284a75eebd39e0d097780f722884389e86ca54236d15896820e3ecc33d45f1dd9d04d0960638581a9b002e30352ef186494a2089275ff3560bb92741bd5c31cb03187bb995c25991c29a4902ff5c053e9d7a74a06e3853731586cace7ed0bb7d3267c86ddbfdfb2caacf41eeb94d7e1b73ed04546e8bb669f5045591fe8c751446be2dfb877f23237df7d84bf0eba065e81a230118c9a8213bcb7f9f97c64c216117bac740fab55ce1b87c0244dbab7ce454ce9fc3a554aefe51d7d3c3c086bd919e99bbe2c37c0968a21e9ca7e709865c26acb82a5b2d3d2e4b96c5189b327f0ba0e6b154764cdfb2a4d25e38c9764bb30499dfe8a7d5a5df00b556cad0e302d0eeac4f1e28d41e0621bae52817eaa8b7cf1fdba1ede07396de6991ae2ddfeb8f65d9f3a9bb948b29457e397aaf9885c3f1d7f898d13319a429d4f0f6b1b74251ee9b943196b25079fa8f20c4c969625103b23f8b9896829e6084cf277c78a816b51fb3ddbe84ee895d50ddbf82de425fa69947f2f55619f1a6b7753bbf25c5f5074d938b26f8f9ad8caed669419a16b88cc80620e97f24e432e41eb313b09e1ef1c416d0fa24986e99e74dbca390c82b903558192817bc1bee5e3144d85962706f47f9c273be4691bdbd3847c0980f7f324d4930e36e1140ef1eb08683b2d8ba8a6eb3a1b3874335a0e8eeab0837d7fc5de8acc9729ded2fa64698e741f0abbb0cda9b6104de0a985bee930b796779c2d3fb7a83489c087203cd2780ccb0cb89091c1ac3d3b3094db041ab5b8e8a3ff4df26653377840daa1c1130d2239b8ed4bf65849783d77d1046699e5ce574faae91ce961d122421f92e3cf254ce5d92ab2f2fd8f31a7a01c1cc58041cae08794a9ffb866e2759f09e965c13b84e31994d3815e9365ca83793f9294d8dcecddcf4f9f1cdb3ae9ac7dc001eb665e3b71a0f9ec57fecf9e65c5849197c6d29331b0a17110b41d3481806a125eaa975891c5f1e585cedef001b5387db5680cebe539fc6c7d098234fb23f75bfab44279826f8696332e9e8faa4b8082b8f6e90ca44339298f1aa6ce614abee3713350e083875266f65205bbf10b1afc4c5a28e735a03ebc5a227999a05d947fc95a7346bb01b9a2188350b803313798b8a1e470d4df2798c005f73bb8199be397d4be0b71ebaf9d662ed03a18311add673108b4a42dd147a1775910cfb46c080d20df28975d398c99416272971c58eb331091bab5573c5073c0026d71ebf46c504319f94fcd97945946e40cf55c1eb67906721a71fb59bf3830cfeaa0900fde054539695fd031d607283cc2b92e76fa7c5de02c95103016214e1acd825c3e693654f44a52b8616a1e2b5ff8f1e8c673aabfbfb0cf74230b9db69eefb6073b936fdae9db7fb7fa6871c6f6512ec1e9c5967b86cbd769099726ad06f1b547eaf53526a414012835eb198075c68eb481e3e716438e70d58d9e277330f17855c3003d49f96495c637ef7d4e7a8cccd3bfa8a632b899ee98b28d34ac1d8885f82903307f2ad91d92b239b0abe88170cb4f4b9ddbba844e4a3ee793365925dc34ba1e4739f2d3804b58bd9170cc8cb4687f4d3905546816342b89b11677af24010cfd3b4f3c4f6f3732367467d79c69fa9f45497a7f79eee7ee3ec37f3c663b17062a95eeb9a08d34d11fda88855bb11dc0cdfb3974bc9065be5351a4a2f9f3e35f4210cc7d70946436cac39d91a8e3e58d1ef9c7cf051995852d43bf4b7bceb7e94307d92af10c8baf9299297333906c1ebf0fe250bd791694f3e8ba5075e12398f1067ee1e2bdc63e6bb02f214f092de76219058fd2a70ba2fb01385697953d107be19b8b259b68016724e401034e3af5a0d11e2b3ed5a566e3823ddbe7dddc3cc406b07b6cf44605f7963ead748acd63502fe4efbcf4981ad61f536417d7e355ace2394fe1bf709062afa74261fbe0e28da1cea258bf02abbdff07423ce7a892a6222bf3bf1183c9e7d305603f9e79547727922352c10922c4c748e4f4125e490e58a52d5a2a278ec60551ed0e0193130278f0cbdaabc4235e7e890726d46955f4d5a4911ce51bb1ab49d16094d0c25a8228c28c37a7e3a504882fd6d65aaaf834aa699e0d952d59c906796597f189ec87c004103f43ce0166f295c7daf9659e742900c71a3e650a061960d8e1ad1741031965876e3759aa0e880a3f5eab3af63cac95fe43a86326d87adb760af523627854f8b00926f11c6cb3ed439f4fbb26c604ca6a2764e47496a993b9561a1cbb809ee39cb60e73f6f87986089cb2a98a28c2e9f17891d540942492de9097da3190a39bf666df9ac6996129c8be9112cda310e2842d6b0e979df45b57c1b86b5e32a8e5bc6693494d6600743ce4fdbb715fab512e6c96ab3b5ab8296fb7fcb8ce2ddf76ff7192b781a666f9f4bec58eae6d2d0af16f10e1528c29bb3575b5db7f42c4ee3863b2df84055935880327bb02712221f298961f731714ba29d89da3853cbacff67359ef4f2c425deee5b92fbd42edbb4b138a35ff6bc0a0f4674106fcb3715fc10b6ea92ceed4a56bc6b4e40eb4339c4e7891bc07cade6a03799c42910e45b4a71f954ce874045b928f51ffd3ac606731a8938bcd8e703d022501dd6ce9f6fd62c2d7fe136efaed5b35c8b70b97a3eba2ec7cd731b4c7a2149a02a9af163923f0abe8e1a2cf6209d812d509c5a2b62365a39f88cbc7a7e59ea3c818e33ddfd42737b72b32f50b4d4938b52945d8db332a906c1433407c622f6025101591bcd9b0936d024349635befafbf7f04b7ab5322809a277f5c4ac6f2ae75f97c1fb9d8892a0f9c32ffd41e5fd84e20604320d7e8e4f080b89ad85cc1d9f762f74c9d984887a3324a4d36e3473aecd9dce507d3856c715e36afb50f36d86535b83ef3ca8103d2902eed1afd034efb01a8a0e528119d4c59bb1733cd3dd9ace601f63c546e4bb5929d4cfd9b889a45cf413f8f24aedccac885d75ca04ee6b510b177108ffe80acf76ebc342e939acad4e01a16a4157acef88808d13469930329327a3695896524533098eafee73a2329d46e7eb1ba6423ee89f0bc397a9aec23b4903be6bb6e764c9fc40716468cbdc6bbc7b77ea00da286305cf90ab0976c0dc8d49223ab71328518e7f32c21fecaef859c5893395678f495342d6b40b2e8e34e648440280dc83d8063992df30742236faef1129bdcd717336cf54f762a00783d414f5011c90f01dde6282cc69678545902ff1684a099bcba9363e5e7edeca112f57cfc318f5ceb6c5afa259ae986eade044b2d07ebfc51f16c4c3a500ad2803d59a886c4621aaf9f681e2a16927ee358980bdbd1244da42dd5cc4ec56375a6f7a16c5f36a5dc228f06fec4dd127dd049375b2dd3437937cc50d08305c2ce534190bb894f62188c64511350f51f7eab23cbe3ce695389bd1dcf0025b5ce9c874b19479b5cfa6e41249563ea0d3538aa9597e0d7d97627a3e0b56f0ab3910c8f1ae4ccfa76c62586b7f0c576b3927beeb963849d1f3a03c4d1775e674e5252b66fed40644677ea8d3cfbb2cd99fb8187fc94cdc4668c3bbb99ee1b44250957201c9ec834d006bd810f1fd5a1370a33e3644c398011fd605b90dfbed0260d17daf85eb60a10a29521c5af4bfb6e44dcca7a31c80b8121a0dd28effe02af7ebb64c3fcd77b3609804c080fbe8a2e52b1a46711b5400972c75a5252fd0418d35fa5c97a48c1d03417bb61ed9f9c6e72387893fa8417643c4b92bafda65de8b8a2acce818d6320305c678465536167f5a8e5234f6c9d554f36a4a2ccb0c1f7e8d93f93c4b700121eb3dbbe34a9f27ae0a781f1e65d78c6c342b538a8f1826ba9e80787520ec926dff03d402f9e09abd2264e8f8b5ac52b462497bb9b97dca67252e312e7b67140d212ba9c32c5f1de0e0baacd66db7e021ea992a3abab9b218702bc4948c8ce207a7a64b0392122f43568394cd5dbb56d709d23a5b6a96c593532051c2fd20e7b46e696c2fceae0aed976264238134cf10de06a1933fdfa138afcd6a9e66c2393287b6eff3edfe93ef3745cd859e2ebbe10eb4cf0534b5ed273a34d1898a8f1732d83ffc2829f586c8975d38cf6a37b6df410c6c47df6c7f6ed7869699a94be216da0f40e8d80399f90ab95c9c312a69147252cd2b014f679bd47314ec8a5b820dc29cd8cf6028bf7bf697fd4059c07e6185341e837f8b34aab8f2dae3d8a757fc81bec1507bb2379e4caca9f7f9c18c64e97b35a994e015606fcf261588e8cabb6d4c42cd9aa517e1b66f581648cadecd98483e85dd53e99ec43f42451bd27621803140d4f866aec2c3ef491149a8feab761bd50ccbb2b6f2632142c98f93e01d5cf60b4da9b324619b8102cc56a67e6744fc9175e8f99e64b944944fd6c8b687421a97e6fa667103cfbd912001fc8242e8f3786460fe36f87961f7f3897a6e062e3b825d6117a1cfb712d70be17f1c22919edd0e1e4f205ef130d69dc07de34f0b0646ff62a6eca06825fc298ae2a6cfd10b1bba7b72e4fae7bfc46d177fd115e34dcb0ddec053f464a6807ab560008f2b732b536650acb2ebbdc298680ed3696d8d7bf7cdec74524410455f3280197e4fa15611017147b5f44c2606e622133e6eaa3516653b030191017148e96c4833b2c990c06f03969f19e76697f68985e315bcec7c984d1f57d5a09841678c0fec057d119b00e9db4a02f6e12594d68e22aa3f7219c7d5e2b50052efef5f2899654dea03ba612d405543188ce77c9ce46ef911f2fd9bece9864e499c2c1d6b8d7215dab1d058a87d1b7b245d4aa27f49757109e537f12c6b0e0543e5aaa02233df75741e0a9ee4742d92671a23f3bd4559cf711dfb19a44c6a2877f54caffa3b4fc647d98115274a2889d9df38dbb664587be5102bb4edaf6e696a8304654fae28af39fe2d7e7cab32399365436a8f230d395ac60cfdb779b2a59b0c8d84dff58d6b77a83ebde5631d8b4969aa25ec4b0fb2b0f87a95bbf10454bfbd9caf29814022abb30afcc213f22bcfb5aacfc46eb0f78c40228dac313223c9d4eafa75f53f9b0591c8f7a34a6d95ceedfac66c0c9932039f2650c12065e638739fd20543e02d64b7e79120806787afe28604dcb4ef79740bd1ecdcd0e694dfc629b3d2ec30256cd0b11f0a87ad18bf085cf565531701c58665b9c94a2f06f7324e7699751a06bdaa974361025b86477fa2d5c6c45a302330126cffaf7d0a40c5cbda47ede3bd05bbf2ab542a68bd681eea2d22611feb7fc74e60435e7f052873206c130b1e0fbed0ad75c1bf6e25ed98a9f5f2e15ac6bbc98cfe6c00af3565841d8c605cab2e90e7eaaff679acf81d5adde2da802381d2a52adc20b901639b5ae5af0861b6d39fec056524e02bd256f74493e3378ecba62d2c38326c65ab4e51b00acd00625fcd94d26be5276c6e0dc4d367d7385c2e9da40b97c21ee1f0a10242fcaf92bd6c1505e6f97126caf3a59ca1ac01fab102f130185f8e6819acdb86a5d3fabfd67aedee3a926a3cdf56d5b01f31abb4afce15c23cc669630f69d6ce756e45c801dfa50466711e2f0ee58588b493ac4675fe292edb0493b16fdf68915186dc20556d39f5901d80cee4f093c74aca137c0922b66981f4d816cccdfb2bc186f396d879fc6f294684b23b35c6da84d575b3e3655c97971db0dd98c2fff322c98f1d05e947f6769e632873cbe2f47868488b03edaf400be5fd9cb5c27e95b84edf2e50d94e7d50b1703cdf61383dbe94138eaa5cca5f94ec91e8d2a67efa4065b58c34b7b01d5af245b57f49844a3bbda8ba1977b83c4c412df7ab1f19263374a38da0417c44295499be2af2b17ac6ae963f02e5b801ac9ae96c3ca5fc2c717deb700cf823d37401d8176ca8bbd7c8fe1c6934657de860e8d3d1c505533ae2fa9cbb5f54fd2b86bd215e543646908c5eff4267ec9f756f15fcb93fb0f3be29356ada61bb2cbeb463f2a81bde33880d2094ff5122127db6e2e563cb30347e5618c90e85fac6acc418c4db44f560e170bd847644f65cc053d6f3b6e1652cd212a066aecdcdb4faf166a3b20d3f7bdaf83c782d4f94780543ddb501cbfbd00433dbc55c8b630d3ed2ddab172993b52717ca9ab95c164e4729132a7ae487083f3dff7e5e74af59031a297135b96eeae193fba5502d537bebac91f4e65b788b836b9e0f02eac1cc82b3580a4785e1cf164ad012d9bcf0c6670e692bd37d39f78a8c5dda76a9585cd5867c7052144dddf7cd9f8a0b02f259d60ecfe5cd8c9697c29c153da5f13325ffb3edaab9ed8529c84bf80c5e409a45bb3ff9658b399608003d6a062a2933da0457094407b6b52aeb98e60ef15461302b83ee5ba354154281a73c268ae2e146ce8496792bf10068f7668a0342067c82a63474324bc9c9285a04d635955733c8eeda40642df42489ba7f1b5da23897a3277dbf377ebcef4b855773b176c795512a8e95239c8d617a178fecfb6cef56bd9e409353855fc9942edae2cbe6090f7a755d83d89d9bebbadf388d4ac0eb505086aafe427074d136a42803edabd082b53a9213b713583f106788840d4c46b7fb6d78cf086d0032366eebbdccb1de334228e3edbf90c810812300ecbaa54345568bccfcef9d291f20b227a6a1b05e87b43d7a55f903060fe8534d12eee3c04b23bf341518aaf2c6ce863c6bfd34aaf48968887a4b00e65d7bfb7ef29946fb28fd8a90404e35e6f85ebf9cf6c5bb8b7ddf899a8a9e28153ac63c67b2b00922aff6bc2006729995995958dad949e97e09df50088a9e98a51bccc2541ba18dedd043101c8ca7e2dea7c038a4f10d443957d25c6847f16be3b2ee58dfffffcdb76032334a096cb5a468743eda394a5c4b00c122f5ce4f0784bcf3f684fbe1eaf847d1cd4e7449d00949adf1b292bc6d71817ba9bad9b334b38f3aec1f0a2714b3271229240cb47bd73d7aa2634992c48e95223c3c711e8c9e8e6ff49ae5e5c27f2b58330d5f17cff988e512dabd64f0865e0c9422d2de2b2489202249acd7a6210d143ffc9a0c005b7db352161616668220a7aac817013612abee5481fb9be550842705066b7eca6b3c6e52892d53fe0d80468e250beca431a691d7ea1dbea36c5ca9889dc2d5cb584731f38c2214d40b7d527cd7627aef4944f7cdd77cdba134a3f4af4262ca2ea3aa33c30b04cb0ad67bd979b911b91539a73482bb838edc8131526220cd49007de93dc603f86f1c14019ff8339f88571aea7e23a5155ea6e802b534c4225a25e23412219a0d1857d171b382390e7dfe069baeaaaa11f45d10ece51a68967905aad40b14d011a8ed7eb8fecf6d7fe5621673fb8bc062c14a10b161cebf8f5a10222bc3fc7b3dc79b66c5e14fc5951ba0525ac83dd49eab76d8ab3fe81de6880b9f63d9673d06c0e4384d1b1e4eb51bdecd6f2d5ccdc7040f9acd500f8e4ff4f385078f8b0ece54d24920d9c94f5c09f593d6dba4ffdd16f73f8fa4076b217d11a9368edc2745068e5be674846500df682f6a2a99b09f2ed6b9bbdab3971ec8a9828b2b31c428096b488771cae5fda32b167e93438be3b807c50e5792a4b4bcaa0ee7688eeae0eda7f91fef9d1b05c51d0bf9c5c1cdb40f2eac90bb3ebf1a95929451db02b619cd2bfecb0853569f6e8318cceb4c291b572b5d17e3f3f9a218d89b01f4da5a28b5e0103446edc36af56dea84457d5399988377dba90a891b7a486023393c85115d09d4a52356d6a42cc64989ca758c239d65634273800ef6ff69dc0259e3682502708f4852f412d4533b62</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Vue </category>
          
          <category> vue2.x源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Step.13 你真的了解v-model的语法糖了吗</title>
      <link href="/computer-science/vueyuanma/dosc/13%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3v-model%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96%E4%BA%86%E5%90%97/"/>
      <url>/computer-science/vueyuanma/dosc/13%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3v-model%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96%E4%BA%86%E5%90%97/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="64d3a45e518d925e41789153fc004f9c430b4538848877cc00f379524536a5fb">5808c6cbf3ac08533f2dffaad5e129c1f7677efb1b6b29d5c2835e6dc776058606f3befafcdef6c24af8702fb88665b4a6c154a80125da8f92faab724b4a5c69e855b83f3fd335b4e2baf272d28e128b89fb1ead253ac8cd6c54c002f67f4b09e8a52cc333eff27c898f04fd41b6bca2d4e9438c09d8b51929f4da9362907db38f7002a55aa2f6b79a34e6c9504c6c7141e5625ddfe8f897ad79ed4bb7bb6cd156c1534eac22ecc44abb3c7ee0f5f8747d5dc3048754d2b963581e5195e577856294456777a3e36f51acfb1773bd8336049d254bb7b7b07502b2fdb65a2c362481df89b07533f5c706dd585ab4e3803a397401d2d7ac5284de8121772802195dfc38f345c4ca7b229b3a58654a9579f1dff322dec83bc0329d2771830f1b12f63b04e152d31bbdf2b0a9cbc5f3fde63dc733d4375126f3abc7949f24cb885292cb553a1aff84216d0876f043674d74408a80e3dcc394de933ce775937e99fd004f1dfec487b4b501b270b6c93571103141204e054c62fe6d5e1999b3e62e7040d9d63e48a5bbb693b8f5485d8631a19b59266f4c02c0e3cf0a99fb1c93a0dc38cb758939b007138c790185f8bb95806c41cfa35dff128a7365d8358fd6f7523c506fa87ad6dc5a582956ca3d00a5c1a64a9850fa6eba3d791a274c0cb9115f94dd0f46ab8c2179c9b06a7429080f1d8e2ecfedc7164eb0d1715a9b0f3de6c685673c8f3502ca50ff1bab395de770b4f71cc40902dbf26d18f227192499306076769e84cee5028bcebab8da7dfada974238ab66a59c8e2975dd31c0f24279c79a8b895bebb67d3e9459b029bf8190bcb50c19df69bb2cfc57d83a68a4fd8cf582e5dcd6476da910d52c0b9786e0eb842287de6b79d4686d58fc69a9219b50a8bea2ca28578bdcab742b4ab027cdde334044091d4a2f83a215b90cb93d63272234caa2e2d809c3e821d155327a961792ab0ce14bb2571c84b38f6a05787ddb0994117ffd4eed120478d51db8ad00900973c85def94e87bcee03f9bb4a60f63eceeeacc03dcaac99461c3cf315db68916eb6f55ca549e3d4cb377f4304c5786f92c15c18a898a04c92ac13829eed510dbb70685db4a221160fb8caabd5d600a3727aaa2aca1f7689ca0132ce5a1b6ff54f9f4f9af0f7a42c8ed7d14fd8fc5e4285bfeb2388994f7be98e600b0bf658493a299d1cbef5bcd99f3aa09d1c5db7e08b1b997a388e00e4ebe9871c4a35bbca4e0de548c497fd741148fcde95deaa694cec7eba80d97c1d6e93f1a774ce09a28544881e1e55b4fdce5f8de85753974637250d3425d09e0eb96e8155b612af7546e29eaee46ae7b0b2ee3fc49367bef2536f4ee494e944e4eab7d7b0df11ce8ebdf766bc00bb0e4853f20b0a78cee76ac9d4d4c808468e707e9a1b98e45756386ebf2cddc389a8db6e1da1c22e542f01298e2f8737a97129f12b61cfcb4e4f5d3036fded593d27adf9bb93e3b8a745cd0c61be904103b67eb9fa1034105684d36d4e7aae52e134b3d96b6dcf60dd676353f0e0b79b1b53cf72b56c33ef1afbee0b922f37b21d939004754e357e4824534206c2817320806e1820e5a2539b764a326ad2d7f9a48de29a3d3602b9ea92fa0e0bc19bfbbac8057bac63e2482a130b1b96ef525b9568a2f8bc328e9d4c291b0d15bac4546543570dd662463225a064c35359072171b169e1c4df5e0373b9b45ae3f83fa491aadc1338b1f0f7e3ad61a0ae5de00c67e3dfdd397b115b40dc5b1011d2920c48da6af06fba4c9cddf2f701b20f1513e4c907d6a907a69ca69d98dc97fe54daa66fcc4103f68d089c98412ff463c836e2b8dbcdb82cedaf710c37166597fb08188dc1af175862a7bd340f78ac336d0a5c185a864eac74a50048315f47fcf70cb70566c2e2ca414549bf15311880d9959f03c217dc8ec6cf5352a4fbf8aeacafc0e71014f3841a2de8d86b232b047c6f45c5fb117c2ad550347e3871fe941c8cd75a7fdb07e77a56f43f798f0a128846c91b0e25f8aaf94583f8c08c7f7fa6f9ca8a268a9e885e127247bf74b2f6f5e8b1d394a2b281f180b7ddecaea8eeb6d88c175aa5543f9aca58b29b3bc8dbc39dddc2b333097fa0a66ace5fb501cae31ce7789f773d4a24997fe5ca6e3424cb955ac9d4830ce9aedf1e102069afc4720db27a421193bcbef09f5968dd1fb939bfef1876f949043fd196fbe63f6de902e02a48fa5d2ff40ad63ffc54f84ce813191fe840f4f7ea1edfba3a4ec8dcd1e4d7b2b0c6d384a85ac40dcceb2a64407f6e8257c1ea08cbbd9a3fe19f2adb3ff2897224ac432fcd07811ba13e32b506657b92ae62e717e2f3390eaf6f0435ee710cdb610cb9c8039c927c9c0b431d4c77979f570477b334fa6c52dac57138833fcfcafa015369b8810179669af94ab7c8c349df48485e230d06ee544a60c9a8ddd70d3a01f17fd00f56b430b03562857d46fdd0a4bec839756622db7803268bfd364981adeff2c0c169c7c42f09dddefe9b5454338b4ef619cd360e1c32bab8e5f41a5b15ae588b42c79c45b00e170f538e309a14a4076ef3df41ad98122e5e6742b63161e62465e8a8731ecc11e5e8fd42f35511172c8f9fedd7a2bc1cfd104351e199dd9f21682862b0ec746e3967c1b2294cf7733654414508e53a05fa59ffbf6ef0e7af8972eb4cd2750d69793a5439bb99a0a8bdde3c42ab5d9c9bb2b93baffe5213e79a01a831d5575360092e7fbca30682cc773b768fa1b69157a9cc0d367de07630e3e51012592a5a8864dfffade3935fa05f4281e088868882c4d03f1d15c678b8368b73c2d0516cd5a93ebbe89bec8872ba4cc3111f32453d4e3781314e6a1ab222da9e80fb96f8c3db75756b6fe42f026eb5d6fa37f8c5948bef82f68b96983af57c7a492b0537bd01336637d873b414b9c1705e6e50a96b748fddd3ea6345754767804b2a162d8785101de7ab150810efaf731fd5791e592de7aef9b6e459dac6f77f25b06b91c6c83e50f4b2a849a07847bc3cbe5142ba377e33727480cd917b873ea3accb929508da5fcd23eaed15faeceb5a3f4b8460a3a58ee87e8a0e8d2a2cb2e05d36a50bee9e674e8c4a542d0e473496c1fa83dfd65ea7bc996779ef7d442aed526132595124db6d48b16f04208410c4457e4ebe62c72e4f15825706667588400ae55af8377153cf3606581c2808a8482cccfd9ef0d48142c281de02ad2ee0ace0fdae2fec421afbf42347a1c3963a76044b96861cf41009e745b93293fc997532474e56a4716d8a5857492cd09001080064a68fd5efefea41c4087a13646d7f5089de1d3fd8f2d5f7dd8ddf070c23e55c34686159e72505117bb2ab162a7e2ca33ae29732b0704a6f4e5bb7ff0492cab00e35fb5b29804d49091140198ffa388ab74b8b9ed6c69ce8106c2641dd4aabbb08c008e444360cb36ed9200eae93a4bb5341ead32df2ded55acd1d7d6b9c8aba8fa7d4e21c2dca5abbddcb3b01fb85819d52ef9b2e8a1cd97e2cfe4d1203270ada1759a0ea8e1764c9253e91909ac95cd626b858bf1979ae4998261690ccb5eab35acf998cb6b004d64a2ee3459c1884e85c78884a9c1ce028450d6cd8fa92ef6b8901e82c95ab61332d7992502bb7a30f69bf35b033ce840b78ab0ade7b91c9499ad0a42378b80a40d3866df0709b1686f3cad1dbd2917997018817104991e83b1390373e17dff60fd8ed403728528564d5d29238141cc5fbcf224e01bfdf40278663ec460c76deddc2530dff7876c5b9c261f280d2302efa0b618367495416119e886d0f99ae7f851df5d5a3385ca8642709207d8f03b3e70c24fb787aa2b0dc15e291793b9114747dbb1e8e9c6fb844d627a5013c4cb0662f64d98a4e01f014a79a40053af50d659e85e25d09be344273dddfd43de1dbe8a382a64f827534d0af8f256a36ad6c570c95e7af5b10e675c18ac1254e3e8ffc601c1a8eff213e365eca4ed3ec2c064b1cad733326c45e6ccbb2ca3d3148a6000b2f4d46a1c865e9c5ce699a6324e03c74ba7c5d85288a59bf8337636c22a50504cbc1fff229cf97922e8c5922a3c5eed30bfa6e6197ce402115d0057450894431bb634a6c8176a3089c42dc94d6f246bcb5b65de18cf7b490d20a2aed4378a265031250c4f44697d2d5988c8c3cab907ccbfb2ea1271c13073fbc1a346c8ed9c1004ab0234bd78462151a228409406336ec3d73174663cb2accce960e728c7af349f06f5774159dcef4864d781c21cc3b26c3fd5b6fe073d13389107d29cecac0ca36067cf3f7a1f938c4e21e15c49d5d6e82e9e102cf378bae8d6c198322455e51309cd9a202ee833f1b5516f350b99ea71ac3e4b91acd0dad57fa8b2a16227f5552e5a5c96bfccbb14036502536259dc15b7a152deacc53bc03278175d25b5ce1519d672b772bad54edfbb0791b1641225244d277fe3aea520558f33c68ccd976687451a02caba072f1904afa7b2bda0ba0d2a2edb03d0b4fa607b6bcec640e22e8abddece01fec407def2282b526e9355dbf94bc6c043ae55d85878bc9c5b6f21264cb1434cc83e21a5d53359c22dd7a6b5a60eda3eb9a5d7fd12345da2651c4db12abb431891e7a0542119cfa5862c744762a0e90af61c3757d2231ca47d846785bf74d5dd8e4a9a4a8a22ead6dae9c2bf955b75c7e81dad60f4625a7dae7e8f59af19935c63e9e7e86429172c312068139363e944d396f9973888c23a4d8b16a058b18248f2ccb21e964275e16edd3dde40d41befefd1419bafac80506baaabee7c61b99b25feba8fc0fe9396bf373abb4f4c98417d49b273585587e6ebfe57a4f4decdf7643a30e11fe7e0dcca880fea66710871a8231e53ec4c24b7c234f2b8e0594f2057ba37ab1512d8a6dc0ebb19c38f02611eb954a452013de452f330e06bd30e335bc6b10b8e6430bb6e5fd26a2afd5987190a6548984b82215e9ad15e45cc7be68618ca0665bd5b7186c0348a2ff04aab3eff2bc11fe9944716af046edac4c1d9785409c0d627f12bc6fa6efc5b2c06600756229a52c783c29b3483b5edabc0acd87a05fdd76dafee084d1dec56a9ed6fbb9ae9de6fc438c6990142553cfe1292da2d2022f6f963359c1b50a1be5713ab0d797f8a18e4603daa6ef688db675fe218e6c2e5086a0f703e7f873fd08510f0583517f247722d27992b0225de347591f23606c7cb393f137a875a3660546d89515ed7ed95b4bb07663b340ba5d0698c45f11c28a10f0bbdf6f1f2956c562e131094686b28244df2aa7737b86eff38c479dc0c5e1de39ef7c4ce2d7776ae01d93b1bd69e5358abae253adc48b795478d17fef1cca4d4334bd16710963b78804087a5c1106b21fa85e76296a217f9ce94c4bd9e566ae5c68a43cce8aecc88667ad70569c9a2d35b9c88f23675c77cdb2bf75d5ac92f67b6015468b93cf7c86bede90573a973391e76379a076c1f6de00382a985d3e29559e8f76e4eb5c5509b0b3c52c8359f156d2ccd7b1e697d132dee592a511fdf1e11f9c54bc231dd66db3b7cef64abf45dbcfc715f9cf13895514ea19be894cd9ff7e88bc32a092cc2248f4f0f5d93a59322a85c4b5a62a40812bcf78b021f2154e9928b53b19b15e5793d2a8dbf8cd04c6273911fd3c3c9275f3e3a2b06e1eeed8cca19d2f2cc87acf0aecb5458b245f72a518c3d62b503e39fe663a47c8b900c243e40f2457c2698d871537b075bcca3f63dd0e2754fa318a6a1c0ad1d555a2e18e9c834a7b6b5fbc92e94ea45b658d04c7a45e28e635e5001057444de1c6e4b9b08a786953b5d214b9dfecb1aba7862e3db2a688b9e2914cc09b1c2c91f9b590bf29c3848bdfb89de8e44487a3e959cdbcb2c2b5e751040ccaee283174c2c266a5aa562aa85eeaaa12a2f8316203e3f74c666db7fa30473fa26036c68eb20a717cc1817d4474802dec0efdceddb7c6f9e7672af83acdd6417969fed444effd0aaf0e590da81f768062da5235d9b37d9a6dc4806e154fc7d22263e021490ff6486f1c8a20eccc928982b4c6dc0c575ea11b49c01e4f75be5b0e2503bd6973817c2e34cd6a140b5745a03200ff49c56265145684ff2ddc7aafef06252a0f5860897118492d00c4d1fe33dabab73aa936176ed226e0fdcee8aa096f332e962dd652ef9b9facb303f127dda3da45b513e70234c021842532c9065422199ec1bf0b1937f630ed30548e367f3142e04e003929ff0d93363a5599a34f720bc1d4869838b47745c6ea60ef1dceb3b02700333a1e3365e48816ee15f1c034841b5a9e704aed66b68b7d43e5c30cf225b14177f157db1a7c9cf67f089242a8860fc195aa7e0bbdd4af7eec444293df3ab0078c212dc15c2c6c8c635b580abcd07b9fce6e6d95c0df2489c76737e899958f354dde6355e1202454adb6c4db1ee434369253602282e427cf366211208b618970b5ad436fd18ea9a20330aeaca55444800855a7468d364bfa175cc0efcb5f2b58bbd06dc23a62357f00fe02f2d2928d1992766b5347d92476550df8a91f93a98ff022a7889dbbbe93c79453dc33455fef379a1a0abb9c726559fc431e2a697f0f0968cf7919d81454cd867f4e006e83b086d86ab58c738014f6466b41a79b05c22eac8a48834bddce426ac3579b1df26a5f784281eaf216a30a85e64c7eef86a1ee5b71d171e40e0e6c530b771cafb85909811fc737f78cda3abd804c554921206b5b9e006d2c56311ef2bee30576ac09a45cec16f223168ee48938b746ed208276646e6910f992c4518a6aecfd7fc28d16ce16223c612b22596f1230d8b7277cf594167aa57cac8f7680f1d2cba7c6fd58d51d57bf65da3981cfcf299011361170f89d9ea741c74c390ce586f759ddb1face87e74effd5b3f92a8f3defcef78fc0fd7cbf3a838bc0d289c1c3fe707804d89838feae091c9a6a3b00661b252d7da2a2786f58a368527979fc4a406b5828a9ce57b9f8aba0e491564c781bb3061de2909a8b7766838becaa05527f736335d36c88357837fcf9b9bd6966dfde5786193423254a0c8c8a822dd647a13f0aae2ade4ca882cd83833cee6eada11a78b43aa3f0e544c5b6596e94fcfdbe6a480c09de847c3d19a311740cacc76de28d524d246e25605682f72ba05db81d7485d19c77ddd50f6181ef932402a79ed55fec594b0fc0d2a560892297c9c011360d6a46179cf53e07dfe5912af1c925338434e3315a536282b796d4dcc9ab468f4a52454d8432e6ede28bda6757c1dd8eec0929396a64bfc1266d6e6fd47ded95a6b8531c6554705664b4d7d148107ef6db2f5c9f49b6fd847de14080def3f1aac27dcb0d02a09beaf180627c161e6a24163ba1c4dce8531a63e96dfcdc5dd988950db8f2eb4b83821c5a5d68d2c4db550dd3b87f0c0241f963f410bb2ec7f40c3684b5d1db8bc16c18d91e467aa89dcb40a6f062dfb95dabf5af124c4ac2fea9f6204befde365c2c732c90ae2debeac593c71da174187ebde565b408ba77ebde3fd765756fadb4e7169f18ee1ed5357ff8686a3e13c02699db8c8f955953caf202411710033a5b1df371b0b240896a0c96f49aa6e1fd5a069d4cf304527186500bac3b04c141a41095db703260be2b0deefec469ae185e75f5b30d514a06fc574fe644a0f51ece350977485cc7e63746cb8ade1a3b4eda0ae3381bee66767c5d9a901b0e85d311806b3a257e193f4b1ebb9cffcc94e31929e7f07408993d96eeeb3833ef50ac6c0b71cdca0560fa319e4bc840812b2dcfe96ee73f0a5dbecf8cf942387307e933cabdb6aebc0afc05ae9fc80b29a39568aec9647f447eb5a86222844065f9c762bc8221d0f3b9a0dfc31bead1e53a632f0834bea40d217e20d980a95a343d776f167815d8a35bc9c4d1e5b6cd4496bfefe3fbcad8b50eaf04293cdbaf5f415200be9f4a83a839622ceb2e9021064e2a3491eb3987fe2cf05beaac548e9240b89bf9d2bcf5a83b187c0fc3764f100933c684fe94bc3b14161aef85dea1214e23f0daf2364ef53a0f9db72b228422e09b37f8fa04e4a9e11d5e01095d7ee5405dcbeff79ca0733e4e9c257c5c3f17c48806aa7943048d9742db56248d85070feec0ddf7b4948ffdb9eca4996f9cf63d6ea3eef156b94791b2b0c7f582ba40febe45f298d98a55f5a8aa4d911c22c5cde385131bf27c2e16be9eba0f08fd521ab19eec6ea0930ee194f0132f845f97f46049cbf2740cb6983248ea8476ce60b220b5e57e494209f33966899a3632b22fd8a85dbaefd3c85397fca4e423953b81a0bc4f07189b659ffb207bd8e7cd77e1253f6a5aa494c6591a71533b30f09b5ecc8c8f7dc82766d12da9cc95b933b0e7ae025ad5ec1b878e6f62eae5efd09c939c723978070430c5d3eb88d1f5d7613a9f1a1f11250ab81be768298c50350e7a07e1c1c7771bf3e21347ff252befc8f00dd11a5100f7fefadecd32fc03d5a4f4d755de23ec177bef040a7f7f3ead929507c70fdf2e4fdc12a68006e08581a2dc71669adc65f97c7ca052671e724f1749fd5466c0fd281ebecb8708f4946da9bca3393cfc4fcb9ec560cefa3fc9c301a513ec99592e3ed1b89f8fc09e4cd4c2c3e15ed62b1436e162580561e0416f19e2571bb9d0b9080fba8910a8309df77867dcabc6f6f41be44a94b455d15775e3d258349d864e26d4f908fdc67531fcc4a916016d7296a5af2382c287d64a806dcf386b2a609012090fd77af84795b215e378de82e13233489b046959c10e9879a3c01685f5f572bb4f62121aa543d3c2b87c0dea4fbb37f85a39e8876ac6e14c1e263ac9a8e8cd0fc39a1246641dfe41b71d49ae3b742dc9fb75cc46c48a51f207bf8708f7ebb172fa5d3560540581d2a73ce3cd0a545359d32cf0d048aec7455e952638e6ef429541dd5d453fba0da635545ec0940cdbd9e4462581e46f738c25791c33f7d80c6e6f6e9b358553f7f4552753bc687c557eba6e628afd51445579f51f3c4f559820dd909d3446402270ed0eac26cfed9b0418d8e80288345f71304600b41ed32fd441590ce14d505addba40c6cc8758502a5f9a6402e41cc648bac225413953eb8859e14d1c75f12cd7224e3af8001d5e2d3ef32fbd7386c5c6eaca86e8834278fc55e2660c83d9f09514ed8fabd589ba0a8990b6a4f80be80f144ae8378f762df36209354036efe2675bac18d1ecad89be715d51b6ef733152c41b3a6d0b5ac7a88f42258b6e24d1086873886d64270c3003fcbaaf103139cf53d1f3e39260364c45490b3deeb94246d25dd6e8be1b94e094244c69843b4c31b487ba3c89d79e6672093df49c4f00b9aba2fcb3adb1eb12cf8b4fb51ecea147af3cb61391e138d9eb3ba4a23422044c5839c9bef68ff3e2ea90bb277cb53e7a93d03d21a831990f9d70bada08d0e32a6b0fdc5897e64d3f263bcff2c571fbb4468464a570e4ae1e9de302bd1b2e8c9e42df8b7f8a7130f8744ee2a6403d30d9b84fe9e75d067bc4d5a5fa5a4e7c8271c1c90d2221f114feacbc01e0c785636762904fb929cabfd8abdb2ba36e7ba7b17dd1e4b3b37759b865ce91070e8b8cf4cbb3dd714d96e7cb65eb97f90b9e9b76ca9886bbfccad93c83cd2f4daf13bad8555eb248e0e54a23059160ed86cb320f78e783bf3475a75c58981c9418f116ec03315a52f3543ba3a7c901fcc8866999cd15cff9676824ea6bbd31cc3ae519bacc1278172729216a4dcbc6b56a3f97d21fb767962b3dc021d315fcac8646697817af82a2d9eb046d3201774d59b1f19931ad67198d56b35ce7ce921a16f44b529458856df2e32adab38dce9ec0749e68c8bbde7e85e180c3b5f68fd989ed4c1581282cbed484813b34168d74bc4abca3fb5d38565dbab2d4b3c5854bfe4022ea08cd213f12db17106fa16d4b888178cf2e7eac28895a0d61aafee4f985986155758f65be771ae282b02197c72dc7afe13954842e8a8955f34d8943054cb3b7a7830b8878b5a51782e013fd376255104406a8dde08824143848dc2d1749e3f2d8ae649e10f5bda0ee9309fead4ef509f715d2fe048b4ca56eaf67bd896aa7cb0470e23473db21f671a501a164a40ed1c0734830f79b8c5695dbc6f2dbb4f43c3eac7481232a8f23cacc7e2a1395e2249403a8bc66cc64a96ea906fce9ec6094f182d6529a3ccc1f9ed8144697fd2a985dbef7466a742f31966af3671d7fe552a5f53b14029841f1fa32e79f12f84cb07d6b0f8fd29e909731b7747e9427e2043940772e58c780379943e1c799023b8c19314f1e011ae6941ce8ca7bfe2b959f0beadc22b0ad008fdeddf03fb9e6435c920f465a6c555e5f0c939b7ec806f696e779e58d1357226dd9c3e53db279c512d11a687204a9c457c9d460c721e841ebc4714e9998008078142bc0321ee3e56c46d87c2e1b3ab3b816bbb698f590bf67b2c71c96f149e2f84bd543a87a2f9bb59ed7c0653c30aabdac11b3c5594048a2231ee36c5c1efd58282d57b94ebf2c58610141957423094eb304635596314e8f51e80ed27b2f17d1b587721c2379e3b1b105f88bb04fcd1a0167f47cd2ca5ca0dbf4d8da91df3a5db5777042763a1e706b3ef932d68a3ea27cb8a56e482f981b3c1063713e06050ef9952e1a4c470d86b0b66613418f408ee88d13c67df35532d1b5dde85ed80379665e4e80980b2887628fadfd5cdd68fbbb75b3afa7af1cdf27dfbf44b87699f39e227c7bf0995279f4846c29d4d66f7d1dac52a3e4c1bb5413e15f537cdd87df8604c4a5810bc2f756c5face9e1f7e5584a8d63134bc284323e67f0909f57f288c134901aa4dd514cc4b61fa87fc79ea4d808262791fe43875a2da83f041216d350d733011bb5a859a4a650899371fed7e61ba92576fe53a89c51e15204b7ba00963a04ae0c05ecc11d3c0c5a81aa51f512f634485fb6566b3bacfe55edc68ca58c3df988a9c18db400a83949b488bbb261f4a9be2ee57fe55d925ad6eaf7d7cd0e89bc9568aab8845b9dd4b84bcebe480e6ed49b15e3d687ca283b1e6564a1eb01e65e4aafc56e3f1995ea8f1128982337d4f69d8baf4d7a9642dfbb57b788c96e7cd4c26c5beef90cff3d25c2d2918bcc382e1722b6302ffb37e35f269b023e9905622460427810baf32b5f25b8e592f2f32c098ec3404633064881dc3727cab431c0a46e06190d73716db1a9ad1b15c8c42e0dca642eacb5bd9eaf787585c39d7e9087ab4ac9031827db0eb15c8193f7f4bda0db3cc812139e6aefd59de6b04d8911ae4947d76fa5b9120a85f46ca5d496eed3716d1e7aac8b51e0b767f15d3a43e15b2f3e8f7a42e44947c6c0282ba54e0743852f2e6c9cf6f4ea202faea96530a4813c247c091d2838d1604122347f311f830b3a41effc5a200ea9c7bed525625fd17426eee00d4bedec84391c1da0041f8a20c35426d41cbe9b6d6f730238361d3c243dde6f3e6141a4763f5a89b1bc3a74c69abe2d48b47a88061480d680b42c9d372615b344d7dfdfda4a6e6e5c7b22e9e24f9af1f2cca4f405856cd38ff30dd4366618b9d03b5c3830e3542f242621b56e4dd5fc6f5e5a10a2b7c8185aaa7a13c1377729a713ca443e853a08d2795630f4c0c966ac5ec7ceeff61da69e391d49d8e198e94acf4c3ccf8238001a1a9b26d753599e70ccfb7f53a6124ed4b8fca838b9f56d5d9cb2b12c2f2d0f34faf85104cdc7c6dc74c0312e83590b24680a4de29b0c65e9577cf6460ff1fdf8372dcd489c935c202b61a1f4d48279f0c802e7afd87746c2825c8e3964efdd63f73a607d70b28b94d8c3f0de5ced10614616393d51039442ffeca56006e26cfb0499c8c8f243bbda44fd531b6124a7010aee416d4e3696a3b73fcd55981a045d3ce79d30070949abcafb92cc463d24223374c3b85ea81964618cbd2cf413c62e490495e0ec0d866c7127baa6cf95dd9812a887005acb7edbad29c5513e84a742dc66b4aa60184cdbb746b513100359457a8adcb4c0cfb370202df4b7a86f03f0d4d502cf20cf682e5e48180305192f3d58605e498a8a4609e56c872a80e64b7e60d00c8006da93828cc354c0c5710e94bf107b65cab973287472431cabe2d5d247cfbd17cd1f7e95edefab5a3148598f51fca8c75643f404af59003c32c434274ef012ed821b97c800f6f1bbb4d7deddc28fe617bb2a9ef031dbe1fc21788dcd86a4ff78e87785ae16adb05db3f9d0c09125b228f46f15ea305e80097ebbc4c3a24065359079adedd3ee36ec28d9ade95e1025cc1199384512f556b03b728f318f23eb18a393885844799cd6eeea22bfc6a330dc8cbd8582389375215875e512c779c1f2c26688eb4c32753fd8a9e9de089eb873df40a6b15704f3c2290da6802cbb66aee3c7228a9adf4bf1e574f366e251562af5fb4541a9123d728f31ed3b61a8af71f027eb0ef36bf633685fcfb65e51c90d026062ee162c99682509b101f6afcd6f25bdcfcca45da97aa4daab760d7429dcd916b742ea81e135b45fd6c21c2e45338ab9f1fcbf01f37f0e095f9ece2da88ce6972c6c98d9a07bfb99243a31d2c70659cd18f45a25b9c59cd4fc43391b55600e3c4f1b9fea97e5174a929ae4896fec6c84c49e7f6161b8277a9260edd430964a94497795158d23e6e4661d07bdcc58ef90020c781e86169f8e2f11e83e49356e4070a335a6825fcccf93ae14f8e3442f910b23c9ad9da0fc85402c8f3ad66b0c4437903d7e1d8ceeb0033896630dea8ed58cc5654cae04006ca53595be0f3999d18638cd7fa10ee2cbe2577900b6c203c7977feb7cdc1510a2479bb15300f80ceb2033b44c619fd1aa26481c1b3b4c7e47e8f1a4ed67a35562090606f658a319cc5ec8d705174e1680d887136e3aac85cbc0c857d3038cf6d588e7c37ad9649e25b763055ed1168b16af3b119928305f0591365c3322f6cbcf46538a457e4df5db08b762c4d91d5bd9695ea009b4440993776670607c2bf11143cf2893f20bd10378ab032d7eb266c90f277f72f545b178ba0fbfe02747c2fa16e2ee3d56627e1f1707e6cd1e2cbb146dc3a07668f4859f8702f5e1be1b5486170cd1d5b1d0fe7d162756f27d36d76166a9f232b6aae706accc23c3bc7829d66975a20df993477cd2a53647271b84e50a4be2ec70ac54d7d217543d61918886f0244c8c21ce213334b4e9a496fd9dba65fd5f2f0a2938201f2bb2d0489a8e5936223b5372d2268c709284dc8e7af7f4cafa77d2d08cd88e61efe714c2f66ea979c0cba07ac8e3dbf44aaa54b2b8660cd077269a7dd083c65ec318df77c3da479a002bbdab9342b95d9b22fe17a2918807d5d7a0b434c7c9d1ac29cb23be0c95b6ce955d4ac30c80b8b77fffdd64ebc699ee9db41564f99dc65dd089d0ed3a92dd28d611919e5a150d7612aaf810f89de28951e6e3ee877bbfb77256aafcdfe2771af987b7a223a5668fa2a5826e48e94302b4fe3fcebcdd2aaa8bc93eca23361621e703b0334c4a73e4f71a7f8984945745f33776ed64ff62c0344c981a42c06aefee1d8b5202953708aa1266d8e696015d80557988f47afdbef3e89a99aea32250bf6e07ad812905fefae88620ed47de55dc94559cc280632ef64f303ba191a3cb2baa1bf91fffda88796857b8c9e86baf072d635eb37081999a09f3f2c8216070466ca0ae40cfdbc667e4734f5b05eefa4d8e890bf333369592f49aa16987e67ec40fbe3b224119e073ba4af07bc54e7699c6e489abf5cd8a9d25b500895aa78f04c78fa7933beb12efd9ed29cd482abc679f6c29199f7e78f8f24cd6c07759a28118e8f7820c1b89d435808f4b052cff1057a654cd33f79332d633ca07eb74507c227f2092ec67f187bfded5766e0b77e33544af128f9649ce394285eb26c0984e32cb1bfa85fe0510e36815b91c6c15e91b4f82674635d2afaeb5c22d3f22126dbfb6b8c1d62cd0fe11d573582f91c4dd42b803c97b045ec446422f86a4a7eac4f1b4aa106086aed876446fedd7be1a4920290e2561a750c6da6bcec14ad5c9e4e2e5325475cd433dedae770a33777e5a4367ed95c8844e37afad4f2199300fbe7125a53b93e2de41101c92310d1f1f0794627e2e581ce3ef359c339d367cc9d79249189289e2da37a1801c0521316f774a642f86d04cbd5b9c172821cdd1da0e238167ce10d8e45c0a9763419f2849e019693f7583dd7d70787b5b0628883e8641befd21fc6b024e5793ee29372dc3c3cf6c96777e328d4fc9ccf4761476371a97a956627495ed5caec094ecf6b99628ac510fbfd8f4005ec9288dfea2b8f0592799a762c7ec9f2f09421f886973c158d95a9d475266a6e5b61ba99253e6f5eb3e638e074f01bd7420942416f1e0a3d6f46217f43b74099bae51354ca385e0e0f4fc6608c2550a1098866ef044c174aa6ee4c312dd34f669316b078f75e6da6b7582efcf43454a3cdc07c6bc44de580b2e8f1c0908c5291c03985a9c4d7b78e595f126068f42bad1124bc571e5cd31f68df9fca88eed39becef4a0ca9be4e94b5c32ea3056ec35a04e8c88cca0c25cdd659d9b6b066da4853e1d29e0bd0672f29ec4e896feef36b385700f2a7cc29386d498d06de4a2c8bca5d84bee5783bf885775843c01f5486b2b875f8a18f24b5ff6f882cef069b82a3e7de9d614c8b2309f136186da0a65836afe2cc65e296d074f8d5af4bd26b27f8c92897acc5820084b521ab5ef5fb4368e4ce3c1289519185f71c08a619a64a07583ff6f132ad6e01edb65b74e96e11160be009da1705f6d51f02aea0a64ebd175d03b50710ff722fde71de6311a35fa672172072bb0f52735bfd89d1443e99def26ff3dead97a2bfced7717efc285cd64e4406ef2df2e4cc379e828bb92e80f793742e1ddc64870902a74f745b8834c5ed23ddae601c07ac020efc8bf1233ba194906120b3995af930693e6dc52742cebb68014d20f2229930b23e6845223cd888bd4fd8226b1564b7cb34af33dd286775466a90486e86a34fee50a877169e4d4d9b310e3168cd11c07de9d65624caccaac06066ae7af6c57d447e3286cdf3f04837076f03cc0ca47a1647b72a89a55deb7b13bda416e3f4ec1c2ebb3fc7c7e332ee89baffec3ce8c0601d72e8b94910695fe73c7f5f1fbb170eba2c558a6a8af2fd96e3a84cf0504de4e48aaf9b68b8bc5033a0280c1d754b6579b5f30a87bb5f7e750b2a9824c48f38f49e2085e8a2862bf8de82cdbd167260bf5739c68e2bea88678e4d9767d5c9d1b89fe6986e8768b3f00360b473999bcf934c7ab65a0c718fe145468215fd4c6eb8964c98b9c60c807110b655a73f985ba09a67c321149696db5bc728c3db82959f86b0b9cc7b324f6650f24550df91f2dfc8b0e2c039eddbe4ea051d31d6feb39d26afa6d91b1d0360c99fdaeb2540bdb600e900d3e4717a0e169e83f5a0ff07583ef7afc6518feb944e960c782205a8c06260778110edb83a815bac7f345ab06c8e7dc5aa7f91e6b6241ceddc04cf54aee40b3d23dec4302c0529ca403b31720a86ea911da002e98468b5977a008b8e7ea3e4927f29c7720e78c7ae103b8caf7daa0eb6bc0a49c41acab673d28b8b7b1b4e648bc10de31f5db95ce5661ddc884adcb57e8e501fa93069a9ae12a68861de11554ea32e4b4f8fa8bd4ea6252ee316fc350189d3b54b73c40d6e50c168aeacdfb959cbf087420c330e1c6e173b285010cf60781ba7623ae942412ef66a0bdfbd1b5271f78e3239ec9887aad4c871d83b33990642bded3f858319c07a66f7e843c673db3962b4926b930bbe809f6eeff66d3c59666d8c28b1153c0db955597d30cc266e7d1183bf1e3921746676dca3c46688a6a34ce4cafad14498f843fcfd9e74a60df99f75d82f76d51350b0e542c1a2e0fda6c05f6635caf0a49b5f3f4db1eb4830b12e50aed0937df6474f943e0d243419cf7e9d3bc1727d512c03ba6dbfc308e087e13b410e99c9cc9170a3e92dbca95ed34ec1d1c5821c6ef67a869e0d1535b8d31135ff6009280beca0868ccf52b114ac26fc480f7240f2c3ccc3345bf6cd5c1bd9bbc90641faac4c618c4e9c3c01069801a25fa2f6372191302a8bbe1d0a0ae18b6762d6b9b7826475d047e141f840c06445f24c73ee85960f3e58ac561e8a2700a36b8b2f79f5371a73255ce7e064c8fd925adc760a49b8be52d80a86227d9b4e32a69f4d171b9556d4e5f9c2273963afdace36e0f53b495ee4a193043bc1f972feea1b0845f05922b076f674fe9425ccc447121dd4e5fa1bfb62eab0b99e120246f406c356cc9dcd432dcc94fa59e973773bfa615ecbc0ad5349435e2326877788f7b9e647ea2cbf438eef37163f3766b838dd256f076fcc4b3d048b77d9ef540dec76a0ddd1de77895b80a9a7a27263325b1a0685ebe5a80d385f3b628b799afde386a80011f4de092d1bf5d28c7d464fe206418fb1fdcfe2aedf71ed1bf8aa6c94c65e38ef69d02639618522cf7ee49199ac4cbc333f2be1dcce07dbbd2d66e5f3a1f29a0996a26f92a9765319d423f0e652997d76ba758d795c8ae437be060c9f8665370462358240e6441760fefdc046a4b01a87926e3e84004852a9a75e878362d56e501721ede499286429eab2d47e8fa2331975d476de05a31d0de8acc9f10fc9525a5f2f70ef0e22442c31e053e872123700d80572d279e0841c284b5f579da785773b8bd43f2c2fbc382c020954ff22992190d4330063d273e87dc7454114a6cc28df8854cb256e26e94b9c42adf84b630be11c18c45c88d1122be9b28813459e9320953f0e25ece15e52568a2e0668d1400db87453f76fa83161686e9ff0759b69f77e1006e6f40b21fcf42ce5f105840bd5a3ddbac92e25324ea8dd43146f5d04dd6fdaed09f32f1b7108c9d1b210ba381b6cafad88763250b4c5fe405e6cb4345fd6be28b8be2ca3ab1e3b684e64c64ae4ea64877ea363cf9035eef28352bee37a1a3121f1bd3381812d7a174446bbea4ed072d3e0c090e44c4023021d61de775d6588a909edfdf60aa1ae7dc03d57a0b354c01893a56269c84f6615574999ad738f5e4a19c216f504613db4f65d0d2a0403c2d05e6d771bb3224aaa245d6f1595d63afca3113334c299fb7cb6befe86d85ebfaae41fc5e9073abcb4c1def01dc5d638e990f917d9b8687fd91ceff0f9c27aaf9672c9dcc5a77990e692578860ead87449b65edf42d3caa8a770781ebfd3d9a8ddde175a1f3d7c382204339567fe83f6116d69c8b9c05b0f725ec767955e0108dc633aaa257edfa6392f194a233d5968a8da5665375f2fb92c49a2eae4344143bc5b67a63413795dca5d3d5f7b9b42a686f1c87fd5d11c9414b48226e5b48c7987e1703e2a5617c6c8d8bfe89d217599a6d14d713ea5ff919c6241a578399963a3ab8818a6b68a69e048d28ca92f8af3fc6751890e5122ec0cdd821f261be25164b5a6aeb1088ca6931651f8580d8c1cd6a140e59b63326104f4c81366a24aaac11e29ddf4e0d0a4c38a2944d03f2dbcb96aae237a8fbea56ea284a5a945aaf5d642247255a7065d564939026d2c2572c899082a7689b294dba6007a79bc679941e09f2232b37c46207eedf102197975a201afc44ba5e0ab4d64aa8b3968f8c6aeaf740b14fca6115561658a6d7824a955b12c258d90b5d12cedc1e7faf33cab4135c2adfc8392b038ba530e64739d37c5eb0dc2790936e9360562c8b549dc7cebdf12cdcba4300f71edd71ca80e3a93eaaef5436e539af7f5d65266b03386a63e110fd4a33b60d64ff7d605f962192a2e5326b3676472f7227c521128c874f56f960659bd64b6f12d1e24efc118e5804d5dc1cc26e2a86e950e977b57bab16f143995bebabfa9a26dfb7d5e002a37632047ce28cd9af54a8170fb04c1f84a093ccee3e46c880373f2f697d71adf994f7f502203f036244d9bb4aea7aedb65bbbade856f13c57ae7187410349b407cae8cab2c95129b260ff29e9fb970f2b8f0688745ffe65971bfaa5336ee45a84a4faf32671bbfe9846e28625e42c91e66346184a8b5344e1a6cb0256fad1a966e47b5c3ab2c171a3c69f356ba93cfc641c629ccaad1118b40d49f36b1c18b0b21f9536e9de75e5a17ccd6c54341c1eadeb4ee741120422be9ae5fc98c3cf0a62f319d21def4ed51427450aa1ae05b36beecc7a50c6ccb92e2005cf969c74c27a3ee9cc3695a89b2af35bcf60fc7efa963f09cd1df26ae8925a8de828f9cadf9637e37a1047bd3ab6d303772f06ce25aacd83afa8ecafbc878d740ab664eb4c6a7c0541ff7f3605185e7472ec984715a68e9e46a965f4e6cd0192f0b2e8f2eab4f47c251d5e56b39efcf70b9bc2ed4fc903ab2fdf4cffb71dac8155916365b361878c3d6db3d0a6a96c3656f6c7c9d0361f23c2666eaf1ff5540ab365c56917f888da098eb1d20b88530b1bd8bead509d252035786dabb4cb19f765620b47d0374cf69d975c97898e49a0e11a20d99940ea2f4314264e1b11bc990d7af71613781fc4a4fb80462b693640b03800151588374d2d4a6ef728d50f60873f55b202aab16685b2b62e5a780ff42ba046adb385ca42cb64b68bd1bf8f972e0fa432e4ee8545e4bb6b7889f161590f838976e14a48684d506907fa84bc8c1d6a5722530ef0e7343ab255ea4e75f1f1e5fd0736def34ad129a0e1ac8441ee61cdc06643b1be7f6231dc40e118fc4618900717857615e4bc9a60bea75d6d3710b3a58a7655331ef92476cecf557430c13bea59695ee02d49e1a40dc44f008c3feb2a13881d34f2b41bf13db260045ae198f358b894851e28889b6d5ac4ee3c4ca2fa1ef6c9e505672e13eb5e751ae98cc6dfda2f3bd5441c19106a83eaba6bbcdce2de64116ffb804349fe2de6fb357f1ef14827af8cce86a66dce22aea0ce510d970c65bcfc46084e6b46c6b8a86702b7a2b89cc7c0f4289e66320890490fea3e7b7a00773d3961e621ddd3d242b98bef8baf48df05a1a22b7d52b4b6e748c44abbed300a77d8b6c0d7a63fff1bd0600aede68cd1006e83fc39150c27f7407a89c86d7af76c2677dceb7cb212900b3e5993c7de98960077855d7c134e22254358bb9ec34caed3ae53761f4cc38d2b766a7ae33161256c12855ec35c0abf95258bb50b135766f759cc393ede194f50ff877bb7d65c35d60ae3ef479a484491560f63648217987a44c0359be6288f29a57db02b631a2f877d4a75b78ec6a325c6270844442e62de531456e3b8668ff88c4f92581510bfaac2ff95557a2596f1ca01c46176f8d7721e0287ba51d4facaedebfb5866b598b302bf1dd1f0be0337eda09e2e48cbce901d21e41f5bf14f458f9daa152ac089ce244a43c58a73d57db546c265999319a452976d726519c13418976847b77cd2c343596731bfaf37c1ddcc55edfb532e478e5657d029defe91c44b691c952a89e8d8d4180a3534514314b00d485e9a5ad6298aff40dbf40ae0994038cda59ebbc189069279275187a60d53eae6878ac83bd9f3b34cc8fb88a6eeaf87f5ca698de0e47ee384ae7548ae9c054a79556d4c83a09117d5ad00b37ac52f7392a7784059b1bcccf7dfa7dc7bce88a1135b2db8fa943ae092923ea8b6422ef77d824302e2c5dc3f4199ce79626c8f3d2bac5763f684e113f8cc3ad17e01eeff36dea22b73d2e7c2e842cfbdaafe38835a08935ab98a7d92e34410717acd93279a264434d5a66afb52864e226d5daa37ff39c9fd8e1037d0e6a139a2d27f5952b15c54297dacb621d07a0d35afdeb7d6978ba19bc3ea74af1bd06d5429ac109f863a88a1935c1e134ab6efa7263d1c64fc5e5d58350d993c8e04ebfdd5e94b4c2e4b97bf5a463ddf60b09e8705d78cde9c02509594ea5dc455b5db241809f10bccae944a1adc70935662f5c7ce5a3a8da3d016b34a4d54ededabf49ce8391554076d7cf0f50b1b272a2b4ede1b27a2cf1b5b0960ebb6d3eaa048cc94797462dd6526f7ad79ed76acc00272d5a490d601dc71ee03e4fd5782aff4a81d735ba142966e16f7d275526bb68575c3e8aa172e8bd2c82ff3445053da7ac2a9107e5bb97f995b69d1cdcc98370c5830aa5d42e136dd667eadf574901aff1c4420892c9fa7782044de528e52cdad66677a64d4c2a7af0f57e026dc2acc4661a63103503ad4759c335c28a02a25a4944f0b92376505f308e75a321f977e71136e7adbfdf2a6011401079d3ff87b65a16d7d0fa44cbca95f6712e172996c629d4f9a18fd6acf3dae6f6cea6034ed7445953a9c571e5f1e2396766490f60c0725fd48e0b6a85088875d7090f021fdaafedc500babc12a22d087f59b34839e6fb049ee1c2b4719dee27f393c72bf5a69eeb565d87df6eaecd2c28a7d3fbcb4bd51ad2cc93e11f21fd26335d14bc5f4dd11d4db73446e05599dbe0950c058ab7e151cdc20e52fa9f0bcf518812629497ed6e6b8234bdbeb7b600cb86cdaf6a6f0976b83862199800564f1d8c1eb43dbf82a4fec1779d31441b52c73a8c3aa4cc3cde722e2a35671d92221eb37509b7ba6f35f04be44ffcda818e0bbe24856dbe87125944dc1eaad53e591728e1f7a216475058d59e95248f0f6dddcaace9fa1c60615b75b8cd4c03df394c7df947265d3576e2ae83a189e294e3a2c4274c07f0a9497c8af46fb6c1346710534f70995dc753940b848d6560168cc2e8ed177755f0f9a8cf9ce97f2e0929484c0cda552942ac2af738fafc3f35e9ef7146d017e498ff718ef64241031729efb7f6d42d4d68eb0c1e6dda6319ce2eda2d186efcbeb83be67902c4246e86a242424321fac9279c7dea6f0be0fb1835368602eedd9a0200f3b8f3890bc48a16c849bd1f844a2d43bb69542f20e1a719a36d292ffbf4ca0733261f50ae72660ba293cd6e5581212023287862c86d42dfbbfafa0a4e771d562ddd4f82c1bb14dc5ff5a10cd5fd9c7f0f22fe4e37794782d7b87e468d9dbfa1d50ff79cb767db08d0f6e71f925386962a1d4b5b34a848ddfd01dbcd86f2e9ec6421a7aa27a9cff0f79e44e2340e9307c7131903a9f8b3bad21a430b17215c65ef24deaace3c9967f5f0013183e49065a62da60d0d859da40ee7df5b2233951da90eac635d0d317fcb39f9fef63272e22485ad14832e31dfa78de452caae7df8a6f3c2995a3b726d50971f4034e9001ee77f090f3d96c8bdef30141e3b7b77ff987b0775209e330b2b675098b23835581e774b650ed30ab2f99d65ebfd4123b7213b040ae0abb13f5a83f2fa0d1c7338074035c13f95aef7cb3c12b56509760d9b714e332f54e7fa625bb5fa384fc0a01f34f4ca1bfc4f9b28c3a6df7982aae3f0af751278d611d414828f4bb8b1da53695a8982ebcd1f138589425b9a8a5eb93ded5e1f4e6e11b62654b34dd54c7ef13f5d9df3b1bd697fb5de7e26532c470470b287e22ba3e139628d26d31426ae642b2b2cb6b3c3a8bc6b37e847631f78056ddc4f7372cc433ecb088400a48bfd44959170b10587b5ece4a8df7f5d0912ba275bd3fcb5c171f4efe57f499ce123b7627d1e66e5dfd2e28610205981e9b0b3b75f66aba18018a8d25abf05474f168a47e18afa9319d44aff1b2dda349326662e1e3b1679988d9ec2a3c6cebae6ba5c8a0fde98437ed5f80fdb5196596de3a77b1ff8bf3fb5aebe03d664cac77cce0e72bd6c0760fea9d0e38dd8a20df80b93c6ed466f54e7c396aab6aaf157c3f1b5cf89ce5d7d0c1503306a0a627a139b793a2e066b2d3c15152558469390b48985043d36a79c08169d0e10c4bf1444d2ea676edf950af75e8ffbe0d3db03155fa689d1ba7a889af4b8e5cd9c5fb48267a36f074b814f8aeaee6cfefbf0ff0aae957e488e0b66996319b8ac8ec3a70d99e516d8fba540be0da38502958a1172d5ae9f2e455e6b1c2e7efc2149ce6fcf8108dc5b4d487bc76276c5448c774b7389d7e9ad063f7049fc199b4e387748d883098a3579fd2a4b7f824242f4add406911a1ae6d3d328924bf372b10a56cd969e01abdfc5693951daaafb58410aa0ced07b9c3fb4dccd8bb21b46f78d5fb2b5435d428372176079d1f57bde7e25c0ac15730c889dfc9f5e1f4ae7012aba426507dd3d67cbe20ea95e76d7098de2310488aaa57e801fd8133f7e297ae0594fe5a7cfe1c011175b9702216a251ceda39cb7def8782748f9b6f29c761de877a40553ba93452ebf29ca73baf267703075b0c20299195e3cb5ea31768a6fc2bf98b159252f089286fd4e9909cff4b6ef2e1f0a255c1a3834083a7ca3a32d8faea9be332270796e35ba8e983988457d0389f8e073c68db8772d1c0489eb53ff0a20f4087a1e1a9c15b671c7a0e45807e49e69063d783fb64a6f52025569e579c9606e7c7040c3f83764cfc97f1137beac9813848ec6c791636ca7708dfc1bdeb15f55265bfcd467fcb7d3036fa1f595171bfe5181263661f474c0c29a45b17943e582d3bff67efced62ee866e1cfa084f2dc920b1566f7a445e2d53dc70cec60c729909f9011b54e6c77ce25095c1190d0db0fe37bdfddd92702a6de78aefee3c3e2b27b12d24f322272e7393d47981a2dde3c85fea1270edb61c1b59f5611cf1c4af175d09476536ab9e64e99142e350c1e6f9070c20dacb0c6df792ca6f40c78360e2372da0bb6278b63f8308e1cf478623e8f7c7288daad7d6bcfdcb7701762f5930e6c8f6605cd696954726a124283fbef2583a422fb393434cc3689f89ea12d3a6d7eb4def0feb80d670c2d09b62eedb9b40863268bd9f202d80aba11bb3c12810b5abab70fcf426171ce34de45d691574aabc8feafae7df6f1304438580ae14e015d88d35a333f9374822f51a7cc39cea876d8f71cdb59e49c8b1c934264a36e7fe0fc66bfcc1d507a61d3cc0236bd190d6c63656ecc858c15a56712b894310c39551696afe11b26a21ced4a430ad89976770af01d1ed7bf6801192d22101fdf69aeb13c59fd52bfc9d0bd22c18eaed8983d1b91a2185c03a65e67c2a1382f6158ed7491dc8f533c7aea1b8c258e8df3c3c4c32cddd6eaf655fa9846578384cafe0d331d65fb27dd0a17dabad31ba87334c6d3df2dcde7a2af5a448c472a5af623c2f9ae58b4ecb5b385d16f3d633535b6f62366e2e3940fa6659bc77ae2e559850c2c5e25cd3e6b5cb51ca1d35c668d00cc007760d80aa47dcc928698abb66b37c57612eb8218a96e2184407ddb940a6c2c0312ac3726d8c42307782f5d88397506d946f6ea4b3c6051d1817561d2b1dd96be36e0e545979e4d1bd01b1d446b4140045c1360445c949f671972235001ca7485f5f1d1bb23ddb0fa2ac8ac4c3233cd1027b75adcfc2ea54f88d01862f274b5d289239dff69e239131e7a84e94174bf77ef59773c04ed1689c0388ce4ee92bc8e2bc90ffe0f937bba7614adb192442643013dc63c20b7a2a441ad2dedb359174f3c291036f86c9dc55f2fca3a96f2bcfbdffb5ae0b530920677f664608ec6f2a0c1f285876f478583a63088d5a9d4a178f1fd23fd3147ebfd1bc06c0acbb07ad27a4841e637f71ca3bd84480b2f3331f0135d3efc18a1796ba205b9d1855e0979aa655d7673c4d9d1ecb6bf48048a31aae151f78d58852edf6e223ca9d889cb0abb8e243a48c5de9ed919086bb7805cd4cebefe4503c77503c389c0f0d991cf7361da4d0681cedd3600049dc3d5ef3257059a1965b8a2ff8fab346b1de224b90535aad86f7d1ddf700de91d35aefc0e788175f7549bd99df72febf469abee46d3260cd2c72ab63cf07cad9e33be6f451a6d41e243d3084cc045d02940e4816457524b25e3e36d34eb12154b98af24e181e1efefe650452c9d2ddff6d73a4c0e42c67988602faa358b0e64b3f6a5fbfda610b5f40d52046d059435996a016f73da3f0398b32e9d1474a278447bb5e0553c2d5afa28a536d2c39446164a42e9e784611e0c48ee2c4c28bb5b308aa16f0b7122bf6d4056e0a865fcb67e9cee856f05a7b6745e81885346e2460d9cb3f75463e81e527c83ca0f427588fa7fc8695ba35f18b6259dc272375d5549b4a41778891a38ac0c452ceef86075fb9147ddea44ebef423b6771604461fe03c4f11de37d116313072fb4a9999ccc4db3d828ccb8ca3fcd77f4cc8111e0c72ae0231ec4123cecf763c7bb641fbe3cc23b46526c6c55360d3833acf913fff4277be5cfc16ae5cb40c0fa365e7e4732fcb9e7648b838dc710bbaa5dc3c34f7b3207ee4b20128f2d7cd53bbf34bc4b3c198f366749ccbeb20d1e88ef05eaa5db9fca255018f1a69ae12081ed1b2353652e45725aa2fffdf1cb0aa321e49069dcd3b783dfe5c421196ccbb15182e89bb2799db5581a08136d6875b0f865b44980b6c125727ec735bd82c58beba8fefad52aeceb18edd682d91b89cf834cd8fcb877160586862b8ecb2145bb1fafe7fa381b71c51af5dfaad40af21bcd7e10f1345e141b080c0f3a6c732c16e8cec530a148282d0af85fc2c3710574cb319424a743c4058a93e94eec0937abf052e6c2249fa5987ce39914b8f01f2ce867580e33c34d14574cdad19ec8b5fad65dbcfbba6e02b1a25613ced6c18b5a83eeb0dde4a918f1f81cae5240a3444c943485a52bc15159f5c7486ffea485368e53df55c1d33e48ec9d7e73a5f25604b15c45d587a4db1144ee7af4fa33ec51a37e7e365cbe75489dcce5faa4f3ba9f61f50c256b8f6a82ed49df848a9774177114f16e703b13b0ebf2739feffe1b10f40b1978a0a93d0dfea9b76e0f493745b9652965a6db15ec612fabdcffdf26df4607ca5cf4d979138a7be467d62c4148e786c9df6f50895bb8f7aeefc4bb9d571ed621c037ae52c787a8b55733e2d5bf12dc6ac5a92437ca648826bb599b1bb0155ca58e707f9865ccf39f737f0440de3e74ac06e546d520f737220cb08e34d28ba04dde502ef7ac028a5fc1917ef07dfef9df868043b43ccfe0eb93ad26c8f488496b318a1574ef66329891434d1810638d628e173ea8b8079016d44759d6991a2a1508413ba2367d0a06ebe1ebb91840ae31328441f499c41f5f882f5746c4ca0846d4a0c4f6b639f6960d49430e52da669f3d614fa761bb4c9de7a659dea4536610134444ca521722c4583cdd42fa8ec6b653e6153fded90138c68ea1c82e6cb663db26ef2de59b3950ef745f6e976ae20ec88a1a38d71dcac4bcebd884d06664bb3fc2d6c0cf1eedf85dbc77ccd5094e22f19b367ac7db0f43ea81aaa48ea04c88581c1ac463fd29439da91ea8ed48805de7ebc831ed5c033ffd471d441804538d17ed024ac1e832efd8445938c059dcd0070ddf3e25ef5537233dcf34488b527a32819c722197293b07ba8eadfae49e7e111739470aed288170899cc8b0b51452aeb7c74164b412a28c215f7129cd1d4fb4102020474ff2e11606189bfecb3ce37f504c4b90191f0d89aabfc7c3dc2b0bb31d1f4b80a2a452ce36e8af272a416982e83f9106ca1c4fb0be7905fa59c7b8055af3a5e79dd29ca2cbdcf6ec061fa14dd1e7ad9b0e740c2f28d042d22d93ceac52d49fe7ad8ebf2b4fb2189b324eb59cbea39b246a81d6cb4e75499964dc2feef8d2f526a2c6977dfae0d182f21bedb9c0bf8bd9422ed86fdd2f43c6a35ff0df6d72489726a2977f74e9f325c128ee7f77191ee1b0d59eb0cea54952343311b1243170bfa08a5963c9695d64be6e9098f0ef2fdaa65e07abd13ca2c8f8cd3dbbfbcc13f1c118f171266acc1c5b54dc77d39e167a71b20a8d3e2c7d1b9f420d1dbbc0afe5203a953a8fc781e8384ec7463ff48b7ec3fa6484c16b63655eeecd7b9732a11cc216b661e5980520359c634be32af42000929b1146d126dc8b4d642f413f4598b263de782d65e19481b196baaa5ad0b9b9abeb908bda66d5eb1488b9f209c13aab5a9534a3992784e5c365ded1a658781ea4b8664cdeb240bc3d84c4a019ad331de4b5ceab42572ab1703187f1d6ef2e50d4a5369b354b796e9fa18e1c0b3abfe76089c53ea2d171dbf0ea2fe07f0d7257c3b02cda64166d69c5aef77a50ac99cf79c1cba75edf000f5713e1f5a5bdce34d385e43285b486b603df82ceb7ee02722b42a5745d04b27790a7a25af0c3d72dba368a4c1308717b3e0ab4ba2026f2d95fa9493a4b541b8ecfc9a61e30772a5f53563ce37c38d145a8e8ecf44de629b7aa4dab46aed650ee01e299e0d804b919989832ebed333afeba1b30d93ccab952644329441654e98f061efce751e46e9586232a9cd6c24de4153a416d6b26568b7ef15d85f97f29e3cc6ea6002d7dc0d33e6d59d03c2981e10ef54d8b7523cfbb97c9745c26d2eb9437ad7da482da6824ff0637e3b1cb878e273710f32a28c20b99c8607af32a5d8a45157f4bd7ea90676795f7360ab21ecda4e8cac2645fbe61ec592186e353a250bae59a2a51435442416dd8a918153aab6bd6821832f61eba69f1130a3530c8a4e618a65d2b39b35c2ca16943d57509ff3533028c7c7f41f8d9155a132bd86809b02f60d83ae972412c8e4a16de2378d1106c78e9d11a2a937ff1abd0c563622bd934094ee4ab719e8c3f191ae41af84e9c5fdb204ff785edd2500841e5025f96e9b21bcd3935f7b0910cdd4a23a508ab4ead6f70d55c4e46388e247aef61e8ec0d9ccc2948a6604378d356759cfcd1cb2dc4091ccb6281367c354bd55704b830b58572f098dce39e69f3b55f97c6673bacb6c69082f346777e5dbcd4fabbb86eeea5507be63e834571c9301303e29aaf3c7388b57133cd0e0b644e1befe0ef3bc222de4efb741f89c71f1719d6d49e0164193cca5cd0ba3fcb2a445e4812e844a6a8adc6b4fcf6a18981b097309f79c0415561245cdcfc42b97ae09f9d19070685dc44d4ea489cb95e6efcd4066a285139efed17f23b5e184c4886a018c8e72fb86c1a1826b93512ec1417bc35d52a241c689b3418aa2cb589e819a45e42f3feb584d1d0e34b216830ac90dc49bab9333eab72d8399aaca923e25a16415393a00d10c9f675296eb9eb3b5fdc71edf004e2d5af39d6bdf5a7026be36f66897720c00f201154f4d23d419f4f4fc77277b0d5a4e20bad934487eabfe63fa6defa132e52041e7da42715f3d6b548fbee8fbb124cbc594ae014a923e8bd7770f523638eb6759d7da1d4c6244cac55b0777fd06a3fa2f32cefee13a0cc8f8aeecf76a9f101b4dca876910cc3a286031e882dfd5d5532abf39721fcbca703462e5326ab51df7fe490523c38b55ee1153efa5c86ee1436d17bdf487a12d5e9fdb68e2753d951d113c2cc296a718405e29c7abf369428e633aa7e93cb1d7d31e6e3bdeff6685c518bac499b2a101c941c65ba6bd78714e1dba0423a5bb10b9457ae26bad05dbea02dc301240a3fa26bfad8724cefb4181bb1cc51b063a8d87737f12870e5d3d2afb77f9e5ccfa1279a48421caf6772da6725eeaf232d454bbccfd6d7a9d6ef3b4e4ed6486659026156a5db2b9c335c5f1d59ef378d907f630106247873c7ffae261c32058e2d610c85d0981d640393f5aab402f83cf06bc41bb2638f59f1b067339c0903b07b9146e0f86964f2c45ffcef2a00760551ff11bb668921e6cdfaee3a03260cfa0464c9876efc18566e5cacc34243b6c9823c0e0993f881999dcc92be9502b69c801594fbfc6e124cd44197e8e7ba8cac94836befe9cf04544b990b0e38d61ccc108e9417bba08d3e30af925c7579bb9dbdda83c7755a4faf30778ccf904d1568bac31aec2e18d86df261a0146608bc2f0bfd1c152ff857aa79232c34d4f1d67e186f848f816ebf2fc75508bb4e4e0ab56fe2e9ad4816ad62f871a4bc0d1bc95b5ab85ac3ad565023c0d690900c573d39380571e79fd7e67143ec229461789b0c5fbaa64052667528b888adf1664c36bc9923f2dfc08274c199e652dadf05e7c4edd922b49ba6eb7c8a348603de1e3d43ae4d27bcbf3031d3ab7b65380c69113c10af9995453523e538f75df783ed06a9c46a87f958ae819b88503080c0141e300d5a3701dffbe7d28c63d74f8718ae08a30d74ad07f9a0cb7cf89efd59aed73c47f1a274c22d6142807031a2ee7cf527255bfc5d4e401bff16841048f77f18068ce864561ffd3015179a398127707e4e4fd11d4addca55474225f7e4d0492230d61578a3aad0f572fbbe8d015d9078d4ead188b6a1d710f36fbbac677d1a016bde88ee0f4e697251931e7152257083092f42edc798f01674079dd95af3da86ca25aaa0bee06d3d2ef51164021d86a50856cccb84abf3ccd497dd1c541bd918514c5aa1c35703859030ca1ec18a521aad675f66d46fe4c522282e2de1577677b847d85711d232be0505c9d85eae5efd5b4165af8d820b4aedcc8a9784238bef8856ca48d6e05b3d44c1445d3f319738d7ba4b64d9175a42c244bb07536e812d6d952aad7fb9d7febab432e05b2718e47b4b926ef79b3f2d3d0524bf0fc3577171f0ac8c439d212a62a3035c865f1f072aa4457aec8281d1dcf58f8a3fd45c5f1d9e1dd670993e80a56ff3224848b792e16495b74659f440a848f93729d703ad5d4e0b7672a8e7faf1eecbe35abd1e2e9213aba2fe8be1931f52cf865bf98a8e4a4c9c3abcf1bc5f48da86915d3630417bbfba21f305fdc0049408477d84ea9ab7a38bf7239d380ac4136edb48dad568d9fff53365207f485732896acd1d64255811bb63c018d078f01328e6747e940ddf65492c46c97752ccac95db1a9835b3d82992d11ca55e22f097fa3bf75dbf5b8351a820c2773e57546acd63cd8f7bc5a3ac0edb4d7ce8a93bca489cba29696358ce6a080352d15ab6c00987354357f689af6498b126f038848986d6273560b8c98f8956dcf5c38d5f5bea9508c5468de1611a7f4d443feee0608643eb4e86cde975c5aecaa8ffdb37e10f87a7e5279a1d9427eda0da035fdd5c99a89f17fb29ccffdee3880de852a186bb4ca917f9f663afff0be42e623250c0a8f802e57e590c85219739f0e5f2f66f551d252a3a5810609d24052fa1aea77ff1034b7148b17412ad1f92d8dbee45043a2e9015cec74b93ec1e838ef4c0f6b7c4366f98340e6a06b5a22a62b918415d5f9ffbe30f1a9f672b54836c52fc6f98afcd1cdd669576dd3efdc197ac3483a2f8b3f28915bd7cb56acc88b07baa7e0b73ed82b836aeb80d59d2a8d89f5d94fd949033a1fefd1c096f40c1e0119ef81394701291476cda324e933b03a606132cfbbb5c5af21ebe942ca299823bc25f8d7b6c9655937aa81d3e9b69141de861502ea66215cdbf8427aa35d4340ff174cc1769c5ae8df8a9bf32d9221695e032e1230290598d21af9894b0be4f5a8db55873136bfcffa063af6fa41aa4c9a2b49144aba76b9cfdcb360b5ff52bd4e0c9ccd6901722992b9cbc2ea8fd1858f80b8e94a9eb62a3dbf28ac90b7e15e00265928534b5937d74e67f1c99889beff310258c8c96f8c70fceb8332c3eee5447dc4851327a33734b1ceceef889d22953acb67eaac2e9c7fb0e0e501ceabebcf656d8a44a94bdc4cdf5c567c880eb9c12ff271737b37a567e4832eb18d09fd1cbfd6b91481353bc9abebd01b72038f145a3df76a8b5c6dcc083e8351525da48e43767b18a3ef125a3115f7f34faf41faf8993d5cebb2cbf9a9c00beffe22ff8518cece97c08f98fa514437d7330e3933353a709af29a8f1bfda2576b976193297a4054d561deb061f1493d5ab1ff1385dd678558e204c60089327823ca34faf4fe07f972ff5b5743e94f08a1125c739eccae982258044009268c621809d467ab171b4b5a95bb09539038383676c6d4c6945fc510ee655c1d79eb0df523244712989596bf04d895fca3507a3ca8ef0e74d9b419c3c9b793caad6068ced2a3a03252046b74cc22551ea50820838cd10d43ff2a21ebde2d877f84ff151238781424cb96931d3a0c4f463d8409743b9d5b35145064c0be37f612d663a58f9631370456cc6b55c2ec52ce8b459deab940b75cb11a30b0f01db892338459bfe94e8f7df62ddf2418e39d14d400c65f6ca28039d988a7d1aa5942ad95cbd526a06641bf9ef06fad4d1f43fb3c1f2d1d6a3625c4bb44fb2c418b6650b31b2abd25051d2f325a3bfd1333956166fb6fbbca3e3e40ae9d5363f39f502898b3bcfea0f7dc7810a01dde5769d4e4f4105c00d161feeadc1ccd455fdbc695163dcdf13d1b54d33b80c83a5712d3c7b403d935c7e28c6d15e29675372ba66e3d0748006e5167adc4c0b5252024da5ec2c3e0561e326e53384cabb6a9028ed3fe18e3cbf633ed80d37b2c7ab055830ee14bdc4f209d6f7d586f5f4459960fd5554d4617d5bfa292921ace7297fa79f8d96057dc1ad1ca2c47d2e21e7f09e2796fe53effe4666f216363ff922063747213d7655e429b050608c888d0e06c07927a2040bc0c911e47864c437561f24f1846719ca8e9203c46ab29ddc23a3876566c7baa8fc12e5b1b21360a162e5d794dfe2cddc9f09508d275202b02f3edac13e06a00c58b98e86254de9a5b380fca73b377d05b4e231dd60466033260f4b719d7164ac96bbb26434b657f9146a5209f06ba92fef209eb6cc65c54ad0e82341f662a7d547c2a380a0e2df9d6ecb3716633c0dc387ce658da50c7d56c6ff65154cecd83eee8a4e357e83cfa35652138b1c49c299194487775222b2878dcc471a31c2c11f189ef001079f55aadc578dbcbb2680814e757449d08bf8b4ec149ef0d039ab5cd73c5f7d0b8ca2569cbf312460b19309c48c03cc8178b7d4d87db8ca4a3ebcf65d9685345e715ec209dd483affc1f14e4b686e4f22f6b622bec22385bc435d6b57f99d6b3a53009227a8b7b085d0b06f350aa255cfd77ceafec0cc564b96aec0dc001d11ac7aecab1dffdddd116a5773891dd08d23833396b533e4aae29c707fbb2bebbdb90fcd9ef2b3dda17a8ceac0fa4a1917d5ec565cfd60b248b826d265c6377c374a4ed99505a914bea3bcbf8040a0125f0f198e73252ff4611d4e5065eb81b5946ce10c79512f40c646a83a2b14e41c58b3c5d0de8704925a4ac5326f5f7b587709847ecb4ccb9ea89c889959f615c31229ea3e7ca46af797b9eb890e2cd296f9d4586233036a8fa8caef9b551b9912ae72418a176e43abc8a8df21fb13f0ff5acb4a4b4655b7dc701c7c18c696a1189cf52c5d7bb6543a1af6e1b6c3180c22c9e4cbe194e3931c65b2360ea0f7153e9840243c6298c2d30783a7d6ec94c21f55b13614a761a8bce154c5e74d834226ae6dfa685df088f4d51c7e276e71d95539f2d57eb671331544ac049c95d956a9082fbc61969afddc464b9bdf13107e32e41c518b131c8fce0fbabb7ae8c45e26364ac26e19f9b73105b898c7e59265c9c18ac3a587d6887069fdbafaebda9a79ae1c50d1e7a146a0ce63abab3157b524dca79242e6bdf869bc342d48abb35e1abb15d90fbb23a6937add16dc5defe456e0df0417b6062aeef5108e8d38a78a1bc46bd435f587c168e666c55e89df4683a23751c4987013428fe379d22cb6bbd06e6980cb45366193f57c6ae6b67515eb0402df6396b64e9cfe3a703ff048ecbf3070a885262a9889f7355ced0641a17677f179f3f79f778e477c2a3bd3dd6a87f12d43de60c6c4c187b4a7fc395392be303381539b401cc291256d29503918360d3a6bc398e9634b4a0fe204eb7d48b9791676a3f949013239f2b49f0e42f1f8fd0577c227c7f6e09aede9c382f182891513274064565334d4ceb4946b9188be0a93933a4901ce06231e5939bc43170aa1deeb5daccdfae5ccdd28c73ba243f39c2717e524778664fad234de248f0c9593bdf553a2f8cd7209cd41ef8867f9566fe5ad9717068d206cfec188f379b12fce13d7f0a8ebabe71719a7221aecd79708eb6d60fd3ff8eb67d5030fb24d2bc9803102299d965e96a2ea23890d251a8f5308185885d3fb30edb14e2944e64a4df5f6276176ac75623283e3ed4e4cd99f5edb5e989b7ffc36b23e736f6f4a98c77abb2b7d4a731e9a9e94db51894d715a3a0b5f1bbc2676d12a785c9958e4c57c6348f9bd66463002182432737825019747f2b56470357794ab4b9ea4cce133d22ceaa0dee2719ef3c63784574bfe82e9987c7c0d26154dc06c695fba397eb415902988f7fabc835b4838c26aeb9089430450b141259cae58f323415b95ad83248119952925e321af74a0d207f56afcf7a76e15a0dd96f566a751f28f4ef5c8b719b61b5b83715fa853c7edbc6b286dc0d53cd0e9addcc4de0b4937aef9a7faadd95b20675dec2c6d297fdf2271e26472e48351b72d4d558349c63ab46916a6d6dd57f47a2cb9c4f384a5d48735053ff2450e6485a394f5947033898adae2f1ec33a9a93fb7dd1e16f843b49a672c25c84a295e55ff97baf0f5e925d1bdaea213e77259ec54baf4a24df666ab721bca5148d647823039fca2774820f67a90efdce136757d0c40fee232c040dfe10e7a758947e0867338e170109dd317a245c0d72baaa3e4f69784c50df0764423a4e23bbb5fdb990e4cf4d7428ebcfeba7a5cafba965e61ca72f57353ec915f4f3dd3ae2aa7d4fc4fee895c633e33f659df92ce8cddaebc8480d6f6662c26540a228b0ebd06954e898da4cbcbc85d2111bc39de61185d8bed282be25c7335a6b9594d14427a6e54ddb5e70fd10bea695de4385306f84614edbf8652ec281ffa627a01543a64b8e35fcb6c17cd4678f60dd1da580a1cecc85a610715e715f6017ae7d55c37208078590c38f5bb6d6817910f2329b1b46d1d2df94cd4536dda08dbb14057710ea4cfa1b59576659cec2887c2d67c86ea64a3dcebcd82a58464174348774c688fe1eb698f0e79f5aed22e1a03bb416b28ac775e0851a305ef7bd252c2352b3d1db76ef56950a7fb3f3bcdb9ce1e19f848dd8eb5cf2b5d84915afe5934d6e1e6072002c66db54414f2001dcf98dfc81257f21a6cfaaef39cc97719895cde7b74d3f18b7184dddd171268fd07b524dcc37efce3c797fde0ce1a42724c63d1846e73813331c5411b95518c37ff6fb4f8d72639754eb4b8c722372c34c006cb7cacac078335d521120e60d6fa40235e990ee3cf9addd1031f9c9267adec085f8107cf4a2149d6da6e23004b3a444e89bc2c5614f5af914f66c3629b4252596986da9e0757c7e1f2b0c85fef5edd99b6e51ec27a55544645326c0f33bd3d8d157a69c4a7372d4c4cfbb37195951c2a320f3cf36976110253e4a87f55ba10f36311eea08b07d18118b40dff547008ece346bc8fe403394ef8eaad9b37eb8d2e12baddad8ae85a6a0a5a62c4468d95b5b64c45ae9cd52bb19ba97969538f15476d3ee321dbf49baa77bc2e332e43937f90f2ee82c79ff03acd958eb38573c74319572a794df0fde4269da1853bbfd33464084e41a2978f909d572c7651bb620ed6cf2c4ac93c9418639965fb977840bc2daf03b50ab284f808ad95d2076832da477529c8e7634fe1ca9b24f1d31b13d1a573cedf3fe97005c0db6b9bd6091e34b8abce76c69d066522cd7a5dd9ff758e8e3a04b857f59c97d9b0f2e35600eb16f94102eb2274ef27b747aec5bdf4333b746a481eca358e11e5af9a56766a5873d3917613d2b26142896392bf80878150f6383494b2928f5d69d74efed78d5f1750ad6cc0c2f13a694b52aaa0405464f6de03de7525e6d3c8f28d69822a44c63ff781fbcab7423007c226c4343fcf0e1ef0ce44bf8f7b725642004637eed7a1c8fb0ed8e778c25d35b3f98b6f967a33cee0be14cc1b7821a029a5f3976ff35137fb5e3544760975eb1c1f432bfe3c828dd0d23ddb95f6e8bcfaa43ce2f9ac6ac88c8fd4ccfb918a8ceb1f0e02044c6ad4c3f8c5e710d88399edac615f70365ac864ecd029be035fa24898037ba33c73123837e27eecb4a727d33948fb5b24910f2ada49a64565e5d1db77f337cb3a459835c10ff19fdb223fb35513f4bfd23c5909aaa08ba70e5f437a0c6faeae47b184977a8015144321d689ff844b0d12911601d8adefd6c992cd368e9da303b456ff099cad7a02cee9a87599df0c1eea7f150789648b0c9184351ba41a2952fc14dfa5a88deba800077752026a4d8d1d98287e0478cfa167dec2a5e2f83c5f529d3701f579f1b4033caa8013861c20eb227c828531dd5926b6fb275121a6bd22f5638b2a7e84d18018dd997af5bcb3040bbaa702af0c54740539dc27306c85f33856ba66ee154e896a6c8044e21db7d66481fbe2313285dad49f15f3536b7f20761b0ca6bd13494bd1611dc003ede234acff57c2de6f477205a349187767f58248a8f9df1b8e281e3f828ac77dcf5c2ae13c23955428639c80db8a6b3b2ce4f7ed88e98e033be2efd8e382ea9a27943ee4f2e344f1def8322db511b5b0ab548336fc1e06700ef74d44f057bcc003d048d1072559b8c0c8cac34fe1b487b03d017e21a7f92e69ba4bc1779fe279efd3c4595f997a54ab4b25b67b69476cb3b206ccbb55e07ff0ffcbb4b9a93adea531682238ef2e04add6341d13305b4a53dee55e109ecc6b05b63fcea34bb5a084a950b31825ee4934a3e22990db03fd74a28226c9105c66ec1ef9d838a6acb7db7bd4dc721dfec50b37df95594936cc772116b9116401739348a85c2e81abc5721cd58c014525835177a748ea68a341a17c05cce51bf6738d1183d6f0daec6be97565273475ce0e1e27e0312b546d9bfbf56faaf54510cdfe40951c9b9233a8b1d6fe70dff7a1ce09ba913c186b3142822929d266c335a97fca4ad43a4e4acdb3c65fded741840f05f38f9f8902900d2f83f91633746fac4e4a76d1159c869d4d8a1d4837ae5049ed8be0fb9dbf5e330b99f8de3f4100a43e1f5b0ff130a132f737cffc2413476681bfa7654deebc6c1b76acb893f10a96dbbe074e4001af8b907cfdd8eb7a990856c79ef2ca2a95fc63a327d8a611f841fc231cfeca1587e8cf5912c871ad342cd1a41ed240dbef1d961b9f3b676444a70bd8e75774610a7f2400f311b7e4dbf57e0fe4e4daad39efa9288742f1f6a66b9522a349f1643e614faca7910108bbf1a3a61b6cb567d314b079754d74eb6986fdc4683be46b63e6eb08e91416aae4448bdfc89f4824e36f5645ab6e011c04a15ee8bc3f4d8380d7486258511b0ce79ac889e5220b94884fbb8517b4fff98e4b2ea80304eba718193193c774379488fb6c5621f1e7d47299daaf1236430d75fdfad92b76c1aafe6748ac819145d8e4f1d968366e8f273b1a816b2d72be1532187f0f3e30c3b8127c63ec4490732b5648907d3d2fea610c85f3aa3ca2f50be086de63c11b0270b32bffe24725a017e5b2bc6a944310e6bb461cfebb6a4a2a5d5930725c5d00535093d23193768bdfc0d7f286702f1f381ae785aa56ecf9f555c102bff8d02c06da43ce0d6a29e4762450982a86299f5958adc65b8444f7004de98adb2b13d6ac37459b2583b468293d713470e657e16e01edb57e89c6a0c881c667ae2474f46724ec12d6ed7c0fb95cde836b584f2687437bb23c8efc2725392db6efb2fde6d772b7384788b4e08facec10c1027dbdf8a8ac0bdc8d965d1dd52287d7cbfc4ce7856c90844fe4f403cf371b38a316c4065b3cfc2b6b0d1abba955446d51f9cdda7454b10d8831cebf6f3b189e6e25aa67bfdd44c742ba81824ec1c02ead9bdd24bddbe80019491afc5fac180204f5bbd4f771eeb3c73e313dd2e04d2f111affdbf441cddb0e2542f5298d372b58d199ac4d588ec3c1c0ebeeaa557cc05c14c99b896f65a32876f2d7a2061471c7275726494b59c5b1adbb0d360eff8070a01aabdd64bd09c4349843402f1eb4c523af223dbb2a3a3f0c47910bda29a51e29b216a2233cdd0dba35a9c893ff9b19c12f5c20d3f79022a7a9531a4fdf5da5ec4346ee70a27353188ef951c988cf2e1cfaf62acc25e55219532186477ed93987a8353cfe897d43a134e857d579647f95bab88cfe9e321b8f448655592b950db632fe56774e3321daea916dc49de888c636f277ea5327c897ad481735584d3f96623b0b1c67bc4c75609613139d6f5864de85f56a2dbe140b046c91430ba63ed26bd3591df26605e1cf1bf1421eab89ef9acbcaa27c5fc061b9c7372855c646c3264d57339e00127197255c50e45057b9b202423958595816635f44f299e73561d822b8459a4ace6dce80079d34aea945c3604556b4875e33ebc1a0a60ac48a3f55a9ba9b91a994d4a68dd2f674e8b2a38d4a882798c0c2245a02b2db6991867ca5ea2615bca33993c9e0341fdb524751f8ca471e82f28488c56ad71f6af8371b0a419cb10306aaec63c32fb1650288894a504e7716221dd6a6f62e334ede0a7bb68cf816a8134aae2f53db1fea5b23993a9138b040617292d77343b87063edbb1ca3cbcac7b44fcd79bd762aae02b280ae3bbbe2393f66c8173ec88068a6f768318a378a46497b01a0dee649a3f4d0bdc28a9d4d8aa9042ea0b0529f10b92a2d51851299b29e74a5f3d424ae2caaa1ea614a2fcb472c37f8e7022c5e4821441c7f7636a3d1967d255ec7b2ff9c6b12c26a8e6edef6fe3d3eb951d15b6d9d419ee2b83df17bc9ccf81177b189235ca891e824288cd508f3351be80342ebfcbb7eca0e665193286082c4acbc773f36941282124247db20d75768cdc145dd0fc5c6b64d0e799f558b7d9db6ee4f579d94b450f7c38605c3ac6b486cc71eed087625f87991ddda5db3a285c62394417963a68d1728c105d7d43df2dec1cda826332e18c5c7ca055609a2430228a14e9e411550bcab7200c68218d0482be897dc8d74f795359e5da0efdcd879927c49401e6dc312830504254b4e75c9fec9ed6c3756ec0a9eb80108b2999744fa57438c042915ff1f1d6ffcac6f2dfb2c8918228f94a0fa7d493744809e224387939d3a55c79b0a5b66880c88204af5d1e744e4f2bdf492b0c466656f11c30e2c9108a0428d58d9f44c7773c3f51095b120a681cf74ce90042fdd6c44c45e7165ac53192509dfa3f48ec09acaf937cdbeebb9f54a247a7238a85e0ec0a77acaf3667e413f03eedd6685af8404f781d3de76438944db4065fcc53e4e6f08e5a63e96131f93b53a33eaac78b3271d7bd2fa97365c4551684a60d5d305a97ce24aee3b94e832d7fa753ee4bb6b37bdd46845b636259f66948e6bb8427fe3da46a2a2e3607a6335ba42e8e4dc75112ad908136b97ebde31329cacfe7790f53182c306365467fbd35d1ac729513985a4be2bdb2e9374d99aa075be0c57a9382196b2abe50eac90d47f786dd647c587c3172441c0dd293c8b41b96bf7f709312ec8ced413123794f03f7f2868a60e73ce4f9765e759a3d93ca034ea09eb7949ea0f0bc48bf04d52ab95cdc4330e65beb55c473955f8c11b09471dabd3f4f08115bee49f6994e3d787415651688e21163421d82dbfbf2e2143ce4d53eed476fd1b2972c6234d1edf2d629a5fa07fe96fc0a2fa402549df269eaaee9fb519f5406ebb209ff5444cccc38a70358f49d2d9103462ddd5f90b24332461305da6afe72af3674d3b5dcf289c4ceb4c3e81acc66c148a275768e53c21bf9f2e86d877913939b7688356c71e08b74b10c0e5962ae04c1badffb5ed7814d97b6b29057c9cf55d445ab6650d592230eabbf9f2f73a151ca2609134f0f1b7452a6ffeb6ad452c685d77ba9dbdc758b19ea961b9059e065fb42c3f69d0b330e5c45f1a00c242e4f26b643e32f4bb7395eb4f7e25d5320f668d2bfb66154b37d1d77490c7243a222d716eb4a5f87a99d4f6ae397f58ffb558e92a58a9eccec6d01c28d6b5f7ddb4c64b8124bd5f09e82adf7ef7bfddb28b26bc1f188dd50bb1e6e450ca305788aa1703e14cff5d02a1dc3ada307056bc9d7a44288fa9b7560f48da497d1d2f9f57fd401ac1a5600cbe9adf95f3fb2709dc0fa2f2b2305e0d7ceadc891acd00932312017a4552c7c424451db7ede29114cc690c0777ba0a9e570b0e436579d79970cecbf5f890338f863d6f766fad19d91f705cba4e2b00c32731ee240a1b610d53f755836d654e25988dd28efa7f21aaad0e2dcda104e1c5a08f3a8212b3a6c35f24c04a572f0ce7c9dad70f2bca772ce36ca7b5d130aed1b499ab6b73963d4bff8c9ed802c8116af541245931e18e25f4994a56f37c86ac37e8e34d4b463cf00efbdf4635f9784e0f057b31c11615da0a277d8aff86d5ba4f7acdb889524ebc77071263fa88631fab0233f02682a605f6b08861c0c58cfdb7781ffb440ed78e1872af9921cf5abd45f03488ad6c911e83717a00d7932002286e771599ea694634f76002c5d789439f93c77ca4b28d44a9d26b9c35af6c53636ea97339c86a9dd3111fd7dea7a4a466bf566d0b3e53ae8d504b16683aa0eb162729a8e66cdcaf55aab955acc2a77bd4d1c6c3f1eefc898181a4158a55e425d5d90f66bc42b25ae0487e592f2f41e4c685fd6d19b860b3b3a38170bf1a02e21ccbc2979d61fe3e8b168895c6db40a57c65e304261cebad6af7e7128f95ec4dd111e247fab824d5a732abc26f8564880496852d4ac17da846016b7c342e34b07ecccf03c0a95b2423c945dd2cddc020e931ad0b02902692a39d3b03e5da93766e0963f299b3ae1026561ca654d5e6bb9cb7929375eb53d4a3995da701304622c05509acc29796240820bd7fddb7443a990e435e55c85c7de5d252dc5d7d741b11867468b8124ba40def58be8f92ab512e604fbae5ff3864461d6dd5727452b7dfe6882b80fbea7c9eb689ea4be238bf31dff4e7ebb0816d16271fdbf3508a784b7cf724710f16d8f785a7cba80e3fc3e3c2b6b8a7f879ff35b229b662786ee56ad626ec7bc9c748376525ec77a466044d8c547920d81d5933dc5948cda69ea4ad65301f090cf03c0c4761483759dd4f5552de23b4e85495b72170e9846e4eebd05ef845d34d9d8f2e9bd3905b68b6f9ca7b96172ba5f1a071a42089602129be80277de35ecbc961e167c4e9b0fad32a7aa0380d3e128c80b2f8b3970203d190b7a09c9929837040ccaf49ee83ed6b8535ce4dbb8f54806297376d587d8f582fe3754ebbcf509b56418b1ddc2d34a02dffef749f7318dedfbf214c217826c79e03abc7b475d30fe46204f9943f4ad4c860ebe47e91c5a71c0d756a49f4236c7dbc89393807f943e129dca143448fc13d5578b3e51837f9d9f4f5043d2b3b9d23feb2b452023fa9623963de802cec93cbdd569ecb2cc18c75763c7a3ccf48c94a4089b06a622c4414151d519afaafc496f7f953c6ec24e3f96fdd06166f14afbf0f6a9e531415007c2b4e3d370d9c2c5e14e4071942024d89c7368f05b4a51ed647c21beb463b7553f1d5eadecff59c8cc6a7f952e52266f9b3b1abe847bda0a71bbac3b1632ffd258f782e2361f4b0d320c411cd049fa2554c4027f5072ea727203acae04766da7ebae29105d50218e3baba74365365869646619154d4ff8bfd00953aa579c33b5c29849f79f8abefba5094a929e3f4ea57c3e1f8e8140cd359fb4b0d5f6ef9d7345792c62f0ea3227c562b77f4a54a2adc48c833aa39fe8c6a0adcd0856dcdefb8a23359767dfb36cbb24f09adfd86bfd533376939cca530b9307cba6efd53bac42c6afe432f4172e9c4b1ecaec7e91b48511d49c4c7f6da4e5151132a4debc53b205d26ea6106f8cffaccf0cc5027aaaf1041442b73a3a563dd5b88ce93c621a63041a6bb45a4e10ef74cf744cc3256a82c3f3ad2fc54f4dc34cc03f1650d0fb90902be11a1916601032b5c9e2809ef728583b2ba26e7218e3812a516ee83f34f0b0f9edb7b5f0ff620f2b4e79814fd7da1e9ccf2d5612841d7d9c96629357c9e8bfcad37eb2403c4cc5f4f9227c4aee63d0d0abe0f9da9a974175f697c4e5280c5dfdb1c6a39fb3c4732714f976fd69379c8c566eeeb7ba15cc1aa10158bd6644c3460f5c5d57c8619d63445e80c783aa48eff288997e3369757f62512334cd092081b16777d2e666c913618c6a6f17285f2e97cd5da4373290adcee8289caa6e691108c8c74a875664f166c557db99c053901ddfe5d4497d04546c7dc6ff216a3eab03b9e0fd52ee471a1848520eff0adb151f02d6b913dde8cd471a427267e25bd91367a97840f8355bf974bf8cf523e43d30446758f0a898b60cef866a171fb4ac5fe5ebdb9e61b1d1c43d5b4ebca7cba7ac3157199c8d78181abbd59ecf20060dbf4b350328295d7bbed0b7394abb6ff3b9f930e03b9e5dd6fe905c1f395087880e59f6b19a48eb4a27dd4c433baa50fa031fa0cb86f7edf0d794c3d81b1b9e8f824f55563c92f2fe2aa9d87aed164903735ba747a4a9c69bb82be055895e96199fa8e2168c5ebf464fb892fbc5758695961179ea6dde1b33f88e62ac5996477676cb91541d5c84414baa13950e3bfb79b569d8b0cb19e014e4c9892c6059a7d8f320260fd9ce95685b5dc6af6002031c8a952ae1b5b9852d62d84db5088ccf48d6480bbbc26cf72783d0d0788e6288363a6d6321fdf12b93f5449e53f2181b1e3c1eebbee78addb554fe6762fc3a84a36e37be2ab045ffca56e6c92992b0c8c3454c2b105ed8226c3ab0a5375eab56235f0303ab722211d5b472902ba888cfd2467b4baa7adc29b1e089a8bf97c97b644d01f49a705f42fd503b0ab3aed1b153ef76514cfe12ebf45f069517a08862199a73cd4af0a304252721afa64e1fd90c1595ec3abaa8cbcd2a9b80afa8c7704ae103f3472641394fd5a5d584b26ff65c6ce84c922803f10dc94e07c7ceaf9486323c31ab970177d0565a761c1c1c3f3bbed1347c685d09ffc2b9ddcadcdf9ceeafe5d14323ea5709a3c4386942a532dd4d20fca32d53196616cd2c2e3fd83714c0b7f84ac0b6970ee5d86f7dff2fda328fc067da0b867d40a9cf8fb84698b657d2fa7195355f432dc200e38b2fa8d4df9a64f3c136b258e09dec07815f1fc1b6485a3417f3339c37fffdf205d89f3e17bc275572d1ac2d0de0c54b8e5635c7c67428dbb9a4b14abf810a9fa95c2312a2f252e0a629cb3a0f6d10b4d994a19357aa0f1449875ce9992cba087b92d0916e5b60e33b08f4c1c834ed1807e51456a3eb05b95bbf9229d412e61ba64b93e56da478515890f118f4ff199cd0391ce80b8a507d3fd9e5c2d7b25db10da3f9e29bdf95bfa84b9a1957f6e5f052f7d19b1a9bf795eda8eff180f28b2888e34be615f04e51fb708ba2a643805d72b43b4e56674c66e67857e342e0230d8e08940e5de6c8eeefe6e915f59c346f3812e4d6052e2f4a583104e9e1af00945d61a43dad3bdb2503fc94cc5c617ec7f05415e7251105848b984fb524d60c0b598c603a0a8eddff2da095e8f7b7309479bf234b67d33dcbc4b61bc89825d16447158fde738be23cf1323cdb1f39048693968c10026ecac2b39130de2cfeb55123cd88685e31d71f6879b10017f9e72d67585c5f401b495148d06e82e79093410b32e4722cedcb665b02d11ff0aeb52badcd94482660aa17adea7c90c00740c8c7cefb5d8ce516e8cc39091573454217a951978ad440aaa77ea42c71a6cb5708c1a8639ddd85ac193fe192ec55c595d20b00ea4e7a07bfccf93240f96d9</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Vue </category>
          
          <category> vue2.x源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Step.12 vue插槽，你想了解的都在这里</title>
      <link href="/computer-science/vueyuanma/dosc/12vue%E6%8F%92%E6%A7%BD%EF%BC%8C%E4%BD%A0%E6%83%B3%E4%BA%86%E8%A7%A3%E7%9A%84%E9%83%BD%E5%9C%A8%E8%BF%99%E9%87%8C/"/>
      <url>/computer-science/vueyuanma/dosc/12vue%E6%8F%92%E6%A7%BD%EF%BC%8C%E4%BD%A0%E6%83%B3%E4%BA%86%E8%A7%A3%E7%9A%84%E9%83%BD%E5%9C%A8%E8%BF%99%E9%87%8C/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="0d880c02091dfa6f5e89f9a2bac2df722c8ed150f4ceed1e31bc68c570e78a46">5808c6cbf3ac08533f2dffaad5e129c1f7677efb1b6b29d5c2835e6dc7760586107c8c6a99601b717e29c5a2fcaf47d1b33334eea4ce13decdeb59651b06452df901530f1e6f97b59496ec0234e037eb8d08b6dbcb36dfc33cfa6acbff84989f16e5243efbf0d9852568017a80e161d88a6b332af0fb4a6530745abb8ae036e75475ddbb3aed4a9ad125c5793321eaad14ed3873fd8aab1a2b473367c8c8a936dfcae97fc5ff30ea24a504cf50573b821bbd532730f0d1ef3c96671bf3c683643c8aca8ad2c3ec58f87ccc76842843631cedf3004fd517ad9f624d8410b43e749f7de291f8b412e983969efd7798973a6c7803d518ae5ff93155098392019124d4dc1c064e532f239ffd452fab120110f71a0be9eb1d76249e56b9b5efc5b4fab9e725e8a3ac3d8729b8385def5935b3d9f860ffeef6129863b0f75037b5cd38078dda9efedcf5121b5fbc7f5914492e048459c48f98acc98fc0b72861d2172fefbcca2e632d3855973f6e38c8faea0486e9d108d898d5ef54d4ba31924ec20c3e47ddb010b175ff889ad7ce1ea1d7358edbbfa8043ddb908ff92c3e3ffe2a2e463ad180fe9312166e0a08168bfb04ba41cbb554cc922ab058e3b4f289c42a4f431ba178aba9dc3504970bbbe08348751e02a59747ac211505995ca6602b3ba85728d6456ac6e1b989d25bb6f2475bba5601f1dd677964fc961590dbc34aee618f13317ac9d4c76608be63fafd27b49dd1894486632b408c5cfb0233ac47376752c215947dbff0e232eadbcf4fe515180a44283ad32974dd53ffdcd321b1c3324b74920bd86aed502a7f7bbc49f082699a91826179048443637169c20938a41b95c1b421ae184fac07731760c8ca9292b115225bde6376108a07c15061974cf28f09e88f28353e3b65eb3e15f431b50557bb7064b97a3bb12718b78d9f9daef9499f37601c42f7f8dd7447ba0bb68e50c9cffeb56b6f8ca8e6b4cecd2a82ca6a81c6bbc9907d61772d734fa3a64593943c826374b0a28ae01031c173452270d5a081caa59e0fe76df42c00b452a726f2d2ff064fd4d6a27cdec9e2629659f1a8e79c0d3b51c44c0d397b095cf03284fd5a12f1d41afc2243bf3eac84ea46594e82010c929933f04c9a5fd1628b331c01d497b9116be85ffcaa038a8ed24942ab2de1087b62470da4bbda43c5f1dedc219a31003bd08f235f9f7d2fe3bc362e722df15b5ab371bb20cd18088728707cf806fcb59aa0009f715a30c05c4742ad6c09025eeef562ff7f8f6bf1187df4fcca9bb6bee5ba9d1132aff8334226e3f4e4fadb5867d37a6f966a0c27887e198b50c6d1b9bdfc0f6a291ffc9934c028e5dc7e2de138cbc5039bb1c72ddad648332abe60806dc75589d4b06aa3caae7cc8a87fcb4b910a3d8d898a3b494d22ab043ab14386adb3a4e8106d5c9d53874aab141af742486a33c095d5bfe60b90496d4ea5625f154c38a45e44a052d17324f2131c6ad5ff16abf134543b7d92efa990d8838ae3c43b745cbd3617a68fcbf628b171a1a82da2be78f6c9c9c06b29f1cddac5795ea980d27e6edf4f6103630062de76f1fa93598be165521138556511e9c63a107f0de6e135ea93fc4d35f6c6364b4d25274f6bf1c54aa14335630f2b064e7d816a73a884734f2260c7643cf3bb13f9bcf10bc47a46150f045990199785ad0d6fc32aeee46af9e8ccad788aaf6aeda935ad35dbb98715d9c636af13502a6751e50ce48a43288c594518c83f0f68ffa4cbada2354ae27684a9e0dae84363078378fa31d3ee62d68367a69f645a844b8cf97531b0cea246c05a242d1b499587631be894867836ce3ac70b79f01e3532688cb0db181a753118995d1d600df993cc496509768ccf35232f17522256057174223990f058b086aca87b6d519e63b19b43fcf20d5488e83d6073c1032cae156bb9ce636fd7bccd105b8de7ad4fcd948b09ddc4065793a60ef495beb1bb07d3ec381701f0590e2a6166f2ef209392d795317445b0b79dc6a3dceb12481cce41e5403dfbcc6faa359df611864f7ede80a8e24e1cddc0e0e23b0c51dcbe2b74137e289c182ee08bbcd4405b4cc8a2ec103b2627d6874d3363edb4de4bc8d9d4924999e7cc7fd515b03b5cbaf36dfcda6621901329d35e43d33dbfbf6607a83104d04bdc13702ae05298776c133eb783dd3db2267bbf93d2b528819a95cf26ce756ae9d8133945a79e2e0dea34855b93a9ab9a96f0921cb72a703947b1c112245f720a723c575a4391f96e32d287afb8ea40a2736c37aa4d2e32272b3e9d8a1f165d5e8ddcc63a9e56a3807601365fa25d8cc9e870150485d3d668ba43e907a9f961b5c7aa109f0ebab375a2fc8be7c2110c9579cc441d0089698d8fb813ddf54926327f12ebeb48133cca758c4d05e78459c7f61d4192f6c0f49a5a40eeb4fb58749bea264d80c3a1ae2549dcfd681330bdf0b87bb3ab3ceca6f289654e8ab08ec98e552addaa61a65daad8b26fc2b0db1c373164a5ba43a2da8bfc95b721a4e017dd2b49df66a5aa886a9116e86b80525633a3b2e52a9a98e3720d4d51033958adc17f8e03d4ff4a3f4394fb23f1801592ad6c17f29913659d12af8fb170df6a5c099e43fc1a1afa6c4413d5a086be2a248e7dddb6df704d477f62d15bdb063858aae5951725c576437f6b152026bc49188e149551489d0b747a521a64a0fae773ebe67c944a4dafb70b2e4842214148b3476ac274631a8d7ba023491eb50931752f32a7c9cabb2ea071d23901cee7356441310077983b989753004bd1e17b13c45b3806aa7ef863be84e1463e9dd81dce6ef94aca7eee46ad3abc5f4f67d288744840ee4e87772212d54f6fc3bac5dc7198625dce64566a7b74db2a8ae525c553657e36dbcaf4aa332a92ed998105819da31b0ec94286a9fb6994efdcd683e792ca5d7da367d3c4f94a9116dd9558412e1bc2d36e4159ab6ba05aa255c5235ca927a7bcefc71d4a2537c24ad8ec86d491ac70993ddc17abcc93ddeb0aada0c787e26e9410f23b3d2f542a5802bfb7f2d565d56daf478c2541c001df9710fe0a714688a4200f0a71aec69cc5a5420fbdd4f0769d5f47fced3a0c15f5f7f08d402bba41d2328bdfeabb5ad55c94aaf0f9a61f0ac0c4ec392138e2726f78c6afa484b58bec1a285343465eca04436a40525d89e4d6319e27f47d6506577df6c0235767abbd9f6cc61e3c66c06d36b970e9ee1c2761a5ebdc7de033dfab63ce2a3ebd43fe29b056e1dd4bbb21cb43e0bbac68dc297dbf92f538cf9bfa54d0e27dc25c751ae797ffa4cbe1f09e9e769e8d45222d2f005ef16c1a7b6be22ca136c902d93f36ff41b6d07925cf7355d5fce364140096d6abb4d34d7fa1847e394241e5ea629d301d17e8123ae901336b1eafd5bd149ce8445f225be142ddf4daac31b66ce2698b131036a8a506f7c6102349426555890d9aa88085a7852be46cf09d524ff70f787ad163fe781cc913cc37bb04f0baa0f20875d7e822d43de42cd601d7c9497339346f4dd75c34294abeac5de608e639efcae5b680c18a88f76bcf34e769061653445cdfb887655c59cfbb71ad31abe347b4e7c11af6de9b809ae666bd47643238201492e80816e3ff1f135bcf49c6fc82f38d836b650c27ccebd6ef00bed3aac16f136499e29cd2bf22e52c42456b14bc46fd183a36e02e900b3f43a74f1c4062e70f21986780acd93cf63d89f06bb6031ffc07589390b6ff52356ee15f1ed41384dbff1778025251d99773a34b0cc0de6716c8c0a0f66472bec65b727d8605efafbdf16304a0889241a92fa8d5b3b22f2d2a0765a8fbf241d889abd36c6fa3d95e0b17397dbc1316e125a978ffa9742d9898be5a1cb6bc3d57ccabbc9c3cf394d0fe71d7508fd84b5078862af56a53c36614f861f08040ebe6d3d9fab9f5a7d4b33099575fc49bef7e7cdbcaf7e7cd923bbaa3480dcf190c9b3165c284b6842018969ab274ebad7fa433f9a6c65ace4fde06addd7d2949dbe355f6729bfd3ede549b40ef61078770186ba6580069619f3ef0e10a8e3067e44c669ee3e0e1f155065721b64c0b6eec118271a439f4b47cc665c4ec686b4676d2f3450beb73d0621656bd66f7fe4b6bc4b416f9870ff6a6d05cdc6ad390c5882c980ebf1475bf520c2c2cc3208ff5fea2c78e5a74a34242060ae5aab6607f2ee5113106d9106fe37c3471557a20486d9d550dea2f5a7f27346af5d2dd6c1887985fa6024444112651c2d35f5cb5ab90fc1a74276150f2811508bcc82db92dd64499689b74c772df99acc433959a02c4be7260c07d828c6774f79188df9b027b652eb148f4f0d05d4e092782d0e8d13f0601fed74dee821ff678eb0f87a129772df666c62cd6d82baad040ad7da253753b0c9cc09ec22ad1dca8351d5e0f83e8d8884f3bafb501447b787f0d421d62ab33c6fb84231ff4f89de8174d4a0e7c449a8f928b508cefbfd9a0dd7b2dbd1a1ac92a4f4a56a52c760a1cae2c612ff4d0bdf3e85b9436db805686a4c792f24a9ab7735868023ff8b9bd38fe66a57f0017b53da26bc0f85a874afe6e0d4dcb10151eb9d27047b0ff06e429483dc2f59cdec0652c5c649349691ba40ae35170e153d2dae9eac40cc3526c953c7ce5df4aa8ae5454a5363a639be42ab3f6571c0af623704d905e0bea0021ef09a001c0f7683b63ab2bed430b87f86456facc4a6ad8cfdda597f26804f775caa5804c27b26462008b63d1163e2b4c9abb969533de135c27532d85238d54d94f2f0e078ca62562a76838fe0a60e11c6de76ea658cff5510c8a2766c1241e6d4f391918af8ad5f1cff0ba4f7a9913996bf5621711037ffa15a64337305a16e47d2739d5bd1d28ab10a3a709a8cab7f0b8ce105133c83730037e8de5490946a8f33ab385d3c46674766ea92dcc8bccc5a0301f51be8d84dd902eeac015ecd79c4d236eced65d2253688670cefe2af1d967f69b7d3740cc1eaf678441abf6a7323d5d8a15d99937c66afbe4331bef6273602d3bde362e546d710a67353555ed7441ab6f3d3ca67fbc4cd98cdf0e72259faef30fb267d53fe3d0dcab7366f5605c1fa0e4ffdab76514e534e745a1f196cec3d2bd53fe837d6b32fa251187cf5856381aa59c0d363e6fac04771ac8b98a975e02fb92f50ead2b72120cc69193c4bb66a1f3d2502013a277e1f5d591366be7476a4310b1c1e3cbc716058b232bd1f7ae9701e907bf035605fc6f8b739304b5f1d879b8dbef8633ce50558dfce19f6b929c1246092451289cb3f1f5f6aefdf05a5309eea93d622399d8461b87413b3c8c3599668b7a0701561e3c2d5316d5739f5302ec1576b230fab6c373ba5034fe86803b9e22d2c84b34c8182fd5264e5d70ef32557a830cb3f7e2ccf36a7e9e29290c3f4e71806efeea32931f731c376ab81900254f175cd33c3b9848fde7e6893f67a1e89fc37de482152e6d5e6de1de6e5836f9061c39b93230d662b87c78b987059987eae886aad1b829425b6e58ca0472f7785fad22d3dfde0bf94facd1d35fe4aeb243a9d8390a7e12fd0597ce26bef2665d57dea0ffb55d0f2c95539de460c66ae161a6a79d7448f76079d3b788fe0d7d4d03499245a71e974c46d6332a6b441a13128f5e4b7b5c61bb7152a0b94ef7c4c4ee7510f42114ea19a9bc95f5d7f277dbca0c9a0d0cb191d51d57747e11b1d6f2bac5a0704c4bfcbaea603c338ce9d5d51488f9c29b56669c3acdc18d16d98c52cf49a9ca10ff71224b155a0a583e676b9e9120a16f18435705afa1d31c2a22fc3a82d32cf9895471d1b0872f6465ffbe313cce48b06922c1bab48e2bdcb8519ec934b3e1fd68b831624f9e6c6baa9ad6da0737373bc53c4eba309c9c9ca04051e80c1150c903a198e7dceb93b796b636bf592daf7be5384b2bf5965d24cb59dd32c2d7e18b995253f48b2f85ccdeee6a2b7099c76a6deff066cf11eb1e86b695cd4dabb05e8cc7b58e52a43fbc3c8327357b0c8d11c46acb90c45d619d2b349295061faf015e320bf60b88740d00a921cb51443b89ccf4f67a5753373b967e8e77b0ace33b741886a9e0ba91b0360d797bc2da8f0c5e487589fb9910c580ed7354e521fb723451fb9863868113934ace952f129eda5d796a8d04e290c2f34092a454318c7b66a4b8016b8c987e814334b0009c0ae57db09709603fa7fd650663193b048e2d61779f76084ec330071bff58834c77cc40080dcfa2b671a873b7b7c9551ec2f9c93ed5bbbb37aeb57a092d890860d69c7fb8beff357e42ef903880864a2132c98360be10466eb3fffe85da2cdd0e3be7ae16ae2e7b3f5191be5ecc71fe14e673211b02e2b4d6d24a7f2cf6da3d23348d18550630e3be71187c4225454b3bc12f55e226faaecac56636f3ce87b1717183f0ce0e87e0c12c19bfcecffcab71d7fdccc1a3a82b9fc4ece4dc670a2e9046df2c60a967679eaa6600ed3b26edbda663cb2f53f8c4483a2f982bc413c9b49615953779619844dd6b664497d36f002be26fc8256808d254b9ae706970ab8fe6b6ff803112f65d90f821872fe4b977d6d73e4ee9f57a591b86e4a9658adf72cf64576c4c80b9cf09ba481c0aa2d56d323d1b2d244543a5eb0cd4aed19279984dda4ba7034f27d3362e7968857acb24c42a8ab2726a94b98058a2b04f86726155dd96db2bf244ba7ff305adbc834b2ebbed51737cc6cee2b745f093a0fd84d87876146d14219e7cc7f7ce14fea4477f1a4851087c0e8b9c6445e4c2cc6215bd5df8e3ee04cfb5d2edcb503a2f79ad63dfa99ded910c857e9402725361d2651e81431f7e75c2ec29f6577e337f5848d37ec2bf8287b5a112b8a376f041fac10bd22d8a96af36ceb05fca5009f5553ff92a83def10c2aa3fef1620b29d62117df9932a89087e31578ef3cdf971eae4006f00715a7425a32a935ee02c27bc20bf86bf78ebb5d23cf1ddb70a69f090c9571b956cbdd197f79b7265ce238e597f058197e444cea4acec695a0c06e4c4293ace3cdef9e6ab8f0f85c8d225a4f1db620d6021d162e79ff240fed42be62150f85509dd61c94eee2ee5b807fd352e7a68743fe5d5784f1f2961246d7081364f334d28e446fd2d3261e444f2615c070b25679d1e7317883a2aaf65fcfe91b25ef0f7a0af45b900db2321555384546286c01de84e35ce92d09a260d32e8efdbe1e5165eb8beb309219fd5db705c0ef31501ae34144fa7e4beffcbfe110515d02100561190b59807f950082aa59163bcd657190b68c441ff407cfe21e1587ffdafaebaaed0573feeb50dda819acccbee13233ce09ea690efb4bad0d42d8395d0ef403655420088f91dc2197cbf731eab187b44b70c8144a04078a68ec62d2aa142b8bbeb16f3b369d47e7f035e266271e8c83a10adf822ef7b3b3da5293595158eef6d16fa1447d6d9a479680a8b5057a5f9528c6db5fbde2451091d6292dbabecbb8ff84186d818c4be9a9ddf72a5530846776ed57af6d1aef8d23ac4d22600ddb8dd7d6487c3876bfc18c3a41a67b92e595656323deba3aefe31da5d55e3473c4b0574e75739f4ca6787cd83a5100d1aefdfc86b12e3a24e5e4802d52857dda7c4cb79d63e80c4d9ecc46c6545653bc620032747f0fe105856b77d625c96df9d0e2af5ed0d21a228410c32b5b6668ff98d339cc2e07f2abe72bdcc8221b126fce62f0255e82cc1803be6983fb46a07854ea6eee128863bb4325f65f7b56111a92c7818c973df48f9846e0e3d107968864448ff1b358c1360d8cd1c6efd8989bc2820678e76a34b2629c30b4e43b59084a5472669813f2a0debf177c8ba19af4e026d1e0c9d8d5450f2b298c5b696ebda2b7acaa61ac22bbebf7f352a046a03fd209cb6ab5a96ce4ab2036d83304fb7621a8e7c32587ec70ca2e3b4477bafa5b7b0c9c29a1d86f582b6141620995b21eae1f2aa9e640db0d0a80b3e9e9e3e661db72118a958f6914bd22a56f2a3e54f6bee14708f2589a73a4f6fcebc80ea1d92ce9b23b86664f4c72d70b533a441e0e5cc522eeed7c7958c30f5e820710b99f698b0a8abad12a375dd00ffc247b180fbc16bc341fcdc56938324774c114e94151ba8f4feee3f6e09535ba0565208c1db2c50e171929df1e2c7380d19de914c9a2a95689f067e414d1e0295e5da121852da3b62f6a06e409f68f1c78df5bbc7e44e91651949507f90ee5229405ffb8c21054c7cd61a40610b0b247cd6b0f52c45cab7fecc10519e95e8789922fae2c1323b955a9f3614418b29d069061238cfc09429f81f16bd4de7f48bb85fd444b6d759440d1ec7feef2aa5f1b7b52cd9bec176d377a0e19bb43acc10030457a523d1ec6e9f8ec0868e5b26850cea18f077a8c9acbaedcd274b4af65e01711b62a39def7319cb29ac01847c99d1137502d9e40b55d4b7c25a1f8a2c3bac804af8a94d4b94a5b941e898f88181607a62726eba7e7c354cf6c277eb3a4d84101a840769640bdacb664fa8d903bafe195498151159cd074fcbe16a75923c774c5b6492da58985da1aa82e4c97430d662af0fe0470e2a5f79f0674bc02b5503912199f1fa118b0151323c2be034c1f620a11c8024c5e766fb5504bc96768440be97f36262ef3c878c1ebb279e8dc5ba31ebe8d46e15b733fdacda980f701ef34296d6c56715df657683e75adcd281a0c77a3113ce55662a7b181f6e91f579ee32967985fd48f3ef4753700a9c740a19b567501e2db5eee3deb2bee076d94212c6e7a71d2b00da44c4117fab9953e99814921c1ebac20ad9486eeff6a6a6b7c8a9a7509f009e19477b4878e5b3ee06346a3c17efbd7680fb4bce94c88a41adc3c049c499319e419d2a03955c57602c231a6c2bb8c8fa361f31f37191fa15332d9b0cd3db3005febaf22cdc418c71f2e8d552ec3f681efd4d478d655f3bc40a766897c5b76cfc4f1a081be38006b6c6cdd4e9a73ea284f5a05006d875f4d7c6a03b68d3e21832c23fca434af459808a3af69d9dd34cb84695c81a5b7a9664e6ce3a461653836ea8645ca28610e99edc9251af0d0ab29a905c6769da67afb5e3429c49e6f21d7ad17f087444236ca9a431a5e331a7c2b89ded84c5a65fac31a70f34d903bc08ad04eae79dce5d92c4561b9111364c8ac39a7359e40a81edbdd8977942240d98e89893dc85ed76fee8d118fcf6f694d6ecf230bbef3801ae190bb715fc9f7221ed93cc4b664b7b65e6b043c6ca0d84729e6ab7b58f714a9ef4932bab2392b1d50b3f192981ffc15382f70bdee7a0b2c755cf8d785210fb994cb4094e0b4d8b565f3e5fe7064a473b2cc9009b956841ddedc80e74d6dc4a92152f745d793f3e0ea32209e53745f3b166468119f3dae0ab2d25d2711b6aa1dcd1b587d4a29d9982c4aea935e0da4748eb4c02971e2c797261a083271fc3c1c2ea4eb6a39f91345f2b92448b8125a6369bebd4dc767afc9a098b6ece2a9586e7eb4f900ea8cab578df494e5c7c56c9e0b47865f5837904b9198afb9e4ee612422172d9e3b43466285c651f06204f59e9a9364fd08270cf1eb15adfbdd90034021e7a729d595c188ef08a835c6235d612c46664bc469077d35ac8b12b14c182aa28c29dc7bd010505f2d276fd823cb04f43ced5d2aa9ee70475db429894a05f18d011ee0194d6eaafb31e40dc22f332a542d0f3b41a80cea530dc12d460a2dc6e65f4f0c667eaf0b6e493230fbb104fdbefb5d89850c9396f08a9885b46da2755257e86067f2a35e2f7e0361039aa87a90953466fee4f0057eba59ddd639a8e99e11ed38ef15ae083351923bd2d1da717d73213575002bfee23ccdcc5a08b3b1fc096ac6342ca78197b51b96e929b80be28979716ce5f29103df14e5b48ff442a5454d090cd0b9285c4743e3f5ea3feaad6a0b1b02a0de4ed1bd71192657033627f419050dd44e3454d68be8655ffbf06b98288bacc35d6a10fb44e0ed907d565e161fce53cf4a275d01b6118d13276c37486cfef5176f4b0b3c865406b40b976ebd30a983b232177a1f7c81a2a4cc0cea30001d282ed4ca1007c1d1fb872695250f2db81d85eb4ad087d96fddee5d228d22d1a6757b653193d85d60cc89abed3c80db0b952326193649bcb5dcc11267eee4ed0b65d68572be86e146568bc7a589da02a3685e7e3339cf8ae4b7b3168d55cc591d181e0b6471c371db9c7c17a18b4391bf791c61d5f20bb41cf78ae71326ed14b7806e1158d38395a5edf8c3c3ee6fe5ebdac99d280e29dfad1175b0c3f8c64e6e2287cb5151a4d3cca0fe688a4d42fa65929a39938c71d8964706be494bbfa7287082f535cd5bedc8807c1e576858f37e29396d29f3863272a42abe7484e116f96e6cbabdcfd0cca03589f50c03643f34dcfaa10f3799eaa429cbd580359b2ed61d8ed23509ac2be3109452470f5ff4aab86a5bf6c11558646d3b720d72f0ffe23d550eb3ee3cc9bce01c151ca018da1aa60603b328ad76d2a487e8ac8856745c094cb1e6a0607039320b6d9ebfbd9b032649bc4f7c778ac2ec62db2416460af15f279c45ae3673a85bf29d5c3ec4b463766e91dc663f58d6f7347aec72b02ff610cd46718e6f49fcf502fdf52ff9412364c643ff23e865f040ce0225643da0b4a222c54384d29496b9c8085964a128f5ebafd51d74379a0b8d38fd7d662ec1acfc4b8fcfdca433b421b3cd8465b60831d61296bf2351c640951f4fe4e5e90b42064d961c3a69f4874ba28c27cf82726a5ee88a269a823f190e3b7e6870d7740cdb6e0a3c963f461da97a13830da42a96592f169ee40b346f0717e79b7fb58b28d16e5d46853466fe1bee1e46c60f2db63c8732a9cfb53717612d4c94f0b484444a7dc98080e5f358deecdeca4139544373f24b927cf733f59c06344385ab95eb2dfb903ad2863453c95490e890e87f335cd69e2c12757bf4aeb60e60257bb2a3f8bd518c9f2e49120d9e1cc34459d55b8c9689842afd919ac7c81b3f4469851894f3b604a2c0d1b43c6f2f5b8e1471dd6daacef4423cf388dc34f99ce6c3a51b3cf42fb62df37a6c072c52327c0750844084e60ed59dc4798e0968f62f44c4b2375779efb7f260fa296d73d625eee093efff7d881633f9ab75a33bb31ff07c053c4ee6fa7c0e3e24b05893166f2d8188900a65f12a7e8c1fca4ddadd56d11fe8e0e88c7d07609a389356930b89c089b99a79c8fdb4829bf3f057cf93044a51e4efa7d8618a7d8c0caa4c2c827da0dcc02675ffd8c6c99843f97fea6dc4697b58ae004028c1f2af9a5f5afd51956d991a682e70093613cb2185221cb0727833cfdbcf9a5e3dec6c1a1f300ed87c6782552ce524814c2a7ec348d46ff179ab40e0ce9f99a9e4ee16609746e7895f1144b2f9b0ab4ad61239411d73d4767f266d1a9f5f0e278a80454bd969a21ec9c2a24fdfa1ba970a271768062ed911872139da0a42dedced8d0d590b610f9fa24155a8a69c863587fe4a111630152c33d26bfd9c09e6b6cf7630ef26a6a0f1eb3532bb3b8c6c4c9e871531443aeb99591771cb2582408684ba50c501297c8e51cff55bb76a45eca8f7a2238e89acc65d1a40e8537f3aaeb0e03be8f54a8f515ffb0a5ba207bde2d47685218bfde7e96418344c6877a936b6903f13ffdd388d1e9414d8d39d11d1521fbd01aba90fffb4b6ade652218ced13e3ba2a6bdc9132666c5d4a85b3666f57f8a4edc247e9f0fcf91a43a71df4196ea1c6b2aaeb0dd58d5aa96f1f7e518dc945d4298f68d89a91cf9ccb4ef8c847a9ececa2489b3db1e1a64f2a56190792b010cef7c999d1b86401d91d4f14fa7aace67c8fa430eac3374f9f12a0ba64f897b42b561385243f5a306c46f5b1ef4415328aac3d9617c47bf0dea35b0488233f11ad859f6a5299e84f30415f670a3489e17cf9cbf53010392c12794d6a2f1203e20af25d3caf0e4511af173917cb77ef5649bd9ebf717ec9d9e5fb2fcc10266cd2dc8e4880ada4a79f1fe0ff83b7f9470baec5106173b4721f3577f8edbc22d15552f0e111d99d73d4994f6572c126ff5706a3f0561972afbf270a422d28c8c3ae9628df7c24d26b187a743932d0b6cdf09ab1628077619889a3729afff5505a240ff7a69de5b065a0058c8b821de228f01d2b2927bd8c0ee2fbcee913ac48a36dcd1e99c4b78818ece0184f9f89c99841694bb662fc202c0768ee6d1cfb6ff5f58305de5b30d6f38dceb53cacceadf782fdf09f9d7f71c4433951783e3a0146bbb8c971bdc711a8d4dfdcc916a5b3ba8995c7ac4491573eb7d3ff17f857cfd24b3261ff69f5b6d867cef1aafd62451c06a0dc328eb976fab20eb639aaa1c91063e6cd4071d2b170acc4af736f69daf1a5417212f668878af082ea4ece6d6e74db1c8a902cf5c5c5660cb4e3f4fa89ee6b26460b29330e360f53f49581f074ed5867055599e8e9b3687bc11fd720a78fe766261cbd3f0a1f390465243d72922333c33e78bc05fec85f948bc39470ffad842992598966345fd22c8291fe41c9bb8f5ad40e09905d6a98120ded88963e1baa8cab798c3de3cd5f70e6fed7d973ddadac0bf37c874fa79e675301f8f342228595aa600629811c4b320facdafe98996758f7edb5eed83bd831aa87b72c5bb8c8834535bd4b591d26ff91c517277318bc23d126ac8ff0fd4d1810b8dd0ca35b17bfc7909ea1c8a5843494727ccad5d1df77b50ca6e62a8c9094bea0fb3188ab1d444735e13ca43986e544a9e908fcd8e708aba9903d8f17ab82850278dceee160765695fc99f55e1fdc490b9d62cf7ea0a27125e83c87224127294db7dbee3b87cf2d9bad93246863920a3ac73f73f4cbc59b6ab819dd2f8fd54c50b793da0b05a909f50a7f1f1f338278f85bd5ac7c2d64cf1ca56fe33d4bdc9cfaaf0bd4f5020ebfc6a94167d22fd66c26a04e07c7d349056a413a470f449dad90adc6cc2f697e9e06743c1b435cea1e7788b96297c5a5631b9e879ae5b02336448952aa28afb68dc61c4389032402c1ab40011cb69cfbbd862153135fa5435f5d20636b39111e91e49cfd18af237fccaa66427d9f69b7c72297edb82e9654e7b22040a62e9cec0801424dc74067ed98e5e6c8c2045d64a37ec6d8d9c86e88f187c8b2770fb44f32530fef830eac7f6c8b9643116ac6990634b5379d469a199fcacf2bd567b6b26f41739939acd6693aecb96ad9447c27088e269bdbc8aa73984fca697bd0a73b4bbaf5f4c9f5ce0730bab56f7de785795d0cb8cfd6e7952687adecce94a89edd707671cf5bc752a41fb7e594878a3acae31003affac9b66ac0968eeaeabcc4f6641941e0f0e3f04ced5239e48eb99452d717d1e3d4682cffd539d0cd663692e33c670d9fb57b366aad7d3106e5b055d6e224cfd67aeef4c9b0e9967719db8308672daa0deb0f560eef246153b3bf654d9d482338b58179d40c468d18edb8a350e90cabafb35745ec2475e99e355de2e0608707e35611f314d4ef7de3608a0fe2fd9a706bbf9375ea27eb62ab2a0c8130455d8b009110504880cbd4e7d20b67607014c5d2b5f7d300194f9080ca5d656d3efc9a8a649961282e8dbe20d21974a73100d6c97556387fa6b5d4acd16383613ab412eb6f006c90d5a26bc1d5c1348c1fe387f31606879b78cc3086c46cb32c427128ec1a7473366f5ae3a2d9ed8235ccac87bb5d8a9d9eda019fc5192704ae8e23d75770ab0cb57c86122a286a100b36f6b0541f108ce039384570dee28cee4d2d1265a2162e39dde452ac26991dfe62f3a9d1d30a8b10cc368e12866b986f66ec7133de54a24cd8c6063382b97d01097ef45f941c000092c90c07ba58db7034ad9e5df6c0320f8e21b129df7658841e80f50e6b0211dd8d093a17c11d5bb8feddaaa8aa634c89b78791fcc77f1409cc08a9ebdb4a4f09d658d13177b15d807a88ec8d75d8be612c3564deadba875528ae3d54c4f7eff385f029a30f67f4d9e6cff27c7d4e8c964eeb9f65dbef827784164268bc1237f13f04264273c1dfd4837e3b217265845c77728a9b249a970b209ad3b282387efcae8c2da082430e72c4ae5f9d69305fb4cf7ec5306e5a7c5f59cf1f5c8ea60a84bd1b63bfa47c5f2444d3dc44f621f429aa44823a40018b1d921ee1553112b31c7b3b01add699c26f23ca521696557a550fe803f2518f6bf46f2be1eeae446d909c1ce29f38a7a1198e5f0b1b76cb5b5e0d80b7eaa58bce847585184c08a06e880e7f493f506b423e75bc4e067468275b4a99c84cae35274ef4b66d9b55ac36db94fce3660798d5aeec3a65ac86fa8a3621762b33dc4697859446e11b8f3530adda7314b7335c8509f8e911d4ef58cd0aa710fc13ce17a91ecdc08eb905407aae37d5fbf72a907fccf4496cf17741a0bd971cca9a23a6088750660b73dce1eae9ce9f30c03823bfaabeec8357faebff1f43151b5245a01682c3433265dfbf212cc503f25c98adaa9930af2d6371bebcccf6b5921a05097172b5cfa71722d1be54244059c3ea15f594961f959b6fbb7fa38eec8dfa4d73535c9d0df813d7bd21a6f324ec6f604e1cf61d54618267c60999874f170846fd09b69cc88ab43af89fd6118a44e6b83c9045ab1fc013c02b2e8eb56aa1bcbd719d5e0f663c7323071c57533eab1201463ff3be4bbef606f8329b418a66da9c5dc73271f4d19c4d9c44891807e81e1e463d15628aae4a128cb9c3b04199d7be89755d53b9d189d1f2d45356c93fd2e38e8c565c1ee68875e319f4f59ddfeea890a596ad728e7ca597c0d3c185a9a9cafe935237765219e5a57823cf6cb31ff4b63306363ec2b83d0293ef286809c9cdc2cc64e557f9517c76bcb6e651ab122ff582d6092e97b3aa472fe44e0a4a8b369553f1a13a4cbbe2d738222b037468879ef7e13db9dbe2a09d5f32e270d4b0cc99b7c310983a1c96f709e44f13acfdd0d56e508c6d5bd511d66e10ae54c4bef11ce8581e8249f7e0456e84fe8ab25816710f48ed3ba7896bfb55cba732bde62a0bb70873d63e517bff5381962825bdc82be1af9d6c37e4138508624b23b602b37762f9cad307bcc1af36044a3a129a9e07cb856b10c9827d6691ac4354f87e61d28fbf39a72f4023d6c13544c51166eb785dc7456b58351263d0358608d2e9dc9408906f98663188650533af447cc25234d9c9276c3f1d3e5526b5171a275fcedeaf9f12e61712ae13a7d4f2772653a9150c42f78c6193c8c65da82b32acb010cfb259c9351d304141f662b713c3d33aafde1793df4db81bd8d6f49d18328bf48b36284f727a4dea8905ab3d4328568e07303d56eadedc2cbb73d951448e7389940b38f05b2bd976d142e303d9e3391a01e5e790d9b9189125b37509596d51f8203c8e18bfe3b2e8b373d94b6be963cf1e019372b2dc8041e9cb7d6657ef72f839f8fe38a6db0eb56367c969498fb830d5a02fa097243afb355203804bda48625bb64f8d9b61e5d8dea62f8eca10165876944b7e7f08d18c7141bdd87bf7e7deb205cdcd49ee78113cb24304dd57495ccdb7e5dbb2932424f150b45a6188a5944da423c167dccf5eb674d08d09b44277ba7a7954b78877fc182a7aa64384e7b156ceecf5a071dfd7e33879ef2e72de106c5f0a5787658e2e235bf6369070c6fedb458556d7e7c0a56264c6d3c450d8a02bd704b407b8802c07494ba6c6e190da6c178b6ada61d543703fbf9475ad09c4c412ebc52299cacd894249e2c17290518821f58c0890fa414439d6c7979c286c5ec63094c9ef9f636b6439cc868bc8e50b1ea441fb292d5c9d9fc206cd6d697c82245368538b5b923b027392cf1ed0a107174f18f405cbdf81a53dfd1bf20d04a184c4abe5787fe0ab681174532463dc74e2021275a9aece910c2d4cb173d79f4130b6fd53f6b283316472fbee59963235a48b4dce0bc22eb6c530303874904a24a9ba3b879e8c467453f8f4edeaacc80988fe0fc5bf4ab55b273fa58913993a7f2307c80dcc4dd842993a79e6a3e58a43f12fff8d3c1ee3528996b15f9cd51b6cdb810c942c79465b4db6df2aa8a3f8d4681fd1f13c1bb06e8646be3f188017f1ff588638ce0e3cfd82bfa08081be16ca5e5ba97e3ff6e3845b7dd252ee1e72c8c7450084fbc3c56612f1b5ec2d6c955460c286ef636e562375ce7b474ae546f5f33c913bf63404aee26576193217fc30c88716174a75b6d3910a7bcee28fcf4460586f03edfed9227f3e8d436dc7995dd9ebfaab2da3e700a13669cf550ba27bdf0a229e0a0afe052add843b77c56e8ce365c0d55d7d63fddf1d6644132bb6cdf8bc385d3024a48d1cd31c9a05870a6769fe43c7280d6c94bec5191c83bd7454d6d184b4e37a7d184daf4a61f6bd8f595d3f6b193701216550e12b4d084f9ec326674189a5937b9c9800c6aa80c8de89cb833b663f551b46c7c573294b41dc9208b6240d6e172292412b264e6ac73363372d065ecb987361d70102b669b004d121f6eb96031582de30dac4ad3c69d17aeb978030d4e448933847552a2df2bd812dad17d81a1d95ea66fcb31ea0c802d2427bc7302df098c4b50eb6269bdf63fc8943e801b6fd7409a27f3906206ff3280435c77b52d4270fa39a955e1d9de5e2dfb76309ae7fc95a8a2575da9444543d430b02b47c91045d32781fe824127d830ce01a64015e0e0042277d0b941692ec8179f239696a528fa3931e3c980b9e8191edcb519d3d35999e51f888b0b6421112f94c6f746c758ef51ba1c7a265944146dea2a18c3c8def8e8bcbcbdaa94374f0b8a41f6d5bb6849bc7248e9b142f67e59db0fd81a4378611669275e65c75994c3eab4bb5c5c4d5e4aa0d83a9a2fe3978039d72f291471a8a6a629ad98095ac662fb1a7b6323201bd8d222c7178a2b3188b8e802bf02d8265cebe605b485b821d1b9efaa77521ef1847b0310a9d3485794c72de01a2e65d719f84e4b812fa28d365e3b9ee1ad6a594eca080eebc70033abe78e02c2a43584ede58dba35358b43af742c45e1b64b9962c53233e164d7998474fe2b9007496d942eaeb4b93029558e87c724b34d40c5e1d6fb75bbc08a47a7c8553557023ca8ba6e4efd9915aa461125c4fe2b24ec255b5c44e966fb187fb41b5ef47149e3fcbc8058cef262afaa866c3d143d32f19f239edebe30495431a601e9b1d90b56bd4d42f1fb28ae5026a5105108557f1c1bfd0fdd52ae5a04126794037898c7bdc10820cc7c91e62db5602dcfe5b44d050ee89fc89913e56e8b445d379b8b53eda68d8118d8c3cc4e4231ae0adb47cc94c7c3e9ae887ce42b7ac5b8e74afff15b472eb685c8336aa80e4e2ac3e5fe7f66e4d3743eaf0e67d0b2d48f20c84d130fc194393b0ef25804e5eb65cdc18a4926a9e927a6e1214e4620cbb40393be37d623f8cbc6e1f271d27d45ae1846e804334b2382dab7212a01bd312a1e25985bb41e1076643fa036a97f0d7e86bd08ab32c2efdd1ab531d9b514be389f9f7edf5691e6cfc55ab78f9b81ec97241ae87d46b380668d9e5c65bee5a31bfcb8b5442ffc54ac3df9a09bc9c259981eaf612273777224c8eb36d40c8dceffbdbf4d5364393b2af80a02e2e73f668657e40a6066787151a91e6308c88a0e43cddcd0212b42d187ac738cbb424b1d9cb3a46e8121336ee3b26664c57f9d5726eef9bd711fdaa6f0f38a7c2ad6dd68f3d8a54f4bef64adac1f5e01765169eb710a190f1fd25beee6b3c7609fd04798cd628357adc0bfb263cd6a03bbcdd13fbe9d1b6bcd4b43a02874240fbf0a5142bc607d331a7969d35f76a02ac6bdfc9a2bfcb5f0c333c24996297b0df25ec8da80d0043ad46798a8b8bda380079c46eb4df227b8582b65c92903ff28e785aa52a4a00a8f23e5fb30b8a9ebbd21469f5b5c0a2a7135d59c17a48ef7285a10a6fbf60a600f064b98acc1a66f110aeaac953583a49e3704d7c7b7ec91609271713bbf9ac4ae10c87215412365bf5f6583c4f622979cd93529adbe4f990481ceb799def891f5cba825cdfad01afffdb182811b6bd6dc35635078ecc13c04f901dfed87fbefefa5fd64c38352b70d437191aabe1b7907431620cf3a3e67e0eb54fa98b4442057a2adcd6dd325830f313f9ef5caeeb503dfeef5c49851a81fa033c922153e951009c78aa81d6249a0e322cbd8b21d3b2dc25179083eb17dfe029e3b558074421db6c34bce577dead2c9bc51c43fbe280bcc9c68d305a31f648497bad36b58f5bf1b0257c946a79457f634f96e6153716273bf15da056260885a0d58a3fd7b768a5f250e475e64fc4ae25731edacc17705959f9787237c05177b0c6de7f100b9732a077bbb661091b2098c79aa20dd60ea0da50d66a6e77160459d21ffa1f8bd7740d80230d94458b71220d7308791202d3b9a2cba326b60e990df10067a8690084ef1374e2634b87bb9b6923f6db12f8f6199ca471261051f248bdc283280f7fc0ffb863d457963bfdcc5e4d99b0ff3849c59ac7130241be2f64e04221504b18226c78fb739e0e0d2965510347daa6c937aca629b841fd1612cd8126b9e10e1778e412b4b32d7452540ff11620eefd5ff84957d54cc2bc6469af4efbab7eaacdeda4e0d95993509592c2fadd5c79a9f4438a6fade81cf048e19c964ec388dd722b9e26dc18c901a6af2f2690a5367cc29c47fc4c1121268d5c6154473777727c86bd563a61bce9f0d90062455f0edf41b1b82dd86daecc885fcba586500b355ca860073b9a4f9236ecf0777379afca044d0e4dc68f3b403832fcf5a5e8845c3aae86076509f933f68b05891fae89bfaf63ab274a2c013558b94c8b5370d0fc0609dea6d99c6124700da65e51aaf2c6cac0b0c3a95591ec50500452c90f4bc3bc4c56922c4844c9dadef6123681f51dae8b54311dd39c66ccc597bafb01b846e9ec6e6526362749f6d3c7a26488985e85205894db972ba4457225383a1759315d800476026572bf6f0de90196913ccc0c1a6de3d1059cef95c5d9172dec06954f3d33315de24ff1a60ab31a4eb8a2f8170a952dab2f59676b0f9c79d0e7332121af28ce04d412ea6fe3f1b4f81086da9d198e5bc8586ee7c644f172d3c56484da6c5140d906b952911a7685bdda592739b668b54a1c9b3be89ec3945366d6d72c4b01028f68c9a54ea4a5741e0501b1be5c9f529c36ab18a9f2db87a2df9a645c4482c16ba6fc7ba3eb3d1c87e964afcf8463b5ec9477fd0adc4b1950b460afb1043f78ce7f723c27c8e9fd7a5c03d7a3ebecc1f561916363e70ff827e8663371e7ac7fd4d54ececfddbe2f02c9eb5baf8f9f5aed4264a290d9813ee953d1164eecbbe6c16b2ab06281ea5945292c56f7fecb66b4dd2d6685c62b5bdc570fe3c10b92bae1e6d8064ae50f0753391a6f09ba053f3cdc02ed5769b375e4402cba2fcc13dae984833d8d89affdba790c6c6ee6a26f489c70cb58fa1251d890cec76baac846f9bcb2a79763a251aa2036cbce27329e40ffa9492f6fa668ad72713fc46d672b5b3e47f6586acd2d8178d2b05e457ad4ae794efa1ce9f089f1b9b6687f737f1c4431599b1c2079be547a1b55a54172f28bc4576451f758037d9099feeb9353b0885a8788efb0d99f07029264b539827d2c11dfe7c5852742706f381dc7424648854b1c7eba4cf4b10549458737d689fa9e72946585ba76df7ae3398746e328eb1e1a6ee971b0b1cbee7b659d885bf7174d0ad5a9fdd2f94dd004275aec3327966d73c78d4f3d74b2ea64a93c019711490e27826760db4b5bf0a25ad04266df50d38595f44c367051a1c4534348491eb3f01c0fae8d52067dd41b6f16580e4ba409ca85af35b6b39bf867841713dda4b3576afd04f78e04380b8f736b16fca91b0d73b1e16ebf8824ad3e56d5328f935668b4889aea2a3f752908ba6e28396ab3d5ea4864c7f8ba3c527ae38237bc4d0ff4f76eed71417b1c86ab7f38f597c1dbc5345da4da1c1fd9f67e8ea6b0f406d3e4cf5b25cad540f9049620dc0ee9754442a5a3bdfaa1855c3c0d08572a434bf6e2cc98b2ed2ec92d22550bc2224c907d2dac52a41cbe5c988d8188ad642d3e91a6cfd19db006db5249c12e511a8ed3290c76ecc6367ded50f58d3779391bf8547f81b93dd60acdbf002e0fe3dc7f5d7173e7621aecca2ce5770bc59a2dfe45c08af7ac63363ab7743f246b06a4916cfea3217698a3cb9ea51914b7458cc82980643c558eee9a578c48e9dbfeffb383d4d683193d2c7dd101c03c4f1be72bf86cadd532133890ef70cf0e5f03c516987bedf0d255200211406743e3e6074dca181394cf23dd67afda4c2ae1b901de8633968de2840fc2ebf2cc616f84e05155628cb02fc0dda2e7041155fef80d0ffbe943adb124b3dbdcd29db9a3c90e6baaa4230df2177b4cbedb71cedc0e69ea05633b77efb4a9dfadfd4755d743b3ef67815a8a9ab67c959dd4e60a3f8958ed3246b7f69a77361dfa5da11b91ee47a116eb36f402fe4d8ed921972b7dc960be8518ace44072cdcd68856c731ad69daefe0cfbd14c5428de95019326d02247cd001b34ff9952c51840e0d6fbb1f254bcaf5e1cad067d6a8ef95938d4b2fd83e2e0b59cc39cf44dbc00d1426c3362faa1124c0576388efe0cefa588b63b84fd32173c8a68d68a9692ca4879ab6f48cd9f6e62c2c7e1f614cfedd8cbd699867e34dec6a249a95d35066757d1e77b452655b8b6dae5356e35c952e438319e92b1871c92d40758fe93167b23ebb0408de3f5309298ce273da94649a2717864d7a8d13d6b9c27c755cdede615e3e316e202c9e0871968feddb89076a42979ff825f22b517ff6fb2889181aea6381b6da4e921c29b33b11820459177c1eddd89e7a0f1c5dd19db51127521cc0814d873c0ce0a6a3231118722bba915ce387ce64817e3d706a8c89874259d379e89c9c44a23add23fa05d467b9eb330e096fc69d174b1e2a4689b71f24315b594400a8c60b09787ee246f00a431745f7cff845eee13bc1a7e2bbab4784b817eb46a12de21f4d3479d7a410ec99f810872ff3fee904ae561cc637bcca98bcd805fa98607c3376c47c9ac5fc59e007cdd86fc61c9ba442cb202710cf5c416372e4f6621cfebc69e717f631e2241e0540b2e5e350f2d30e58d50ce22f0545f9824bc7143a677c4fa97aeaadb4daf0b7ad2b9c5feadc20d5493d8cea14d3bd0cb3769b891b2034a8651bdce9736282197bee42a0323eb94a86e9f278456fd526350668b94a4e0258f46559e45b8fe7ba1e6f4c9fa04b9fdd41b172e0e4cc36f18982e079bc5b0383cae8546edfe1828c7ab070b7d8ca86d8fc913c5fd7390f789c53fde384641fab813373144e913c5febc7e895318524ad4183d4ff7062d722b260b476e8d2657e04487fc7e7d70cac51535a4c30d4049614d4c406039fa4ee91265907d6b3f426fc557695782776f411b404325855253e4897bd76819a7862966e02755740e42d7196ac2deedca4fb0066073d29e02da0e953c6159ee3ca8661edc01b46fe189c6cdc9e3199d7c0c0531e3c7d1f07eaf962a6afc166d9264596b3e18640d87c7a9c3f29be453332e165d6ac7c5d6b9a7e2cdd6aa79a99c42a77b7cddf4126a926d11f4513cafa29f303816d991b7710324954cbe2a195160746b0dd497cc40e268b50c62e7a8dc798f9b6f10c582d331b0cada29d4352ad1dceab42fc1b11c724ec989c1143231c87c04f5e4c22e28210e84986d9092ed9d6d32391532cde4ce8bec47ebd318cbfeee575cd89914fc57ab52f1a326f2112fc9730c3f5ae636849dd68b59069829bbeb949a90966f402febbb92d302fb2fa036a29cd68836f1e8e6bc9a49dce6a5bfa3a47f7a1f3b34c97ff598b03b0c5b1fdfa5444275b3d6a253e385bc902b477adf4e1ce2a40a90ffd129451d9df78b96186e8720768ff53d7c37827d9e78093bdd939fa0d13674534328de56e1d75dc3c79adc335c4c660de74552b33a91890a2b7c5886e5a152cd3cb8a7af8038d4ee1bb1b2b3265c880bd34ce53cdec38c9a130de3aca7aba103628c0a5200cfa4a00b42e6817e1b5f84a584c4ee2c5114b5c690bb1a2513795be195ff0d1378ca8ab81a5a4b51f1b4892b4ef8632081428b56724953941d848fb24b63636420e17391fb54e26eea9970bb1693b13b35a97656abb65afdc9708f0b834fdc26c4c66f425fecfdcb2be546cd27c4197900e6a8e4dbde05bee7d32c7034bfbb9bbf72d6e6dd22d84aab8b823c339e19b3c817c2d290e088c6e540b4420cce0de5e44ed966c2bb8eefd70a8c04173d83185a43d0cb47072995e3834e1eb8a0cf4701d796d374c683b60b352c40cf7eba3e978f0f510609e71fc3407e7ef2da5f59fa8dc068b96e2f41227a5efd1e29e38ec054bb78bb552c95a48dae966dab6ee1bd66a74dcf575e568d36b6b7a0a00692e07d67afb604f891b04923057553fcd8d2457e576491e47b3155309478dfe3216b5a04143b2155f2dc2dbf5305dfe903aa5b460745abbe1a93dd21f4134b18b3888bc68306f40105b5e210153a951f175f1a8c236b584836f6d6f5fb4c06da8a7db3bb795990ad1c1b207fe9d492a95cfc4f7cd55dcde9c004ce6b278782e0438ffab88887e5f9cfbec08718a513555ea36601545ab3320b136f042559598e5e34c50ebd7c6095731d6b12227f814383afe34a31f72e3f1898b2f14c0872b891d0ba3c27a48408ff0159c201542ac6e99a9a145e2ce4dadac9411642149a0c41668cc0be6e4e1f7fc067efa40005396bf238c9d67d451b2a4eb81e5f8512bc0e9a0d75236b7716b55de02b6634a020b68fca95b9e074d1adfc60788fc811ae5a74bb15d5f42cd9047ad34c6e1b9b205ddd3836c9262a7b521d78a2c6879a77e72125718f2c6f63e2f0168c2abb53128224c6523a680ff6c4e6c025834fad0b282ea642212303a7b565ff192844ca7e115877f8025dd6d4d73b98be223f6aa6739020e41fec01bdb2d4a2725a2a6e8729a6c16692ce8c7e5cd414889f8e689620a2e38781f7d96907116299bc29fcce8283404ef8ddb834f5915ecd87421b6b5452cc7e9fb95765bfee96a911020a4911a334abe815ce25dbaa3db53542ff1e6f5b9607ca59719b0dfe555c89f42351d73e899b1e39f8c7459fc70d3c4f3c5dbdee9a1530c2172c37336650ea1c570f154ed39bdcd887e9d26d7f27d0a8c08d5cf9b0f7be519b2294fa993a9ab93f52edfcdd2740303f6e9206f8d03cc21e4959399188e5c90f8dff9063a76db08b493a98a5d94c51bfb0a7f352559b1a0a8dac010ba43a059581ee3eee08b45ddb076cea0d42244bd718c6d064ef57c020bbf09f63757a8bd80e0777e1fd3d403d228e7e0828ae08b1cadbc81549544d948575cff1add01224281d42062e17a4e11e70d29a9badd2f65e1f9912fa85544871a725e2a8ae74a6667207482b12709c32fb171cca02677354d6511c92c774bacaecefd639888dde9f14dc9ef246e0c5b3acf731b3012d92bffc5af3abaa824f4e3cffd37a7cd46b630141e23f296845540e85dd9f2ea01af26ef8c01caf9500cc7412f4b7be77f8c736597b10067816a8f5432ab2759a219e02a88960ec575009ad2e7d3ffee46bd90f90e5d9c7c34e6b06402927623a64c3deba5432500cf20040687dab49334382da820c86ee302a481f65b5edf58b8d0291b40e3e86697b233d1b2e63d2a9ccd3628c529f9ca0974127aca9ee4f71c48cb71a8d292a1c0f94395227c111453ad4e927b0c29c5728e87416ff02a7a2e783d41ba9529e893666ebbb42293bbd6f605a82b1c2859571bd6254784d35366bd6a08ae76cc8d5999187b351f3728ff061693c3252091741914bf92c6f5ae9eafa90a1ac5dd9ca09e460a1c150dff0988d39fba0c27b39afaf46c3723560fe16cbc04b361c7f98aeb501d553b945a65018d7c9abba67865d0b8095003385cd5050ff3c2dcf4873f8637bf00323e8b246fecf96139e41a86ca313698f0c6472d836831f37dfe717de932334578a02a5d7b0351090230064de3c8c2b734e915bf1bf9c2f3313e8b6eb5e60a4a3ad1f8912ab7a1fdf4ca761b5a7061ffb4d5c36e5ac8093a5a61c75b9578db2c9bf57d5e0aab2dfd53e5f37bbf25dbe6ec69a887acda6fd002d4010d05ded07b6cf29dd003413606a45253b4c90bd22cf665b7f53116aadc1ab70e01cc5e72a3d66c9caa86202d80b225a4b6f6451f1d2064e9eeff49fc2c354fa016f048f83b3669006248006447cacf0bcd0cf213c50310e3c1bf90b54a6a222504c2d4ba39e4d95f10a1eaaf116fbc51dd80c18e5a092b4c0453653a20160bc38ad587679a4164ecc95403bb698e766427ffb6afa1b9f15b3166cf13fb938df6250d46b84970d91531c3a4d56543af4a88405890ad285569515299090e100f5d332ddad3115b446016014853a792c5385a05594c3364eeb705c0b769b7b003fa447c9b4310050a48c7869d11871f0e5b572da7e338dd4c39ba81f3f2687b555da0da1c25c38620e871b12413bff0c1b6e6ff1e5ed3d353060230880a796fdc1b2e5fdb53ea550aa6a8c42fcce8130f9992612e922575334f1dd10f9ed6a1ccdae1f679ceea82192a5d30ae5c2431d8956df5cebdd24b34283e6269e36f2af9650c1f34ff21e50cfad2a9676768b3ea6535d1b2c9e2b200057b414d856ec9e18de08e4da405116827c821bb7cf3b52ed485e52c94aee5fb6d331e6b071fc4082b978adefdc3a5caaabbf13ff4635350d2ac213425fecfad23e1f35fdc2c56118d4857c0949daefa6fec964b736826389ee117cac37accf5f4698b55a51555cbf16b6379a2f330e6782433e603de74c0cab333bea12ea27cdc8a7648a427cf4165d22eb84e0ead231b18b3943b593f05f716e6408bb91cfebe56ba98001b0c2abd68175234477a2cfdc9e9e3a08c7aad26e7e1c5895d44120b951f7fac3b2261ffa4b985cf28aba854cfe33cb049a8d7f1b41a92e944dd88ca7085d500bff606d152f1c400e8cfe97be41a9835fe15a800bd8b137f1de1b1c8fcd6f361b141b45f2518726fb819f24f41bf90fdeab592986ea6c300c56aa8483921bddde7cf7286b699037c0bccb78a0d092e460fcf1259f169e185033cb9a3db48ec3e4c58c0447d7679e4d59470da3bfa21982105ea0130f0d1b5d98ccfcfd0bfb5b985274732e3e76a211f0f5e754eb51355e63699ec5bfd5de95779c8111e353dd161ac8486258dc3566d12b816234fa7d82b5b4c67be6e47d4ec6c92f8842e5797896b78393aa0441ca9dfcb2bd16dfddec5ff59ce2d6e898bd40419d0e3e030d2bd9c3a3dad126cda475654072c58d7dfa503a2588e3fcd9f2902a53a08d8ff5ef4501b220845718c2f4386c2b67c7abc7aac0a48f7b627eb84feea737e5a96dbe448e997780f943a8de4c23151015d66a4e20a765ff18abe3c9500015696134339f0f1e93b351614dc560464faf3ff7fb85b3c87c14495c3357083b225221097b585fba4e5ed85126bd0c38cf2212b0b66e8921684f03818f17cbada2d2e121cacdd2aab4dde4cedc488c71a65da26888929fb0fd743c0a777df43347a5c862b3b2cf967953de16697ad5633916cfdd6eee7d56cde69a2046978a789287298f6edcf8913dcf8243064ce22cae406b36e407f575542664285175b8f2564584a2fc9008e1fecbc9923a15c2af26afb55101699337020d37cef9b051d1e411ccb321793245f3bb9caa5dfab38ffdf28d7129176565a8b621a73e75659359a304217bf2f2851fa15942b63bacd559d617649ad82f2c0314da58da0c5a14e2ddc4b5537ab82298cbd6d79aba1188606449e401d3f3c7e161ac779c6769a5a9c7f7640865a99f264d0fea8601c4b0c23d6e459551507e6fe05f3dbc1ef025c228abe4613a780682b3d5b005bbf92f0eaa5a7130f59e1ea41ac551191bff6a1ddd378a0873e4f19415a0bff901266b99e44ae6d3c70da14b2ee39c3cb08e3a79d8de9c574c8389351560a64748a75306d4719fd85a96041062256902ae693e4525bc5c5611d03d24542ad132fed7187b06e2b0f4f92fbaf6c7835429c20d3e0780ec276babb88f91bed197563a64fda1bfd9a44f9e6c50833252380e1c75dd147dddcaabbfef7001eb4c04804123b4b7df6a548d8b80ce798e1d870b85f9e92012a30ecb477b07d6c8dd3ca93b8ddff5990c844eb837f1f355b56911a2e5bd95c5d03b9845b0d1ba54b20f22325a3c364c866a15f99b2689d13ce79b69f0a3a2257e0175db8b609e88595b3ebd9d6738dff19d9462c8e47ffd94642beb1a07ed0866b5d01451aa7acc5ee5a9bd37e9e54a2748069ea485235756a57d11263a7c4571f5311fcaf6122769df846e1dab80229c843a283a0a0caaa393389233f7c13979c1222d9bed99313364028e9683d926faf38c788aa7aee10bd1105a1ccd63056f94db03e2c25d42a994b848fd7e0da59947c7f5a47ba83dee3e19b953350dd971e4ba0d90dcbba0303b9bfe420520c01a2ce92f4b5fa3bd86440394c54b12092d8e2169acfaf11782878868f18eab6f6a032d05da1d04d20a523d2c7a0b74e8624e5bc14b950b090beb23fff5bb6c46ed9dabb03a4ef170aa3057656f94814e9e3221a21631127aefef93671430b07426fe928add34d9d4f41e15079d0ee620a00101ae5337031c7795c8caea00ab4cccd91e2d343aec86d6475e72f7f406e1b6a3abeca9b1ec7747a531a3f396a1f930d1faeaee35c1a42e803f82271c8b83acf851db4860427bb4bde4d6710d6565780d5b8f992d60c695e4d303929c316dfba21fa5201c52dc9f99fa505423d6a9b6f6d828006a3499e87a71bb5ab741ca2087d36d527be56df7d2035a9651f6715552ed7350103e4368bd27fd253cf4f7ee1afa2b107bbf1b1564a3f713c863a9912f5ec93ff1b64afb7156237a2e37adc18e2bc48a1e0af743fa86d4dfcc4eda64a131bc5cc4b993687e6379de41340f6935debd51637bca164740d4033125e2d2e657f775a6d694e89bd74f67c651f096eca1d4995150ad330b6730053e6b4eabfc59027ff9d790ba437f37b82f49aa40ccb26fb8988e685830fcdd6f51596aee0d91e4ef62b55ac0d91e050f7b87caa49f9896f624ad515f7cbef23fcede2c59d9944674d02c56f44f2b0e8f8ef40c79704a8dba2e98300864f5de63e62655238bb16ef0498e24227b10440e64e3e3c925a9b9c78bec966ff434aa1c3de84612097ccdae687dbb7a9303b037e6ce4746cc366057a09c5826ef29e6da1b299f7ef3097629eb5b37f52b8ed582c8ac3db83d28b2a509002be4c4225462b84df1a2e9f4ce011548f7fcc96f461ec3e6a97ebf3bf4f2877712eb28e8a3cee884d232efa19de765899d540efe2ffb28b8f74bb657088823289656f5d0472eb573c0887da976304e53f58202f7877059ca81f3cd5ee71a7efce07df627ad1bfd77d6f8b71b55019c628a84205ef78d5f269d552d0c5a91558f1474ce33c8e7d4f322480f9bb4810f9057a8eb5103fb702c409578a800ea00d8bb3d9455bcc5fc2f03c8ff0829f2bc6598b0ff26b9e95e35df75f071beefbc3300080c46d2f9122695bf8151e33d78d1d7ad9ba437ccfbaa4a4b21c58f7576188ad994b6eea37502df320a694b300b23e6a06c2ed348090610bf10be9920a25793926aaada64135ea67c6d03c2aecdc14e03eef0903f82bef4095222db29d3e52e94cadaaa0bf72ba9300d04e2d392d4366c966e46db13a833c026faf2b1b0380aa58582ada69b6b7dd1bb64f33b7fe4b75bb91ddd1cdc35dfc790e6a48d172e03cda2880e5c2e71e455997f5efd22f7e48443788009d79954c4719a05e1b0718b5183c1fcfa400759f79be71aaad3bba104049cac9fcc9b1ea5bd33f035b3f5439841d39aca479e5234677b72fcfe2931c2f94d5ee7665d8fe93579c5e8bfdb18a8954ffb14b2c687bf399a5b1c31a18f8f0b2953657f40aebb2eb6f27d8b42d5465238a9e1ea7b6d79748e6a796cf8b9d918326e3f4b0a1407bda63c6b0b5ddf9cfe92fe650dede83cce236e9f18fc5d879f904222a4ace96a742fcce4f6a881ef618677ed425cb08a505e30091e21fa0b0897ab680c12bc1314067be853f189bd0b62811d6a98c1e00061b842f74c1897c5525400f50e8222972710a2845c9492523b5315c3cc566f97bb24ed6abc05759464ab76b7783e9314ab408f129d5f824b00857f5a55d180a7849ea6937c7bd003a8a3e661942238b6dd3bc85591468925f065dc40eef429ddcc8234e6d7260618e35c690a9c5b7af983179aa0361fd1f29eb55fa1485ec77404aafbb8979fb754ca3d0a709a2d370f7e307dfbdb0277eb807e6eeb9690a6b98c2f8356e488e5873f4c7e924a3f4d5d46a4780bea78f46db5b5b2d44f4da5f619fd2a53ea6a4bf13c62b6e4c7634e0e6ff4bbf68db171e60531ddc88e170c0aab42aefbc37ca51128c8c313ac1e660fa6a4c46bc2a1f6ca689b218a70a03091f8e4fa7a775c9ec0ce6842fad0e6f6ce646c914c7f900652151764c2356aea59d01ddca22f0d1f413a7a1f1c1e30d9004e8b44b790e79fc381f100f5c33612eb12c7f24a35a5297dec330447467f3501687267d5bffa3a1fb836c11fe26c3f512ac1da4469ac16b6e39e98826f03303372d392461d04c2128c66a95e74a0cd44eb462e33003a0400c51bb3ede2316aed5f112bd55d8a37a6e61decd1f013cfd35d1fda53e8897596218f2be1e88c939676312051809d659755c08da30c278c0715aa9c7ff89dbbeea1751b4240c777647e69f749a3414c994dee17a0ef1dcd3a4b36490f5e5e58a90498b36bff8625b1b1f5107efe0f7b80beb36b35da768fbd54352c357d6d5efc5a0a5521db496b315ca463bd3d990423659618efe4b66499d7adec33ec94ac37b12e6bc9bd4f6aa378af09f07641f6bafa29214551e197a8a5b9785af36f24d22ce5403c74c8379a723bef33a626b35336abd130a44234959c80cfad4998a6a997e48cdd60f9a8f56f3e8cdfb9a245634a189d46968466e34811abfcf293232980fc08b311482ee98dc0606940206166ece5325dcb7370625e2de8069280f6fdb52ae07451ea27b8e3a36015d07b1419a2286d488963594f543b2d541a2cea253e5d1081b10a27e10d08804884a533d4720bec318e3516eafbb9779639d0a1096c3dced7dafc2f0b7e17e713f9c60c76ada5d6958d1dcc6d3b99b96e5e2972448bffedd61354f0e3f15c0702b1b7500449927d5983067199c282f0f54ef10548e1be942f6b3013c380baf2d92b0416e92b40afa0ce00aaf8e9e601b292496fd8602890cbeafe735c744ba570b405153b53aa767f9050d14f3420ff0db121e9283459b35137da1c8e0a1f78d0953fee04daf7600aa7ccc797c6b3949523b2f55aa7b41a8cdcee6ddf11c8f52c2af15c0d27a4d192a95362100ace874529949bca0bc2c83df0d55b84fd2cedbc589e806f010094264482384873ab38635417e5e861d099ac1b688c6cf85f8ec024b5179281c484f980cedbfba207fb04d2a9c2d165e29472c2b3d8a98264d17bb0c122369dfed3dde2ff8a816d93f45c655caeb0c842b92765440faffc67716ab049b04553067113849cbd315959bb7cad6f10ddb7e3d5145fee8ea4d341756e58ef93e4785b20e5f4a2638175112517ad6b2c94ffd5980bfbb79aebc59498a64f90e7187418527e00ecb097cc389bc5b8cb97f2c0d74e54589b92a2d09ace278f23f3400d4dd655b2c7635cfa0db93507e4adb6d4e06e334d3ddbed4a039e245e0f0a2b62f36a9a01d7fbe4d6d3453cd9f00a5e5878742613190e107d8913f86759ca5fcc875f474f1bada5e49548aa80492907c7f335cb4be33761382f0e213dc23ba93400f0b483b62aa1f072c78b864560c3e49aaa4ffeffb61e195042dae1ffd85b6ef430554fd11653bde752223ddab0c2e09cc35243f8edc90af7573d4c4c251347c1b50c2da553eeaf3c5907a84ddd954372ca4f884ff7e28d8ff8241f09369e7da0af60cc678492721de692087b1e0ade17bead99cbb72dd5b0a38a9b445109df84f17460748e007bb327fb390cb599e4363ac9d7d5a3812d9f1dafb0673a120bccec4d561d89f2f418a8f6dec154a89a4942ca3845ff256ae15a4329193d2e3c4a04adbaa1d2656665dfb303bbecfd553d802427f1b4a288358bc43a1cc52660c1a3342c26f84dc1b41568bf0ff93b669749427b867da0c7d6f20e2c1d2f0c313ebfde5562491ce652e57d9d3a11e79b70c33e72466bd7eef5146a31837f8dbb01ed73e7b22e1278d070861a2cdce0cdace11bda488a3c2e38822b6d97ba0e38222e48dc69c73d6f0c893380a121b458a44d11bdcde9fd6b5dc9df568f2a53fc8cec3b0fe66062b299226aed36f9c894fd9fe6543ef8b66dda5b01de6880c86a2be71dbad983c8c78816e35d9361686d3b5205e4ad5f15d52ed255b59cf5bd3d0e850df9ade8ccf690ccb488d5d6ef59f2fd16c79dbefb002bd471b42dfdc4f92944e3e633dd98b0fcb60fe0cefbd8fa5889582dddfa9f6892266388838084969d15eeeb24f362b50f9ba50a1152caf9cec51cdb1ad00a6c3553b2a6e2de0b98233ed654dbf4e3d99cafda8685c5d1a89cf25e79a4f1353fa6419d0640ee9d51e09258100705de0908cb21f318d658d6bd636e912f565f7a0cffe8ef064ad4498f837859c53ec33aec65afcaaaa01ccb4926011dc09803b8cee86e8024611db77f8ce903af2331d6a4579730dd4f0a2d178e8dc5e4c89a829f47cb56c517b64df5ce7d9e0f8b770e4ba83d106bf6cd091783180b6023313762d18360aa1e10bb74235eee571ed3620bb8d28eeef34fdac454f0ba6ee25802d905cfb517d584152ef7325a65ec87ddcd29a60827aaa67b52ee37f23692dc19ec96777f4465fb247bbf0585b44d3b726bcc7fb555577d609d303c5b78d2b28cca97d4d9d53f829455200b363c699dec8c3e7ee93de99f8b4669a21d2468321af025ccba166e90ff9e6186411e1afa7ed2d62dd5e6881362dfd296566c1c3506f39adb8edbe48ebe7a8e17acd678f36358cb3094d676f926509aba2bfcbe326e9e3398feb93d50ff3a8954a4b1fa07ce207a9d96f972b5df1a606cc2459a1d91c4e6c6dc9847d4b7ca28db908d1c75412ceed0c402bf7b73f59308ae9a24dfab29ec1182911563e9f9711b1ccc2db561dd11d461fdd8b4fae60603c43bd6d59af454b6c41235e19724e2b652d2a1a7eccc2d367f22587e8fcb04a6268d28c261f428ef3254fd442b2cdc479203b09b587b08e031943bf5d6a2a730eb43544130699a0e41bb6d512a2655713d94cda2791f52f83fa5d93e4083695678992710ccd926e659c00ff80885e0232c6c27ea30ff8eb0f3bb02373a79e46c56c9726fab5e55948a26c3e036a945e41e5f642290d4d0921c61870fbc5f995448c0b1a93545b2a54a037d6ab3d1b7ec515cccc62b506a69bf8184b236f192f608ad975c04e8514a76b8d7edde758a5a4d11d892c8fa65a2e74b58c8faf6a160e0545de2b66551bb8bf501b22d3d4be1334a0539eb50bba21eb789b8e218c9bf5198b5ca3695223d61bb1ddff5ff88e719dcf58c54fe9d21386a848f5f38549e164ce46fc0cabf1ebeb739d22ba64beb917cbfadef5919fe6f3d2ed83d589ce342af4764da2cef079b5cce688867a1c773718cb4e01a3a2c66ba4a49c70d7de377b6e3abd89268223805e656163c250985c27b7384f38ad75163b8ef0c89364247cb840f05100ec752db46d92947fe2916d1f1f400076454be63589d9990f086537a3507908612722b203feae1b9c523ee2fd9ad9faf88bc2efb8b3f5d33b3da01764a98e5c17432f713b0abfe5fdd7b2ffe03f1535fbaca4af4adb767c452c9b594502d6ec454c8350b97b7f770f08cddde693680c092eb989aac96782e1cdde3168523142bcc305a0f8b0b47d25a0bcb31ac37e4e3a3bb8606f742e8caaab85c148c422271978e8f64fc1d2f9d302e11986a12246fd2c5ba1ea828e7cdc3a817f4b0118e4cbfca3284464e021c6604f5bcaa56d6de6357e774fb531240db2c7b98b49cade9e7ab3b05d77143de05d1c71b43c3bfaab93b46bd74b3d524d3b6faea67e37a4f34c5513f69eab840c1cd04dc2637c16faddc0d6898feb218416269b7bbe73f5baae8a9567935e1f3c6ae4c3083bf0811f387e265cca8c4ef39fd5216c894a9b931ff00d2678390ed3bf004ed5bf5efe1e1d46b48b0e48cfea537013ed8eddb7a502a3816acab62315ca25c03c92bcc43f2cf7f99e6dd77197c9033977537e2e97f88217c52b91c4bb9a429ac187079395168275752f26617e35b433b03b70b20e0e2dd4c435a8db6c4b5e12d4f2a6f413118373cde6f235339f74dd07958602bc2b180099f1727c49c5a5ad1d6018b707626751856a8d81ea75f1bd934bb423413285deb7d7a4f6b08eb5b8285d23d52f59ce62b8b3cf5faaa54801d301fa1b3859878e6ed4355b5e4d550677734a10fd9c42c89b9fe0c88a78c191b58ccccc00b01c6543d0f63d6c63d08738cce1c2e3f8974acd5a5c60572bbabb2df34f1450261ed6a68143c4db2b4e1222110ab4ec12431df42ac0e89e84a0f52558cb297980bd228dc782f1a7ec741178e07109ed901136255ce208d4a757775296b3adf80fe5e9aaf857e4abeb6f2c9b5addbfc8eec566db29c9615be6f61cc5d49838b107ccab1b2632a4086db6019ffcd442e4bab43109a234188bf288ba9c2c9fe99c90f4e7f9b1c3832e8e5748e85ed08842b1538d89ca8af19c616e546703dee6fc1df7672c09e8cd075e3da632d950828a455328365c6c9c366b041320bc3d4640d56ea2b561ae1c8f7abb81b5ec1b0504af172f0c1d331ceb008d73cc9d387bd95a3a4b0dd908320c5f33bea4b1fe785ebca1c1bb9a94dd0600488a7ba1e4973b57bc3b049b8e343f6ccbcd8167868274758f56b616f6bd91e623f08327a29119b564ff978b8900d258a4c09988678519f33a02d44f2347bb1160cba84d6f5984076ae3026bf7a7f70fc9bf16a7568d78125e835ca9a991645bd360d5fd12b8aa106f92b0a899b7c537d29c125d9b196d0bd32c5b084633121503279dbdf3cd2e86abc1af1458b11a2fc2a40aa3b2708ab049134a22b57be0bead0c6e9c84854d1254d8a8a435d9a80d407ab1c811c836a745b7fd47d2c4b9b3416e8ce16292bee1517b210e16ab2e325a2ee1cd00b921f0b27d342a272ff0d2c39a26ec1ab9f873a89e7988c84495337920c2862aeb61ac3d67bb7bb77f3c4e68852a94ba42eab65ad6a293ddae2d0906052fc8752cfc5a22d2a5cd8fac0bb2bf1a912a36f1bb929460b2ff092ca15c573953814daa3f546e721401feb20db1f7045a2cf4f039e5c824955405dd8b96c33766585b18bb80e05ef569b8d0d4a29ddb92d42e02f8cb0bb9a2a974fdac983e5895e4b7e0a5bcb60effbcf7d133a4feca2723d73009590dbbbdcf12d556e299468fa7acd35387cf6f8b2226471ab7bedcb7cc27cb492dd0426491e77a3610f13e6c6a720f62dc30dead468917c828fd9162f5ce83d5f25ec073043aa6a4e90b20a1d212b0f3e2d9519194dabec6eab4ba6e97d6ae6f077b9a45fd55e0b3e86f7708038baead615478dadc1986c87fccb5ce1f5e0013af7dbb19a980f1b1e075c907d1c8a7c3772ecc456c336752f6be69029f62b5eb023e77c0ef1cdcc50f2b2b6d41bbc86a95fc4d15bf612c05b31eda96dde043a5f31435c477db23866ce0eb0aa541e4150d7547a13ba91cd6cb21886186a621a5456258b8481da5f37ccc279e65a3179b33b87582d29ab45d0bae8de03e8d98979fc46f7883113e612d74871b89d506512225c6e55e2c841b867d42d717df949e46903e5149f286885dc0e596a12b13a3b287d4c7b4b43b6bee2e31e787b90c57581ad3b2bf80e80f9fc4d87dab60ef0b76122ed49fd6e3d2d37407dce07ce06c82329083d405a71d908888e8d0366a7ab9aad27425ede070f9c51983c3bdbbd41ad7b998124b69f6136352795bcbe622509047a149768e41ab8be68481026720f494220e82480a20011ea3fed4e3d98738c626113126d8b39135b5284c9fee64238feb70e63fcf67e368fe6145edc7574d671fb9b07e3efc56a28d799f026889bc868d5683525f18b7b55ab1f6be28c2c899b5ae6012829140f661ea46e76bc662dfe46ed5ac5b7d60185f8efa530b4913b28ceb9b4afa43477bf3584dc974f5a45b431e099918798e4a0abcf4831d313b977307e5ee2ad50268f64309fbd3e3b607b39b413b722246829ca406a39e466a2634e95c22d0953fa141ca10b6ba8c284b27e5916628187b1b432b4f5ccd9a9e4f729fff3a4f9ff210069bd13fc563036d51d851b951d50cf67a193d499f8c78e1125b16b9fe0a3866486d0a0624ee2aa26bf7600aa7eba682f0fd7313b42940f59b4070c959d5b463d3cfe35948abdec6752d412e04d87f4ab537667b29fc47750da663865e535518f61ccdfb594bc53b2f66eef7328de17c5f04779fcd9697063b1c1d15729a6434abc9743f2f6c02505164e3d2ed3258a18f34a683279cb25471da4b51550c84e03a80ff56b7920e043ee74c89d0e14632f2505bb007aca8e7906675758f767fb82379b7abea83db55c247eded5d393c27d6e1af7e7c2157a3fa110de8ca99c5ce7b6e2b8044214b267f646b794b1552f701e6cffdbf79c4f6acee8c169861a6b3a6545f6109669e5940d1aaf7234aeeeafe7f5d127016c337adcdaa55ccbf5355c368baf3fcd50e1b57f454601c28e0fb571e35392ac7003c61e6f73198422d306c9ec98343597d6aa4c6c2591adadbb10f796274c68cd43893d9ad8d1d4b83047dae206fc4973454407dab3cb6398e882f29c9f1c00facddc58befd6a9503917ef13362ebe5a04df246c9d604b2dcea4ab74c01cd401e5109ae19c709d8d9f2cdb717e15239f15504f45dd670cdf8b23bacdd8db9b808b4c58268c8f8febe36210123582d673d7bf68f73649bae1a2bb3ce6f30d1219c68f853f1a0d68273ad8b7e33822077cd6aee070f4a5c5a26fa08edeccd771b9ff97129d797bdee3b8abfa5b84d0bffc3976f5d9800b8ac068bc4e3f81239f070231d04c795759e9f019ac81e1a83bf244a6237541e74ae197c464b4d35d089e074572ed1a3795d2290004328d275b6ecd0ac74a2381b81dfefcb497e8f5ae8b6de8bd2adfe828343c63289a3b2e22399b84ee652de1cfc0a4aa84c832cb21bced184cfb0256cb75081aced4a87c5c7129c9e59ef5b2035d1c16bbd748a193c01917e5b4bff886f8ba2859e524ff4a7c2bd89a1291b4fe8d6b61050d4eb3919a6d82f95cf251067a95f9a48e73f329f37f79c5bbde0e1e50b40e42e51d6f7e3afb7f63eecf482bdc1a73863b2a1dc609bbf4cbd0669cc78f03fc8eab73c0841d83369f5e3dc4a375bdf9ccd812e943411becb6667cda68c3ba72df35067e9786885bdc048b7f261b79ae2032ecfe3e1c2e84c421fdee6c67e8fee6850e02d607e588070f7431521713742b59acb884b1ddf28544a0d7ad4e1e20c5febc65269b7843ba3af6dcc22a9d143f83d7a9fd1072354b3b4ce31abf3b8d65431ee356ca9f2f84a909109569a99a108c3b9a00cdf1bb373e6ebf9ce1ab93391f71003e59beaa6a92af2fda98dbbb004909795e47d5b2b0518e00e68559e65828f3f19b1abda984b94978b00ec530ce58068a9198e40bef6d1a4a8ebfe7c2fb24ed1cc7cae0e4ed75ed6fb9349772f0f9b71cef90846286ea23b8ffd72361a6c5bd89faf72094d87e1db5e4c127abb076e436273ef9d5e07133276e19ddee115dd4fc86faa13b71746c452c0fe098b3e6db53c4ab0b69f66c243233c8fee433ee05e009a41d2c8b7c4ac2721e19ac15ba747b36ffdfa8576a170f918923a0280da9d10858ad1d7098ee88fd7ec131c4655e0ca4297da00c6556bd45802151bcb1adc23b2d09a2f746f25b60e646f70fdd3b0cb2e4ecc0912c05a82062aed685656b58d0994322e4953b58a557aafa8d4361c91f02ed0606e8645e1fbc7baa38fb421b5424569b7936568c3c7e1e85faffba689ddf4ef7cf605d99a6a9c04aea28cddd90e24a227e8cc53b4da029f125ef2f41dd56b105a1d0c966bd11199669e17423148d02dbf54b670a545c2a929d0e95a53770b41989b127428f75bbd15d162862d0bacefb9c1d1a345ced618bcb3cee0e9c08cce62a102c2f00af548574b8180db5a8fd4afbcb7c89bce018ad4a06166bf9e8ab44ce186e9cfa87785fc0904c53720798f4570e8ffc2127f1eac0a857b153180e6589bf4c4b9f8388d2dfb4216eb516464d594169c07c8c5861427a98efb76a8ee9e5833d1cd6036f0156986e7cb2ef7ee02d507fdd60917d9eaaa83aabc9c7752dbc4abf6ca75302918d680e25f46f70285b9780a8ea2b32aa7ffba97c24e504c8192569377b558171c45685844c7094e819a23b395cf86cd7286cdb39728fb191694ed8336da7ce0f9ac62e67dfa020129a37cd22daddac88a200fbebea3b79a598e0b37b61541babfbe9528f1ebd6956218b6aad9a1ed57d672be840b0879ff887fcb68fc457aa0e613b43a623ebde82d08b7f852c896723efa29838d4b089f2f1911b9dd68b4872d18d6a96a63cdeba47d1fe4f4a28b6f3709312a7a50ce9ab58cee55e2efeb79c9f52b8995c46fa797bd6032839bdad6316f3ac2224bdb9bf89635f746e1a474b02be477a814866f9282a17940120974b2e09f0c77b86e31a2c8a966baeb72130cfe1996b7c315588f4dab2dc6992f2b8248fb948d2e6aefc3e75a0ce26d39fdceb75741d6e0bc340be6f26a9d566c47ce79e61ee12e343397976ef37bb15b37dd7b1a3393e7e55a45b2f62d5b7957b1507855f9dbed64638bad0e098ea74e297bc826231982e210a765897951f02ecf249259d25086dba55259d5c9c67fab48e8c66f2968eaf5a745aebb1d533e09939e8c4d37d6ad69d62148e610845b76778ef246d5023dbeed3c230873541e512bbd860d85ace438359fdb73ce18a45b410b2b8ace7b62b18fad80f811f1d9cd2594ed9a76f33659f0a21e1c4205ea08428004fa7631de1415f5c8e4da99382c093a5c8561286cf0a78f306961b0652843e5347dd294c3779ee8c9d58751ee26e2a1830e4ce231bd34c582a2cb7c6c4a49fd82006ea4bbf859aac2218cb61bc691016919f0ebc9197482bb87c17faa1120fe164d100824d6322b1c6b8f9b222d881967d4fadd93b95a5abd4a3ceb9f03678d4b3b45be1a6441431ee9f653e2413f39e0204ed5b8a7199aba39201aec63d2d107d8d0603886918d2399b013b061ad493652779f717be4d7a3fe38823b3b48b81b8bcea83733864798ac63eee804b7309515f22aed96fea2ae8e935c526e35757f1169f3ff2d60c10a18b6691a4463e68a3e5577d201b981a17593d18f6507ac62cc12c3e569d25936ee01b1be2ffcc825399f9a63b3979b97228ef3ae18a875bd97fcf05094b7b704dc92f3aab674affb7321c7269573deacec63c3d18446206461441e0fd6d28c6c628c2ed941c0eb06943d5aaffcd4bb108f85dcea90a1f0d8ce2aa9b1860b346db6dd9b0bc6ab0796ed0076c6b88e95e5570b1dca33069e7d281e4bbfd26b1544fb24a11eeac6201f0defecf28b7e9d6f22b88995e75ee84053f1617816e19eb729c3d5b9c57a0a3ba83a4721ae00e7e4dc5e3bfcaa3b99d7dac8aef46953e18b3420a00221e35db59ba4e397e34fc2bc64077e19234000482191b1e391e19ee66e028d4f6d059329eae883ee7a7e08e85728dad6b9e7e50bc724c1edc3dc2971b55aa43a5fccb069dbfacdf96639c691cef6446cea90594e86adce20e7cf84362896100a22875363df28049649bd80fd8c1fed2ee811c9746adca033d8efcbf67bfc99cc2d226225a14937d8035150a76051bdc56e5059003dc4510e03a32c31a1d56607d89526755d32606019336726566a675b7c59b8bf0f403a970815dba201883dcce7155344b8f8d783d5f110992edff7e063dda298016b1fe6ed09e01aadb745cc4fa34024d0ba6e2cd98bd7d37808af2b64a19e0ac378391e9b16e6ea87854c8bf96b48e49d6802b8f8d0e01d11b62991e5f9dbe09947e400b5b64f052c9f45cae78913f97e71045cafc3fddf06d35a7245c578cd5532763ae368cbe5aa7c9fc836590cc3a887fd672c3546068d39812ec58e233739c2f26ce949f51859563783733f5a74b2907e9675659ec7722917b235f3f1a42cdbc4483b85a557c450177330765ea3ccc119665c69d61f98308823ffe5d905fd543afb2af411ae5e231d432ca4c5211199cc7dbd2fea8c44f22a6001d00b93bd71262d538af50c09fa0327d5d8c82c413f1a354b61fa56596f78ddca2c82dfb5d1911785606a66eabf0382ad33b9321cdac46b9570fdb9ea780e2b5d4877809015279711d2ff1411bbb7990519a1d99fc6f8346f69c463526c0c2cfdf706dad6836f1575ef4143caddd37fb610f10454ee6718602a3e8793d79affdbf833c95e9ea7bb2aeb019019927bf1c86dfe7ffd764a15837d6b4b26ea0f7c8ed68980456e6ce7dc9cdb31496e076735ff94f13132297c141ff9ca2333d7fa8974ee676d4264fa4e884e9f9ced738b1aa90c1c97bac157a28a0b2d8126838d0e95ebe537ca989835af3b0fa9cac98cf85f6ac9030664fbc7138e494aaab491c1dd5a991a97fe1409cf43fcbc8ac7b4f4471b595ebeb8e94930573b7524b3cca6546bb7e3e0dc62f2ca3129d61c365ec446aac24e7792b120386d31d494e9a1918c103c9622600c764a0d0d687b27f6622d849b89bcd71933d2947b89438c228ebfb71013cbd4c2280e53d3f5f65cc4fc6d9f4d93c8195ac37c29882b9e4c2c357a2a674d142bcd15ad9420cfd432f8c6c2dccef1b5e97f84e087f2c6afa27591f9b88e5c907732872bfadb4e9a7e34b58d3bf4b1b9d6ded2d434cbf6a33b32d5ceaac0618513f505e5817c760f2dbb3a2e95abe5b02246d6f8395108eae338759652f9ece5f81f64a9595e405635d01259a6f74b32fc5024370dce7003111dfadd4a1720ac5d59c284c5446f4431a71fbb345e3d1d1267dd4bb475a3d0f849418542e62dba510d917508885115d143c6462d16b69db41be3ea4f1fd6b60cdecebca1fbed7c3217813edccd98fa905d2f750e9db548d8963b4c61aa270d87642a3ae7aa219fe9ee8ad174dd896ba076d51fdb5401b3c1f1d145deb4dd7934a2c0e2c3cf9d7478caf8d945f24add5374725adc89aa150f09c91e556b3e9107ec6178baafd8d3e0e915a70739b41c3a7f5bd35c54d8a4089e302b56928dfc48bcbbf8998c3a6302df707102c6de5207aebb3c9b95270c722d38d6a65fc40e7d98c0f0e93360585d6e623e2d116cf09371ad9d93d05029f300808576813c8467ecd2ccb31a4af94d365c9d6dd660d706579281dcdcb4cdc7f4638f3fb59f06bb0f75e0fa9ef8d2601648aeb892b2daf8dfc7c53e68f5e57e3b0d400e6f088fa82c2aafc8448c6cf2ea3d57c559ed35129e282a912a709dc01a6be35a8962715bce141cab46b22e8d304dd026c53f997e61d407f0f3c7fd885d099e1da11f8f69fc08c4edf5c51eefb47f4f8f42356e7066c3d25a31c8fba53234b38a079af3a7b97719a621a568e60db5ad297ef773433c2017a01f080c7777bb5642847d5a3430fb651effe9c54630c91b5f88876981d3780950fad45eb12388b21934f019f41e5e36bfcff31ec83760649a25dc9ea9df0dcf2fd8004138577408f95512d18682434f478f4db75ae6e1aa8a0d3db55e6a1a3329e91840a13ce614fccb5656ca8899fe316bd5a80a297bf94f9a662a7b3e29645520a21a2e88670e1f42d9200ad8fcb3d808c5eeb943031fece802215f477ed45fa87aa5f840fc0aeabcfc5d03d01b188f56af33f94bc341b49542c0bd3c49087b80fd1efb261d9c1ad6355cbad182fcece1ca9cc8f3001f7accbb1bcf85c9c409692f661a3301ff2e1d9a68bc4f1f486d54411a7792633eabdf0c72933dcf997977386479bcc89bfabcfb6a9fdb33cf55c3b7206913feb438e98d31e293e8c59438670ac77d629bad237c80c3395ce47e3ff0031311b70c06e3d966dc8e337d9a344f647e4afd8f0ff5079b8ca1818b4874c2b2ebc8f5aded4c7a73371bdfe1340b0877405a3c51bb309b8f08a161e5000ba282744fe4a528ba272f45512d69402fc4d417d57bbc0712ecc6eb21be66faf5223740c64a0865bba22ed0c243b09914b2c1c2f7ff364bd4b7da9857137e637ad997dcd6af1d5098361e41d88bcd87cb487b635d2578cec36b8b440ccd8eacc5ffb82608e9b5d2cb5b19e83c5bb42c18c7eec7e759aef446cdc4b49b900c1d5d44a6744d618d3d4c6aa379311a5f78129417ef5b656bb69a1c8a05b7056db56881a812235b3db78d3958b46eafd877641eb4efd0600634935060b20db83b8b982b19cc677483e9eddb27e996fcf5d93517efbedd3f885b13ad87174672d311136ecf4178bbc1be474d529f1f80ccc7fe91dff365e9503dc0f70aa9e02a5a6113809d917211f83b2815852a231927353c50224003348c56461ba9a07dafa8bdf150a86fb3be4c1535df976aa4fb4cb551a5a8384a45ef5e686d55baa856c8f4b75d835e8dda087d54c0f0bec4e8405067bb387f4053b94623f9dc93a2a38481432529b6e993440cfe7ae2be5a3151c0acb53e5f8aab53da66b2701e9c01e51215a1e1518680cb48b8a160c0ee5f1c25333a4fb9294cc52a5db46898b23b3c112f2c6bebfe06</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Vue </category>
          
          <category> vue2.x源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Step.11 揭秘Vue的事件机制</title>
      <link href="/computer-science/vueyuanma/dosc/11%E6%8F%AD%E7%A7%98Vue%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/"/>
      <url>/computer-science/vueyuanma/dosc/11%E6%8F%AD%E7%A7%98Vue%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="52a3b5aac6edd1035edde16c15b85a6a22d405b404f74ec0f9399ce097eee5ad">5808c6cbf3ac08533f2dffaad5e129c1f7677efb1b6b29d5c2835e6dc7760586dbf196b675b6219686c89b9f1d4655ce6a9ee27d4f0af274379e37f9f6230f20e460c8c4dab94b7df59007ec4458184b236036a123c67bd550607db7d586f871926864542648c97d1d357aa90a4fdbb738f6c866ee9539c58620b85a0c62517e9e4ffeabbb31a5498b41ea5c896dd446eaa0380e384ee92f91a9a721f070802c39540684c0c41f44f141323fde8480268763cbd1a8a99e5149546f92fa42107b2e472ff3418a8159eafae972d86b97f36a5511a3ece5fdce7df82ac982abec8117af287245f8d5ad18fc39febda54f44916e6ba1a399eccfe1de5813ad97468aeea85cc8d44c2dafe722c7608b2ef4421ab8a3d623684ee9092a08051f119fe222d6580d55d1d5f217f9c69817e8391769d7319b65fe0fa760e69f3bb5ecdd3a56be8617231ebc25f55349535e79490f5ce15fa8dbc07bd61db648e6b2802203dc7de61d5bdf8898977445a09d036521c3c0994f13199516989af01df1ab3a0f128968a7f8e0b40d3cac8e825e619567aa10f1aeab1073e2020716f4533af8eb4f710b0b0350596490413b23925ce7606563ccbf826cdc22ace3b809e21f2c0c0be6fb13f67fa3fea6ee588b979eb13acbb1d3b0405b8ac50dae0ca4ca4deb87a3c154ec41441f73cf4ebd399362b37931d4e7f9ff0891e711b848f11e254e5afc0409418cb56a2cd1f98cd935fb489cffc85cb529bdd0d0b38724b15e7260cea275a621d71c145271564bebe474271154f41254abe49df7c0df256be3b1407cb769c39f3918f8c4198ac77f50236eaadd7f3b058ac692790d83679f7663fa4196b7ba7bec97154221311da2dae46ff99fd46bc61167a430de1e9f2bfa006c7d6a16b4a63f21c769195db247d0d65242d359e9b1ace1376ba1cbf24d474c93bc2f754e906d97d7edec0a82f51be37be6517f24507e0eac126d6964a1d147d189083a54dea30dfc87a53a39517f7a107b21ff6d55510e0609c8b8bf1110dc8b8f41bfa2a2ecefed8db52421afb0595469739b0832104f70dfcbb30749fe2ec35c5ce8e80571755c5b863cd28d49bf0dc3143f2600ed6cebc9c33615d3ec210ba365b2c0781460e8151fbb834448cedd6fd9f22b5fc4b8976532ea9e00986c4b868a9c9d7e51922067e53fe842a20a7a56ccee2f7b7287b58bad94008741897ecabacd1ef1b6aa5ee1ec02a765680eaf11378553f9a488cc2580b6f244b26bea51a3daffae68e6c74110073247d033b236b4782914f834823ffdefc0e28ae2a71d4ded84a41fac3ca78e862fa781a85a334781c284565ab207482278fbd08577c7a6031aa3c192c88e4156944ad37cc2d580e5afa342d2b4a6975debec798239f7b8db0a7919bab5a7acaabe6517935e5de69ba1cb2d61eead21931ce10f42488e024c9bba2c9ce447ece76532ba74cf6a28ccb98639c56e14e357e9c9da70708bafd749a4cd45ea62973154b4f0a2404528650367a0fe33c0ea0bce73c1cfa2b996d657702ac63ce2b1afc8181a9338919645a02a85cd75a6df5c76ac46491a5653ac5d7025e4934f1a6b41199b7b0a0230b262bfd51c38daf0186152a8b4127e8bb5935576bfd5f428b78dc8104a8e05b98ff0f8474a6fdd81794697fb886d20aab07a4ea8fab80a1a009930273c043659d0f59c65bc702957fcfe24182b273c7625f39421ac12149a51457778c05a06cde09c615c846bf4d6cead9cc703d223d575387f8e60f4cf28811ec822a220297989472ab2cd51c637ea2f7a657a842e77a04f534291a78c5f0ea297625b56506f7f21db830de04aad1ffa2d5d06e7eb3fc2d5e41f5bc588b04bb6087a5b4a9f382fafd8c6c37f1dc9fe4d2ca9feec54a60d0f12d8ab9846e74d836b51bea3c3c6eafce45caf997e252beffdb607762e0e86cfcc2eda2a64e2d62eda1c364c7624eb936a1b19adf305db91abd250b769150bc5bf13ff7d3df45377f4d69f977c0b84491f2c9d95b5cc522658f75498f847251dda510f4dc8d586ea4c4db052d409653d37daed917bb34c2a54ed57971da7895d88f1692fe4f7124b65d5955c528f4913c7ba72e934447cbeaed33b2bcddace5e068112371a019808bb41041fc34558326230c0f63a7245f09224eba73e91e643c4b8300fe0eb629cca408735bd2c199b8321c12efe81e4aec9e6f65c2add0ca430c59e7f3235c6db9c431bcfbe299b115b4b61d1639c1c4c3f69c7a8ff61ecdc0711f0b3bed86b10ec434dcf75c78c7ef95de2972837efda8d943bfcd6b49452af1664ad98ff804fcd74a417967cbff2a5da9c7884c59b2149964ba6556be156c60bca3cb0898f09ed9749dffa1596a6ee6100c20d363a4a7fd97e1ad052cf5d211f2a2f552d84cc44620207a70bb34bcaf790ae91d427ef945666bdf6d0ecc5b7be4f3f6d9a8f3868011289d9c704a932e53840a3f9d9f84bd0b8e2ec39c896796c3f5fee4aed539950fabb22611ac90d5b0e800d3eaab49f4976176891d9fcc8bd7d4ab3a11b160b4c795b6240c87f28efe87c87bf8514ee11817c77fc6851df97cb24a42a9082bf5ca3fe7d50886ae46f9507fb83d85bc6605a33cbf9d6fcc06762326bc910ff1086030bf265040e03e215c315bc75181a529877218f29dbf071e99c5e7bd78f156aee6e2a0e42ff3f0285ed9631be880a303393507c1aa96d19558ad8e71ae97e6e71a63e652d0dac3ff280a9e3f20971814d5f27d892a179928c866924bb354e97acafeec4193472198549785f4a54e9cace87ad225683a0328b0496c57ac59dcfbd4f979d4f602d74db8947f4de2c99c5215110deb1eb69a9d33f59307b26842710082691f643fdfcf40a71f551773c0fdafab0df35a72d36f9c82c9d3b8a9da3ff491676e3f3b00eb1c13b82ebc6256f26ae4dfe3fa1acec383414c62bc6ab2e3bbf828dbf1e7148d104f6a2c6cf9e521dadd0384f49b320fabcbdfa5eed6c3f995e30e9c3c465eb0bf710695ecabb5231ef0eb09b58301144e57ded32e35f759647c6f6df963584126452cf19eed72acb41550915c8c6da2366b08227872010eb7842b0ae905f3233845433512c932b054592d51bc62761888a74e19ab05152d2a06631965e2b2c4b0b618e000c2aa7b1f6db17ea9e88f0a93b3f5d284509ce87a75918ec0a862915381f65ca5028d3b8d10ccf46b0ea34cd7b13bb379b0cc07d93b583fddbbd51e464419db1278c55f8abff04e521d8cdcbe39bac24aa4694a2c18b7ad91cbfc8c173c27aef2d30b1096ae54c4cf6e5b78494cf2230b1fa1c4f7df01bae5c62cd141f39a1ce5a16ca3454fe9151021b0717c9fac18fff55aee1406d2046574a05b9a3764e5b8adaaceae0c03cd3e8989f26603634db71ab05081ae7330d2c54525df45d5bfa47fb50180d956e8225babba3bc411fe819d12218db781f58a222fa1b8684851debed35a1ebf58e3d3c85d9fc3b3ad727e82e9e6441db7ddcfec6046a9ce557050ec06d30a61cf23bf6f11414eec19fa30dc9708b474efe18cde6d56d52e0bc2e2a914cca44a7ee22bad8d765513dbf2f3cfcb499897e4f22ac0f7e37c8edf86e0dceafbadcc68de24d102ba5e8b94310af22003c6f31f598fd03e5f24fc61f273c0d15dd54e7fd9d9d01e1cc49b79c3bf0edb3374824bb1c7aca7a0b3d999867a67d9e707cd2fa24f59fce5c2fdcf308869fb71e0f36a3a69246122a3b2776311d6a7ad0f13a683a0f8ecb0c89fba4405d8695292daecc64ef0f6fac09db72037cd17abab15d3ea232142c5f0f1cfb886299806c71ab2cd6e38217077b2d722612bf78dae231d204dca4e03e515e8f09e8179d759d4619998a034f8b4bacc8b101beab3d1efd9eaf9e0b2f8579be15e1f728c4e58686704464ff2401939f0e96bf3ab8560d5dca05c811e8f89cb2e3ffaf74cb6f4f2bbb6e1792e4d841e1b88dddc22e86fae84ba1c60741aa9394d8fd731fb319421e324ff4fa777e45cd9ee7e6ea6061903bc2d66d0285ed3fc19164e94f079224881bee3560646134d71fd984652c67f67b0729ccf816310b45f777311c372de1e12487673b77c316efef54cf33f6bad479e66ca997e81ae77e8a57365506e6e2a46a57899ccd0c1244c629b28cc812cf5f3457ae9d3794de26397d7f130629aa6f1d7e6c13ac15e0700da86b3cded80a211037bc6b59a90d773433e8073f0548a95519ec90df7848913187c5ff9e010baf8b0904fd189d9a7c74cbed5a6488e70e9367873060bc5c9ed35da30d35c05bed084647ef19a68caf3c70dc52ea6a0e74710e93454246675e362d89648c2879e053994a88467e8ac658ae6adfefd84873f5f9b30a5a5d4cdc02d72d49c887c62fbeefa32de65e6969f865472da712c189e58b47fc4319b87940fd51d864baf927c41e31914251f5bc060b3eaf210744019b23aa23e94acddf548e34311dd5f4fe81de4d8583da57bd7d1df5e0e79c3a4f73663293353c30662be211a634bab7d50e7082ba6a14432b8f189cf678223cd6702376e2259117b35c25d9ff34e16906c50a9ee61d901e45c45acd04f7bfa3bb2296e553e1242abc0cce73bfbce598e8b2bcdb86ab508170004dd81728b05c449eeee832b18ef89eb124f6c85441a9160bf0d0fbccf19a6ac6b84fb80e0de5c22413b1b7a9fdadf32c37fea5672b54e430a432f2b1262b097bdde6f7744cfc15080ae9295e5471371d186853491dc420ee2573259a599bd807fcc2685e38239a714cbb95bbb502df49587216baff41f1e127c196a70360cdc06c13a32b506355f55ab6e6169fbd75a4365401f50b730f0e7951cf45a2280f5d2b278659897066bd3269b2daeb464c3611b87dcbe91e63c7f6d716d8e283f92f11aea53bc4be30894bff98b7c08bb41a1aa7fed1823bb7acc7967ac2d00f44363e95b0db6fdc2033326d791ecb1a72f381af760c95633bd33eda16edaf462d402b240e962f951fef8daf62b73032e7fbe250004bea4f0f46738e3395ac9db27985157604e2bcda37075f7ec951e7a6afaa227fe0fe35aece027e24f2b6650c070689930c5013297d3a80a29ca440631f7bb408e986a962e5725a1ec02eb77f70b109a9850dd703ca27488a176eca394d3f61811b22d95a71709e183eb1559b82218abc65238e4516f24c0ebfa7577c1dd8bfb5b1a808ec6b8a38576a4d019cd22463517c6674dc10283eb999558ecf160bd53595b46b2c84e5b4ce21503948594c1f04e9014d48b2de4a4b38c73dc2d3b96b6dbecaf967d5a09d8fcfcede19ba6ef5ab3555fbb8ecfb96b13833b8b733cb8664e3df96adc464f67436dd006638de30341b479bcc94696b363eb13949bab6e5a0a9d32d15c4623a25258ee9a7a982a94c7eb8c66c1010010da3e1842ecca8b37059f40ef08d97e031cc5468eb94e58ecb71b7e42be7bfc35fe2f504b5d00d430a907cbb887ad260f9efda0031c86fa6eb12155193c9c76f7cfc754756aba812e3a59e229deceffbfc8b83fe00aa8fe3f7a48b018d073ebc7f404d5a753700aaba9914dddb2ab572f7b667833dacf7ad8968829b4a35dfa4742ad508d655e08fbbf2ecac8994c0514207d97aa04049bd697c9e2a8f1e8b4281ea79d28e1d35dfd7e89a6dc7c48ca4d442adf943d5d9f9819f46df653a60a797593ed030ee594576892233c2c666a12296f01880a7e7284b9d17d7673c76f0190f7358651b8ae392aa80670f5d9abfc2844afb9c16318fcbc65c42c1d7eca4f4e597fb73ffa893e2de00cad9b548016eb3b3f6c5d940ee0d22963e194ef0dc4c5b064a834581a10f4e56139ec9447c640d22cd630e65b3088c5e15973dfa5773a73354fb5a766d57c1f8eb0beeef2327b805e335e0f901e40de87c65409791c83c519fcaec8d2eb587f74459c7f27a5758cd6451feb7bb48d5bba9dd32e01666aefc4e429f39d10a64ddf50bf89125cac5b200dd925a9822f03b069fc72521fff5cda4d24caab728795586753f899af9cdb1a594fc0f3f06385ad0e3fc1bb522647a426ddae20973b3cf1c93ddfde4a604655ae4cd46cf6158a10ddf1b1866ec4d3bf75cb87ed0324f16c55fd2097f724656d9d041a988b169d9d2ba298fcef8074ecb2ff956ff1ee32cb4d3f1b8ac38bb7d9f6826783ee100377ac71fa5a6b2e4ff37fafa5e419074d203bbe3c3498bc0d7411d682812d16846d3360600a6c8932ffe222a26f2ad4d2618d97aebf36fe5b5998baaa4be4f21c6b31e590796ae94b3a17c9226c59d9be0fd7eef494081cf5da498653037fa77887dfd1150b125acaa82cc37249b435d4065f0b648be1eac979ea3ec0618f241cec1d8ea1c86bd818d7535582c6ea5473e0cd522bd359b219eda2cf1736daf06f913b8496296652083cf53471aa5367e6a709c1576312db8919bbf890d79c18719d23ca46ad4353aa5ab0ff63c5e78dd9bee9c3de0eb21c40a4c5b13404a4a29603d2dc10e3d88914bf139f041c84834722c6739dbf29cb1cc744c9f879efcd0539aa2438d7e37e25256167c0b44a2c19122747a2b295e8d8f9d9b9ea0a50cd7eb99b6f2a3b08e37904aba33ee5586b23a37c6d777be734f25725ec794f8479ea50cab2d4f2f15f90e99142fee9a469de11eaa0af8bac4afb632057a42c317a5f58862005394a45e28ea3b3eddd35037d564b398799bbe5d923de4d092b0659908e38850f94e14a70f0aa50252253ce113c382e5ce8282b1b868c8ad31b5a3c238f7743612fcd86503382202ff7b0c3469145be42cc4575761afc0b11bb0191b075a0b8f11d3a994e51da37985a1055698b191ea20303c6e7a47f5792fa82063fd6bb3027cd8fcbdc4a17d8ac7a9ee99f34ac47d44d338d78c5fbd968aeb729d78e175764cedd78cc7eb923635aaa6599d68253db05d619aabe4a0f9071437dd645f575e6c4c3e42fb3e27fc5e19eb29e67089eb4d011aecee289118b0f4fc6da442728132a79b655a6a533e019417be155a2e3c0f2ef9062547bd2aa7ca4fb9adcc4c432e59754543b0805ad9ad989f46f4107568f370dc63ad7bb60749729bb2b0a5a7629d3706b0d9058b3a300b8f8417c01c2a03104bfd2ff30c78f197d525ce0667e70509a6aa757a81442affb759be90eb942d7c83446051868e2ed4602568b674da4db447f6d5f1bb5bc60a01f195654240df51ec3dab40621e21878872651bf8e9f389e6f6a0bb4c983c3e5981d9ff0de6ccc0c7573f9250d6c55a718d555590182409119135ac6e6f9a9c89d102c725354989f7c69b90a6d50c794604b6a7490e76e51c09cc1841cfd3b0c83914bd42da26a2dee9d4b97133dbb1380c3fc5458b452b23a71f6686e1aa284db8d18e38619b77b54c8a7ae855e88ffd2dc898d3fbe2ae1ee5cf7ab66dcbe058d15b8a440862e46a363828cb871539e694ac5a06eacdaf58ef284adc6f76274180a4f16ac55181babd0af6c6d058554975637a13158506d6a1c3ba21d263e20ad3e1f141d9156c3732f57085de8308bcf92d5efc3acc3383c2bb91ce5a4ba3f605a327cf2e8a2cc87ae2cb375cc7f40801e02879aa154598d80f144c32dd1a2a2745974be6764c44b9102c65e8fde3939f36c8668b05b0d826af3f4863f33fc6f41e45e1497a8ec7852d2f5e0eeee7e1d60d54ee804156c84a8a6a875d65e4a011343a81b7fb9c6a4bdaf8fdc3c48d367be0b73157047f8946b2525915be81b8b148cd33e97c46c1f90489ad3c02ab8dfce2facddb5f22f04b69603b8626a81c45837cb714955d932e5a3d27e86d5f251097d13ac6709991fec4647cd13a09a050bb07ecca56f5a991a61e7f511e2ca3c2f709168b1643c70e7575caf54cf1f4284d44a7f3a1464eae24fbdf8e39eb6c3c18385cad58ec56ba6b4778c9cc81da4a3bc91ac3d8a3a78c21bc8acfce48f4c601a5893ae3cdf640a4c5a3969650275fd937680e72d447462c3d5e8de2c764948ce1b73aacc8afdee1266b6938930ecb15e628c72e2cb719bfc1a624f3fa435d88857d4fb81e0e7c33c355db9b4b943a12b10df2a506f0960b63a9c6b2bd00d38f7bdff3a225faee717f8fbefc3f9dc82c4c0bb5f368c09cd44ec3f019eb04ff5334b71d21ff73da4b80f7dce7c67b2fa8f2b7efc54cdaac21823f9c5ef35324f2e77d8a9c9f73453153039d1a39bcc4036c670d27f40d86a9a99f076b05b3feaf2eaae134fd32e99c9e8af5d1eccf18a51d10f629568f6e55b05ccdcbf04a89379bf7da6512e5ecc6d707a083cd5ae27e7658936336f684d625ffc253e6d78e5cb81b065e527a49ea369ebadcf34d748c7fa3dd6bb52be8f5c84282b711d080416176057ef30a1057ded9ce666cbda842f07e9999c4ad5a497531885b3c90d259e7f79e662bc9de1e5f0ab8a9c19fdbbc325cf22e76126daf2a9c29178d338a94f5c46c4bea469c37533ce6a2391f3f0d7036f3a55f8c0640d21afb3bab40b01d52aa933ddbc732259cc7bd08a4275e763191dc8e28fc3a63429ea4f45ad22ecd5a0f98470b99d8b6d81be0b9ddae08de59a4e6da4019e5eaae8aa34f3365349af63be5baf8a21042293bae16689ad3efc63688437eac5e4573caae68ae12e3839209c92a4407b5c574f4e0521cc54f48b08e3ebed28ef466ce3eb939db380e34b6b412a2939d6cfcc064e6d84e355953ecd3e6f05cbbd386d11e654d8c2a2e9db11a1ff772b8675b74187050802f5bb6a75b8f119098f23a8ee43b00c3b6d5922b9b2980542cce7f4354e842ef67103581ef118c24dbd5474dd9406a1ddd8ae781ff9421db00d5c75f725fe599f3f7805009551d81b9d4802121e8f0d2694c53b424135ee3d582b7ed009d1ed16270b7bc15ce9239ba02512b41c5b25406ddbb86cf65eabb0432397835894efc0b526fd7a68ba45d61dfd2d45403528aefadc337f334dbaec29ba77e7726ee7ace456769a36d8996249c331dad3e6e03b4b49f54f3bee8f11cb5cf869314412340bab7fb3effcb0dcdb541124234c7726e40254fae134de7df9f60122825f8c078dc2a4a92764fd8db0e28e11bb089b6e3a77fc7baf4b7838918e09454713435a133b913a18f7cc813290d613717b3292e4ec68424c104dba1b78a8315fca87178bb0e8b45f9c70d18df3ae1358f57dd96dcc7eced9712ac2a70eef2d75b733a2e9a8fd7fa8a15fd6b74e2e76c9cb20f32a74bf5e0ea89d735684cf6b3dd37a6d9b72a8b36caaf3d143bf7fc8fa538bec69d1b3a354caf66ff0624b44c422bce56f1b82f595cfcc2a02fdbcabad19533bde70f7d27641c1f21e2a5874b27072e3f3445a948a12baffa0be22ac52f791ca5a8004fd2330229844cd86b52c431d0a5e07989e8a85c0fc45171fe663c5eb95c50de5a3890eb7a433c239e67447984a37383eb1167a8265c0c0772013e75d70eddf8fd3747bd45abd8ddd33d2656ac67f63196b80bbbd446ef7c01c89f3e4c5c97b80f8ada900973c73341bdda0373d1a082bb52f552eb1da4594f879afca3161a4a0faa7b4477ee35f7dd4a82249b12ff405ecfb95723e9dd3e1c33e9f068c7abf67dbdfd7225fdacea5b68afaa4f54bc4f8d80fb2075cf5c0c99f2a0fc7b7678168ca4ab7f4ee8c07bfa7818848158e23483674d920076b56e5d537c807b63472a3f3d5987c8490cf6072e61e1406d79b314c2c3d76c64755967b1d74a9cee8abc238c770e47f5f1b093efb33482c92305f25378b0c95edb4d72d7a8c5d1552bf54e01b1a492ad0404968d91d53e61e1c81b8ff042083a9d4e6fd58ec0690930673189e299a6f4a79ee97e67e2bb1f27da33905bfe747efb289280f0fa93e30fe7a085b07a9538b63b97251b8565e65fb02f09405a0282d38809aae2c7768946a6bca38322c6a1e357038969867d9031edeb99ecba14715538d460a2a370e50f0a6b822024055b2fde506a5e26e07cd9f854e61b88e508dc48923cda9e9606acb5210f79f0489b3e720598ce8e4e4dc0513f8f403beb497893e492f8609a5188a3a7a3f38f1557bcf4fede3e90e329ef1dd918eeabcaf4313567ddda52955904125b9596eefc515aa0c9963566960719c66406b3b2abbd5edc92843e711e7c803f78a9dbe5496bd3a9669a52330ab909c10fa3e4591e21d128111ff13227764245f5c429d4d1466a7aeb927bd7b45fe3b5118358cd7aa5f586ac65d215b256415a3f685f7097dc6c4530e4b755165ac346cec703483a1081945df23f99eb96c57de44483119b832dc6688d37f96416c662e4a759ee02a442b78559b1110a899dacb7d535860222db7d2959774e1ca6bced94b8fd11f1800c5d8555994d94f3cfbd1b8e2d6df01e2f83b1f1332a0c104a82eb7ca1606b736ca4b2bb6f9c569ea5d9ad7a40b1afb9f803aaf872947b617a0046e99ee79e7dab615a7043310ddb95e6daab5212caafa3ee75005919532cc409c5a3ea8dec683bdd8dca7b7708e6c487f56849d1406cdb8c2bb53249057dd7b6e8b9dd34586d0868c3bbf20c2f797795a738657bb6f85d8f77fa4ec7f3cee0d0891fedbdc08e9a629abbaf5f9180a5eb40116b25e57cadf2411263c116aa57c6ebc2544f84f5e96cdb16d1ca5df5afcf606cca96e3465805f52541f286314d762ff9b062ffa9bfb9133e5d6e81082f176caef12b3feea79387d0ab003f9ec0aa807e7e44a9b717e483d285d06f0e94ca7a8281c39bbb0ca8d9a837f09d79e9999bdf9cfc650149eda2fec0664e20dfc1aa9b563e54feda4e1d037acc3cee8e5b3739dbd939fe5584d2a27801eb9a39bf900fc6f55f06c847d26610119a04e6fbfeed96536df253de05463f5367df3c160e14ecae507016f3333d0bc795e4280a955a054033f71443e2ae6eeca3a742759d71c76100afd8df745a83b5bf1bd1e9c52917eb283805707fa856dcc7ab3b4de7add886e43ccd81e8695547c6e532c694e95d90bf554ef434642cca513409ec46e0dac3681cdaae2bc9badefa8f8bc17f508929c29f13585e7546facb3e902741e747025a7494ab9d48763e1cc2bbacc68bd6fee55b0cb6f67abd926afc0bdbb4a938fdaf3db6c37b26d5b03909edc98231aebba8cfe3a5352d2eedad8044f3c61674c0be76ea8d081e4a5f655b74526a3a15dfd40648b31b30772e825130b0828c7d15a7e2152486194cea050b81105e969b6648d6cab5c05baef4dbd40bf6056cf438fb822a68d5a9e9f1fdb2922b2d39a4646d8e437c8aef1724f372614eda7bee4fd8ef92a81a3ed35bed2d2124ebe57b1109b8c5acdfefd6c6bfebc286f8ead3e3adbd401181e1d854021df8046a572b2c24b7cb03b3b975850675077cae28587a11089caaa3474f3986a322d9be6b92fe31f28682fc88caf6cc59a006f80ad6e9effc5dc8bd240eaf365a1969dbd4b7e271f269457cd528a31f09bc2ca61caaa8fd7ea5f2f1410f1cadb72cda61b1f3095365cb3dad7515394fc208652d38916eedfc2057ace6dd43fd7558030fe812a49c640536636b5d7ef9733be6efc705a01eda78e1ca7613833ceb310ed55ef8ee71dd640ba4ad105054e827d2339f38006effe1becc9dea190efbc217b8eb1b4302131453d3ff882d8eaee1f0966a1a1cd7814f30ed1b0efbb81f72e47fc6daa6ccefd760d76ead2b782d6c4407771c8ba7dee6494a2bf1815ab7a1bc1f60b32e34d4d39791e645e4bafc954227d3a372afcb761a3ae59e54e136a25e0ff343e81e8af5d460ec3354cb191d9ce9955240ea5a0aa5bade0b2e38b8da7155f0197015017512426d4ef1692346169c769997884210585ef485be32df555de98fb9f2d8825403da706baef6c36f004c613a2be53da166927e866cca1b0e664e7be2add95b010afc85887eaad49274de8e1d5f105ac15dd71dddc45145a4084ee996eb896046116c5b541b2259b514fed00bb11e701a9d53ca9658da23ad2535f12fa2173f6357f6243fcc0e52bf6f9165c5a92869328df1c680fafa81f580717d38032f0b44f491f6da5d51cdd08ddc77813cf2c44fc7c2bef4530c919f1d6e5d1fcba61472284b41473b5ae67386a7b6fa191877413b1346b30b4d25529c4bd8462a1207151ee65fc9181fc96deea10baa3116c7e8d22bb28de89979d16c89b82a308c0f8f4eceb51f64f29f2665bc46e2e0ac636e48548794cacc7f9fdb27893a5ae8e3ca70258d0c169f6cde33ecbaf775b017f599400cfe19f9aa0e2f567536f9fde31a2aabaa418f9ea4e8c5c1fd21cdeaed2da07cb8f1ddb8c579a71233a9cca79fdf9ba5a658517197bdffc9995437dce6fc632db31337e1be42f15afeae9ab71e622606cacd4f14b457beacfb9e4f8e7b4614c043781c178aa4521f2c7964c0eda9e2d62f37a04f1640155ddf858d9fca6cfdf51e464b453fb19f4160cc3f3e3de42d30e18b489b8468f320440d55da59fc0577f430c3c5dda254b850c205775e7a6ca8023963549559572de4464d569e9bbe60cabe9ba48e09812acb601072f1f5dac5ddca0b090e65aa5c42fc66d5706165a89692ae395efb28af93622a60702a4094fef987350f883ac9e395eec8a2b68a234ebd5c292ce97b1380df9da9e71d4b0c7a7aa8c207bc70dff64bffef41dc64f9ccbcd22fe7d60399cc381737e4a830f58cd97025ad52d3cdecc64367f966970e3a44358ee1a33869386a45492aa3480419c6c8937dd260972fa366416162093300eeb481feb46ba668c650ec5988a3d93b9fbc9ecd048ec62768353e4361b63feea0adfd621d9415f16e6401a71ee2da13ec7e84dec0f1d7d2b69975f73a5e345ccd786edf5f4c4505cfd9389c851d5c9ad3925aa2e56fb86582accdb9323d2b0a43b1fea65df77e45e7ec7b4e3fce940dbb202f431af628e2b4aa3d02a8b1cf06ee49b35f1ce8ef67222653a06411ff188e2206b5813dc46b9c99511852e33787ecfbc467bb16f2483dc7dc8cf0012d10d9ea907a86a408b2430217f1030b2e2e0b2d7033a8e8468d4177492cec202aa5835f6619d6a5a5648a6299cdcb3f5250c07d764d8e92737b987d7ddfe3d020a10ddf86145cdc2fc008d1171fa995c4036126e8bf826397bd7879b805714a683ec3fa406172f93fe62187217f5758310b3af337e67771c25619c33ec2ce49b823a9208e96d3a94eabc0e4c79ab4ae21f75d63051fb5149a6d6304a1ff97ec271d0802269937b71d7e099ffd5c19240ed4fd68fc0e53bdf4091722e35918e2f4b87b56cfe120cdea39242a177b937504f7f71d8038e4d05a82b51ca6d6e937ae1b07985431d2f54657b9eee4513079650c74dbf07c13862ab1db04bc41291fe65202dbe4a545d09b807a654e0a1d325a3e70a238f2cf419cae85f6b7765bb2de596b4d3bed00a5a27f4549ededbf1197cefb86ed7b79aeb0ce9568c2c99421b3f9bf508dcd2388b8a41cf8b7127981889516d96fe54eeb81a43ca7f79b78a88bee307b51989be1307d005be5e5ed68fea0e75ebf21cfe2096b21bd536897811c1985e7a46bc365d98c52086b4773d83216298147daeb7469b4170197e39efb1d4bf7ea3c7dd0b476f46b80fbee560b5c948d630e1aa8821f33d470dd497b359f8b8f2f74f2c830a890e5613a69dfa2a02e2a2f7ff53738802f09e1e4d7fc8338f094712d656785b8dd2b46692ddf4fa8a7390b76f5945024b4c8cc76599e163686c2927f2d4bfa3b1eb9b2261e1fc544b8a2fff4b4053749ae65257a169b5e50f5d3bcc40c8741aee54b2fdf222e945317ef127239b40188cb3655940fc5ce57115fb39c84e051d45c6d1ab22d586920397d04920cd8569cdad5e9c9c90c1c91d5256b2dd2469127f25fa75d3a46ba5756c85a888786d3a2aa3eb3ce9c74f70d267a50cca2ec9b5aa92ad8f541e6a7446cb83de929ca1b7bbc900bb6909f914d148c572b466264150a04707f3d3129c4b28a627139d4678203b35c0e387d7b91bd98bb122ade27f72bcae6272d499a508f08297a061de4cb464d49820ef88b385266f6d7a3653c63f802c0b72db4a39277543af34490b681a3a99a23635151d9511e4c042256e98312e86217d89b736c80f762fc02c584e412ee02ce78b815daad9cf44c2a0068369ef2d98475e114ab8934a395f71e35eb355f913d90c881b3afa6596d7e5c3753576d5df88cf450f9269616ddc625aee50a6fceab1a668957941dbeef32cc6e1f890f431446c93ceeb2b8fdd9cfd65d8939c2b09666a9dc2584ea128b80cc07725ea24507e447a8e0a906828f4e16e47040421df6e97363c8fab7c373ac5c65214f2b65cdd3ba3143e1ab41ecbba783d704c980f2248d1c6a9cd43cae86d046beb581e18f2be77973789eb65b539f5ad0c09266dff67f74780352216837eb6dbb8f9568db63c63b21fc7319c06519407ef741dbfd6f3d50d2f11c0215bda77e0f7e6aa42c08c473fc147035b5c93617f9018d22f7d9335d07419e64fd1285580cb1c1687e88fb4306fd70de39628d844b62f1a4569ae99405cb369d3501d0bddd79b43caea54bd57e83a3a6fbeba828e3a4f836de98c54fcbff2da2a6c556ca57709ebccf4fc3ebe04a1fc38b90f92bf6aafc5c621485dfbc07d6ad5bccb773fb7f9fb5437a9d0c0ca1f3f7540ebb88884553353af895b733c3b39f7f6a4838d00029b9d36f7ca0d09fe8c04db445db9724dc527103798bc7806e320dfbfc9638ea3ffb8ff2c64204c3b2e47f0100669b128777263da15532388d76c15bdf47f4c651f8229b1c8f78c0a7c2b7ec0e9d851ad3eff22b9e14dc2b94f56747ada1cc6cac5c51ded3639b194e24a86af37827e0b54e7ab23ef2db64b759054a00ffe0608835289ac6458a5e5d1ddb0d5fde158813e3c4222d9fc92696b7f2ca4f16200787d9877f9c03ab7bdfd2d109b5da2881d58806cbd5ea2a9f2b82f15d7d9c9481fae2fbae15dcef0a64847dacff6d6f8ce7e90b8ae5333c79250937f75ee967395adad8c112b2da11bd11b4c41c9bfdd2785f9497cb7260a923c6c1fa07aeded6263d187b05b80ab8fe20fd29081dc31ddeec2bda47c63067743831328794f6f0d7fcb137ea526f938ed1215af739a76ad18997b25447fab00cba63b6d8b6f2f7287182b946525a098adcbdf265d0c4f723da22699b6536dd7afa84b9c02baa16ad0d7c5a7a20d0ed49adba130b5095a464aa2ecc2cb7fb1d0e3bf5b4b58ec10e30acbc43aacec09bd8d924ee0352e3791fd18898c6700fe9047fd39a8e7c9955ae4f0dad72e98f63ab72e1eb3109da8ce4816470a5fbbf5fa25f20367fdc750c8722703c4de649445220db5478b19adf79481b4d7f589fbb3b11e2ece6593e0e0e8ec3c250440917dbbfb146b11419273dce913346b3d646fbbf9624e348df783a4bbd5c9a007e1233f426b50f9c1edaa04b071323e855b163a060f28ac9d2de3bed5707858cb0d0e821fdbacfad496688b65264468c389e59e7080d269b4cd33251abf91ca3a26e011eae7f4c862efda7291b3dd30e23efe2cb2af7f761807738ac9ad91a5d61e91d9113bfafecf2997be64c313497e18c502da0b549615733aad7c64153492f0f7722b6db0c17860b8258fbff3ad54bc6a1b87ecb202057ede8d3d139652337a7a0746b3f117582b27b83f11858140a5b1ccc8dbefe41197fbe3a7c43992f0d1fd28647e91339f62ebb7d266904efd0abbe6b53559de09fd849aed15d58b9d2310b9b70dbc600444f9fae06716ae4355e1950d833066db593dd19ec119875fa9df76d8519e4bc374b9710c9673c86b069921960762ca85577ac1ea223736d46eff4bee3d63e765e5b7413d572b0c46f2b33fad76ec7daccf565cb183acf1d97c502dbe140155540c0855fd821b3fd0e65d532a1da0333776fe543775d6285291b02a582f65f9cdc5d6a2f770d419147e717652a2168cebae3150244ef9c0e09b41baab78ceb2f338d89845de385d2d8f829d05f7f541f2bd11bf2172ebfdf6f637ce380fe454f702db009388db6847edacfa11bbedb42783c70a1ef5adebb7127681d27b641c321a6d3f87c168d91082bdc46e1acec2d7656d8055cb0ddc3ab19407f37459ad237c5e15fd5b73ff662bf97f5b10bc39be212928e3ad4baa53c4d1dd82d683eeb3440f41061673519fce91500586e4fcb52b4fd4c1fc9147a56edd8efa1726b7412984cb6c41131591aa8f48506bc465e5f4b99792bedfbd089cb3828bac2ab21bbfad1bcf701ddf6bde1d579919ae8022776f570eace012317a0a94d67deb8e433f24447842566d5a704e5315385ff4adc08a627db610c94383d0b60deebe40aa6142b127cf5ed0719db5a66ed44a8c05c99ead04e1fef1dd09ac620cc7d768680a2d9a22b801f7fcf757c4ba4abc8eabd8c8a13deb83333649440041b2411d04243f5847a2fcf4ae9e2a70df464faaf0987046716d26b4ebde48abb5e9755c754709731675dbc2374b58b90e48e18d5dc6fd7acb028425613275a106d04aeb939688e74720487a77e118f25a3b555146d4b108b0d1ac8b597b363d71f4df3fbdb75795135f5bfaf378a7aca18ea13c2de47e7e886dda2573ee103f5a89b6fde2eab9e2f7d040e719c3a119bdf58be0501592f5900545c36b4d538168366e3aa54652aa508c2fdf2ed4386200384212c9cfd05063b682dc5952d5e1b61fc11043b0abbf3c935fad7aa6fb5d0ec4590231df2b1662132fad3f77cb6560ed0a0ae48054436c4f2b98a39c8271d25e5e2b3809f59d8144a12a9fa13f5718ea117f8cd6c37e73edc7bfb6b2b214d7a4e7043003cf2cf3777e27489b7557a705fd0985333d80510d3ba3866b9ecfe3d5f2dcef43ec5c008e45f626f788e8ce9ada1cfc2083c16c5dcb85a50c359d3d3650f65ca86bf0af28acced64b61de8c3e9044d88c277adbf852252d7caaf82ded20ba3174b9b11e06f7437cda0bc48393563d519e9d2f94ef1123003b350e9b2cb09a2a2913a10a17e870025b4707f60ac92cd9c70a508b5e285c283a40044d00c41fa9270b1005d4f078bea878d5fb83741444f013402760ab4a3a829b3a54f1ca3de9b6db5cebf87a59d8b99a0e3157eb3789903fe962f165863d78f4813aaa2049311b29b3c1195806384d9dd44b4eb24bba06cd6019457f81fa3c3b9ac356c2a201b283e2a8a50486c3a61d9ccffb516763c00955046cd58d2dc0ab9444d2a729c473a754c176c751f6dd35c90a9d34b831d815cc81280f85fc70df9120c463db61cece968e7e856baa74deb9c650474fa9f2623dcc28687fc95cfff6e6ec31ceb4d75ebaed8c671a0bac8bc5f946f51c7cc74a29c089edd5d8549ed4198f3c36fa5d1bf74471097e4d4c3eced43ef914cd3f679f640a2b4c5750e96138babc56af4af01cbad5dce615be5a8bd9f553dd9218d25ee18ed6db2fb11665c13c1285b612830743a06cb627f703a386cfec0d7b70587b00b01587d2316746682f3b508a7a7229a457233263baa16277596f8041cab7526a9005d1240d9feb2227fb0853230efebbf19d8470651ad797e73df79aa92c3ca8197046de39ca3f816fa1df9f935a3e8609e7407fe5274f00c3d73fd231592b672542f4790428464c2b2b2e93c12006f9de018c939c1a576a5f64a5a2cd861fb9fae5a7bad81f07f9ffcd7df91277287a7becb7196fccb14886b24748cc4dfd5802f9960b56efd9e0f31137e2a4a7ee097bb39e7c068437d80ff7f62c969756284be6f04f7fa56ea8d0aaec84e626c7ead71db2db0cb7af7e31cd28249e443d0c0ba0866f3668ad256f42678a3c61a11812daabdd968e5e978e67a0a3dd2b9468c06281a6adbae152e61bcb6812632ac72b5f1d1db5d6a6b54e7a1878cacbd0988390e658c513172f1c53f0d9300da10b49c15399e3fdbe1a83e8d1a390686985fa5aac315f50500cfaca062a155407fa92569d6859352351af72d1d52d70978c7a732d68db3faf838c27afeba27e2b2bd39f5a4dcf4937735316f0ba538c530d55fe950cad79e04c067fa2ede18c72b2c384cee26face82824734c868a214c3176d2341a517b6d5199e3b4d1b6a0b3c154a08eba3dd7a8338955f446c018a7017940b6fbbe9ab4533f8d0ffaa857d6ae73af3cd2f34f6980d25435062c68267a30dbf0c21d7fed2a19bb4154673e4804fbb16d2e60d6d49fbfb63cb7a04bdee1deaeb2679c2e972e53cd216b1041f472218bcdd8814f203a8646d7bd943bfc9466f00d6b4770764756915fc21bb16a6891bfdf747b5aefa4860c3e5de8007c66b85e2af0a6c0c9b915547cc8c7aa6f144e3c65d2cab446b348378335470bb1ea5efefb6eae12087232e2ea8c04cd28830f252507f1d0629d85c9d5ff7a67608678cfe2c2fa6bb32418ef7ca8511db2b480e8cb99c0298a106075c029d6d8be9aaf0b1dea63edf17d64021a667718ed22277752330cb38bcdf137aaa4182ab61d09b695c371d9c239fc45b12997d0b6be58ae26f5b7f1f7f647adafa0e7a7d4fb0983c7d9f8ba507d8402d691551e94563e66adae6a8de1725ca63537aba797485161dc4c568fa90eec3dbb4d33d9757d88ddac2f3c445f17542f31f78d6606395a5a90b7f7c6a527439016c7c732e38eff6b6e80ad2c004234999d427b10c3e86b1f16f234dedaa51b6b018d417f367a18397da7784035f9dfeb5ea50b2ca7cc70b454dc997e05e44bc7b9e070784a866c009bb37e566ccb6e1d2a8069edb92f8ae66f51058ee6c1548d5cefa3769b7c31f0670f40d40a3e66eaaa68518f772bf27fdb32f2b2ba9a05ec2d044aa41659d52f1b805e897e3d13f83f9689a2e4bde67cf662f9d59c4cf5a5f89a7892035b161186a077fcf9a73caa65e52815d21b098745179a42a6a4d553fd5a32fd18157adbe102f81e97c718d141a86b3957ed517b5f8f0cc6cb5544a0e2e2478015695306f674d4ff8bfdcfd045b4cc270f1a8f701e24498b6ad808c18f6dcef42df1abe0d50c75e6759d72cfd5b0266adf4205a86b9377697370b57cb5f05233cd0c5350054e9c3f076cc89b1c508713e3cecc61067b8a31252c0317f6188261800122e2be11f7f12a85f878b1b6f9e54c0012688b3ce6dd818d4d0140df5b0af42fca1897901f0ae756afd5322fa1771930daee9bd7fa1621460a304d4fbfe1b97c5d7d39c5120f94ffac7fd6f27f06ae584bd2ba4b2f36622d1c2edc8741330dccdad6c00ee2dbb48cfd4365a9a2c33890a1f3d7911d5c68fc9ee9b9409fdb6d126df40e453f1a809f56a59ba80d3c7650c690c6d292a1bdf5dd9da7741ef50c7c42a80db49e39b53fc0c4462181d2c408d5465b157235fe78cff861d9b3eb1001679209db1eca4320f9504f1211a0743e7a225741c56caeba1cf423702610773a364bf4ab226fff126b2a903fc2aef8897f661fba34fc57447d984918cad3cfc58247af04df85ef9758fc40d3b3defcc7d56054cc986184c1c4557b9b270cc8e75f00156b9cd5414e05df0f6e93c4b8ee776e0884745194adb79e0c1b59f8ec1a2809a02a4dec69954ccdcfe83c13a5200a201d0c87a2c3700fd2cb341954cbe2a367f3451a0e57dd79d2af7b8b8a7ece80aced851cc5d45789aa48068ee03c1861e4ca55ceff30a0218244acddcf293322d56c461a330c23929f2d99934d5bc1c06dbc5ceb454646067d0e9d431452ca38291a9af2f67e31db2e408bc81494ff7ec8cc18706e994a226c4ea330c6d4913e10dae7ec55754dea3fb78be285b1a2c85a4cdba399451752488853b0c81665c135be2a006fa912c317314d0356c0c6404a52932c03f2149f25b1633410b8523819565d6484788d268381a1c0d3d0dee38d349369f768a868de2bffb941ec55a4bd665183505fae606bc984a8d6e268b4fee5695cc8175325a77833e00812614275c7edb908b45fc9d919c2b3d8cf062f9f02dbb0d178798e2c836a9e186a9f41e866c362854972f46bde8bf5af1cb2b272e92f405fbae2491f0a69b6c1551b98ee637ba187eca5afaad7da9c2228c66293b685ced4200e1c9c222596a25dfcc97665cd84c5f562b57954afeed357bb205cba78b023cce99c5b157eb3a0b3fe704f754e129049bb5ed134ee4afd50d2166d1e5e1a61d7882efecd083bfce6eb2433ae2690855fabdd2be7fdae75eb74e5f7520f2515f267ba8605aec8880820a02c7b180a0a5d24bd74d4dcbe615d0f1ceb15bf5da90dc28e3628aab4dce311f2469a8070e5c45534ff037ca3e293d9e4ef74594e8365829f51ad2a861ebd760d79a6a9b56603d7951fc8966855b75b206e91383c0df73f2463d866376908034b3b8d6ecdbadc3f11f4775d93025fc866530d3697cc6295f66d9296eb352bc69c9ddbe6e6c8dc2195b2bac54b0b2ee7fa98a4c7d573ba259d10c4e1aa19308f2a9ea935d9f40a34445e8af79fb5c5f2fa74d959431e94763e34e6cbe2d2160198640b56dc1f6e9abdaf0d4ef676585b58f1723deeeb0f25989a2bfc3200feb9e6039c6101b00d8e231e86ec2138f350ee3f25923327ef378b8102af081b832e077ed3baf4e2f3a32df9eec4e8b96eef9eccbd34721ff0c7cdf7949556471e571cc00c900867893128395283352a9091527076f805df5ac30518e4ef13af6b689bf5c0fc792474b3724970963b10015b33ba1b87c9156ef593e5f0259d7c77f35dff9bcc28d374a9b4946bcbc5e3ae0fbed5fc7cd141a92a5f6cc35df34db52c6d4a9acb12de366f4412d2960450d0a688cfa2e732ce1976254142254a4de578fd793a3f3e07de862af52a81005564da066525099f1a5630dc74b5940f822197574ac710ec6fd244c23ccac6a5eb92de6b32fdf677b70cd24200faa4f4708f946b9fb7eaf386da71ae8508d3d48f78a5a7169b6591672cd02776f7c8d3c5a17e7b38eb00be2af5c751f63c41332b93f3b543b47e3f2b910e29a459650ee7a10c5ab0c325c29981e959a1ec834cd3cb93733ae28e357b057c46428c8d9c78dcac6f8f05a614c1edf937db0c672ec21ce53cb15a6706836281a491b9499598958e23fc99e5cbb9944b2f56abc23aaef48d41e1b52a044aa502765b277b71637f6db79aaacd5126dece7f61d73042ff70886eec9d2fdae66d952eef237475c54671a22683d236e1d0e3884d9de50fd1c2d412022909bae889fad45430b42f2c2a2e16134755fe1acb5399fb42e6e483564d93d6704b9fc472f40c1c3fd51f3214f4cee03dc8a891899b54bd940644432cd7bb369ce0b058edde25ea5f849172e70700e80f072beeaa906b617f0bb310e98b886d129dfd19b6068e4a843bff888db82bca4e2a150aa5aeb01a7a1e5aa7eaf581e81bb30ba3dc10be34d63d66bcacb3703772f7c5b7616548ef4f9b52213d6a5a5ea5ffaf0fd65be85c472550fb1dee28758c13ec812ffb146480efc5078a6809b0874aaa90159e056b8b38a71f8cf5885e011760f057b9b3d1e870f22ea86c43e7748546c02181ca5e2c410a62491444d14c6aeec4c33160204f93649e334682ef70e40797a088c78a0f549785ac759c2a09d6d32a3dd843bc6f29aa7374edabbe70411cf81d9b7f2e3566a7e1c5136724085a4bdecaefeedb958a144a5611504d601b65b32c43a181b4269695ff6fc2d3196d48073a5dc478846b37467b5bf05828a8ff2c9d7631668ab57fc2ebaf0036c23fd32ece71cef985634a4a47c0eeaf318e726d9d1073e17e6a01f597f7c7867c34e9e454fb93d7fd0036f4d4dec547e569ff406c0e2cd3b0c29edaaf6d4a3259489beba447c7cbf6133d964fd74be11fdb29d7527abeeefbe554bf9576b81fa01d5ceaed4ce29f96b6e2ab44ad13f3047257af5279c3e517b27154b0c9bef9a6b44e9cda33333065dd2bcf248f5b77eb1d30acaa17c10dab86c7038961591b3e26366794f87a1a4bcbe95d5b102178c744c3c51c98058db964a1354c7ac30f099bd905b9673001e6e8e93fc41f06e181d103afe4608e56da36626fe01f087ba5c430469331b3f9148ed1edd0e55bbbf4d6eb45ef6711b790081b9aef12941b20e4bb00ba3db00f370099b4970d77b4ad974037b01d4418bca948e9aa7ec5236ccbf390505c9d34fbdfac20d3b729b56ac92ca7845040baa34ae95b1dee38b58c0b2f1010c8974df02b0d0add15545a8a808d0b6f341ca24182bfef43169fe411ebd5efb5d2e4152ed1975af9e91f0aa0794c3dfc94b61d7c626a3498c9ab243f676793821b1bc3bc059412addc85b0b6b666e390816af8f2188ec24556787da85ac17738681ba1e7b39cee241f07da13fe00c7abf0a96348cf13132f3af5f56bac2ca6bf75c243c0512aafe34d6d1b21c594be2cf35ad3270ecf552869f2805fe4daf983364170202fbe81d2d58b09c8f2c5fc73a36f486b459dcf7de25a90075d3f08a40162ff73f129ab487b7484d465518dcd71e03bd4a3d2673f37895215567cc6beff1847018c1e769aa985c7cbe1f8f6004fda5f162322d66bc2a2c5ab61ed2773434d49b5ccf67b88f81116b9ef16d093f9b1f114ffdf79c2d1cd7121601b2adfdb689025b898ea9e1005e77aaf68f26d8ca5a557698717ae3c3bc05b49407c4b6c8d965bab73e3499af45c0b090f4dff5a0a5c72269fbfa9022c6fcb34dcaefb9b3131adfec799bac75b94e1351633df0c8f235e87a456d04731a55222e17353f79b0d8e67276666948000e90dcffc05ecd568ca11472f76e36c669903c3fef039205657f0d821c49cd86b13a37a37c114909c864b1363da573cbab52691e002e04028ab09014f34fbe94e9db4269984455904936602c065e7893996bf9bdbb369262405b137e6c15e973a56ed5f12bac6b501a876425d33ef3aa9877bbe565fcf7fc1cb3171bea81359384706b87b75320be6e3e6b931f8046d9efa21b0994f4d2e0f276713da78c10311e2a149a9ff58f1783a159c927f664e49cdf85d100b408bd2eba584c9c2130bf97b7d85fbc449e5595a7c1f70c634a4279549c0c72813b274cf4230356eaf2d97bc23e3e25bf4aaec431534f52517518a1677249a0e1fcba77bc49e5257e4877c8713f6393cceeadf74adb5dc3a53e73c8b9147d1cd3d7a777290a446f8911df2eeb12700ea275da483681e1cd6b552c7ad4c09399e8fdf4ab777e11a99742384df8ed22000853605738f5bc1028ffd7593389eeccc3b402780e8594120427cb5048b759eacc1f4d70a92768b63df1c7883987d760074a7065612ea3a322fc312bcf1fc8279706208bfda6884bba3d09b0518739b9ce77f846b9b3c725ad0344f705a16552d7fb853d8d50ee0664808b8cdc1333021d07ce1cf9888d2841cf635f01c771fe22f770a46dcc9c3f42faae86ac5ecd15b57ae394a76cecff9cdade91924fca518805e3ddf0ec48683aa8aba7ac99c78c835eda304a85b790ecc5e26ba328d88e07e05b3cbea6a8acb3d6615609271fb15e9937a4387ac1c8c675ddc2b4258b7c249fd6c0c216aaf4e1e80f5316f7953257c8e3d1777dd2db97ac4e31313b9261ccd44a29885a7de802f21c19a268cb57c5d76917cb4ee29f967656086f2e88ef3c1dc732ddd67616f53910252e128663b90e097b819fa1b4d5694f11b7439ae90716c9b4dd1c5cc7f52508d3105c850f0a9ddcde357e86a2bdaf9a8a696be6745725c5c0fef5e39226e766d1e2f0df0c054da7aea73d3752497a8eba351f8cdf48a862ba9619d052adfb0b315463e3204ef9d918b317b9e1f35dfb8b7de24931526f11142a7fb1899a7a4a3bebde19d8402b929d537bfa46b28fe6fbadfed8398b690f6e021d3b6b1888e68c2adf32d07f9dbf07f16b6725e9aa6f3427a148892a826893aadf36b8029f73011e386cbd68aca33c1dc60d5135bca219d9eca1ec44fc198b4b3c4d94bfa2e47fd14614d7d980bfd88637665034865ba1b2357ed0023a5f8d4d0facc00db0a0e1cd18a83d8165b293e7d09ff1a089b07053f51949da4a385c4dec8aaaadcc3d3c40377ff8f6c330a85d1ff35c2fb47958d1e742597b973aeabbb95b876671b00b5fa9044ba857461eca1ca61fe7710c07b2829fd06324438f8fae43c059ebb684a5908646286e1a23a6f4341601f0f87ae81c46e825aacdf86193ff85402266e348f870ba206882cd279a1cac77051776d11b04e82f869e8afef6f99672fbac2daf38ec5ecc36252210886668e0ace74104fa3da2399e29798d9e09f49e8703d0ff4777e9adbdc3d3366833d30488481c3774043a1af035a495a82dad02cb60b6cf0fe6935138aa8fa3381e57963d4399665fd7b696912b86ea065d97a212c48c91e2a6a9032afa678deff92ecd77fc22483791ac912e6306313cf162eca55c3cee03c3d46680c863c96ed5c62e71938c799794c9a357352b5a53c1f43df457936a23aa3983d5649ee57304132aef4680255c11fde51112c47e084f91fe7c3191d9a24bc9f73a7b523fb0ff895eecd939e7f3fa5da0d3aba98b827f8a4496b3ebd9d93d7d946fde1eb8c5e5ee434b3b700c6353b33b2db8140979fb8b3c1406e0e4175e97804b7a74430ec26455ef5759c0a31bdda688c813ed15ee5f563f0bfa0c7262cc7ffa11a6a7fb264e69340700bc4ec26bafd03eda7fcc5478cb7191815dd574caa678ac903d2c2ac54d47d1dccf93bbf96890ccf6c5c126e84f86df56fd0263090b88fed683a4833a71518fa9f90eb69da0f20e30ba4a815beae1ee0dab302c4b47dfe192467785c6e0fdcfa72e61fd17690dcccc4b1681355529ffef1fe1aced24083cb4f0bb0bdb7e24b550cd14e742d73f21ceb04a3fbe2b7729ec3232e3a0343ecbb098bf8cf2b1ddc8c8f16899c162b687d3b0d21486f2c6d35c84e44a8e994d0542c58f1d0763d2fd443e2344cb989ea31154dde2a23408cf8056e032104ebbacf6eadb370e491e8908cc5a18db4527730bfaf02e42ddd2437b8868dcbb9ac79e47501125679815e0713d105c63f7a77aa1df5070f157b8b4029b612a474c58c6d9451fdb95d3b3a7ba9682e4d4069ca4d805bb9751766111a34dc2467506613abeea896cc46dbead3406ac1f231ad9a25f3b24a26003204abadf2ba8cf539f6a75145980779331bf784ba28295677e79331282e57f8b935dcb2201b9d0fe396b8d5e9138ce90bb5ac7f782f3a3c02051e530a2b24aa30d2c68b9417976b90667ea4172c75eee8a7ca6385b9d13eb04c8b0a9e7f28b17d3d95b91d520fd91bdc978aab5473581d0f6d7de5393853124f3eef16f07ebc07e92112ebade9ce9ae4aa4b110ae9060f868d2694e6458d04061707e590f14bd4257c47f7ea1377712740ada78744a4fff85363ec4eb85a3b7c07d12ca4c18c9518f255eb22350c2b61f0d5671b87a1c01bd13a7a6ac291028dd8ec34d2229b2b792dba9eca43b0965f0f753c9f6d623af4532191a3f726b04c222e62aaae1b28229d38f8596e8c7e8a5da2e33f267409242449453dabf94c40feba07d8553098f1e05cb0ecfefbc0cfea831147e524ae815a9dcf8fa3cb0d70b6fb39c791621ba30cb1dd3c23cfe4ede5ca7b16c9d85d66855aed781d19aaf6f42139517f650b8467ddfb79c2702900e40ef696a29087fb892a1e2eec369a8a9544cbb6b8dfb145c7ce043de696d23b33f208a1a0eaa02ba1a86cb38e6233302b4028b3bf8e85f1724fd3444a6f7cdc92e0511fb2f47b36cb583b3fef8d51a14d8df86d1a1dddf515585bc1d6eff89f71eca0061366f84af68abf023a79a235d7247e08717f9146b5870b8cc30a1d8461fbd08cd32aac5bf678ddc167593a504c4efec33892e04073c91b14ec343fd263b55e28eb548e5b2d90e57bc0367f907c8aca2295b7908b02b4ff5627ae6635a3b6baecc0079b166d55b5fce21ffc67208d66a366b122dcf24134118fde88623e06dc876340217bda3b2981af089b839c5fdea577c63588b15243708bfd37f7a665f5f84b6755cc81f3f68df5b87ff1c2481f2e4ae07bcbcfd0087f2fd4ce4f858f8b39e5cf2ae918f082f31fd3008b8f83fdb51450f8d9d24d9763fc55e32c2396b831e28232d360d8fda3ccf7a6f3e7e467f7ea47db1b48366ae7ad660a93afc6145c30d00b2dc9e9e99158b34ae56643598475eecc122e12eb58c46db893fe360e7ec276ba765be8e46d48e1b4dd707c62de47bf39fcbbb55ba7df6b1e814d836544d193109734890aea6180b7ceda36a0e9f8580d72400da67623fac5c95db7ab1399371ce8a90f51d5b65657d9dc221033ef88552fe3b89733422d1d052018df0ca1fae8fb97fc885ea065412a96c6cbe337020edef91fcbf0bafd1057d32cfb35f99f02f4b279e62a4497d438fd40e12268a442f904840a7b85634be4c2627278345bc5653ee21432fb20c974b1881b43fa3c6c992bae13dc305fd8c5d27374af59aa07912f3c7deb997ed01e5de681af46bd28a07eec5325bc0b5e3f84a30a786e37b5027ee9aa696cd376ab2e1b732a08f1d4e6b7dcf2035b656acf61119fbe7be4cdbecc117a4c69935372548eb282e02150c3bb03608a9e35941865d0aacf0c1a8c24546c8bf1c81a777bc4d5af0feb262077067691480716f8cac8556564134b816884785cf9d69a3a610ad2d29aeef281ee6dead803f85622a9979e8f13e7511364186359b1d3722d87d42a9b994384abaa95fb35ad70c28a03a8a377f682f6c2cfcf31328f798a4aba09d690e9dab1312709c39a84c64dd0f555b15f4dfaf3a82a54ec2c02dca33e89ecb3b55cb25d926f96dabdf451cb708efe0c744689131bb235408a9f39cde4892bb62b34f56e0ff229cf2dc324a407fd07131c18f6f7db0e1a0dc1e556db8aa1f66d633923bc098d2e1b54eb872f99a0602a7a35110e4b5d2639caac03dc449b30ffe5477c3dc257b2415d4669b8de4a8941231942887ef556459e28aea02e6331fe3469654b5520cf1e50df4b0c327c02c0c06eb4a263739f518a03345bfef09f79a412e79dfb540e0cacadc373a3b51b203481b3dca6346015cc28816bd429ffe4a661536c3053e72378f35813eb7cd27a79c22a951784de391145ed89b34814cecb1b8cad6a4ae9bc4931ec30a38ebce5caeed69edef8effc56ba4c07e0e2296c6255ea7af9623bedde0c22a3ad488f18e6303c61ee4767020bde3e309a76b497db45faa20c4826dd31f62fb8d8678beb21068cc32c8b2c48128d5aec1a0ecd60481fb07b62098a1446495bf9a80aeb68fe3d3a462ca745779dba1d47ea4472e2703645ec918a6e74f3ce5015a809ee3a7388fe30241d67b5a4ba562918c48b1bc237324f4648864bfac44d6dca492606e5d3c19b9d485ac7ec9828991d54b53bb65c7351432cf7b0b4ac9686b5de05fef9a0858cdf7be73994964ecf7f091e416c56a85cec740c1ae463c38c1d2e1e6f49c0507aad0fbcb88f285645ff862c657aa37e2f163e72837e81f5948fdd36b74780782220d7a0a1e882733e724480dfa8d2854908b2c67a1662876c283702d66b1048268a406b5afc2e392fac698d32d3636f5289d960d87417a5a150886da021c1c58612e0fab68571434bae5ab68e0c4d3a00c07d13b2fe9571e85f48878aabad0f1acca96c5fd1b80d18136cd156bb146a8a68d9399abbb75c3bebadabc8b7e9151718a7666064b4dad2c5450a63d080dd83dd93e0c319d0a09e6c004496d0ee7161e86c31f590c1fd9c4d813ab6edec55ba7b390f88252ad3ce69d4d256f759b83f24525d6b9b259924cbee22dde8e6f02782c268ed0b26b5df3a07c37195199a239ecc7bc33e9566db6e3527de3c3860374debbfa8863da5e14d72c1586d6044a0b53b9a0de5b432a156c7e8ae2850e580f500266b9072f8bcc9a3646657aa037aee36d663ae3ed10700d0fd1478996a14ea5175a9a6dbc6fdef2d7d3937c7b21e940923594f336146c52e1bf2052b9195f84acddbbc5653aa4e9aea4bb268192cf656342cffc7cc792c8e6bb3ac1887700bb78958a31752fd87e62f60d56e19d85285aa6d8bbe2d0d352215aee40f0f2b90a0955e4afdecede02f2e4411c92b0ab9e16a20cb1c25ff0d928efb915eeb1dee65566570b6a1e746127087598a139022e0a30b9e435c02b7ea0af508d3f0397a40ffbce7c0a1816b041111c002488ce061a9b29258af12e1e112670a3bf062efb7d1ffe9143b9cbce68e78159d635b4a737ca21111c5d77e3481027a34b4188f1089656bd77f14eb5af2328d5019a214d2ffa8e3d1e3d7d9d17799e0af36e31cdc8614313f8deff767eece6fd2624d8828eacf7e84fa99b396685516597f2136ef21e4f9d5446f945648cdac18a51f28a0246a6fb2445f3ad621937e335e81f483efb72cd548fb2feb75d62c6f240bb194085f9ba4da5c95043214cd9ae52cf96d04195d219c95ee350c4a708435fab55607930a89573644c945c0ab7eb1a5e7e7dc5a9162e1fb290ba8d96904476fb279c69abd4cba24e8d78668a41c031b32c59e4080d030ca993023cb16b9c186ccdf192b7c37297246ad9ce4ab33ac8132df0be728d77c9245c6d4ce69c1f1517ff40a7c68d0eea5cfe1c6d9c3ad6f917e45507e0f6f65315c48251dcca265606e6a2d010baaf9556e53202bff2c13adc9f6d6ba89688a02623fe6c8e44dceba73826eb4d9053a38536d0e45c7d6520d1b3433038d0977fad3843834f42278defcca52a1b2877a8c899cc8296b99a819c7a0134f3c321f826df819d9b4b00315ee4a1402909702d0fd0867882c1c7061f5b7042b540612f4b271403a9c4915d659280f5a4e19e241161972efbbbc5b5009fe211c4dc8a7a9e8b71ae3fa9c505630a3b00ad1866c04c7080e6b4d8c106f7863032e44d931e032b14a26a843371fb51ae6d64b278ecb281ec1632d5a4cab415115954edf3cac0f815846fee4d3ded4214e1db3c3d644ba4c509949171a113c4fb7d2aa718342d0ac2a4cbc3d06b7739a75fa7a07a5272efc09a167159f6460409488fab39de4667d4e41ac83dab2fa3cf20b8db10d28c41af4325ffbb4f76bb618a1f42b0871485d62125dcf8a0fac2dcf34718dfe3726cd0f0d8bb1efa77f2d5d3470d6d7b8ac3195f06a5a21db0a801f58630c14109acc22e9b044daa13e25db89cee50976b896b2ef159f81d698049e465b9a5a83bba53ac80fd81f91d61769dd81185f304714449a0c0e33f581ed918160526932d73baec2c39997a41c91878343541d8b127d5bb6e679aa778f481dedd5322074d219a382936578756eb5930141322eaa5d772329fc64c14d7ccba549ba7838372e522d24903d06a06842cfd02b8ebc265ff5f64c2aa52635fe35794aaaab41661b4137b28a402d83facdccc5a55cf453f5611665d401375b23124794f48f98927851c2e8a76edad83f1c3cf2bd56fe49fe85fd9884984905534f6acaa376e246d33b155e7874943d79c76c8fc119a52966f2e6ed67619870720a28c9a6a220ce8e36bc6610ce4822a677e03627e38508a7a7ba3517e466d34dfaa18cf6095813aacab33e6ee24b6494bccc5f701c3638886a6806594adf00e234d3ea50d06b3c15f1d2f5571552bf0d05e1e24b7fb1048d97a38ed5a81e025d1228d7e829b18707167e495f3978b22693b21a811c3249f7f1f0bc4534ab9dcdcce83c9564822902d4e36a15f73ea9d7ba479baef89f8cf5218cfbe55092ec3f8b1ba643acdcbb0d59d2c2e7d89c2d3db838a3f993cd392c1f1869e36a089c3fd9ee3d2fdb6253c04ce7a3803cc61af97ced58c1b4ec72821b5588afbf5aab2003263d6fa434087683ee35e2414137647254fad00182c624387360888e7602b404daba33c582c44e6f96509c47efcfdc8663eb45d4252d6586632b5e4ac458b9fb40fbe8e4c21567467cef23ff19aad5f45159ddd3c32176355c86e00bed2bce9093e474c6b5ff86f41c27dd5fb057394bd9a69cf669640fd3dfd8e6b2c55b3c611998a5a6754579c75c49917f0d125e4526e0de3c20e43b6043e557ee26db7cfb3d0ba0b059f92c06ab72421e5797c7b3c5dd94a2982f72b5e44e6987c4f1e6b0a8ff8c94185e8f34b71ac896d798f60a0745e7f50e48b224f051b07a6e7d6655da40acac5746df75bbdd8664c8a563c7d8e6c263833b2efccdd370163026b9f9008eb40e4e8c0daeb7237724fa65c3fb4b636ab359a077674a665b58ec70ac273f099545bbc03467b5e038f7dec4dad064244e3865e3c17ba9be4eeec381fcd133bcca1ff471b913ae31cc5002e38d674ab0ea38ad40324ba639ffdca9085a92249c0539c12b66a97fed9b9b7fe3332bf9c72b795630ba983e5c837e9c9e905421a41719cd12f0baf3301a970d2ce4efc882f9c1528836a1969bc4f956ff023640878e9a29f24455029ee0e1ea8f7d8473e52550aae81ca961d0d1e296558ed97891fbe30ff9ed0ee890f90af98fd0dbded2f804e5a58d5c82655a1a67047f34ab885f51981aa83a8397dbc4e6137b52a3396f07b8952f45056605747395252859adfa203a8db9a19fb43301a41ee4a6f45c6385ad13ffd1bafe1632646a687c8e6a54b6795bc2b4738067ee5d2bea5d418e3b6e1dc06cb4fab990767c49f9cef5d9f2bd7f34828fe825c1b0fe41de040e945f5a4fcb5df580b7c867feeed6b4463ac2f190d22d8a9992a149bfabb556d258a9eab0e83fd609ca7707c6baae90ecd0ce3a1acb2ce539fd04d867e11020a9e9d9a7f94be0f34d5e269bd8819d25fbc79378fadf5ee565957b3b629b632524fbd0800a5e4e208976c8aba9397785d894b49ea3c10297b9bb364b1aa96cdea33153797839bfc7e98b3eb65fbc9954d96fab8496bece281ca44d5d073c8e3d3479d9742973ac15a869ebb69075b5dc00f0b76ac6fae0c6929c69717db420960258aa55955c2db2541139eaa5af6bf0d167f5d0b9da3a5ceac1efb2a0812b188c3539be51e459c83568e4e5ed48c11e469d0f6ccb8a594571198955d1eb655b99921324957db34e80c286aa6a89a81db8d2b538d535725dc782221c216ab8fcf9c62b498e67dc6e4c8ecb61945b55785bd40638a13ab3e0aff31575be9091f92ba4927c69ce75df57f544d44b2daa7d307689044e57932bc7394ec246bbc09fbe1badbf25c3fbc0dfa33486f382b1d7f6d407101f43cff48fee57036fb87e3d5d17727dd7a91721f80f5837b2875d717be73b75cdb8dd694ce92916a90ded73ff9338025a078e1828189a1603baadd1c30bce688646c9a009e65fd9e0b0e8e50060199863411208a797107d0d685e876674c07d46b1ba1f93ff5c6ec10c1cbadab03d4dedbe04900bd1bde6668737f7c0bbcff2dc0192af48a1bceb1e130154f2e70df3fdc52e7ca784e305e238f26ab3f63b119fcea30ecfeebe729834c3a50f90015f8628ee6a9af53c097730db154b4347bae313ccd2bf66dd2bfa84410929e14152a2af1c4651a0d1b68d8ac30916b08afeba992ab589d40f784f8e3d92dcf6c6beec499d16657aaf3561af4505431ef9add4b6a8d27ed3ca60cc25f1c61d33815d33d444badf6fc7e0df4c08f89ac240d463d9c5970a110bcdb1c5c0b836317a57afbc90851ead1d477b94ade5ef9a07f1afb0183601941242ebee7a33d2039a89f78da9fa058ce0faa73fd0267c93b188c4158e8eb05c8141f7c1e7b78a8fc8f935a893f33472f2177495af5bb6beea415366679ffe5481ec98c62d9bf4f1f500af059320f43d2b3794c79ed2cb4c27dacd40dd158dabfd5b8ca2262ccc906dd63bd9b50f901b752c9445de425a3b65e8b06d0203633dce87c01b422209037639995cbfeaf0a8f4e8c99b65d2f78defce75d551402f3bd14b3a8a3d5179f917ce7936d0edb190ffda159c161bdc7a95bed07fb65e8c9d83d3ea60882af28442ba93462e80f28be05299f9a0b5c86f556512f8d293958ccc3c70000ad69285e0a432787535d7533ff85b3f9f078aec28f9fb1f8738a63dd33da1ed0bf10c5aaeae9aafcff2771a4bb4342af9d1755c6ff4be03cfd030f5647667616ab8bd5f73f806c95d2e7fe997993aa62a9666bd82852fe6f56499271431e24c49c5e45264f82164882f8df8295f23e447dd7f21df672b8e51a1ea11d6c1e3f7a692344f6ec103e17b9ef17d5886c37aa254b94abc5be7c85671233e3186e6f0f4e2a206ddbee8d5e0f4e3dac45dc752f678a967db8a7e045da1126887ba5bf9600a6f560b1ac486262778e4d0e0b45d1b02febdb558eebb1932a9403ec710de53c8b49a02347fa277a5f8f3e874fee8c9c73d2709b8249610031167a8951e8c85d45eb1bcfa627cb96e6ae374458e290ebb26064ecc3d465e8578f553dd2307bf046daf65bb70e0c6ba1c7627ee75afd171c5150c7c237aaa78c597de8fd63033ebdfb124d54465bf437b3a955bf3da1beb6fd8862aa310a8d6767846688c07f58e7464a89751d0537583af602131453dbf4494c7b59e49607400866976192d76e07c4d8cad086067f95b0ad5eae5b0e56c98156cf4ef9fa1c28dff39b3997e1e470ead0dc711aba94c107af4e42d5e144d422cf3fb7cceaf7dfed4563e0c7b882555a04bdda7be2945f662c602269f36f5efce0e7961ccaf09892c076e7e0706fd8c060bac68795b926d717f85fab6e048e38363c52eca0f7116467c9d29f25b4895c7d93bb9ccd848d204ec205be2792a8c11a904bdb03bb97fccaadd86e86e683d8ee4d5ce867628251252b726565802f5f97950206ce073a3690e04bf6a9b2f35526dbce51cb4f2e9b8268e24fc783862660822bdd4343a0c77a519890cfb37304a7597af218792c9aaf85a5ef805b02d1c63686777d34ad5a0ab62f59a7fcec8effd50bdf74460a93222da964f515538714eee5d6efc70589592c02f668790e3843de44de43e8a9aae68cafb2768d362b8715411bcdafeda718dc9ba23ac574f363957405dca94942117d9bd64b6c5793569aa29576bfc9f60688eac258e5c52f36282612a9a49d55a5b89ea28f0297a0248358995daaf02e66d0ac86f08d185bcb8cf184a210252c23490c48ea3ee052d825164e64dc0bd2885f6b418f95a4e72d6ae47aa748d432ac1457905203eeeb94afd1f742da1c48b59a40b703414819d98984d35b66910e52aee4d51f1e93b9ebe525c5e00f680db1a861bb37ada7793a8fcd9ca3c30ceac278a18379f9d788c8abcbde2a40d240999f8e158bcbaedccdbbef21233d854a52bb1a0149c02d8280359b6f9000b9cd5617c6fd3e1ea660274afcfdb23ca3098174ffe4647ddfc27c9d6a868d9cc168c0cc803458b0ff3cf90294244ebe733310a3956b68b6bd285497bb02648ea86cfcd98243610bc761182d866eee3997996361d0bd93bbcda8b6213586f402086cd8f270aa46dddbb0e33352303e8d67c08987763246b57b58d9d33ffd66d7cc82d9ffa8c023461431712c6b80b281d3d3b08555ad7ee893d763eaf4f2279ba9f39d2f638431dedddb38d23c9bb438bdd8038ba81331d1449742f1b66550257b39933437937a1d82bb81c776648d1f0901ab5b44c8a724ceb28dc8f964abe97146d9d4d948c764cfa00e04b0ef4d8cf937a6ecbcb6337513062b961565be2594f69783418d2de04aa13294a829d67b37893f2cfa46d177b017c9278593cdad6df0eb65bdc4d32ab9d9e15d76cdee2fff5eea5dd5614287b649448bcccf76cd04617c3829b5ec7ca3f9ca23ac298667a698622fb75875cd9b31248d57d7e3016f3375fc1484c4430d5e44dfe72802c5ce1a0096fbea44ed152a5bd5b463dbd25c926ae420bef9b94c73201eb582a78fd3391959d6e8301f1ae691e1999890c981389be348dba32bf6f0f1dfc3a9575d529747299b1b54d30032f0504f848df726465e55670891973442d3e8175e5179ba5198dd419503e00bcc6e58bc60a376976ed995408a65152f9a55d1b6e3a9a3c5f9dd38d031f89236fbdbf20e63a2244dd0142279ce46e33cf97c2157fa9928d43f1fbadba9966ff768d1110d9f186cf556115f0cec3f71dd332013233d834e5cd483abbda8c9feb6c89153f167d467cd4ce94f9879d8eff7b46bfebd21438b63c27d8fc0360a37b93d986e6935424b089a85e303521343818ea7630c1ef61f84894a825497193e44ca23f155ae122e853b2bcc0c4e6406474fe8b72d3e044c98bf32aa55f274187da16c41fc55b9fbcbc4805a9fd092fda4ac9e7e7cf8ae4e3a681b6c97b11c103dbdaac6524ddb4bfe0b33452af5d14c9ef3db0844c441a144a993cabe0b2452f8df8dcf7bd31f87f4b5e5e944b6677cda71f6137d48c8de50136a27d9978fe2879165b6314551ec018ac40cfbc3df70314716f244655a71f01721d426f5429fb2cfbf8664bd53812c2478fe94c2b4209f100da215e5a524689bd19847baf8ddee155596acea678f364225953423e1067ad42ea36293f0cf824294021d2744b2837abdf9c32b0ad02672377087ca692a0ba0c960fb86c3bf1bd54821dbee4fba8389e3456a8f5ed792a65aa3ff1b9b3a984f87dd28396251ceb421cf30badb6a482a3e65283acfe0f92c3d063d9d71923ca9f4309ea36d92dde9f5972de0038ae9ccd3f81d7f81d1d8687f532d47d9d80dae49419c7d4afbabf91e2df48125d4497288f7324850f0b3ceae1d248f29a62c4356c54d39f5b0a73a259ff9aacb8fd95dd3e0c2bf6588b191e4edecc4ed5e7b1806634de64aa19d480a75cdb99c755ffebe23165b1e89582e7c9afc173a75884eb02c32e350d4c3e715fed61080d634ee125cb36175f1a307eca26850d6940b29f6daec8f40f1d35c0aabb2d508d79486a9f7d7ca2608316ff6a9d56f14179bcdbcdb2a59271e7c9a293aa10c8f7814ed6b548f0f81c45770eea19dd0dfb1aaf1358d3789cc9d29efc8854a8bcd9443eee9ad1f554a013ad6e867f56a850ebda0240daa94948c4565ca9ab8ccaf0aec52e8520fdfcd5d07dd0f63177fda06ba321ac7b1e539971b658a350ab7a1f19b8bdfcd78ca75548ed760ca704d9aa00d055c8e86e23e9d465d2d3b27fe9ecc19aaeb00005e7963855829fe5de8a71c0beedc7e8e8eef493b081355a53f233b840be2a4eb3ddd6db2c87b05325cb92b67056b4f986fc7ec4b3a201c227845f4c122156e98f878c9ffa0295cab07f88d22a983ce962df5a45025e94c6ef67f4769707dcca9437ae71a6b8dc3b56a71801dad9895e4125a8bab11b0970d11fa80cbeedaff753befe33fa7ead3f2fab7ed38d22fe2539e61573c5a05e35fb46b621e1a8e6e7e8623f8160198bc0a2746d669f9d8f18675f01a31545a49835452922de360d649c4c29a2bc793e9d817c55ecdcbfd1c36c60ecf8828f03b13c50b7a3c7ce8f2f02bfe72b286dd752b55c91837d4d714190a152b18e2d3bf2c43cee04e34066b59385462f7d05ae219d817ecd23081b596decd7fe4cf3a4a4b9a678fc477049da920c5697e9da929bc2d7690279190e9d1154c6c26f38dcdf9ecf9904734004ae918d399ccd75fe32a7b2e895b89c6a7394a02e29670db35069fc2cb42729bc9b9c1bd892c17d6efb4e56649b0e0b1e2dd7c0dde5f147d42c8f4e8487811e7fd6cc65d98e25d90a39b179994faeb662c8bfbd9ba4780b487f04cd754ae3a9f6e4ae69716e8e2619ccb7950a7d268f5267b9b9516e71283f941aead41d673bd8f3a3932a762a7461d9ad4259c3cb6dcd6dd01ee9539c4b14830c7708b1e053a533cc31fe414e58f451a9748a181e6706b89acdaa7875154a671841fdee825fe725d1c25230c733572ec16c437c6feadb9ec53b3e65ca3cd36a59e64c2ea93b0dff06eab245f181194d348ab5189c88f66b1b0eb947e50b1ae810575f78b1e50c1444c0342f964ba1b11194fbb0817d89d9f6f566c6a2e8dbe50e415ad4fdaa7913dadf77d624a01aa503c0592a3cedbda137e21cdef65dee63c46eb2e1d6f1f7873a57fe757f6261fdcf1518c5b81176f626bdda73c72850a383b21e300a108d88f36a62c0794cd2f0f5fbb882dd5564d0eaf161437f3935bc13572c1fe6991acf9a72b35a85feb13a62a9c728d6f0e1a9984c78d9fb3b44115cace58eacd6442cc25e0b81661035aba1b71949d7689d45fb8ec423bf2e60fe26ac37445aad00262782ee11b589bc7b97d28cf314655e9fe08ebfacd7abd5a366cbf25fbea30e3fc662db607bf74aa4e683c9453c71e58ddad78baa598965fcea68763aed058219574b44ce7abb0253244b21ba91ac0f95806b93a428d93c4fdaa53ff6e06b627d85ef2131661be4c246d99e1a6ddf1a04f851effcd049173972e51c78eefc538e2a2c238d1517b1d50d0ee991093086bbebc23981cf57c083c82d03b93135c3aecf105cbae9d92741bc0d40efa429a41de04c1eb6c1e6c1825a9611301e27de0574cda3f5f8498ad8fa17347648a8668b3e552be267855247286de9c7ac762421a3f2647e31b6b36f4cecf8184ecca5626d6221c7e46d2cefc5ac4f4ba0c4e62ded6c9ea2957ac9eb4ef25190899fa7cc7dfc0f3349f7345df4995be8be7e54868518a4afbbc07bd8fe693bc7c2e57f2f74f56784cf3d37689feac45ac5ede675938abc187ccca9409558d0b8af89efcce5452064db5b64cfb537d0f1d3b73239c2ed184d4654811218b262df49cc3985dbf9a42aa8f10e23acdd4449967af56dc6cb50e04db4f93b3cbfaeb560cffa6f9739688212c691503c4e7663f4783ad4fd16254ac536e0f19ba72f2f9c4288eb6f33cb73d2e770a9f5f76d0076aa140d1542f73fd66a3b0b35d090bcd1d61ee07d19e54b586a9ae799c92061fe8b394864d85df4425b959c0aea354a68cd9ae03570db6ef7c448e38861859cd845b5e2932c541ac47fcd9c985ac58f3c2e6c121d6300edfd20541dc6024c024f7d981b0ab9b223316b640680e424e47e6e86687efa4799bcace67ef075616581eddea4f8e54bcc7e9a33d243edb78fb2ce95eec22741b0bc12d38c52eb2f03662d2f996eae8f74710e3293fab32391e2a1a31e737080ba4d3a58456613798ab9612ae8393ccc5c45c76cc1b493de48f83283644305c98dff36a8b21398eaa6e1aa49b0cf426ffecbfe1d7a0e6ae34bdeb3212f316da25df53436e025786c705c58b703ae8abd31b4438c2bf2c83cc2e6e32ef424c8085a861eb23b26827ec610f0249c289dfda58223ce824a15b8b6698834e7266d52124dbc6674e4444bf023352e23e0cb863add2d4033d1fc69c33e54ee925b7cc881a4d4f6c5214c7b3d7828b41a374ab594ff4bcbb2ee8b9b02f1f6d6c4d8a7c82dc57e9727a6f7407ca70172be824666314c581a5ce6c912ccc20ef11f5e11391b1d888769158b63c7ca9ae4978ba1cd91c3dbbcc629aebc68e9da4da4c1654a2ae5c49bda071687c28b9e8dcc9b2db2a9f494db518e19e7ac8a48d0495b1dc39873470ed24cf46445d0b954f36ed114a970f2f8492ff06d964540fb00a0043662d0fee7bed5bfb66fbea5c50f84dbf70ff38733db1185277f2e1622557849fc573dd5bbc4cc19f8db2b954c1c5d5e6e4000b138e3085b26ba807c06d99cbaadcc59b104f0061ea6e24b803a83c0313dee6db108af0dade70246b93e315828dc1478562a77b2f1d11bdc773d938b321d93385d446d6457e267a4e7d4766b1f6a40d8cd36c1edb446e21684e4e52d8172b6571a747418ece19f484cce8f398235ee97b6f31d506f7ac0dd5b01d5d12a8699cb4791e7cb6761093d0fbd006a44749404b13ce41615ff9521b0557ebda0522f45f8ac426af440329cf8ed2e40efca356093e67811ded92f4c156f20e39d9da9ea22dc2cf082b23c8c9104a8ddfb3a0e15e0e5fb483630c28b9f6a29a03bfd03505075fc20a6e8be82a8d1c249aef5bab96468e5c01986915105cbd7ab8dfe616cb685e30009e25386cdf945421accc8cef90d29d4be5631a2eb1166af040edf7bcc5fbd2699816ea9f585c6559bcb01eec0d29b44eaccec1bac182a3c3893344c1a107b88fe829bb0007466f6fdebf3b135a5cd87afd4214489a7a956414034814bfaa0e6f59bfb0845277fbf3db47253863abf85bdede6d1b4fd1a68bacb8c56325f7308b1e094b30188f008c33b54cdf5101f0f2e24be08e7448975696bdcfa0b2e14cf76b09267f13775c43717bbdaee11716ae5650af94bbc24966434bd4e91500cd68017a35939906137a2528150b8ba87bd8fad8cea7fee9550fda2005d4baaebd209837bb6e3e8bfa15154aced7a7c17a76ecfef9b76dbe053e50e625e2b22ea8bae0c15da56d05d1c153f3536621718532045a9ef5edd1a40b217c91cb199e54583a3baa3e3341950321961076256be42ff74e37df955f4aec6146b9c21b30e62da3d52c9e2d2186536e4580bedbc451a65b1a27a8f655a149ac83dd74af8d7f6d2e7d0475c8c3c651b92be23598edef19d0e6efec4ca637ba58adfa29b9d964ab39ffc2c1509d9bb13f7a41f4137d94f4ea2282e6f11391ce845ce8a930c881035b47dc069fa1f46b3a32d5ca4dd756d07ad2023c3d29b0acc29603411e793d6b69dcddc9896bbe3a8ef32b0e4393633186db296613305a4b7f08342dd73c1db85819dfd027d60c9b2dcdc9b070610f7b2f271d4df66fa2618647b49e6408fa4ff7b9cc82c143e83b6b61f2fe56fcd3091a160753552159486da085f916f06c7e693fa17eebbd9617c96f4203354c8f2369109839f7bc1a532de1d4e9803b0294b1ad6a680853208b29b9617223989db5d8b08fa2397960710a103fc59d67ed6354eed6157001ca4677c821672ba8194f3af7d639d6a5d35d5f02801f2bf56a2b9998f4ebfc3532ddbf6cdb74e6d1e73e0a497684c027733a588d5eda1805ddce849f6d769e5839e7dca08a4b205b7c7ca5aea1a0fc957cc55b3d8a2069c24f6879f2b859d232425bf6dc117fd6650116f02e0a4c1deeddf7d1e1cda3480977f76ee47539cd945defefa15733eefc536d49910efbf98976a0f8b7e5f9220b1d24c618921424717652c53313aa0f71a14a6c7b51778a251342e3a8942acd533947bb95bf55f130b333dadf460cb0cc160b8fb3d6722552da656abe7b47a3874047bbb5711c53de73a50508cad70a56afb6a324bb017228dcaf0bf5e7c10b125ee756a723ed3d2387cc2b33120a3b6871bd601fd41df633dd51cca50aeb153f5c7cd113b7087599516079356cb71662ea75a2a6566616967151b60e347575f817ecec0e129b490ab088aa497bba13147cef89421ab9453512d2bc88f9ef03e5a547eb5e928466b9bc369849604f5e2b4acbc458f1eae097487e8315a4904b94e9a6eb7f13e6eb1ef9bdccfe84b95d587600aef0e9e9cb51f683f4e4641fe5542dc9cd8e8e8b138030802abdb615b7ea23c93ba8b7d6ad181f60c71f3f7b715ba16dd34dd2136424ac6e67326f4e4787374900d359fca23612d2e9a90cff34f4b8c145f6c61b33a3c73981a6a26d0429cf4bee317f45053ecd90321ac2eb0a15b826d2b52b29c0d7cab3851d45369092cd1f0b171ecc9934b21f876c56ea2d3cd66d14fea2644d6083460c5baf5defc12beab7e4570b8055b8a093692d3813e4af763649e6028ead579dfd419f27bb49b03adf7ae74f09dd9a12ad74c8b0093bcbacf0e7de51dede5bd2d2cb8f0b8aff997b8195e3f82c31e0be295434b87501f51407b8c8af1f816e30fabe60c084181f8996f367b996a086c6a2ae439d745cc2b86e2850bd280265f0eadf82ff24898d76a17fc62454ef6c918d86b53e44a531ea43133008f3d6140b2535b0b7362fc8dc759013543783ccdfb3895a01c26ac3aaa21fb3042ef5d07d1f2ecad22148b5e968b6b90cef320574e11b86c9d3063b789b0042ddaf7b3d8b416de2f87e821084b940d47abf7b5569e7f6d5c0f9d7f2fd39d227d0a951b29f60a19c55266598928c0f758d7480b70192383d3fb958ca1f28a125aaf753944c22ddbbfba0e06c79184a1d8829fe478f14ad510c0f560258e158023ed4148a71031ae3f46979b129b47db7f6fd5aa6de6e37b969f7894e9db3da8ef7f8f8efbe7655fb4b177f503aadc8e3061da19b1322967f284e6bb3db7477eb6e2593849f618afd885c30288ceb00221068033f2da851ab97669ed93cbe36367b7e3972ea5111e0e05b3e4b086cb80a5d03e9de2790ac3fa43bfebd6ea66f8463ded1160bfb9416a7490b7c2459eb7fef7a3a91f7f4d5914aec5800fb68aeeab2edb6e55be5ff4d1a84c6e3436350a609ec0837713c9694e37ae3de8eff198b760572facdda7bd905b0c2ec30713d60579e012dd3aaa3f081189c3632b6f48f921be30aef22e0fa8ee5cb4181ebffbaecb31f82a2c91a0756c0595f3ad38fcb8fa5b7e49201324c4179c04c4b84608b87681686e72c18b8818936aa607d849206f1ac03c758a0b8da4bada6750e4d9b365ed75cbc182544c96794414f9a2e4bbcc75b058eb80f3890634ca9539443d3923d73f3542e7fa7c1d74b561dd90345d6a443dd244d530f1edd9bbf7aba8780c40f1502b0c162ca05bebbc47414965bde8e4535ff7a5b4b21c272e8feb2a0b4287242346b2e1ab8ea0cdb9b493b4dd11bf4a24b7b1481c3cf2687002bdf74a21b6e004cb15f559e18a2afbd7f5571ca9b322df3e51570cd5dca9afef5c430418d6a3a122237bcda8c687521651c5dbed956b1c9af4b0319fd9b6759329d867a40a8840fd105f995c5c4bb51c2537c827df2c801b8f5a6220c85874cd02b6f653374ea1c06b3f277482d3bb8a311ac2c1204e428d9335c4cc9d0b7d81038457ec48328f4b771d41c8ca3588d6b99084d29209699474db9dd019baf9f706bd355cf631af566e605c9ebc0a3e44849d3f8f3ed8a9ad41ca822e006521f1464991b259dd84b5ed7ab0e677403f6e9d89827563655d1df0332bcfcfe902fd9fd18cd320cb85b1ece5e91d62cc9a58eb633adc40bacd8931d754dce9f2352a2d975dec353a4a8ff12f4f1317c485e050c3bbca0fadc77967c3fd8ef1acba5199106ccf8d6f4916ccdb2e7aef6fe850287121b7bcea3369db1777b4b713e3a3e8d10f3cb6d3bcf247978645f4b36ae1db94651c9f859b6f7bfc03ee37e4fd1de361bbf0953f804f3fb16f93b1e4e45bb4f39075210cffea7cea3940ae52fae3ea41c323df2d65471d88aefad42227c6bf54c61198c0e2e31fd8edaa12e65524b51edc086ef1f996d5c3e82836c4537848448da59de330423c40efa4bc571ab1e0b211a6dd44ecd5b03815f38be75c82c826e0cb1ed3fd41c22f42a730949d4aab9292f0a65431b9ea861c18097cc29df20292f1098807588e30a49d89e2bfcc3c1af9f2038bc182749fcffe9a1a153531a89213e507de5e261a488d5747ecb8d520c99b4c39ff51d89772603582c5768166bb8d7115738724659632b79fad3b649626a0d70f5bab7c90cd690e1b11949480c27925d66ad92b9b41ee84f7985957e0e12ffd040e9edd1337d6c0ec83dcf49fe20c999781e5a103c7839743d08d346e160924e740abd5cd8a6ae70d5bdaa5783e6290384d0341cc9fff77693a818764d26e8b60474456946fc24eea971067c898e390f2cd239e1f357a6395e7d1bd8b8cf6894562f854dffbcff6633b95395b1023895b4d916ae2ac214458a9d984148b0137ce43edf4a35a32a29614c71ff7df79ec0a80eab8f0a1beed86e76114dcabc11ef140c5e3f11dee07baad68f357186cc618b31c27f3df5650aa7ccc0a75252d43eff37b537bb4d5935804e1293885c492c375a3127e1cc447384328976de2890566576d09cef60211921888d54857b169e6f689b8db50721e56c5ad86424b4808bec8847d29ed02a252df01ad6e11e218995fc68cedf4e0b66559ff33d32b54f803a04739f63b4b2ed182155c51092dab92425ff591226cd2c021689b44421157a310a181aeb29e17ec54311e8408adabe6fcbaac09ceb68e41d4976136bbebe02068a66e523f0c6321c1a566428d476b2bf87f64acb94af63763371cc5042e8c2fcfc27f669017a6017dfe22da3ecd88c2e74b7a10c33350636d55a2a35802b7b38b83c149d9baf86a7318b6e6c3160eef74c8fbdce9a1e9ac54f268bcdbfaafe3afd137c4eb58861ef0338ba7783f42fe220cd02d71a1986db83651c2b3e1168a5e260bcf95ee113b8a0f4e83a9f12446b463782ac640445bd52b8264235a810fffaba469b89850475575251b35ed62d1bd0138a65306f7aa5e27858564d691c25f8053c936e14425e9c447ed8e862326a7c56b72a319e1ec88716c54d54ce9bad27a6cf6445a9aed88b7b5d7f795b4edb1b5ca5c671324dee3bc8f1817bc966f21e3f0f17d5effa121fd4fe47e4b656ee8d310d43c1b93c99064d22da76394f8c16f24a6a819ed72db52766cbf42da605e199916e71b001b0bc6557251e730ad2918d8b76433b5f82cef7f40477545237d14bd5f49e5d726c72e6f0bf13a85e1ee5f835a936b29fca6f99c414007e91ea06d1790e40d9e6162b2e7be231e66e397cb46ef2efb46beb6f1cfffdf463d3990630db4b4157765cd6baa8f962369a7bf296429b7ac690dbabeac8971c52c60e6d7e484fc6bd3c17f597149814abeff481bd4322be81db997a8345e5ff5cd0656d88036ce1d894afee5777da162f94e93bfe35591e0390f8212434ae8232967a71387145638de1671641f28d1cbc3237d787aaaa0a7058f7696f0c0ba926b05f4ef8ef6307f586f738d999a61e523d4f4bb5d729235c0bc441f2dfde3939ec16a32f3ef9a7a577c29a78abd110e8f2c403bcf1ab681873c8c19f872395adcb63002f4b3ae8b454a6adb3e5c6634df9a6189ec04b74ba21bc5397f5cbdceb6791fe9d57ef39b4f87f019d2e0e458b3ebcabbfbdf5c8d8b7372fd7b4b13603c4631f53477e91a881c343e2b92e6a6b7f6e3adc9869017659062def17794fdf90cb88fcfc96552b6a35ca76c38d192e7eb84c3379ae0fd59fa8ced06e9fe11dc0c09c9003627d56b81ab9248eb9bc12f161861ae313b9059e20767531e7e8887ca798c78907fc6931e2186b69b2058b3a4bcfdd0af67832d7527807daf8fcf037af27c6a02342f9bb2a48ab5a5d7fd44577a3147ebb792ed745fd37743d4f44f59216ac19ff2e06abcfe2345823f9cae4b0cb34c3344827f72e826c37e998260eea5110ce57aa6a610392887ef06960c161a30125ebe9f3f4fc20e638e9ec28566bffc46e36ce0ef67b1c243b3569b75c566cd463a02e294e3c8bfe703755e3be5d0eaa775aacdea01eb88b7d600813513ef2a41b2e2e7a67f9ee8aa2530e869316ac54ef031901533d3b9ee04a33749dac3f6c56fb863893ac42b07f7e3a41b14deb7c387334b6f80ed7d976e19d4c366507e3af506377829bfd0c90450cd676149132e55e6daa85e339a1f3ed4b0772eab01d9cf1ff62743b1eda40d1e3859e1afd85f370e202586c752c872148f017c598d0a8c84467bb1007b2c2b2ca7f7e3d5eeebad4062754d3b217c74efd865b671c3b6ab4a721091534757b9b7ebfd94d976ce5049ad405c887af1dcaeea0935be8e520429c6e54c77bc0d9539bbce0a9394ccfaabdfd59e83e5d087b130c27760650bb2fd8e0158c53ac7ef2f57f5af496106eac6644a07f26c3aec1a9291e5185d95d0a1051fc7f5191602850d3a9611099b4dc4c81164ea120c1f753eade4209550197f01d1ac35e27bc60e345e92ea0f731c19d1d731c85ad37016f8a9afc518149d5b8635eadd9d7abb07b1bf976c7c4db2af049cdbb33a1f2b8c09ea8671054b73349fc44c4063c8d7cde270210f0ed2bd67dccabf6cebcc9266345cd0010ee487d293be21fa4ea3572222720fefb7eafc6ce41a0c31c517f48177cc58002236cdc1ae49462f47e5e54c55f45baacf934c83e26be5f455c5bb7b971fe9365b937444bda00207ee3486434ffb3bb8740e368de6acda069845e1a5d2079c66cbf8257bc6ee8f3f5b81c2f3fef9ab707929641f8d62c67d1bc7544158bd8685ffad43c1baaba0df72401bbfe289d6b7c608b7544da3ec22ed084e1249f07fee4703b11018216615efc442376a1874ea013a869ead7c7c0dd9c6c0c5b29d708b978f1e12c37024b9a485304c64a7c5b8f77732d16a15cca437d82a9e8652b8882d3f5f545a72226bdd3aabf3eaca12e8bbc85837311f21f39adef4599684ea15fd55f08ee7ab0ecb9e5c158874eddf6a4a65976cf147632946f6360b2b6d699c02db02333a54112e7f30951399b57fe76de7ff91f96a21f5c5f39c888906326e2e4ce51f3023efb96f5682a09c3fa24ae6d552db0b366c0af6c7be2a20e49ed01983e039f042f677556ba0e96c11807cc487858b7124e99baab9e70f16b4e0453109774ea28315311c2ae51c53b48bb6a5bf61e2f4c2c0eeabee4a1522e1c78aa87948409268d2b1654e886e6d969cc48364ae2f81939b3b818e7dc8763a475275559fe8723e72ec13590e53eb538efbdf381a11c73b2ec5f4864e1488f737b8408add98da5f0e8d7cf3c414ac459e4979e4158c0647e7a7c9bf8a3c8519fd65057cf85689b66af9623f8661941b7ca859b4123848a0eafff0b53004a5e063ec0973d1f7f6408c5e988c42b58298ce204ae12a2ae75f15d80a7291d94694de85d6bf326a86d07e1eaf2a3b104a143b00c0127db6a68c51de8fb3d5f5f9ee42669e1c16056d60ae0d5372dbcddd72246b355d525f6deac19f118efa6ad3943cabb18f68c24547834bd6c42ad0a71a21b631fee5abe935e7bf8888dea53e45b2d69318275a5a0e3ea9ced779575132b4c2b1abe8783799c9c2d792d58290b9807dd66064f271d6812fb744d7589401ac2840187a9e15b0b8775d79d0503538cb5dd82407e15a7ae03d44023fe6c3e0e08f6cf412fcffb789587557bacf5720f0941fb42e9d1691ab18beb6dafcf38194eca93b9e9f4b3e1a5bce50466cfc439e7f5600a3b897b73c115d9bbc23263cba5ea707d0f62556da31f7e9a64e3ad4da4c2f85d1c075f7242f4fce7554b5573a6773d3012d13762def2143b4691f493074be7325407ab8322a4a00b1db90299285af2a69e112107127ceaae8baa0b38b36a477e55932a8696d254c2c82a893c2eb226b7d7f113f0c30d90f1cea1f0976182c8a0e172c2f200901f7da59669af94ffec2a72d5e16cc1db71ff6318d00661873369e50ed0f586e9df112a3f8484f7dba13fb1de3a3690cfb67dd8eac561d81fc43c7178be04105fdc6bd26b4ffe183fb997d472bdc5b586f62fe43b0be8b3f0d03d1e67e08d3c432cd75bdcafaf2ba7e9c3a26c788ce8af26f882a5261b2dc97cf4c21e49956df0b8ed5c4dfcb9dcc35e45857326ef892320ade18af60015a324d6efe0bd028b9fef2b9798a41f8763a8a424eb09c32e8c2adfa445d1ec96ff971423c1260a11f325e2abc42ffffd73523275f3692fed5f91a3a7b8db07229926df4a32c64553738558291d9523ae4af84b784283f011a7a2dddce4ea466617f41ee5c66dc2c7d9d3b28bbf29fec061a903733d0329c702a7459e38e6e611f9de1995425b008d365cef89adf76e6c9e56a7c7a866bd978229066607142730fa3e1f0b7c7018bf2ab361681ca2600a131471754de616cf172f19ce93a9312e39bc33c141f9e1a56e07bc144083eed1dc4858fd564bce45d654ed801ff4b3b2dcd8565cea5ff29e8d1d44839d71c03501cfd643bbfbcf8f1f3b4e9d237b1af4461098ab18f5a0811e71664b5f7eb479b0a46f4a950aebcb1374a3d230c365a2e5c14b143473c9caf005f5b4ddd6739994bd51afeee34f8014140dd32ba69d642cd1e3d7122f8e1826b7d4cf683f1d41e91cd7429e6e15ddd50d51a7480df03a6b8c9a35e7a0b772d712d1914e065d9a4f8c66986c3b8a3b85248975110bcf26bacd841c5a620cf49e7685391cdbacaf923681cc69d32da7f11161ceead3e529648629696294c5d68e600755052986443483866c57913a597174e5e3e91e95f5e8d985ded50f751391aa47896d9ba62a291c255c58517ea1c711c5a7a69fb96a2b591b908d808bbd90328466e6527d7197256e1eb70826d8d03840decf38107baed16fed94b7370745bed6fab9e8ba384e3f92205e29c7110949de58682f8163d9be7470509c0b9bdd4b2434b09447be405965db33060de3a5d743196f78148ddb1a39ff47e8f63a36d874baee2fd1ebde609a2b01ee48d747b7712ad522d8b9e75e115208f907818e76cd50cd05f842131d539f17c5fe8a710387405db364dbca3f59705568c5d3001b72e20e999d7fb9884081082eb032ea7edea80ccc6914984a2d6653781fc5239ff2018252bef70d22ec12668295169da25644c86ba3eebfd47b4d70902e2f8ea2104c23d85bc0595391f759a2fd7f3b86554b8a315bc8f9184132f9a911ed97a558f34d75a4a01c3df2de508d2567469cfed687bf15fd1aea28ec76160a77996735cfb86eaf706831b2e39dd8041730c53d797fdef088f20030b7c55a6468a91cce15aba174fd51f0ad57767956a0ef5e74b2266e1ad0659bc79020c8b48e55becb8ef65cd6d66fd994cf40904d9aadbb075175b1ec252092b067b23da07fb646b5d79cdcfee989b7bea7d82dc299d42b45c7ac90198562eb94b2d04d88a1f322c5fe710981b141891bd152817e2e9182ad315e96c71f4a40a6fc729561a64ccc7e644059d5a75247c1221211ea6c17ac54716eebf49095ffb9b9c46da04b5aea0d8d04b59cfd416eb85eb062f0f65de9da8eddc75276152ae2f626b73f76335eaa04741a92b8b57fcf8e190544a0d06ed6553b8958d0c598c352d3a4a97de7679d57d42b0d38cee6e54c11b6215de67406e07e7e6e4e27a6164e6510e2e1ff1f5254a5481b11fbe111b45581d069a6a5c4bccb3e3eb52481330503714f369dc8af376e43bd01be3d04babfcb8ee133ee5ecf10df2742eedb7680b805d340359715dfec474dd8c7003d27b3e476d8cdfb894cff7c73a8c1dce44b127955cd239e38ed944a196e36f09a3e6e615200ca9d776d095823942525b4b4ee9355c23332f25f6a373f4630051c6f621a787cbd9a6cecbb0ce27931e22f751f1dedab895a900e4fce70a9acf478278e7f1f6bfe0b9391874b9d782a3e1c87b8eb006ffaa58fb96e26753c122cff9ad0c472f71fdc42c431e8c5e733670533be00cbacabbf442abee93bc7ea81d5a946d11abbf2309530ccf05b517158f85fb61a1a3d685decfe098c0c4a52538110f9d340675b7707b8ea8f12cfacc9f4185de818a1f1e349f36d1ee09e5373002afa61bb5070a6b00e01e98110f658eed7b3cdb61e7ff98cfaf4098dda14b39904f18b0ff64a335d2a9b6c21989efc30a359c49f28be573f0947c90d22f522d42c58878bbb4b73e3a70148d4556b1749372fba5877f9dd99a1aaf6ddac2bd8f75182bba35a0bd921bd2f3c4e8460780c060267e361cff5b5449235cd0cb69572d5cdecbc15d513e3a13e8cb51d60bd47ff56edc85be7023492460a58804dfcdd67690a865550016867c344a17c91f2641b88a839a846238f4e3811411322c8aa1a55c39b0d91660989b2d040f40e1ff8d84c7ed2cfea38a10673ec11799e513003d2c7e6d29088d1f9e843ace2d13b194adebb3cb9b6254e420faa894d0c278915366df3980acbd7cb50e12a5ced39df0f52c522a59b235191c4bd0228f00ea701a540eb5dc771103de3b1f1ea78fa8d6575f3ce2d207d42e4499105323a198a9998ee4a712274c45b08f11a86bdd54d211e18026eac9b35b4cce0605c8cf9109f998d296ae18febf92b5852e47fad0cd1946e1edb6ca2a49e1afe7300950d759f193e3da1b62d3cd3786dedafe3ff82e479bea7df99f5c47396d2e2f7be5f8e01137db7275985cbc7ff49a3e32818af1e9147b46fddfb1ce83e1d0d47ed46ceea7cc754c03e40b808efa27df0679e57d169a839464bb94c1ff691c385ca5eaa9703db3ee1203b4f7f60c900798f5cbba6259948d99fa4774ee3d201e708ee0fd540f1a886b6f8d2e9a2665e071caa3c4fbff6c62b7c24649f2e544c34e4e45e4b04afc211c8e3a59a466fa254677f10dd3161cd4aff9461276e04c700fc86b5c86470496c883ef350b131ee6278f1eb4298bacf99cfae8e3ed4bb8d19b97220912c75e7a1f7fbb98bd657e3bbcfa45668d0ecbc07fcdbc13f77dcd73081b381b3b09206657a8b84b86d68fce4538a8944141e87a30633af01710ca41f24eede68f8fc5f26e85c8be1f98d4332d0ed847e57836ed81600bf325d166d9453b99cb58801ad888b40b0260b8c081f331ad91286e79eb92b830229643fecd95a6c11755ddea2269d69a4dda714f33a0defb90245df0af0d89c24e037189e0671f541fc6aa85b140dea2d5599395458aa4de9360ec3871031c946f2558408b9202cbc1afd99362118df1e1a8a2fb2e4947e9f0b1b5efc1d4d25c16e6f171bf6e5c40836bce5a42d1045b45cb5a041fe68afb534339e719026219a29f0d1c77b4cb39252d89bb2494691f222c1a54f1afd11310aff4de10b8e8bc800ac3aa39ab0eb6558487cdaeaceda32c666f6e9296ee770bb635de13469b43760a2946dfd0255f09cdb809a7ca2fdbf426f96758a2c29cac08c16a57ad7bb37c1e2cb4483cbc3c97216816413da5a668882336716f9fecc22a35b7328492738aed51046f5bb1df6a4c596d0ade4e40c6416d9a5c46057b11505273149c0eccbecb2ffac6eb4bf10e26784450b54f5aed5fd324451f440cd4dccec32d1b43a8b675c20974477eec90dc8ac36949dec8d260c1a2ab2fdfc4b0727bcdffdcdfb1f42e0815a64200a40d84c34b651be2d1d115686f34606252422c24a2fc93d83bb2eb0bab95f5102e3eeff19411563dd7a320b2a657080a3dc1336128f6c82226245474e0086e0388804e5df6284e85af9a2a87cf15c63f8a608e689274f708ff363ad661df03649fda426bafbae29056c05bbe296d6eebec85e25ec9834c80765df451fc52f1d4e2926a091bd82f673ebd8b28144f2318211760b529309ceb06f7b711a2bb9f8eecc98479b1d981796c1284ec99a1e9a40eb778e94ae7dd8d3090bd67a2a8acb10ddf917de5e013ab9a45bc240d641b5c3d398e1b68bbe4cd7cc1069f8ff1193a91db40e4a5a18a0789ca128d974becd2b09f745604165a73c1ccf7b2defe10f93f681a054db2798ea5ccf6a76c032a43b039125934bca11fc070558c71c6ed2fbed55be0098b93c26f24a082a9673ec53659aca4b7e84c182f077789c79c21716d4cd211bae4e16f0991000d85d31497b2d36ed4e043716907ab33aa55aa923aa74dfddc38d388f0413ce86eda7b87d658cb30bab22814afe3e53f3ec7682e0438ee357c8fc87f8bd722defb24106d22c9fa4b9a7260f3d39f04306630523c476fe3d79ec29d590353edcf4a4b7740d354fcd5aaef02bf44888636035758480ef2bd066ef882f162e65a715092c91bba4b92d8542492cd847723db1ffa05d5d96489a83c866c8949214810ede64cafce00e060c4f6f3fac3e342b4256e60e0a9ef52646180d0a0d873a1e1a3dff726f08d429d96e2582c4d3e9213684d46a056c4b26e5036b7816acce670d558f1987a76cb93103a9a1ec0146eb599af4c7d09d45918468d572a74e2209f1f4c0a187329915e80abbb9e12bdc7a419ba6bf8b3c3f07a4c426bacd3a7bd511e47e4c84ef591760abac0c7a7b1c10df5ca4e2744ed67f13e8c4e5a004eb3b3a1d20ed7e142a619ca05e375b430ac64b5401690ed7f784fb57becd8515fe1c997034c9a42a9c41ee076cdf639b8ec319b88f29aa3292c1eac478cbdbb571ef9d88cec5e9712e82dc213725e1485fa0c865fede176a7eb7e00508671c55dded4f63480dd87edd153f823a2339448f47376754f39a4de1a402bbe54b97fa5abd5cfc986a90f434412b241822a4900f9583c6be0517b0a3d19a7a2547b41799210327aa0f797f09396040a3a763aeab81911d2591fe531fa95b16aa9369873c5e2b0cfc2317fe43d588421ac1dab1428d3e30b5e3d27da663340ecef5465f6858eba77e8a0b806eadcce4491bc00282a3aea0f0d215996b988e4a80c2ad7e214a8ec33c56e44e2ddb637c7d139e26df25b3905afb2e415b020442d39cf0ca48d66d0623a950ae9f775b13cb12290e22eca467de035aa87922327896b7717cbf57b29a7ec1d4802545450d21e4d7b31f20f31baaaea7db66c1cb1b0e97802f9b59bf2c9c7253af4f19f4135a5d7d20d5c639ebad24683e80d1adc2d6c0fccd14395a46637fe095039ea958239bd7c7b3a80fc5f1b0b6764757a55e9cb341c0563cdbf90240afe9111d3d959d89825bbe9a2d1568f0bcef8c7e7f11193c9c8153cbaa12b9fc5a6df8d8203db4e93dc8110fcd48053df11938ffdac7c7e9a60ea57c52f6ef91579d873c9ac8a7052a0bd31c73d3ffbf97720a920bceb6a8ffb7c5158997495dc227c7119b8f0b21f4b93d9ac7b2e1a9cb5dc07c666602260c2eda461763110584a72c62f084e08794cb569498af1bf936bd78b00165843627655ea58ddc8796fe3956fc152eeea72976ad1ad82bf894fdb43ba4c16ce9e9c6f71973900819ac1e5781dba22c3190ae647443f0d73519363be421d1e0bf1d33a96cfa455ff832073b5e350baa04d00bb1a74e9deb743dc485e62b04994a2fc68763f7b4de6f0d8e285ef3417fdea737e28bdf094a42f993ca6375986da70c0346918c573893b97ac93ba6a171634d90bf4a32b7b5164fe8eb153506774d6bff10c2020ea75c00c5fd55e52560a549a2eaa112babf0dcf71a89228aa93528f033d3d948b5ccb6ba766981d75c3bf6b472453b3dd602d609278db575725b469e27fd500cd8e404a08d933f1c4cd096aa389150f9cdd4a7b5f5c30622187e7a41eded40452062cef5c82cc7bbdabed4bcdc9523b1b28f06f01b4e5f96f6f227b628d82d89bed775ca97a4505b1ebb5c68611f714ea2c0c71c9b60e14dc2e73c18d09da71f3d92e8b318489b90aa8732e37ec7bc595a8993647917054fbaf08ff8591692ebba093972e91abece2e2ad6b1810878d1c4ea2b93b3862308f6853594e073cc19b520fded0fdfd8e87b36c7d3bad88fcbc8527777568f8640af78a1d3729681fe1887d7af98362087e9e6db674f615e5c0f65ca1dadcc513eecd4c66252fa79202b79ad6e87822b4cbc335313fde4f0b030a1563d9d2956e40c2bc4f95a99a1ec09c65aa4c4b9818a45f579b</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Vue </category>
          
          <category> vue2.x源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Step.10 来，跟我一起实现diff算法</title>
      <link href="/computer-science/vueyuanma/dosc/10%E6%9D%A5%EF%BC%8C%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%AE%9E%E7%8E%B0diff%E7%AE%97%E6%B3%95/"/>
      <url>/computer-science/vueyuanma/dosc/10%E6%9D%A5%EF%BC%8C%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%AE%9E%E7%8E%B0diff%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="ad9f54282372fdabf8f02d45a522a56c1d2502511ea69940324213672c1d1bff">5808c6cbf3ac08533f2dffaad5e129c1f7677efb1b6b29d5c2835e6dc7760586a2f88eda7b3320ad8c7d69902491019cc804cb95f7dde1f94cbe7d5c0dec84831678c2e2a13004cea0e8a9d456662b3f47e1d8409e3ca69cdb67455b1c5bd27bd492478f7bd8c2bf3f2cc750e57806dbe43260cf5a648b2264b050cb12bbe7cece2a720ac18d680f306944edcc6fe58bcbe37c332d823ac93ff54ac3479c28e5ae7bcdc3c78a10fea55be0dc712803d777f7ab5dde7c8f7a7e5cb28bc6c4897c764c4364829060b81b7549ef16050c138cc4fe49db828c850e2c360437534dd9fe2c277d4fb3185eda6be70487c2970f3ced3826735467e33f65a344135f85698f3905e1e73007c2e6779070c541b11141bf5856eb4217097d19d66d1baad62958ea05a4be2671f75598311aef45487e8d8466bd2a1a8aeee516e32daf46068af87a0ce9bf6b3a45931e9dfd05c2a726543dfc9128dc91819ab111c05a972abae24f50d5283277c35d56d0a787c96e9344e7b9e7a02ca8668911f9ed35ceeff0f3af5b7280d4a28ea192bb474a3990b4f2defc6608bb8376cd1b52b80d666ec10daacfda70085d715e8c880b1eb790ef890c85b4586e057c3c5787e977732078a6b0ac260cdf26856662319c3c4d5f8df69179bc08fa53e6b59c3257ddb3f0d37d5c960d42f2ed20d6f697e6e8e6ab60f958bd08b7974b169bef2b18345026512a43f6599a2f126b65f4299c5079ecc2ea8fc7f5eefa4191ee041b6c68836514a44e19a9f1fe2a1614ffb58eaa7ab640972ea5e357d94a854623bd82d308e9238f3a770cd78ec3807a779fa930899948ff7957d192dfb8e7471f817b3e527a7e1e46214a4b1e3fbc7ed0b5f2c0a0a7e48f0da4ae557c39f55cf2c75776a588b45d5b021791cc5613e578b1daeb76233f3bdce67108a4a9defb4867e8a215544f3ec171d35919b188113fe5c6ba14816fb478de8d3ef81e5f6827e3350cc96d02958584547b7fbb176c8c44dc56ae12d15e4b80d840211187d046f45607d3c6a66108b5906c57f4be60aa51e73303c4c58c815c666209e14c8c90874722d89c7bc95ee5625bdbc4c51f51fb1618040f69457217bf5f19c33ade7a8671be1bfa970a298efb78fe0059bca38f0b996d6fb5e4db757b9e67c81ceaf0c53949ec91774fd9c97c10f009b4c35e2bfa662c7039389e2b2b83c7b31d3bd89e9ec7475135c654e5ddc8c335daae07ffa80adb45278f560e511df0926e7bd83a5bf2da03e886ab4631b5f9e972a09129d43d49a7c9e6e8dc58457b596bed646304934bff57f1bed68acf33a10ac9eef28adde1f97199cd899f9454b501d75b99bc81b3a4a588ac132ed2e202abd717c55768c20e11f35c085522f7239787fcc0f631f3a08cbf98dc0a461ac31fb14584b2930220cc1f666b225b51cec0be5439b425309f2c2cb0b15e7127286c3303ff73de5f935c87ca4a1231663cd0568d2b492486c3134621ca295b86e6bfbb6e0ca8b7e07837ca89e5e7ffab164cc1e00ccbc2caf4d1d231dbec413cf4330fe0c8287758d904ed6adc51b0cab8fa762dd6f9c9b4ee928cf7f7c8393b0921593935e19548dd090fff911e9bf8491aa7748fb93e76bb89e8744364912a55d9b6584913ed8e86dc63040a11cf0c2f52bf7d705289f0da7622b0382016ae2a18dd61ef8277001d48f061c8c457b20bcc95844458b62e043c3dc29bfd4a1772dd1ffc8aeaa3f44f8cdcbacd0344262b8c1205191d4d75c8c520face613e4c86833df394d784996e61e67a514c936696f42c925b091c9e7fe8f2cff95304f20feccae3ef776535bfc2ef59d718f24916a58a1c017e6bf3b3222b6a4b067c60bce131e5a06428dc5c54ea2cacddde3c056257e41a15987225c5ab3da9b714733d8f1082677f44ded2d222d87a0466d1623ff3cd4d548c03ffea367f15ca48550424e885156d70ea42d1500ddaa8523a5fe70f3c820c2c63f197c575f09c2901d18dd9643a2ca5de806003d7a89bbd1db1777f3dc14dd80c30737067704f6947ae05f656e128f39a17b52e767636d45f5785f03b017bac8de5535e9e76be0323e98762d032df569b811aa9a2ae21b2da30a48a575fbfe30a9343d20e2115eda9f06485e6d550afb01f9eca2222cc83e4dccb614865039e0093d87f56cb998f6368fc9287af7807f95afe6243a27475a9fc78e6e8bdd4334a2e8842f6aa5bd50a3b4e179df74ed45fd6dbd498a1dbc389361db09f3dd38a00558e504a728fe5b209d495744ba0f690f44a0ac91b5d73b6cafebc5c8290956ea0f4fb119b5684a45883bff0b5bfeb6dbd046b57df7129a774f1e7028748ce3ef8c5bbbe34e26c351aa1b119a08f91a978d5d18621b519e9c977671ce4dede17f02ed20aaf2142fa1e2296e7a0938253bcf56b8dddecaf312e2fcf072f162d6f6713676a209c9b67f2f38181f1b9af0e41ad94940b46d7ebaccf59893a22dd0b685f1db66c3bf96ff9a72b7cc9c047cd065c8551b49e154cbcfc7100eec2565bb38e28e77af063677bf9b9c98b5b344ca59909d95fb8222274af6d33de13c40936dbbe384e746d9bcc65fa0385ca6441b3150c93011205975d45a2eea1fef48bc2c498e11fb183e302cf348b4086e8ff652eb09924a5d5919967f38a8ad443c92cc10fa09ef8738a2b455e0c396d05e9990c7018112a5f9d2d41382e5428f9730426baaad53d6ea25e44945ae075f72f49de3b65015d1bfba9b493cb1d5eb54081ac144bdb67b8a1f791099c81a496ebe784eaa2a65c16cd431f6a76af07bb49b3e2959bd65389d0e69d3bfdbdfccd4d796c24b0f13a04ee1faf7b9e3d86983652b3e9df7c10767fa924ab75b96965866fa95131f616aa8b250f8a6936e397f473decf3f77a3c97b7b64875b6918d451bfa7650e722053a00fc2ee7c20098ff9d566c9a0728b4baaf1643ce04c2e7b80167bab69b60fa5c4c53d934203bbc613b93f5b615b802c81aa08d0756d6ff4a813d0b61fc11f1005cb433c94785a85608ece72b92a2310135dec5b11f180a6dfc0438d2654d8c8fad32cb78324406d14a94dfae4c322cbd01ac1ca451de26b59716f0c998147763e3337e10d723d66c593ad41e7291b1e0370df69d715770bac6b5bf09c2ea947b00d8f343c131e232d1ae721ecd7057001b50873c5f8f5774b1cf2ed3df2dd7cf69877c35a1683e150d4dc3f69ec5d30d9257edd0ece28b26905ade8b7f470bd746b98e79e7a417f2d83919ae5ec999f51cff10b9fdfa020eae2bf3ea812ae8d20a68d98277bcbe4b192988e40990f3adddbcc2a24132e5c9cbc029f0670554abeb9a0c7b45541dfe51d2c32ce4f2ab2d291f93e7a81811748a2b849d04343ba1fdb54fb15d8d6952a1b8b2ad2d7e5037658e800a257bc3aa0a40888ba63cdfd9b6b054853c5c7529d69c5e04f59efc3b8b26d7ff53fcd655d0eaf849f75b47005c3b6177ed721f26eb863b595a7eb921e189c55e1215d617099c66b6f512e5adeb0dda9a923e1117d5a8779f9a2fbe297fa690f5b2c292d7699c425d5a66fe1a87512c758e98dcef658b4eb8b61f5504d357ad1d921a0df9dae1bf22c3770e6c7cb88f7e0195ff0cb1e9d748a3658bff3ae057c6ec757e3da2051656dda075d7c8fe360fb69d9a5da055333d1897e0a9af65dafcea2e7f274bddd6e7f4035806b8a72885c2e5f7c71dadce876f3e7240c08735815cc8fc98c8d2b2b07f2f5d88db58485b6b891db7bb6e6c52460cf8d9f89a4c387e9d53aa978728cda2bf37a6d70ecd7bcaeb7e0f9774fab74295fbe7d383135fbda4fb8df2c7f1687a6d1e18a0e8e26c0e190a153c38f228859e4a34faaed952a225f5bd67338c9d163314de6b57b1d729f5dda5cea7c3e1b9d189787b67895a073b5b3cc84cde42be71aa2991323ef77dd13d5a0956fe061885b8102a607f0db2e1895a08481c8ee3dbecc4e0910a50700f40b95f030cfab748496f4946517f14fb7e35b1c0e0eb7721031dc0391a1e8b616b2f56ca93d7534e1217cf580cf4e495e31a7488e06effb2117be95f4cc422b6be762f5042931e1e9feb1c4069adcca0573ebe2518dfdb7fb58176b3dc31fc81cf54a134d5c5e399329dcf9f0ab74b52eb9154940caa1979ab5c12b96dfcdc99a358e6a1b5263a79b2bb1013e7d7903c19eebeb0125b2c36c9810ee569f5119cfb19a7d41333d567c0c434f37526cd84412e01a0c4daeda0affc1152eaccfa30c8ea910368ae0c2d75e4f8c5f2b108ed2bf1902b13ec47615fe21381e180b34f24553bc81b5dbbc34d8032840fa2bbf5bc8167ecbd289a28c2adec1f079544a46db2d79ad32cb10c271245763e325654986f88d4406a598eee38ac44169de71e23415c22957ecdd8b376ad3bdc185baa6867314bd8413f2b235805ed71a9a2f078d6373575d4ef2f9a75e747d28ce6becf2b0bea223412af7e0685e279c99b1011680afc04b76a19d56c77e637eefe74c2ac867240c3dfc49660f92a33d272054c7bf6312456679a40595e060871d6ad746de4d28e31f2d8f771e4bc68d1be61fc37befb59dfbdc87125216595dd2ef6ff62c7475475af35970ae7eb2c1b1b589e69c91e993a1b0811cccf504f54c65d45e275ac10d99036ebd6827a6e89322170c6c3bbe6e27cc64e494043886e785662baa60b97e59f935d749c01bb463813a2e12d7681c5e3694918a1c42a0a70448cd1a17e9e13fe852512f0b12fd96df987d2decd9600342436df314b71063ffcb4e0c1b6c03d774a894c71e01314882235bcdc92b3c4d050abec1eebb9c0be233ec9afe8ec6bae9727eef566c8f2679cd367559a414ab34ffcc0415b3641bcdc5d87a98b811aad7f4d67ef9b29b962992b36d139c64809d41a3634e24ea6071db464ca1488231194892c4228d126a5a38678a3d7dbaee0cd69a284fbd2c1c2aa09a03d4c31c65ffec9a35e3a0268c979ffccd551bfc95bca4c21567db8f13bcac3f20300bbfebb451d10eb7c0c64a71afc30a8a3d1098c57fb42d002a7a6b863c841762c3c651e688fcc3be973db6259a1e9880155dd87d37884e22568c4022055f5f5bcf644908660387563092938bd9003874531a01e36d61b65aec5ca5778d48ad8287ab3ff301bd94b6a59ec6835fbef3b549a0634974fef7c2096febbcea91229b404ba3835b3449d762e9829de0f2baf2aa93da41b76ee1fa5bbdeb52b4250a404acbbb21aeb50eff066a93797ac6d6d9b84398f5f1c76d0c65c5975f1849f8168aef13ba5f1707fe87f268ad0dc4215558f867f6fb3b9a42bccaeef8f83c2c2f887cc5e11559e6b930431cf78b07641cd021cd683ac8147cbf001edd1606045009d65dbd0c5bca09dee34c4b073679a09e2485033c34ce82822303b6aeb422d61f06d2a19bdeafe606ec380a721b256cdd48d7c68e3a81768a6a6859643c9f909970f16f065ed521d9e7358e07f3547526a0ddf65b24bb18c2d1e07b3f89e19ed245b96ef42ed1ffa3bc487394bfec3397df3b7f297a3f400db6977435c5366d0c5b73f250f0a2d7fa8d5858c18fcab3eb212dd444b43525c6f846b73287e7f82240aced149885e9c4d5bc8a651e694d75b90a53860b9edc482f6f9bc62780d533007309152918be03154fa7467fc1ce445eba334b77ea93e11a87f21906808480ec302e93a7463d30cad3cc82568df06c38833b61392dce348f0c4bdb63315466c340d06f2ae4a22a0dbd3b7bd64038a4f6167c78725cef4717c8d4558bae52696f0a57cf1dc51430ce1958fa0e6f733b2ba8ec198d814e45b4bf152693217281819eb376d5e25d09b51e04fb734c9e433d710d2013343b4b017233afc87e890eeecd8972113517382828c02383c9fb48a49f9129bc54b8433af2527551559c7e80ebe794b890374a2df9d3b995aa50f8e1786fa520bc882d3284112bfbd004e5699299af29cb19d29c6243cc6fb95c2bcc19238fe09454d2e0625919494dd3e0f1ecbc96e251bc6d8acf782902100ad7edd6f0d25c902c720ce48436be02a6e1f440eb14332cdef77f948753d5e8d9bc92a3f039d31c7518cec8b3a023a6e9b7cb65c38993e3ebd98ec560cbe800ff9115e937fdd72e389c46320eaa9d59c8612591c8e608c20ddaed89ad9aaf5a74f051a387495afeede7fe56bd43353e78a668c6284cc42db7b3d6553b98b0fdc290bc1c3e8d22a4a33b80ee4cf93061fdb8658a872b4bc3e8bbebe690f93d24c1e0185b7b17116d524e4b2cceb17ca7a6437650441c702de4b5bbbc63e439096a9a2c1857b39845d084bbf7619c0c651f8a5884dab4f16b6652ebab0583ffb3d68ff5f0deeae9713902195c9b220e241466827f99ff17d94acb941b7ef3153706ad01ee692dbd7dcd3d1bba8502226a3e7f8aa1f94c558a1dc6e9bb748a3229e9aad55e1c9a7490c9051d0de71647302973355dd9f201a48b2fb3cbea49d609d1a1b5f55a7fe20ad9ab92ca964bdb32dc16fe716209cad8a848b6f7e5652f7cb1924ae46a9b7bc6b21aa5efd648f40a127e65c7b0fba163af3937d91cd4d70c2f38fe18abcdc18b4c712cffadc65a46222ada017f82f2d3c426eb57d6f41af2fcd4b7467462b9ee7f3f634817b124746f54980a4ac1bb4e0c0249ab107d31f0ee98f4bcad7046b7449183ff648bc275f4aba804b1d590b0dba5544716e2851624e6450845e79d4e08d9ca2dfdccdf98434c2f20f2c0197aeddf66bf27c3073f4b0d981201b57970ed472a3a0321ae00f4a8a60ff1554047f5463a76c4455f19a2bc16f56af2a4facb81446cc2a80b9c509749a2e01f14c2e40d7b38750a23f96d9728602aa14cbf0e0135e91a0df3ec8eb113b2d3dcd8399929aad5b11090ffc81558a6b7f84b26634bbd057c5578d1d294b746dec6ee5012e09042fb90e9b0453466e761a51d0f68c3ddc567e77b62d8033bbf12e3e91948bd8e895844b6aee3166f5f824f29c647dfb4c415ee1b9aac0d9e1ce7a6b993bc75972a1f314b4d25edc449bceadbeed8f6388a5356d9be57ae92dd9155c07d4dc566c230eba5e662b31ffaacce89aaefabc4301deada467623bdb81bf59f84e89b10b8e9e8a2307932419ddb0caa54230c00e4fbd668e193ab668f0136b840888f8c6f3e8d2b81a759ab14728b03597ce5039cfb98b86cabb1bb33217a7537c402df8faa504a1531479e28137bd179ec37f1bb443a37246687e7d6c9b3f30a7c43d8330ced1a58db1799469d30b38557d2955b8405e41fe90bb262f355bd5252a6c97173bc0f78fe5f983d1fd5c2d14cab9a11c1b78af17ee76a7be71a56e773fb72870e3ac92ff9c50a8d7b5367042da057ce216b539d3b4cd3b945f82a8e60ded55880fc4adb2386e94b4741f9764673e94025991b33d22413e66da1c0d72d861e5cbb279f97a62d508c744a98fb3940bfa1dc5d09c9210a4f7aa1e210504f534fe8482c119d6362d8c34a698d092858771c29d181d492fbdfaeb4aaecf3a1e8f36b9ac498537580962660212be02a5c37f6c4e367a8a4a6c0a646772d1891caa79596614285508ce0a84931e5a96bf7bd3b1cd492212d36e81fdd097531f0f9cf60293358d7090ffcdf95ec4e989661c439b0079fe52482024657a1127b60b4747f27564c5e38e09da02bcbcb8228d6f68e817447a624f3873ed51fc4de558e30443b3d9830e337f1628efc527e04e9a41decb497f36ed94a73a09911afc456d528ed7b71733774d9f92392a4118c0c4ce01242fa1bb5e3c1047463191539a7a757c2e94432e99460b519bb9864d2e13dfb2250569ae5e3555583ba4f224814b3b42d1c9ef789bc4d9740570e1ec560c247af6fbc4e36ddfd2daa8374c210e7ce63d10000fe1d5abc1dc2a6e1ab64b16fc4104bef2924f1145469ecbb14171b554ccea2543d15298ea33bbb118cbc048ab58cdb0214bf4160a69cc08ddba494777efc7510ba9be1f7a647cc10f8239fd3044118ba0e0a338a564a85f194fdb0c523538c6d518f6c5b19a81349a54aa247ed179d5d043f259d33292cca561ddafbc2e39a065eb7f68970757ff770472e3d4922c50f6f184143cb87abb0f82cce81703286d437d88df500b71c653d414f9674d12111bfafdd9c0ba31321149d229bd61d19c80a294fcdb057cd4e84936256a9acae2a19230d1945ae20e2251851f0018d1c022be99b32c943ba3b6f5376860b7bfb26a2d04fb8a545c0f8473dcb581666a1b67608e9c3207d7014dc6e24dc8571e272188e18500ed6b781f4f1929f3fe26b955ad34b3a479d0dfb4787614c06d57a14ca47ceb7e6b08f8324a20a15251a3149c34e00bc6a74c9094c3f898a18d352d719332c9a4aa2fb5d65ba59dae8a0c4af3e9736d75a6726aab0cfc3571e4a2b8a32e1faf3ed8007410299d70c9cd936b2a715c388e86757cb3b8c894c06c53626b356987ace9ac012cb5234bf690763da7dfbb3be874775a11d32c6cc0f0f3700c317ca48b8fac64d305bc87e2b31d75a8b7363e908c79a24e28c87e864c0870e33f97475c2956fa197bb6e371696886fa40f2d052792b89df459fd0e63afb531110ac39a6e5380a4e384a9361abe3bab2bc8d4df4ddcfc1111201691e4cc5fccaaa3be0a517c4954c54dcf785a6d533ce184095edc08d075076b5c9d4acd516258a1c457e1a15f8eac14b41adc9f995c9769c442ee9fe6cef8c41151adb224795561a9bb6490f5c728431f3206a7dfeb82feb31045002983d10c0f46c1eb87223ea6b679dfe36277894648ba0ad1b403a0ce2ca5f7210d9f4cac4819727b93b63125549a194c4690958dd68824d36f12b7212b77a21a0d555acbfd0c209049e21849b8b814e5608674aaeeeb87b720b010c23a26070d11497cf40f1071496223f0ea387c20b7b1a74559bfe6d757bd53cb9b187868d189b5db05486da12a17a11aadadcc9d91a251b6405668a0f60a27a898b54f52c67eed6f690f3d9c8874649a145a2ae2e8590620655ed6ae39a79f61ff13258b4b82fb776bb07173f743d8f0880be96057813ac1d979daaee539677fab83508130e9373a1f2c4befd43a8304f0320cb66df18022ce1cfe2e1cf8a58304383b73f7cbddad833a93a85d4f65cc6949d10d28a9206aa7e4d87b41c0bf4dfb810745db14827f16fb83a4473cdf511987b0ca411b300af3510c90c08c7a0cf211cb652462e78691b84f5faa824eb8546089d101a08f6593ac44ab76bbd773c7dba35c554caa8a167fd7a5c0dbfe2a1ef5cfe11d800b099ba9e9b2ced32771d64ad5082d010c905983e1ef134f80a7c8198dd3d283b2e4f19570a28b917ca180539715a2eec0127d3e18350505f8baf39b0b62606d9f906125eb7c02fd43db02a6312a2dbbb0e289094ab069af9fb7e6bd57bf70876f66041831f43652aa6cdc1dbe339b891fdb2b68628364c409da5ed9197e2598f7b4ca50bdf847674c3fa9525d5647392c980a5e9a29fd81ba588c7507dc9ffe65b38bd9c5499cfcb7d6d7f81ab5c8246c4c959180b73f06c536e02f7020555ff262feb43110e879d748807377e7121f3b341f203d8315079ac50926d38f238e85283b9548c4f19c07136d8dcd449c34697517e75303c4e5bbac37985b793832b6ed608a4d8f686e181c20d22049d01fda72e2a8173f6fc069b3fbf4c0a1e22a8c09278203cada50bf43d70f6ed5a9bf61c8705e07cf9338abcace376b934ec1fda842861ca8a9871672c49a619494b087acb790166d715117ad51018d6d9ed38799d4cd365d7d518e119ac81436f084faca9414a9f88e8507c1d8f698477691669b012ceb51001b503e9e73a45dd8cdac81a3cd646e23ae8aa982424b6a986b6913345a3e00441a1ae99ddb5ca9cff243cd4e8a13172275b84be0ba7a22553e0e3b161792f787f0826f7db1c5ebb0c27d2d09b33b1f52433c2ab4a57b7f7d5259c052533a0c85411fffca2acd50a196be26d32d95df91335bf973943e29664a8da4b3dba55314365e05adf9f0ed7eb458adf411db5329e68ea16f26a3baebab5f3e5e4189fd29a5b66e3f24179335636e654be2f7e37d1777b86198f471b386005e45e041365e3bd8131c174615518c6b90041f4295d65f42e09c7279215675db50f0b9fd4a222443c020d47ddb2d39f7824383ec7b9b7ab9f482c4daecbf97593cf575f68e2c91f94378252ddc5ba6975c13f2b7f410e69c04f812f08d97bb8ddc5c5915cc707d43ec42940492f380764ef827ed5121bd94cf82fd8d7d22bd61b5c9843f0479a2d20379df1a211d0840e027a1c0bb461556b0735f432a8e9e6058288de6bb4c678cbc86f0a441ef8d8f3ada550784ad1dd2c943c5986651bc5e0d57e0f9f9846844e69bc683088d627d9cd5629348fd474288faae2b95ff5993c391f2c384a7f53eae37b081bcaea848c770fc09da3cd831e3cb81519d0758fa3e5bc26d876b3ff5b90548fb7074ee3e7322a8780a8712961463f8274048969c4485f2767690c55ec1467f5d339d466c81e6453913ddbcc6af8be6eea2328e914f640fb1e51a558a86daa15986f3dd07f87387a931032e564dec2eeb1259bac51f99acb704862c509e1d57a01776f11e40b4ab01b640c6c8715a7545efef4f3a6c838fc151704f0bce6c0f22950fb51f9ec49a3fc3eef10d96344337cc9d8f9430f370955abea4d9a2dd0a512563193d4ec678c6f4a401500e1bf83ae6f72cbe234247f33b44c9b32a821d6a874244db88565075ce59565286c22125e0d40be0dcac190a8791d5b08a9f8cadb2f049f43e5349f9084b0c44fd899f02f5fd4d76243f88932e3b649d78f248025f052ce4a68e25bebc16c8c40f2bd30dcc7f5e165d5b6208a5266f7000986c62884eb30d5e91b137d622977b7132857f74110aa604f972880b3d549436ee66444c50bd14a4b70c40a95c9df547beeaf04fdac3c9f1ea9e12f86feda23c99bc60e6cefe327a24001104ba4a3c0a3b38b0752bb2f7a963fbd7664739fcc959976f449b034272ac2f75205bac711d5dc1769f5a81eb8d182d071b77feffa3019df359a0077c2d468b5bba8b6b4da0fb3eca50ee8186af8025614e1ce2b44c685f031976a20e04e3be11de97f54abd5c01424a922862c45922668b17b8389f8945e032424a8166d17c4551272869cfd7254458f4c5deb56f7b4b6b13759ad41ab1772f3045744bb91f9170f7bb6ef30f1fb32e40ed1091a626c12427f6a16f043d3977b957c69957ec4a0738458223e8e2e8e611453033ff7cea32a559c29acb8c6c390dd7d4b23f7cadd121e6f09363b66278cbf3aedc4474c93104c32364487698443d5293588e8c399dad3b00c7a516cfc819ca22bdc47851a915c257b102a1e01acb60ace2e55531db39be39a4ee0df8c530b346e7f471d203c17deb81b790b206076f5c4c8804e7e851d03facf6cb7f8c8888d76c04209baf64043dd8a0b2d4a6e51416499a6135b8112a9596d1572800703107d5532015094b60d3832d9b84131e125520f37e0c7991fe21723ce5198ea729e31afc7edcbdeef4f675701a8426533364b95add9ea893a5aa4e6679bb9a67beaa613830e668e2bd8b9e2869bb24edd4e7d8546dde4ee4a7e20d16f1beefc0068ecfaae55880f6c65304bef7378e9605981f6f15bcb179fbd6ce4c7be7ec0f48aa51044d15425afa8c5e1e8d4474f55570c2d0b51e4b0e5c35bc262838897189782956cfdf839646cd481cac8aa2db59c54ebbb5e54ed6c67f405db8e78d1c2b0b5d982fda41704a8cc020c3ad8616ab41093373c8b2217f13a7ec95be69fe49603ea6df9cc9be50d6481c24084f75a18f258b5fc4a65faef142d6a00bd208e66125deb602b4e6ccf12a80e1bb91d466bcf1b7c42bdf100c732cc7612fd3b0f34fc3e2b7149a47f70c2ca1eb28381c8d9fd422714d5bfb36dd871ff5d766784f139262c6d7bd33c02769079e420c6d2114cbc593d4e4697ea687b44a2638b10ea94193b1ab16c7ed0fb71c2df9db15f5514c44005ad95ff24c42a3272ffb3dbc5fdea5419cedd8b8d49f03bf532a8f59cd429375d171548d9540f358662ac76ca036137ff79215b73300fce77dde6f6d071722b41e94718334a49c92824a55ae12acd026be9cb02398e7f2d1e1ea2ee2e01db3a63fca7f78843ae2e8d4dfef1e7c463bfa827007f7c8d001086fa36dac79ef9d693814903c241bd732c4821202e3aff14530dc3b29c7145af2584137e80e968ed699153e687aa185b6a68a07271ce7aafde8749f7990c14486d2281664c6d1fead2171d5b70ab2a69c55f6b4925b9aa89e689ecb0bb975e5091a385f3bd8156ce9df2e4af257d66690d67c1019ed547820a4fcb472e1fec3b7579606b59e876e6c1bdaa4e2a0f78ff2d08ff3dad913492664f5544eb71d05842356f88fcd056e95e09ddb64374aa19b5bb9085b317514e6c539f48c342e17a0c8c9ce9f09ae59ab7ccb7e6d3414b5cfccc0a503df591f2dc49888d4a0057527b6689fcc0345a6f0c38a1bfe7fb28eb4035fa22e714713d9e00ce4779afa0d5a74c488a81e08e9f1532d8eaa8bc803eb26cb700bc70c1be65046617f5c6e2a3414dda2791f16bcad068efc34772c369e574899f27c00454c4f89ae07ff4ea64671a6fcdfba6febf67cc20d66710bd83f7a396638ebb3cac6915f9930624aae4cc9c72f0871079e6ef4dbbb417589c576a0dc2a991f1c1388a4bae04a72279a7b5301ec4d48c1fc826a4a69ff9456b86d34d7b6e3cf1abd1c1884f424498c98a79936365c07a10b64a12915001e1af83f1f0f821599afa4a5763b643588c327c3bf70e466575bcc463cc2e87378ec2d727f095db033a9393fd9261dc42fe360d8fc9f4ee271fab1ca85216dfcbcc94ffc01a7d029c9360f4089f79a5b526d4d8e406d451af6fba12962bebe136b10c09b303d548665eb6f2a409a7960dfdd07d1ff93de032de369524990a8cd6b81c9da82c01a3a9a556dbecf0bd1f1599827de18e1ef193b6344f462a629c984efdf0c02bbb9eb120d2f957887f36bda44907e8ca67d5b9f15849baa2697d336efde4117cbb3cd6b10345caafec77d81c3231a8acd78f6729014eaa0efa2d52618b410c9cb3a54ecb8e87d376a01ec6517331ab854d6148e1223df9040fa0edfa2cc32beffafdac05e1868de547c3aebb3c04e3f0c8b16f9765d355a1d9a3b6aa9802aa2d31414755b039726fa6c3c7fffac5a45a8fac5ccd495e6c8a09177b4285aa506561a4219e6045e55d7bafc8b5eee6cc45e1eeadb34fccf33b518e5b948a8e74bc84d4364f5c427004fb2061df2b5abc7c6030d317f83303c7f36f378ca88571b1a9e1ba48511b1cd14155c6bf5b47ba224d6d0b682b7f4d919e6c29a368ea03e42b9872019eb221571be8e2363b35d18ea8d30c54e7212a805694336429a8ffb35c659644389969b3d080d1e78467079f0462836e437798ab063d5ecb27d416d9cf244b71adedce9e9a4081fe8b17838277d038c716bdf795b1e4ac2cb9d4b4f3465a0c3249a4535915f80f09b86bb722314f15266ffc2b5ba2ce618b3ed702b83c9145e4381440cff5c977057541f4ff80b178ff5ca66eeef579f4a49c59c1a06deb9769963671499a66efeef148c93a67466473dad7e8da0c64e868502d38bafe49610b220741036b3b6451551e7a351123229b4eba36c71b1fc2701f910db32687cd7aaffb089f6fc32b77d6790c10b9f8f150b11b4ea4fc44355713ea2217d197721eec2eac6f8bf5f5e22a242c23de3d7617f9ffd35264b2dba779a176174b6ab266b02d88c9823e49638bd99ad85bfa4793bf519685fc2db55d1d0bfa9866f2c46dfbf7cca06d07dff8b41e4ffb309428496e4771707dafa9269e2cef7de53b362c5f87d70efb9f0134acb19bbe168db95fd525057d2b76e7b59ba0e570ffe742e8ddcd9ee274d4eadca03d9c38d9bba052d08f3b0f6481e04c9fa6a72c4f98e874e907dcb784eb1ce490086774d64f9399125f7807cfba48e1fe71925524b011b5b6604bf980c53f207427bff2a346c11903987a20fefc255f76ff261ca7bea72c10d5973e32e461f6bef94032895e6f5f49eed842cdf9c72e8ab50d7527daad4a9cc47a3b7ed56df71ff45c574ef09e8dc6177d7fd65031ea52fe08d565273e125d0eb7ea28e6140975a9ab3ab6e3a7c1d01d1760b1c21d3879d440e1cb121d6b0dd80d2abd2959d53994ec2d2110c740d0be496e29589b42ab01d37efde28c517f90d453dc3a8b993e858377471cbd440e0aee0e66ac2e64d7954cbe40df829c3995c82261bc1389edd5a8cc12db4d42fea1dadf0119038e84bf3310d1841aeaa6a575569cd89acc058775cd759d963d1390c3cb35bc2c40b03245ea38722e8264031d9c0bd433c39219bf07875e38a4009bee8d5f4451fc59d7eae94817a4896785742ad1e787370d22e4aa71bdf2cc1177f0a200c88883ddfcac0599d0d5c37d31ea430db3d0f5eeb3e0f2e86a0501c6637af02ff496d8fa88230a4dbdbe7b8ddac18794025a507a02fbba5cc5310458a73df61f8e0171949c1b60d9909c9675e3501f3d2477da379ef15b90542fb80f2d6c41257eef104126c9d3b0eac7e9eaea8749d95bc075804d5d0fae815a53de6bf3ddbb62732f40c3531d721e306e108cd323a39e5089f22a73ab136640538c332dcc045aa7fc130497f929d83d6edaf5035825a2f857889d983791d1f859d4b0b2f52bc10450a710cb38b35aea1123d1d72205bcd01ca1b69f2333705e24fae4698b386d38ec5ef3bf52b2266f0ef9f6c6332186a293de03399f22dd7736ce3d4a9b3ee71c296fd9c9e305a0faa8693846f0c5f71d6552a152fd8b963b3f4bdc9b4fcb295737aaf8804f972f9745504a010a98a0c493432b9c17550b645eaae35bf7ae2ab43a505f211897bddc8a1e7791e94cb46a7694e3f2fdd76c93ca0063ab72bb3f55ed3add950786a94e43d8973ba964a74d653ed6fec04f708f873e9f06788dcc3339380e19786c451a5e1c5d6ff914fc4e06a9a4d7cc2acb9503c52eb4271bacea26bbdb8500e02f0718ead15445d4ae9c428f1e85b4c51e7ad0d9eca7ec6e4ef48c747483db133b275ace39b965bcc8e51dd4ee9a1c97eb1d0350f0ceb16330518eb08b1da53ba193afa2fe69b1db64642c3cc926beb8cfa3881e273f3c03b0850fdd0b2f300896788ce413572bf5c90232007be7b76f1069e6cd4d208021f90ea0a36b2e133b8f3eec5edb1c97105784ac091ffe08d687745a355f21b8b385b58c065ed7f15d015adedb1a367bb2b161b3c561de3a7e0c72861e2e3a45a66301083ba43cc09b8d1be2a20754e040672c92ea4fc35b7beddbc401be914c99ac474b25193f5a5d5fe63cc6d291cb79f8b77831d3d3c4c0e3381d9d56c178705d3cd4011d825a5deeec165c2d0788d356217bd0fa840db84d760aff8edb6367bb07ebe02334630955310a0a78566016fc52e90a79581d3f7c5adf6461bc69e8e78956b93ed575d952291162a4c566259c90637e4b723884de663d99cb565861d8c799d2155793ebba7837dc5f90dde5cf5a9a8dae242f9cac02a486b0dd9f73d58baa2422e73bb57c5031d029a3da12f223381b784be6c4ea9f37a431f487b7050c2697afc70fa59ce0ea9faf2e8a621afda871938d4f8d6fe0220670f210857d5a2253bd79c3c197055e58e395f5e5b0da39823c27374f9dd07df9dbe0bfbee18d7605a7809035ccb2afd4c77bb4f7cc997a50e038e3a2d4490e67bfa9d58bf40cb1979b3237e2a895b59d2709048933ceae7979ddabebd3aa8460eb27855e89d861eb9c6fa35381ebd25da9aea35895aaaab6f7ba04b018d3ccb636e975a2da1b196b37ec3e69e4af8559eed1c969f0ac15aaae65acb848a44dcedb21c346c941a4b11c22b000c2d86d6671071b1bdcfc0791f43791fafff566d9e65595d7a80ef5dfab45c85a8529626e1a5f9df39f14cd0d990d9cd617c4e0ee4d2d5ed46562a7616f3ce631648dfd73a96ff68f37c0639f2ff48f9b002f4f2bb4c402e4a24429a5fdfe1a61adb9b45817ec901ec8d20c285174e4556485115134c2e9e8e9d64e039bccaaa07d0eb646741a8cb43661e0ea9251ce9315551eae61e98390e8174dbe698bd3ae7cfdb4b42f80926c4a86f18c66621f45dcbbfca2b81ed2510ba1a53218ec6ce214ee0153de8809a3f4cbda2b5d4187680d89f98e0f519740b341eb8b49c9311a2c2cfce14df58288a186e0b5ce0c1054ae7a045f88bb8d7cbd81349e4d4619f4e33eda8b5f3accfcad19ee3074cf1108acc4f55a444920038443c1e816652fe61977fa75442789903574031a0a7c53e8e19251fe653372bc066e2bc665ad69f56e4c61b42b7a318632c95c21aa0529f5b2211e7a1df72784358d2e5d36dcb070d2b0ce4386a71bba9f750909899607645c6d9381f9b1f6ce47f9fbbc5a8cba783939fe9b3e724d64a9dc5dd41623a0bbd71c713d60c382b7c48af83633316713443edd6413275c4d46486c929553aaf219bcf92d3343ca99a7f2f501156e94d3dcb95042bd96ce9aa03cee9cfc92700ba26d4cdb8657fb8594154fa97fbfc1506d570852ad151adb045ce0a39181fdfe1ccae84d8ec7af5c74a425004e410a4dbbb30267c8388edfb34974c4fff6955abb881815d2824e2457796b880aefc452ec2278588de49e81d214384ba427261874952b1c90502a1e0b9719e26989edc8e3674b9163e0f9b029855232e5ba7e1112177e70177ea56ff1d65b565f9e75c7188a3cd94e54a397cfe534cfdaea56c724894cb3214749b3cfd69a2eb066e698fac22714d9e6e446ba05f691aed34df2d3227845a65aeb638984e49d83dc80cf5d807bb38154de10d6697dc50bb8418fa66e6206a4bffc12be4afb4e1141712a0fe14c3aa43e25a38d4a71cc0be9c8341c258460c0099fcfa3dae38fcca5820b26e1ee3ccbffb3e657a1692a68b5df31b8ee6a6c834c25d2b22155539b0edeed99d747a617b1e30156b5f1d936fe86dea76edd05353259117e06c4c929095653cd5b4c3fa6fd25771f6fc5f7c20f2af0cc60cbcc1de641f85af1325c6fec019fb9865768b17b1305f745bbaade188d452a7e3af47efa5ea0bf8a9c6bc301d2082dad3fb9219d9a6211e2ad9d89d61681ea843236cfdead842d539ec90d4dabb1c303b21c784e6438db92ab906ceb5a0fc2ae0c4c416a9bd4b297be4170732e89d9f6e738d583afd62509256b3cd2e0a3e0a2b7e4fa4b1cb6be670166eb8ea419d768093a16b6f3ad594a3be845e589d84f91b81a9a73f80390a094891b576a3542f65d78e7b21d8f056b282b5150ba64b354755ada0dda7b7e263c4b5380ecefaffeca03a59013584431d97136de81e6456f0f3c8c43f5d468f340b42cddcb60735a730fe494d38d73f0f361fc885c88e89973cb552814bc52adcc5d3d70c4b6d8b5efe858edce3fa90cb4c5e96842ea88d1a1004ee331439b68b747def157f48c2aa72f951a09e0ce3b18e1809dd9dfc3a2ad7693bd312a3f64b231730d4ba6f16dfd79902ceb852dd1c7b6b3931cb18f0814235dd437c759ed91ecf6a874111a9bcc5365f52bdc63d0d0fdfca2ed3c1180dd0875a2712b02b5defefb0b7980ad69f339cb89f99375864c94645b1f0147133c07ec94e9a4ad7c443c015eb1a48a8f63e9fd88eb532a476512a1f59af50a39c211cf130bcc8a9c19f774d60893b52973bf1d0496da7336ba9d6da1acfab927f8616c1bc5f0edd1ebeb164bb346cc2543fe01b26b137f1d0d62888c27eadacde0f59e8833a9dbc89e2cb9d6b4874271bc6f609de9fd24556a1bd07162c282c9259a315204136972a7bfd0270de8e42c55ebb3620c597b34aaf12ac3c099736591e7741599f300d95e0014470f558f965282cfbe459bd40cf1112d9ccb070c7667c9bba4411371885f2d585c253fdfcddb90b6fb6bc05e5e9c5b42680a4e0f4b8d311001acd0b3a56559c3a3f7465f2b5104d3da517a44e392d333f27e07ad654593ad6d3835d36887d4b20bf0f80933300359bc4c4d3e1d90bad9c94a7c8e97430b20ec172fe9280241ea2c830f71fe556ee42a6f01868ff9e35426afc4c01a938634f302a10e08bccaec44fba1fb72ec73ef61e5c19ad0a4138c4307f274f0c2151032decef3d407d69faa03d676fc6a176ae9f2d26f1e71a4c14fa363606fcd5c93a93ac1e6ccfd68fc796b2a8236c925736eb46f8d988a9d1d82434e2b26e2cd3426a5d593b160854dd55aea07a8531aee6ff7f1deed4e689ed5baa236d0a54a057959a32b7d66dc8267b70fcbed3f52f5cd4b9b0d44c53b0c86db6a6d0c9d2933c535c3852667e57e5f366316ccf16357bf10493646e39f9b5e4f667c7f70b86e6b40a87dc266944ce118f1f7b5756d5bc7361374e1332949e85540d73bcd0df98a241191bb9a63c5ece8b85c16b64ee8fcfe4066508c25f3072a20bee84b255f066bd5c5f1bd8a7aa632adb4c12d327489f5624c4fc434e2e5922e405018614ff19524ec0f33e97533c064055ce5b5ddd5b908925543d2fe3c97ab70a2777df4658e4ae8ea493d63ba0cfd8976be41abeb11265ae81f97876b51e25f7c827215842eafbaec2c1b24229ed2119853ff29abd752340b68b5aea36a6e8f9831207e557d7f70a9e830c4d2740c9e3683891b0cf67623cc7e58e13e6513f4ac32b17dadc39199397b44226a2d320b37aab72597d25f1c105779f4318442c7d5475459c686010e172f7d548138296e23d3914ea7b5652c90c69ad16206a19d62702195f1a9938da2fb2f22849d635d38911f9a7f1b4713d2e7dc4b69c2181a2ab7e5e14401399c0f207d4eeeed6071b37b0ff736e78361be382a8c586274c7cf5f857aefe41cfd561dc447041e2ffb989a68746db70d423d4d560c809e68e9003356b1029d60bce603ef34881b99c29c3df89a90cebd8e389c88ecd56d05a48062a03a1e651527b20c531bd50e8db5f4e5d35c3d07995edc56711f572adf9de2d2191d62be45ecb8b69bcbaab68cee6623dc97246dea2f5df1f9950040a0e2eee6626e6ca1c39bcb39d76a62bf98b9aa3c15822dbf21d42f8abc8eeb4863c47d3ffb04a3b65f93cc67f5c50e345ce2d54ca0ecc308a57e6e80f7eadb12a96e6337e1656464efa2bdd6a80d95e30100e390339a6ad02f788a83a4d68f82c72c7cd49bafe6d271044ef76c7701607d80fe19282efe4860d5d81b03817e6e4e55c83e86c656bb419a22fe045bcb15b414084742f74ea6e5bc90b7e74589e38c83ee6854d89b967f5fff4bdcab6090081f205eac201dd48eda69974a59264ef2456b3fac4fca050e13202eb601128e0728d905820648c4dcf9b3bbaa18434d5fcc0d9e7204020255e2e1e406e99270c3cf16a751e2cf4b26cf35f005c679da70243b83da45cdc4da3dc2166b8481071dd8edf0c5f145cbab4a61493d0c751bd50bb633641d265ca50b995113067a80f2b8702517a51031e3d40de45761f46f0f0a5ed9354a25dd42998d760f4ed9feb7246d735c3164cb47c7ee97f0496a2deb2b8be7e5e4418028f0d83cfc07e18566bb983a3d4ec0d2cd754d6829012589d48086d80cc211599633b95241b3b56db84338b41b4c9888d318f6df1394920db94f2d69d2bea0452347802e39ffee4cb24488e6106af2dc541348978db9d2f31cae1e9076bf54c424ffcbb516307be1c460d2d56feaf386085151a6581ebf877c00e53ae84fbeb2e3864a783e449816a8b145b7eae059768e33b6e521fd04d230e5d84b9a5db1489604ab35e50b4fbd3933c84ce85f014f7378d27dc9859a566a07e83d31f014e5b6a2809a90764dc5321c37feb198b17e11163bb7d4620f9cbf3a7bd6f321b9efa7a283a52061c93a96081cb4ad6c5c6450434b0f92a6fbe3c007a93e1c7257dc9c5cb8239d300bbf3bce08635686725f5ebf447409744dc335b7792da263f6ef7befeeecd138f37227d969a803f7d095cda9cc6ac11b7472002ea05b0f5f03ecb85044253540b470109f1e7388d8072c6ccd427688a2f1f811c7caaab4ac3b74788781ef05f069d6c5f7cf0fb8b1b2d579d435c06eb3a14ebb326547687aa1fb22e40ff68d896aa377f33ac582f81da8d1aeac332de680104612d94af7303f5ae7201d9e2da2ae10a98739ff3a0cc51f263d16dca6c6b80903f39f07fb63f9f05d4634551af97d59edf026b28cee7d27dcf684ee9b101ea3f18335b4e9d4e11baa0b78a9715296bbe486e495541cc9848ef43d2c9b25b3419584b6304c890845067753d87842616d5c27c705911bb7e7320614a21d378e5bc2539f5530f1f093c89dd7d2b93580b6df7257e2d8c36813b7d2ba3c17699dfdf8786ab1e2eba3aa59fc54dbe6182d6a805415acc3d3f1fb11b5b544a8e4e2097d6ef69f06e6098436d9597273fb69689a7d58f644b6911073dc458a2a6fb09586c6a3508e76656e1539ca13d1e2e14929704f9419a8c1f72e4b05ee9bc9eb9c6506929b292c7bc24788a75fffb9e49b0eacbd7bf876229f0069062a59ce6643dc96272756612ac0ae10c1fde1966f7b660c777577d8798aa54c4b35632e2344a6a5bc2a69a007c08aa6183754adba77f21698952194129c5bdc5842bf99497fba18a515e61b3fd1f0f151ba46d182cc4dd2e265d324859e921a9a6e0dac05ce26ddd6fe5a8d16e852c230e4f868422389043abd9aa8a572be75c45f07f79f7e14e118d9370f03161c43ecf6782ac8cb9844490843c339f92b9bfcb011e3979ae25142af72ec257a4316a7b7c246dc0ab97196afd94aba9eab0e53e80c9398ca1d8a382d31e2b71292833b4f3dad5256b5416e1f537aa05e37a9a185821198b809555887b9aa7d2796ad74572c241acb31c4a8e9e1b42b35118a2b4a2c3fa0ef9ffbad397037e3d772a6e6112ea19e523b600c06739d2352d48fd7ff3af7b2de17c96e01df60cc71581995a33658a0d1df142cb08ac32a4ba791af7a9419bbc91c9a2ca99f866f1bcb1849973bf493563886ae2f7d7b9927a5b9bed537242967fc5cffa86c4960132a6ddbcf7ae9c5b64682090b39540844ea5ad5311a46f9d49187dd799622072030dea2efbdef6261f5285ecaab16eface05ba1b46331d73b52b904871bd1ba4679ea787295d6b7610b37e2ac41ffa5c1fc402e0b312651c4adfdfb7fc053b418f7c73e15c13d0360d7f776972b78970b5e1fd7fd7b48f220426bea71f5f7c4fa46a5ab25efee982c7d0243fe4421466f8b1011d60f38c8f6b51e7b047dafd9c46fd7b6a93df5ccdacf6b144293391eb0a1167e1cab853793b58b26ebbfabbbb8e8454ceb37479d143ba37f173c85d278f237212150c4d075ef1ecccdf65ba464c6c2ea32c66261d32d38e2a07695aabdac29e474e076068708d9039709db2d2712a5884237633c5ea9c63abd556be16627ba457c18b8dc10ab8457f8bc54fd4e557360abf9bd1036f90f91530d0c08e3b3e4068b243c1cea9322941773a05a798c1abbd4f8f8bf8b71a4b7115eb9f8bf7a8132feb2438735ff0c717f24da1ef371f743ea749bac52a0cdc55287bfa82807a96eeea604a429bbda2644412ecdd252536d71f1d59a1ba3cfc73453b70c744179ea1626623365809fc20721439caa3f7ed14c757cdf434a3bc311e173f2adad11726a8deb53b8089faddd31077a71411814708171d278fdc43661c7e64aa825c896f06eefe7841d48758eeeb47a9a925e6d72e2df684c71d36fda5ed379b7618e1c72e21a5162aa9dbbfb494d5d59fd72a6e7e1934717cdeb30cacc3b2f558900f920e0eb66328d0f7ab8df736d4bae78d5936de0a485625b4e82be77b7c42d388a2a1db3d29574bbf1a586aec46101ac6474516d5f702b1b1b836e2d5be767c280d603ebc75353a4fbfad8dd8f1e068fdb44b252f92689c0d4051d37ed9dabec3fd61264f9678caafe48e0e65a704856e0c6670825b50cf7d7d56cb03f1a4075574f014f87f47ef67032b275fc66ce628be6055f29ea0f230954f513ecdb0534148af83195494a59d9e50d7f3431188038fc02e40fa264ede9c1a5ad1b08037341b5b4f134b312eedc6bb70edd4c8e7c9902526f9a638c2160181ad2f5cb537a7fa24a4d8283a8446ab6c0c303e1449b5ccb72d579f469f5461c8e7ad0db9179bf6de3d50dd83300dbf7051e127006c80667ad9f8b8a1f212ba0e1e0df368f45c02f426d50fa265d06ec2122bec7f4b4aeee5d779f514bd62e6b939079ef8aa02df69e394348363ff65b06fe99b0c2059c90888fdb173e25a2693a9523f1309e0431267571b7654181e5bf2470617acf2b0149b838b6215a3d0f12a3c4b27d2639af936e11934a248250765b5c86d8196bf1c88cd066c19d445e5233a643ae1efbe6ec8eba533877b52b1b1713e1f00661af8b9c276c034714b6a5e4f5897c5e1a2a31ee5ddddfab8ee47fedcd5b30f0c4bb76dff2599f91ef4b3fe0c76c58ff999e1c98606e88a4092de8fb7e1590c5474522dfb971f7f1eddd6afe0da209373dac335fb5fbfc5bf11bc79a0209cd7cc2fd064833071e50da761b41140419dc226a1c5b1aef9e78333810c89a33acf0cf47158c5399da8e4caed9f7f6275b195e2dc390260541aa6acd6c8fa6d7274d1a736948572173941e8d137db9e04f2ed11e79826260267367b967ae6fe960d466ad70a3f533de88d9564f452400002d39f132ceddba04e10544f701b9aeb365c0314c201dfe5cc7d2868a64adb3fa09f216014b162a897196ebc06e4206cfbe85d4b9bf0abf64900b51d447ed5f28075e2547241b6bca8f992166c5835d9f511c20f14e9ed34c9f556d95a3c085569b19b4505f5cb55882cffe5849642e58cd3cacd70ff8d2f03d425f9751898502c12b36da20ab59b507c01f8e52eb0254794859044c0808118ab0f7098ca778988766c352452bbd0cc8236c6f290d76028721bf7516f541e499574802cec9c7dcaa9acf444b7d90f3b7e7eec6bb61bc4dd4bbe01985660ac1241bb38d9ed9d232ffb96d996cc392830d0515e2c14e868d8b560232db41c0056a971195812ffce6dce6acc6c08e2d94b95813291e4a5d7bc7dd8cc200a6b90af97370fc209d6a0539e65c33b737f6ce31f59c3274cfa7c179a3420e1ab60f83fa2b1b0a515719a84a4854dcb8b3dc0d0b1dcee17965b165783f578506ed925125f5ec66a8d846d943bf723efff8e017351b15ae0fcd879da2e88846bc91f92368b954cbfd44794db0fcc9178ff54e75b3e16bde55a3d9c7adbb292e24faf0aca97c199ddf82eaec4d7a2d0dcfa61159892ea4539ce7f722d0cbd15df8690068adf32705b65ed633a6c525c7de5b1dd760aefa4c14bfe7ed46886ca7acc7eab42cee470987231bbd98a70683b16a4ad166f146a6491772a9342e7528b509189991cdac4611aad6992828f500188356728dc34b45a417c03d926ca340119ca80bee472ae3363d76e4f61ed6722644d6d1759af643b48952a4c13567c5343760d61a517ea8593e3b4a4710ea264401ff3b74392b7d01b7a47116bcb8b87ba5f057cba295a9f699c13ca91a49b1c71e294ad1582f742e78f74cc1a228123847d17403675b5ac1f67ce1b2d34324e86edbdcf8dd2f128a5a74d95c25d12a2a2096218edfa65a2a2f41c429bef4015aa916549a4322c02d0e87184b23b7c2c09d2c955635a066f3f6d7dfbb942f8f3e09a98ac43b51ab21cd5e23d73afef8b8f06229a23ac5a002004b91f7f1906db7ac2605e0afbdf6fd35d1f7196854fe47547b4dadeb871c92b53991495c913d6107ad3886554df7db5b142f6eabf3faa361948dfb2e6db42cea92ce74dbb554c23a2296d841a75f5f93846c1f1937678371f6d478ce748702c4abf8bb00733356549f8174a9666e0b5112c5cfda0c67b9af5cdedfc07032c1a4eb2b70e342e2e99bf47610d6727e787075854390f000106b18b59625fa87c446513c6ef245bb5a01bc839c91af8c249e726c955b474e4857f659b53bc006d3b16f21d32fa7383b3aa0712106d2a6e36e69462e6da81cb6e345c96ce3b1da932be4abce60bd61cd974ac699259b276e7834be9b0b1c06f70ac83ee52617e7fdc8c77aae0175e91b52efbb57fbb7386508a01c2c7762f0da88b5044ebc5aefa667082a71ac3f23c4a6fc890d25dcde53862bacb1dbf6ec8212710179c0195d6c47f0c46dc12520df295add2caf694e023b64cdb4f3c4e26762a2be4e4e77fb2cf2e493357ab8746e6588f84fc96c126dfaa00f1afb8ea997bfdb2cfb0bc86726e2291ce78438387621cffe4c168fb26da0385e13257a0a2f64d941e222e7838ad8bbc9bb0adda695d0ecee4f4ca0fb34403fdd8567b5edae27a161d0efff241451da646b91b01ffb7c936e0d9ee2117cc5d2d87ff3e402248c58826be6288720fc9b5ed295485791f5a05451f27ccbf8daf6ca4c93d35380a64b95c01422ab761cbc33118860755938212cb344a70e605ca3af2228918051700b5f0564d51fc5a87398f536bb0107e632910b54948921ab4db611bf67eb7b2ea51b72c8a83be81bc0ab859d14f87fb7c661d2f3ac0470031ec6c8681e4252d79c30a6f8d46edc39eba2e8fe1e98425c88bbb446472dcfb0f2e0e2d529c08afe58e1aca548e59bc97a831ec5167a9d6d19ff2eb4a4bef941929d74de68a9c12c5a5920952d78887d1ecaeea9202f11e6fb72268d3dd8f7ae1134c2379114f0aae5c236bc988e33614c56297eeb86150d5af982852ead0b4e08b614bea9e0f5e9b4e2fdf6a591cbbc98bbb97c1a8f6793867f809c263b5369b42b9ab673903320cfeab5853df9d9b9d305d2daa8267413fdeb67ee1d1ad2c8d551ac7e862eb52b99362150fdfebfebc4f5b9374b2f8a84e3b0698ade6acdaeda10b2cd57a1ea4284e596d8d464e01ac6bead5fbc13033d84afe2667d699d4322ffcc2a8a2aaf61218746b39bc4eebfe9102fdeb23a22b11288f02f79bdcc558a0d65f715d8441b2feb8655b1b42e7aec9404bb41d1bb77a413cb820ccc796e3a4af4d5e6c6a707fde36452b0cf0c1bcc45171b68fedae01a04c6e90b0ccc9bd40f271b67004f6c41a3d6958d2a5424d8a89c1bf117963858700436fbd649552202be7a224d5a3285b053aa4b8702437bd2e299dc3492dd0eea5d73dfd11bc5175a800fc0669c303a34644dadf2f61bd2d8757950994fed150774313615e42bb3123313c38021b1ed55903cd13988322aac6808843e8f6a4aa41920ce30417458f3164507dd6a3cc2a0a19c696f0cea87c03255af8917a17420fc39d757e8f82f0025ad78b95a1bcb27543eb4433f1e977701dd0f862554bf7c500f3e9e0e6cba8c05ecab205829ad117ddc159cd3f3168abdf377e37bee0897907743e1f0870a24fb94105be8862fe8c874b89470ad6075ed6c30e188817ac2178c501c46b144d51a6d8a20639562ab96335c8061ed675e795bfc2c815b17d92a238294d37645fdbfc44204abf484c4cb7cc719918d3b30c4644b32ed37069798552dddc25e972f52b92de0e3379f803bca77db17f09d537da8b0a2a9585c1dedba61d6dbf8ffc6e8d6cc8ca234f1b2e14f9c92fdf82f82b590b2ad7a8a0046d8f4ec940888cc5002b3ca4d66e81da8e59842cc0416782f78363b58d8b13e53b67f5ad6f84d1db96edbd4765f26e47e3e45597f1dfaafe68445a07b6e45edb8628ffe1cce0af17bc58d9ab5e69d1bb1e0f3cbefb9b7e7ee622065b5d1d3b68fef63f5fa0b094a45760470846dd5ef2441169bd52ca788e00446fd906e71a42afaf4f5f336a09ce2855de503ba55dbc32a9f1f3ad5852a7eec175b84891c01d64fb07175f9798d0948fd1a0b28c5ea5856e837bf7e67b309df4ab1bd823a45457c060ef15ea2a2bf9ec51a4c587dad4e95548e61a91f610383071e91693edbff41c6d349a18acca897b42bb70677571c84463682e04cdd6de8a2dbdfcbcf20e87dbf8dc8986f4d26d4f301b37ce4e59fd7a530f57baed3446baa5f3c460b98865c957ee5c107af27642b16d7aa46ef4177ae45cca0fca2e30923fbe1ddbe847ca693689f66b319d1b66e0ba73c14fa3ff19735325c89cf9cef8ae0f6f9e9c67fd1823f0168a86d7cbe462093d434ef9bab4796bbed2701f062bd3bb929adfa333a4898280707d2d07b79c0bfd38937c87e720ccc92bb04c75788cdfb99efc27f161c64890980ed4e04a769d4a2b60453ad9a1c926ee36390b44d8c09871e527839729bcf1b010e473a2b84c768bb257a5cfb40ee1f59aec86277092f7f2df1d0cd9bfd9a298c6e306a2ded96a56ef403d99ce0ffcda8ea04add50cb20f86928cee90905c91698104566459e075adb56f50717e63c9cd8432eea0d04e253a26dd82b5a5e23a0e7f42428a476d0e3c7b4ff1fcf4560a8330056c9f31f262a3f317fec1c760b08c1229bf64a348f16021ebdc559254cbf369fc809e43db6117bb27b23a475566270801bbb4933943bc277b2b1eb1e8d027b3ceff46385fc40e8120532de95d58f3d2fce58e379a1cb380e80438151f669795df91538f0176ebe52a928a92f4727add165a64c015b11e3cbf0f8f0c1bdc6b315ac15637a0e00c016df107da348e4a88302173081b4dce33cb806be8bd2e5d7f2ad102041d2fd9ea9db29013da3d97e444449e3e8841cb36f609d8a6fdb0f94fb8cd943020846742a6e84f1735bd75be0a4f2b5b7e7e78723c0ac8d48d31fbd4b47ac01f81438cd9811ac6455f52ce595b1e9067a0a3548f7b0b7ca3bd977d9dad24bf2b7342d72b43325afd2868d5de85bf5c12eaf4e38f111f72b45075e4c056b90a3f972b1fcab67c6dc363c2d6221a42b09b3786667a53bb5b434beaeaebbebef98432e08f2e1050028c6b7eeef21c54dc3c8a2a81cae22e9bad2c70a6317464b0b14562405a7b96455c4680f40722d29946a7ffd3e08d67440a65806eb660e007340d83c378e66c87f2f9f9a5824c23de6b2785f824c8042fc1b6b50f7da42118f920e57ac24b2a3b2ca4c7b14b274dc769f3d985aa356cc0c5858c80e89c4e6e7acf6600d67ab1ff2b07aab4cd0a5e1b0c4133b39e4d23530c825ab05b28ef1461f75f88e0e4a0a2420b40ce54a2cdcf59c0bc735813a802671abb5ac9da837f1f2c96b26c4fef00cb85e1773fcee8ec0e96aedabd1fa567194cae62e2a45d04ec11cee08fa185268e0cf4d46e9bc4af60a1948b9eb28d4ecd58db727520260248bebd55254f4855e332f353200da7e4593a56fe6999255edcbec70c79093065fdc115239d625857e6e763fed1bd48da30be6c18dccdec64969883bac6e4c3ae98f7485bff7ef2c3340f7320f6d7463ca0a6e30f9f4c0edcf34e46c263df3b4ee6bf380112b69f4b104fbc3e1bf1c1a5626d01cdd7e421a2cfcc0b4cd4340e5a99f68049b4593ae42a9a7b272ac518f37ee9ac623da657fabd348d5058fd828740fe9ea642e10f9ce067721cec4cd90367c6b05e5359bf2dc41496736cd8d2f428f9915cef2d7cd406d78bfdb0feb4d4c51a1d596dcf286e056de310fe96b19ef9c761d855accaeddd5b46cd926087acd61eafa7490f0243871ea386516c460fed7cd9b0127d4c222c9cf23ad136e5809a538987d9f60859ea197c067603ae2cf727d1e039e6d7ce604433abb2e24846d04a06d0e429103050f11a057e0f4d5f12544447569513e6d5722d17fb43248782fceafacffdb671913ffe17a2a5e0f948a34726005bd085d4cde6da7890f405145c2c204155d39616c8bf915a8631f50f019f8fa05202835ccb27c6af3460e3065f905f4ecdcac0d717da1e5390dade05ba185cd2eb5cb52b90ffcc2495e9616071e77b300cceb6313fc6a5324b8ad560f205f61f395e364d7b7447d3cb9ee3adb44fe746643fffbeeb8b96fb154bb782714b90c4b3129c0603648aab28fa9a536120fc7eeb900246366c41983849dd8a27e1509d6b2bb3efeffdb679b96b10438ecdce95c5e7b858c56b280e8a39c2614442d093a830839481dfd665ebd0f77f7941ff1439590a73f0d797fed92fb4852de66967a87ee418f7a9b3b05c464b3e73804cf868a344af36fd9a41993aea2d6baeabaef8da3be733a743b00d6c57afe3ab5a26b47423be826be88df431c4a17e8f51a75c29d2c5dcc58d796d29dfb56ea1217693ef975fc4175e59a96d63e1f2fcfb44daad433462f398c691aac89c73d44bb28d3b4d57a03b78f1509e09d0d43d71db596fecb3372bf7da887fc36f9ad040f1f68c96483a51009d822aa3189f447a9913cc353377044d4dc02b3e36a7ada295f6b578ee51aa1adc40bc8e9e25f2ec97c34c3421b0c867e0d95fc9f6ee2746fefa1fb9a4cf2a15842d87adfcd3c62aad679e19ad684ef70279071588eec6c94f8b27c12fdbd4c499039c86df748dd3a4e7fc90d1921b513cecd96758fc04a17e7ca0e6911f20f30da9507bf70d66c11317ee54f83901b057f18280a9675735912c4198ea3e3cc3798e8da569f1a27551c5a54286b910b3d3d32ac21e974f7ca9c4beedd0423a90d67cc570f5993e46b3743e653e70b2e628cedc32ea2982119f1341e703c3e201b7444b3bf6822a1f02019fa95a68c4fa099dbe8813a4c9d35dcd5ab8c6ffc1a7c50cb252c24465d83906df32c73cfee1ea5e6d60c57fd091d8dc2c636dd4ec5be7edf67813a01eaad21caff45d6c52516cdfed653e44ba924f94373db57ab8dda6c9c3d01ee17e3d427b15c2d72642af8d7336a09019fc5fcc171f797db608c95364f6e261d7e32622132e90602439e4d686090dceb2f0e2f3ddbccfce05830e560a1c4bd7f333685114ccc4d9e04b2d7d043c97d8b40c9071d3e519739fa5d3a588d4c48abb6cfc2a69c6fdfbdcf42145e262430069d63ed051c79996aa9343f0c7399652f288422f0c68f62ddf8dd84a7a9a2e9a73eea580a91523ce2e8e66d8dd2d1901af0738b97f3d77960cc908763ca96979fb6160ee4a9e444323f40bb3d5110321983b85ada6bc42da8bb4964e8fd71de4fa6bc6e324cc98a319220c723056dc119f394dd2f2f248ee375f3fcfecd3a3addad96a62c9cfcb391ebe6d0a6b58dae4c7f41736d9d43eb9a2b8dd7736497d9daa58e08b88275422568a26e90f66effb60a917817d2c4d99188605ef4e7cfafc9a2e44c7ce7795817cb07e183545f7250422d262292f06d9d200e8a1185304e0901c6c7f2325a7da150c5f9ad53a8a4f8594617c06aac08137e2622f1d4e64f3a428644dd27c8ac4724a91ea7d579ea08b1c28a03908e7b0bc6a0c873ec6a7f518e439772f40fa50a58d031de398c4c64d3f66f3c4376c81f6edfb4fe93f0ead1b0e0e178731e6bdaa3cb836ca7df0dfc1906e3151a127217b02e6267c1926dfb412e5cb02f32df128366711ef0941248a0bc052545489ffc06dfa5d726940a8241728d3b99a05b3d983ff7f3ae17c29f080b8df78750a1d61e3f61afe2015c03fc25e68fe7ff1e42b8856f71023cc69c244f9120039c3be0817d9a4b17ec1f96ebd3c7e8dad67db2c8f1b3caf7a72dee3d361a8eeaec188281084c9766fad5792d04752328f32dc839a19e790f345e319acfdc6e4d287ff24d8c0234542a68317a9e99b8e1e0eae9d58926ddbda96b8fb2d7c323f425f4bb56f651624767525834c7bbca9e2e535169f9169877360273bae5b822042b51ab351e686602c88adb29854fa9457dcd2717f9fc0d2c523a215ade12c24bf6831c5f7748d3350a126259b9ab58c464f91435fb1d2058b5e3423fce7d5cd4e4b60a7614aeaa70b1dab6a03f7bbee1b32489777c1aa008dd494ebd0b8d683f0acdfaab75292d0ea22c3ca7a06df341ed40ed53684d651752f16eceac266767a3c472cfbb6177e5bb2b6cdbdecc5e911b7da4378cfa021e80c86ba9cbba2f0d38a44c1b2dcd7c8c6d9930060bfb794c05b917a9714e9fb4c9de0f80c63f44b72ba7b76d452d21fb7dfefbc95b216168e5e8126a761852c32a80aba8cf28fa4cd246a0e2713761bb960c341220e847e3392bb73e3839dea1466a8bb0b063e8ae8aea639a58827d25e05bb525ff942607f78170f6138f5481139707ca01f1e5d649409eccaa1e2c96175693bda48d0aa1bbbed7f59d9f51634ee53554a0f5da3a5ce9ee98948da2cefc9c6903d1ba995e25c4dfa6eeb8f8bf8fef53f1713e6e984f9fe54606d3a4877de806bf38da96dd230881e4d1b876dc2cdacd0e93aaa51a732098592bc86ac119a13966dd</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Vue </category>
          
          <category> vue2.x源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Step.9 深入响应式系统构建-下</title>
      <link href="/computer-science/vueyuanma/dosc/9%E6%B7%B1%E5%85%A5%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA-%E4%B8%8B/"/>
      <url>/computer-science/vueyuanma/dosc/9%E6%B7%B1%E5%85%A5%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA-%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>上一节，我们深入分析了以<code>data,computed</code>为数据创建响应式系统的过程，并对其中依赖收集和派发更新的过程进行了详细的分析。然而在使用和分析过程中依然存在或多或少的问题，这一节我们将针对这些问题展开分析，最后我们也会分析一下<code>watch</code>的响应式过程。这篇文章将作为响应式系统分析的完结篇。</p></blockquote><h2 id="7-12-数组检测"><a href="#7-12-数组检测" class="headerlink" title="7.12 数组检测"></a>7.12 数组检测</h2><p>在之前介绍数据代理章节，我们已经详细介绍过<code>Vue</code>数据代理的技术是利用了<code>Object.defineProperty</code>,<code>Object.defineProperty</code>让我们可以方便的利用存取描述符中的<code>getter/setter</code>来进行数据的监听,在<code>get,set</code>钩子中分别做不同的操作，达到数据拦截的目的。然而<code>Object.defineProperty</code>的<code>get,set</code>方法只能检测到对象属性的变化，对于数组的变化(例如插入删除数组元素等操作)，<code>Object.defineProperty</code>却无法达到目的,这也是利用<code>Object.defineProperty</code>进行数据监控的缺陷，虽然<code>es6</code>中的<code>proxy</code>可以完美解决这一问题，但毕竟有兼容性问题，所以我们还需要研究<code>Vue</code>在<code>Object.defineProperty</code>的基础上如何对数组进行监听检测。</p><h3 id="7-12-1-数组方法的重写"><a href="#7-12-1-数组方法的重写" class="headerlink" title="7.12.1 数组方法的重写"></a>7.12.1 数组方法的重写</h3><p>既然数组已经不能再通过数据的<code>getter,setter</code>方法去监听变化了，<code>Vue</code>的做法是对数组方法进行重写，在保留原数组功能的前提下，对数组进行额外的操作处理。也就是重新定义了数组方法。</p><pre><code class="js">var arrayProto = Array.prototype;// 新建一个继承于Array的对象var arrayMethods = Object.create(arrayProto);// 数组拥有的方法var methodsToPatch = [  &#39;push&#39;,  &#39;pop&#39;,  &#39;shift&#39;,  &#39;unshift&#39;,  &#39;splice&#39;,  &#39;sort&#39;,  &#39;reverse&#39;];</code></pre><p><code>arrayMethods</code>是基于原始<code>Array</code>类为原型继承的一个对象类，由于原型链的继承，<code>arrayMethod</code>拥有数组的所有方法，接下来对这个新的数组类的方法进行改写。</p><pre><code class="js">methodsToPatch.forEach(function (method) &#123;  // 缓冲原始数组的方法  var original = arrayProto[method];  // 利用Object.defineProperty对方法的执行进行改写  def(arrayMethods, method, function mutator () &#123;&#125;);&#125;);function def (obj, key, val, enumerable) &#123;    Object.defineProperty(obj, key, &#123;      value: val,      enumerable: !!enumerable,      writable: true,      configurable: true    &#125;);  &#125;</code></pre><p>这里对数组方法设置了代理，当执行<code>arrayMethods</code>的数组方法时，会代理执行<code>mutator</code>函数，这个函数的具体实现，我们放到数组的派发更新中介绍。</p><p><strong>仅仅创建一个新的数组方法合集是不够的，我们在访问数组时，如何不调用原生的数组方法，而是将过程指向这个新的类，这是下一步的重点。</strong></p><p>回到数据初始化过程，也就是执行<code>initData</code>阶段，上一篇内容花了大篇幅介绍过数据初始化会为<code>data</code>数据创建一个<code>Observer</code>类，当时我们只讲述了<code>Observer</code>类会为每个非数组的属性进行数据拦截，重新定义<code>getter,setter</code>方法,除此之外对于数组类型的数据，我们有意跳过分析了。这里，我们重点看看对于数组拦截的处理。</p><pre><code class="js">var Observer = function Observer (value) &#123;  this.value = value;  this.dep = new Dep();  this.vmCount = 0;  // 将__ob__属性设置成不可枚举属性。外部无法通过遍历获取。  def(value, &#39;__ob__&#39;, this);  // 数组处理  if (Array.isArray(value)) &#123;    if (hasProto) &#123;      protoAugment(value, arrayMethods);    &#125; else &#123;      copyAugment(value, arrayMethods, arrayKeys);    &#125;    this.observeArray(value);  &#125; else &#123;  // 对象处理    this.walk(value);  &#125;&#125;</code></pre><p>数组处理的分支分为两个，<code>hasProto</code>的判断条件，<code>hasProto</code>用来判断当前环境下是否支持<code>__proto__</code>属性。而数组的处理会根据是否支持这一属性来决定执行<code>protoAugment, copyAugment</code>过程，</p><pre><code class="js">// __proto__属性的判断var hasProto = &#39;__proto__&#39; in &#123;&#125;;</code></pre><p><strong>当支持<code>__proto__</code>时，执行<code>protoAugment</code>会将当前数组的原型指向新的数组类<code>arrayMethods</code>,如果不支持<code>__proto__</code>，则通过代理设置，在访问数组方法时代理访问新数组类中的数组方法。</strong></p><pre><code class="js">//直接通过原型指向的方式function protoAugment (target, src) &#123;  target.__proto__ = src;&#125;// 通过数据代理的方式function copyAugment (target, src, keys) &#123;  for (var i = 0, l = keys.length; i &lt; l; i++) &#123;    var key = keys[i];    def(target, key, src[key]);  &#125;&#125;</code></pre><p>有了这两步的处理，接下来我们在实例内部调用<code>push, unshift</code>等数组的方法时，会执行<code>arrayMethods</code>类的方法。这也是数组进行依赖收集和派发更新的前提。</p><h3 id="7-12-2-依赖收集"><a href="#7-12-2-依赖收集" class="headerlink" title="7.12.2 依赖收集"></a>7.12.2 依赖收集</h3><p>由于数据初始化阶段会利用<code>Object.definePrototype</code>进行数据访问的改写，数组的访问同样会被<code>getter</code>所拦截。由于是数组，拦截过程会做特殊处理，后面我们再看看<code>dependArray</code>的原理。</p><pre><code class="js">function defineReactive###1() &#123;  ···  var childOb = !shallow &amp;&amp; observe(val);  Object.defineProperty(obj, key, &#123;        enumerable: true,        configurable: true,        get: function reactiveGetter () &#123;          var value = getter ? getter.call(obj) : val;          if (Dep.target) &#123;            dep.depend();            if (childOb) &#123;              childOb.dep.depend();              if (Array.isArray(value)) &#123;                dependArray(value);              &#125;            &#125;          &#125;          return value        &#125;,        set() &#123;&#125;&#125; </code></pre><p><code>childOb</code>是标志属性值是否为基础类型的标志，<code>observe</code>如果遇到基本类型数据，则直接返回，不做任何处理，如果遇到对象或者数组则会递归实例化<code>Observer</code>，会为每个子属性设置响应式数据，最终返回<code>Observer</code>实例。而实例化<code>Observer</code>又回到之前的老流程：<br>  <strong>添加<code>__ob__</code>属性，如果遇到数组则进行原型重指向，遇到对象则定义<code>getter,setter</code>，这一过程前面分析过，就不再阐述。</strong></p><p>在访问到数组时，由于<code>childOb</code>的存在，会执行<code>childOb.dep.depend();</code>进行依赖收集，该<code>Observer</code>实例的<code>dep</code>属性会收集当前的<code>watcher</code>作为依赖保存，<code>dependArray</code>保证了如果数组元素是数组或者对象，需要递归去为内部的元素收集相关的依赖。</p><pre><code class="js">function dependArray (value) &#123;    for (var e = (void 0), i = 0, l = value.length; i &lt; l; i++) &#123;      e = value[i];      e &amp;&amp; e.__ob__ &amp;&amp; e.__ob__.dep.depend();      if (Array.isArray(e)) &#123;        dependArray(e);      &#125;    &#125;  &#125;</code></pre><p>我们可以通过截图看最终依赖收集的结果。</p><p>收集前</p><p><img data-src="/images/img/7.1.png"></p><p>收集后</p><p><img data-src="/images/img/7.2.png"></p><h3 id="7-12-3-派发更新"><a href="#7-12-3-派发更新" class="headerlink" title="7.12.3 派发更新"></a>7.12.3 派发更新</h3><p>当调用数组的方法去添加或者删除数据时，数据的<code>setter</code>方法是无法拦截的，所以我们唯一可以拦截的过程就是调用数组方法的时候，前面介绍过，数组方法的调用会代理到新类<code>arrayMethods</code>的方法中,而<code>arrayMethods</code>的数组方法是进行重写过的。具体我们看他的定义。</p><pre><code class="js"> methodsToPatch.forEach(function (method) &#123;    var original = arrayProto[method];    def(arrayMethods, method, function mutator () &#123;      var args = [], len = arguments.length;      while ( len-- ) args[ len ] = arguments[ len ];      // 执行原数组方法      var result = original.apply(this, args);      var ob = this.__ob__;      var inserted;      switch (method) &#123;        case &#39;push&#39;:        case &#39;unshift&#39;:          inserted = args;          break        case &#39;splice&#39;:          inserted = args.slice(2);          break      &#125;      if (inserted) &#123; ob.observeArray(inserted); &#125;      // notify change      ob.dep.notify();      return result    &#125;);  &#125;);</code></pre><p><code>mutator</code>是重写的数组方法，首先会调用原始的数组方法进行运算，这保证了与原始数组类型的方法一致性，<code>args</code>保存了数组方法调用传递的参数。之后取出数组的<code>__ob__</code>也就是之前保存的<code>Observer</code>实例，调用<code>ob.dep.notify();</code>进行依赖的派发更新，前面知道了。<code>Observer</code>实例的<code>dep</code>是<code>Dep</code>的实例，他收集了需要监听的<code>watcher</code>依赖，而<code>notify</code>会对依赖进行重新计算并更新。具体看<code>Dep.prototype.notify = function notify () &#123;&#125;</code>函数的分析，这里也不重复赘述。</p><p>回到代码中，<code>inserted</code>变量用来标志数组是否是增加了元素，如果增加的元素不是原始类型，而是数组对象类型，则需要触发<code>observeArray</code>方法，对每个元素进行依赖收集。</p><pre><code class="js">Observer.prototype.observeArray = function observeArray (items) &#123;  for (var i = 0, l = items.length; i &lt; l; i++) &#123;    observe(items[i]);  &#125;&#125;;</code></pre><p><strong>总的来说。数组的改变不会触发<code>setter</code>进行依赖更新，所以<code>Vue</code>创建了一个新的数组类，重写了数组的方法，将数组方法指向了新的数组类。同时在访问到数组时依旧触发<code>getter</code>进行依赖收集，在更改数组时，触发数组新方法运算，并进行依赖的派发。</strong></p><p>现在我们回过头看看Vue的官方文档对于数组检测时的注意事项：</p><blockquote><p><code>Vue</code> 不能检测以下数组的变动:</p><ul><li>当你利用索引直接设置一个数组项时，例如：<code>vm.items[indexOfItem] = newValue</code></li><li>当你修改数组的长度时，例如：<code>vm.items.length = newLength</code></li></ul></blockquote><p>显然有了上述的分析我们很容易理解数组检测带来的弊端，即使<code>Vue</code>重写了数组的方法，以便在设置数组时进行拦截处理，但是不管是通过索引还是直接修改长度，都是无法触发依赖更新的。</p><h2 id="7-13-对象检测异常"><a href="#7-13-对象检测异常" class="headerlink" title="7.13 对象检测异常"></a>7.13 对象检测异常</h2><p>我们在实际开发中经常遇到一种场景，对象<code>test: &#123; a: 1 &#125;</code>要添加一个属性<code>b</code>,这时如果我们使用<code>test.b = 2</code>的方式去添加，这个过程<code>Vue</code>是无法检测到的，理由也很简单。我们在对对象进行依赖收集的时候，会为对象的每个属性都进行收集依赖，而直接通过<code>test.b</code>添加的新属性并没有依赖收集的过程，因此当之后数据<code>b</code>发生改变时也不会进行依赖的更新。</p><p>了解决这一问题，<code>Vue</code>提供了<code>Vue.set(object, propertyName, value)</code>的静态方法和<code>vm.$set(object, propertyName, value)</code>的实例方法，我们看具体怎么完成新属性的依赖收集过程。</p><pre><code class="js">Vue.set = setfunction set (target, key, val) &#123;    //target必须为非空对象    if (isUndef(target) || isPrimitive(target)    ) &#123;      warn((&quot;Cannot set reactive property on undefined, null, or primitive value: &quot; + ((target))));    &#125;    // 数组场景，调用重写的splice方法，对新添加属性收集依赖。    if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;      target.length = Math.max(target.length, key);      target.splice(key, 1, val);      return val    &#125;    // 新增对象的属性存在时，直接返回新属性，触发依赖收集    if (key in target &amp;&amp; !(key in Object.prototype)) &#123;      target[key] = val;      return val    &#125;    // 拿到目标源的Observer 实例    var ob = (target).__ob__;    if (target._isVue || (ob &amp;&amp; ob.vmCount)) &#123;      warn(        &#39;Avoid adding reactive properties to a Vue instance or its root $data &#39; +        &#39;at runtime - declare it upfront in the data option.&#39;      );      return val    &#125;    // 目标源对象本身不是一个响应式对象，则不需要处理    if (!ob) &#123;      target[key] = val;      return val    &#125;    // 手动调用defineReactive，为新属性设置getter,setter    defineReactive###1(ob.value, key, val);    ob.dep.notify();    return val  &#125;</code></pre><p>按照分支分为不同的四个处理逻辑：</p><ol><li>目标对象必须为非空的对象，可以是数组，否则抛出异常。</li><li>如果目标对象是数组时，调用数组的<code>splice</code>方法，而前面分析数组检测时，遇到数组新增元素的场景，会调用<code>ob.observeArray(inserted)</code>对数组新增的元素收集依赖。</li><li>新增的属性值在原对象中已经存在，则手动访问新的属性值，这一过程会触发依赖收集。</li><li>手动定义新属性的<code>getter,setter</code>方法，并通过<code>notify</code>触发依赖更新。</li></ol><h2 id="7-14-nextTick"><a href="#7-14-nextTick" class="headerlink" title="7.14 nextTick"></a>7.14 nextTick</h2><p>在上一节的内容中，我们说到数据修改时会触发<code>setter</code>方法进行依赖的派发更新，而更新时会将每个<code>watcher</code>推到队列中，等待下一个<code>tick</code>到来时再执行<code>DOM</code>的渲染更新操作。这个就是异步更新的过程。为了说明异步更新的概念，需要牵扯到浏览器的事件循环机制和最优的渲染时机问题。由于这不是文章的主线，我只用简单的语言概述。</p><h3 id="7-14-1-事件循环机制"><a href="#7-14-1-事件循环机制" class="headerlink" title="7.14.1 事件循环机制"></a>7.14.1 事件循环机制</h3><ol><li>完整的事件循环机制需要了解两种异步队列：<code>macro-task</code>和<code>micro-task</code></li><li><code>macro-task</code>常见的有 <code>setTimeout, setInterval, setImmediate, script脚本, I/O操作，UI渲染</code></li><li><code>micro-task</code>常见的有 <code>promise, process.nextTick, MutationObserver</code>等</li><li>完整事件循环流程为：<br>  4.1 <code>micro-task</code>空，<code>macro-task</code>队列只有<code>script</code>脚本，推出<code>macro-task</code>的<code>script</code>任务执行，脚本执行期间产生的<code>macro-task，micro-task</code>推到对应的队列中<br>  4.2 执行全部<code>micro-task</code>里的微任务事件<br>  4.3 执行<code>DOM</code>操作，渲染更新页面<br>  4.4 执行<code>web worker</code>等相关任务<br>  4.5 循环，取出<code>macro-task</code>中一个宏任务事件执行，重复4的操作。</li></ol><p>从上面的流程中我们可以发现，最好的渲染过程发生在微任务队列的执行过程中，此时他离页面渲染过程最近，因此我们可以借助微任务队列来实现异步更新，它可以让复杂批量的运算操作运行在JS层面，而视图的渲染只关心最终的结果，这大大降低了性能的损耗。</p><p>举一个这一做法好处的例子：<br>  由于<code>Vue</code>是数据驱动视图更新渲染，如果我们在一个操作中重复对一个响应式数据进行计算，例如 在一个循环中执行<code>this.num ++ </code>一千次，由于响应式系统的存在，数据变化触发<code>setter</code>，<code>setter</code>触发依赖派发更新，更新调用<code>run</code>进行视图的重新渲染。这一次循环，视图渲染要执行一千次，很明显这是很浪费性能的，我们只需要关注最后第一千次在界面上更新的结果而已。所以利用异步更新显得格外重要。</p><h3 id="7-14-2-基本实现"><a href="#7-14-2-基本实现" class="headerlink" title="7.14.2 基本实现"></a>7.14.2 基本实现</h3><p><code>Vue</code>用一个<code>queue</code>收集依赖的执行，在下次微任务执行的时候统一执行<code>queue</code>中<code>Watcher</code>的<code>run</code>操作,与此同时，相同<code>id</code>的<code>watcher</code>不会重复添加到<code>queue</code>中,因此也不会重复执行多次的视图渲染。我们看<code>nextTick</code>的实现。</p><pre><code class="js">// 原型上定义的方法Vue.prototype.$nextTick = function (fn) &#123;  return nextTick(fn, this)&#125;;// 构造函数上定义的方法Vue.nextTick = nextTick;// 实际的定义var callbacks = [];function nextTick (cb, ctx) &#123;    var _resolve;    // callbacks是维护微任务的数组。    callbacks.push(function () &#123;      if (cb) &#123;        try &#123;          cb.call(ctx);        &#125; catch (e) &#123;          handleError(e, ctx, &#39;nextTick&#39;);        &#125;      &#125; else if (_resolve) &#123;        _resolve(ctx);      &#125;    &#125;);    if (!pending) &#123;      pending = true;      // 将维护的队列推到微任务队列中维护      timerFunc();    &#125;    // nextTick没有传递参数，且浏览器支持Promise,则返回一个promise对象    if (!cb &amp;&amp; typeof Promise !== &#39;undefined&#39;) &#123;      return new Promise(function (resolve) &#123;        _resolve = resolve;      &#125;)    &#125;  &#125;</code></pre><p><code>nextTick</code>定义为一个函数，使用方式为<code>Vue.nextTick( [callback, context] )</code>,当<code>callback</code>经过<code>nextTick</code>封装后，<code>callback</code>会在下一个<code>tick</code>中执行调用。从实现上，<code>callbacks</code>是一个维护了需要在下一个<code>tick</code>中执行的任务的队列，它的每个元素都是需要执行的函数。<code>pending</code>是判断是否在等待执行微任务队列的标志。而<code>timerFunc</code>是真正将任务队列推到微任务队列中的函数。我们看<code>timerFunc</code>的实现。</p><p>1.如果浏览器执行<code>Promise</code>,那么默认以<code>Promsie</code>将执行过程推到微任务队列中。</p><pre><code class="js">var timerFunc;if (typeof Promise !== &#39;undefined&#39; &amp;&amp; isNative(Promise)) &#123;  var p = Promise.resolve();  timerFunc = function () &#123;    p.then(flushCallbacks);    // 手机端的兼容代码    if (isIOS) &#123; setTimeout(noop); &#125;  &#125;;  // 使用微任务队列的标志  isUsingMicroTask = true;&#125;</code></pre><p><code>flushCallbacks</code>是异步更新的函数，他会取出callbacks数组的每一个任务，执行任务，具体定义如下：</p><pre><code class="js">function flushCallbacks () &#123;  pending = false;  var copies = callbacks.slice(0);  // 取出callbacks数组的每一个任务，执行任务  callbacks.length = 0;  for (var i = 0; i &lt; copies.length; i++) &#123;    copies[i]();  &#125;&#125;</code></pre><p>2.不支持<code>promise</code>,支持<code>MutataionObserver</code></p><pre><code class="js">else if (!isIE &amp;&amp; typeof MutationObserver !== &#39;undefined&#39; &amp;&amp; (    isNative(MutationObserver) ||    // PhantomJS and iOS 7.x    MutationObserver.toString() === &#39;[object MutationObserverConstructor]&#39;  )) &#123;    var counter = 1;    var observer = new MutationObserver(flushCallbacks);    var textNode = document.createTextNode(String(counter));    observer.observe(textNode, &#123;      characterData: true    &#125;);    timerFunc = function () &#123;      counter = (counter + 1) % 2;      textNode.data = String(counter);    &#125;;    isUsingMicroTask = true;  &#125;</code></pre><p>3.如果不支持微任务方法，则会使用宏任务方法，<code>setImmediate</code>会先被使用</p><pre><code class="js"> else if (typeof setImmediate !== &#39;undefined&#39; &amp;&amp; isNative(setImmediate)) &#123;    // Fallback to setImmediate.    // Techinically it leverages the (macro) task queue,    // but it is still a better choice than setTimeout.    timerFunc = function () &#123;      setImmediate(flushCallbacks);    &#125;;  &#125;</code></pre><p>4.所有方法都不适合，会使用宏任务方法中的<code>setTimeout</code></p><pre><code class="js">else &#123;  timerFunc = function () &#123;    setTimeout(flushCallbacks, 0);  &#125;;&#125;</code></pre><p><strong>当<code>nextTick</code>不传递任何参数时，可以作为一个<code>promise</code>用</strong>，例如：</p><pre><code class="js">nextTick().then(() =&gt; &#123;&#125;)</code></pre><h3 id="7-14-3-使用场景"><a href="#7-14-3-使用场景" class="headerlink" title="7.14.3 使用场景"></a>7.14.3 使用场景</h3><p>说了这么多原理性的东西，回过头来看看<code>nextTick</code>的使用场景，由于异步更新的原理，我们在某一时间改变的数据并不会触发视图的更新，而是需要等下一个<code>tick</code>到来时才会更新视图，下面是一个典型场景：</p><pre><code class="js">&lt;input v-if=&quot;show&quot; type=&quot;text&quot; ref=&quot;myInput&quot;&gt;// jsdata() &#123;  show: false&#125;,mounted() &#123;  this.show = true;  this.$refs.myInput.focus();// 报错&#125;</code></pre><p>数据改变时，视图并不会同时改变，因此需要使用<code>nextTick</code></p><pre><code class="js">mounted() &#123;  this.show = true;  this.$nextTick(function() &#123;    this.$refs.myInput.focus();// 正常  &#125;)&#125;</code></pre><h2 id="7-15-watch"><a href="#7-15-watch" class="headerlink" title="7.15 watch"></a>7.15 watch</h2><p>到这里，关于响应式系统的分析大部分内容已经分析完毕，我们上一节还遗留着一个问题，<code>Vue</code>对用户手动添加的<code>watch</code>如何进行数据拦截。我们先看看两种基本的使用形式。</p><pre><code class="js">// watch选项var vm = new Vue(&#123;  el: &#39;#app&#39;,  data() &#123;    return &#123;      num: 12    &#125;  &#125;,  watch: &#123;    num() &#123;&#125;  &#125;&#125;)vm.num = 111// $watch api方式vm.$watch(&#39;num&#39;, function() &#123;&#125;, &#123;  deep: ,  immediate: ,&#125;)</code></pre><h3 id="7-15-1-依赖收集"><a href="#7-15-1-依赖收集" class="headerlink" title="7.15.1 依赖收集"></a>7.15.1 依赖收集</h3><p>我们以<code>watch</code>选项的方式来分析<code>watch</code>的细节，同样从初始化说起，初始化数据会执行<code>initWatch</code>,<code>initWatch</code>的核心是<code>createWatcher</code>。</p><pre><code class="js">function initWatch (vm, watch) &#123;    for (var key in watch) &#123;      var handler = watch[key];      // handler可以是数组的形式，执行多个回调      if (Array.isArray(handler)) &#123;        for (var i = 0; i &lt; handler.length; i++) &#123;          createWatcher(vm, key, handler[i]);        &#125;      &#125; else &#123;        createWatcher(vm, key, handler);      &#125;    &#125;  &#125;  function createWatcher (vm,expOrFn,handler,options) &#123;    // 针对watch是对象的形式，此时回调回选项中的handler    if (isPlainObject(handler)) &#123;      options = handler;      handler = handler.handler;    &#125;    if (typeof handler === &#39;string&#39;) &#123;      handler = vm[handler];    &#125;    return vm.$watch(expOrFn, handler, options)  &#125;</code></pre><p>无论是选项的形式，还是<code>api</code>的形式，最终都会调用实例的<code>$watch</code>方法，其中<code>expOrFn</code>是监听的字符串，<code>handler</code>是监听的回调函数，<code>options</code>是相关配置。我们重点看看<code>$watch</code>的实现。</p><pre><code class="js">Vue.prototype.$watch = function (expOrFn,cb,options) &#123;    var vm = this;    if (isPlainObject(cb)) &#123;      return createWatcher(vm, expOrFn, cb, options)    &#125;    options = options || &#123;&#125;;    options.user = true;    var watcher = new Watcher(vm, expOrFn, cb, options);    // 当watch有immediate选项时，立即执行cb方法，即不需要等待属性变化，立刻执行回调。    if (options.immediate) &#123;      try &#123;        cb.call(vm, watcher.value);      &#125; catch (error) &#123;        handleError(error, vm, (&quot;callback for immediate watcher \&quot;&quot; + (watcher.expression) + &quot;\&quot;&quot;));      &#125;    &#125;    return function unwatchFn () &#123;      watcher.teardown();    &#125;  &#125;;&#125;</code></pre><p><code>$watch</code>的核心是创建一个<code>user watcher</code>,<code>options.user</code>是当前用户定义<code>watcher</code>的标志。如果有<code>immediate</code>属性，则立即执行回调函数。<br>而实例化<code>watcher</code>时会执行一次<code>getter</code>求值，这时，<code>user watcher</code>会作为依赖被数据所收集。这个过程可以参考<code>data</code>的分析。</p><pre><code class="js">var Watcher = function Watcher() &#123;  ···  this.value = this.lazy      ? undefined      : this.get();&#125;Watcher.prototype.get = function get() &#123;  ···  try &#123;    // getter回调函数，触发依赖收集    value = this.getter.call(vm, vm);  &#125; &#125;</code></pre><h3 id="7-15-2-派发更新"><a href="#7-15-2-派发更新" class="headerlink" title="7.15.2 派发更新"></a>7.15.2 派发更新</h3><p><code>watch</code>派发更新的过程很好理解，数据发生改变时，<code>setter</code>拦截对依赖进行更新，而此前<code>user watcher</code>已经被当成依赖收集了。这个时候依赖的更新就是回调函数的执行。</p><h2 id="7-16-小结"><a href="#7-16-小结" class="headerlink" title="7.16 小结"></a>7.16 小结</h2><p>这一节是响应式系统构建的完结篇，<code>data,computed</code>如何进行响应式系统设计，这在上一节内容已经详细分析，这一节针对一些特殊场景做了分析。例如由于<code>Object.defineProperty</code>自身的缺陷，无法对数组的新增删除进行拦截检测，因此<code>Vue</code>对数组进行了特殊处理，重写了数组的方法，并在方法中对数据进行拦截。我们也重点介绍了<code>nextTick</code>的原理，利用浏览器的事件循环机制来达到最优的渲染时机。文章的最后补充了<code>watch</code>在响应式设计的原理，用户自定义的<code>watch</code>会创建一个依赖，这个依赖在数据改变时会执行回调。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Vue </category>
          
          <category> vue2.x源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Step.8 深入响应式系统构建-中</title>
      <link href="/computer-science/vueyuanma/dosc/8%E6%B7%B1%E5%85%A5%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA-%E4%B8%AD/"/>
      <url>/computer-science/vueyuanma/dosc/8%E6%B7%B1%E5%85%A5%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA-%E4%B8%AD/</url>
      
        <content type="html"><![CDATA[<blockquote><p>为了深入介绍响应式系统的内部实现原理，我们花了一整节的篇幅介绍了数据(包括<code>data, computed,props</code>)如何初始化成为响应式对象的过程。有了响应式数据对象的知识，上一节的后半部分我们还在保留源码结构的基础上构建了一个以<code>data</code>为数据的响应式系统，而这一节，我们继续深入响应式系统内部构建的细节，详细分析<code>Vue</code>在响应式系统中对<code>data,computed</code>的处理。</p></blockquote><h2 id="7-8-相关概念"><a href="#7-8-相关概念" class="headerlink" title="7.8 相关概念"></a>7.8 相关概念</h2><p>在构建简易式响应式系统的时候，我们引出了几个重要的概念，他们都是响应式原理设计的核心，我们先简单回顾一下：</p><ul><li><code>Observer</code>类，实例化一个<code>Observer</code>类会通过<code>Object.defineProperty</code>对数据的<code>getter,setter</code>方法进行改写，在<code>getter</code>阶段进行<strong>依赖的收集</strong>,在数据发生更新阶段，触发<code>setter</code>方法进行<strong>依赖的更新</strong></li><li><code>watcher</code>类，实例化<code>watcher</code>类相当于创建一个依赖，简单的理解是数据在哪里被使用就需要产生了一个依赖。当数据发生改变时，会通知到每个依赖进行更新，前面提到的渲染<code>wathcer</code>便是渲染<code>dom</code>时使用数据产生的依赖。</li><li><code>Dep</code>类，既然<code>watcher</code>理解为每个数据需要监听的依赖，那么对这些依赖的收集和通知则需要另一个类来管理，这个类便是<code>Dep</code>,<code>Dep</code>需要做的只有两件事，收集依赖和派发更新依赖。</li></ul><p>这是响应式系统构建的三个基本核心概念，也是这一节的基础，如果还没有印象，请先回顾上一节对<strong>极简风响应式系统的构建</strong>。</p><h2 id="7-9-data"><a href="#7-9-data" class="headerlink" title="7.9 data"></a>7.9 data</h2><h3 id="7-9-1-问题思考"><a href="#7-9-1-问题思考" class="headerlink" title="7.9.1 问题思考"></a>7.9.1 问题思考</h3><p>在开始分析<code>data</code>之前，我们先抛出几个问题让读者思考，而答案都包含在接下来内容分析中。</p><ul><li><p>前面已经知道，<code>Dep</code>是作为管理依赖的容器，那么这个容器在什么时候产生？也就是实例化<code>Dep</code>发生在什么时候？</p></li><li><p><code>Dep</code>收集了什么类型的依赖？即<code>watcher</code>作为依赖的分类有哪些，分别是什么场景，以及区别在哪里？</p></li><li><p><code>Observer</code>这个类具体对<code>getter,setter</code>方法做了哪些事情？</p></li><li><p>手写的<code>watcher</code>和页面数据渲染监听的<code>watch</code>如果同时监听到数据的变化，优先级怎么排？</p></li><li><p>有了依赖的收集是不是还有依赖的解除，依赖解除的意义在哪里？</p></li></ul><p>带着这几个问题，我们开始对<code>data</code>的响应式细节展开分析。</p><h3 id="7-9-2-依赖收集"><a href="#7-9-2-依赖收集" class="headerlink" title="7.9.2 依赖收集"></a>7.9.2 依赖收集</h3><p><code>data</code>在初始化阶段会实例化一个<code>Observer</code>类，这个类的定义如下(忽略数组类型的<code>data</code>):</p><pre><code class="js">// initData function initData(data) &#123;  ···  observe(data, true)&#125;// observefunction observe(value, asRootData) &#123;  ···  ob = new Observer(value);  return ob&#125;// 观察者类，对象只要设置成拥有观察属性，则对象下的所有属性都会重写getter和setter方法，而getter，setting方法会进行依赖的收集和派发更新var Observer = function Observer (value) &#123;    ···    // 将__ob__属性设置成不可枚举属性。外部无法通过遍历获取。    def(value, &#39;__ob__&#39;, this);    // 数组处理    if (Array.isArray(value)) &#123;        ···    &#125; else &#123;      // 对象处理      this.walk(value);    &#125;  &#125;;function def (obj, key, val, enumerable) &#123;  Object.defineProperty(obj, key, &#123;    value: val,    enumerable: !!enumerable, // 是否可枚举    writable: true,    configurable: true  &#125;);&#125;</code></pre><p><code>Observer</code>会为<code>data</code>添加一个<code>__ob__</code>属性， <code>__ob__</code>属性是作为响应式对象的标志，同时<code>def</code>方法确保了该属性是不可枚举属性，即外界无法通过遍历获取该属性值。除了标志响应式对象外，<code>Observer</code>类还调用了原型上的<code>walk</code>方法，遍历对象上每个属性进行<code>getter,setter</code>的改写。</p><pre><code class="js">Observer.prototype.walk = function walk (obj) &#123;    // 获取对象所有属性，遍历调用defineReactive###1进行改写    var keys = Object.keys(obj);    for (var i = 0; i &lt; keys.length; i++) &#123;        defineReactive###1(obj, keys[i]);    &#125;&#125;;</code></pre><p><code>defineReactive###1</code>是响应式构建的核心，它会先<strong>实例化一个<code>Dep</code>类，即为每个数据都创建一个依赖的管理</strong>，之后利用<code>Object.defineProperty</code>重写<code>getter,setter</code>方法。这里我们只分析依赖收集的代码。</p><pre><code class="js">function defineReactive###1 (obj,key,val,customSetter,shallow) &#123;    // 每个数据实例化一个Dep类，创建一个依赖的管理    var dep = new Dep();    var property = Object.getOwnPropertyDescriptor(obj, key);    // 属性必须满足可配置    if (property &amp;&amp; property.configurable === false) &#123;      return    &#125;    // cater for pre-defined getter/setters    var getter = property &amp;&amp; property.get;    var setter = property &amp;&amp; property.set;    // 这一部分的逻辑是针对深层次的对象，如果对象的属性是一个对象，则会递归调用实例化Observe类，让其属性值也转换为响应式对象    var childOb = !shallow &amp;&amp; observe(val);    Object.defineProperty(obj, key, &#123;      enumerable: true,      configurable: true,s      get: function reactiveGetter () &#123;        var value = getter ? getter.call(obj) : val;        if (Dep.target) &#123;          // 为当前watcher添加dep数据          dep.depend();          if (childOb) &#123;            childOb.dep.depend();            if (Array.isArray(value)) &#123;              dependArray(value);            &#125;          &#125;        &#125;        return value      &#125;,      set: function reactiveSetter (newVal) &#123;&#125;    &#125;);  &#125;</code></pre><p>主要看<code>getter</code>的逻辑，我们知道当<code>data</code>中属性值被访问时，会被<code>getter</code>函数拦截，根据我们旧有的知识体系可以知道，实例挂载前会创建一个渲染<code>watcher</code>。</p><pre><code class="js">new Watcher(vm, updateComponent, noop, &#123;  before: function before () &#123;    if (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123;      callHook(vm, &#39;beforeUpdate&#39;);    &#125;  &#125;&#125;, true /* isRenderWatcher */);</code></pre><p>与此同时，<code>updateComponent</code>的逻辑会执行实例的挂载，在这个过程中，模板会被优先解析为<code>render</code>函数，而<code>render</code>函数转换成<code>Vnode</code>时，会访问到定义的<code>data</code>数据，这个时候会触发<code>gettter</code>进行依赖收集。而此时数据收集的依赖就是这个渲染<code>watcher</code>本身。</p><p>代码中依赖收集阶段会做下面几件事：</p><ol><li><strong>为当前的<code>watcher</code>(该场景下是渲染<code>watcher</code>)添加拥有的数据</strong>。</li><li><strong>为当前的数据收集需要监听的依赖</strong></li></ol><p>如何理解这两点？我们先看代码中的实现。<code>getter</code>阶段会执行<code>dep.depend()</code>,这是<code>Dep</code>这个类定义在原型上的方法。</p><pre><code class="js">dep.depend();Dep.prototype.depend = function depend () &#123;    if (Dep.target) &#123;      Dep.target.addDep(this);    &#125;  &#125;;</code></pre><p><code>Dep.target</code>为当前执行的<code>watcher</code>,在渲染阶段，<code>Dep.target</code>为组件挂载时实例化的渲染<code>watcher</code>,因此<code>depend</code>方法又会调用当前<code>watcher</code>的<code>addDep</code>方法为<code>watcher</code>添加依赖的数据。</p><pre><code class="js">Watcher.prototype.addDep = function addDep (dep) &#123;    var id = dep.id;    if (!this.newDepIds.has(id)) &#123;      // newDepIds和newDeps记录watcher拥有的数据      this.newDepIds.add(id);      this.newDeps.push(dep);      // 避免重复添加同一个data收集器      if (!this.depIds.has(id)) &#123;        dep.addSub(this);      &#125;    &#125;  &#125;;</code></pre><p>其中<code>newDepIds</code>是具有唯一成员是<code>Set</code>数据结构，<code>newDeps</code>是数组，他们用来记录当前<code>watcher</code>所拥有的数据，这一过程会进行逻辑判断，避免同一数据添加多次。</p><p><code>addSub</code>为每个数据依赖收集器添加需要被监听的<code>watcher</code>。</p><pre><code class="js">Dep.prototype.addSub = function addSub (sub) &#123;  //将当前watcher添加到数据依赖收集器中    this.subs.push(sub);&#125;;</code></pre><ol start="3"><li><strong><code>getter</code>如果遇到属性值为对象时，会为该对象的每个值收集依赖</strong></li></ol><p>这句话也很好理解，如果我们将一个值为基本类型的响应式数据改变成一个对象，此时新增对象里的属性，也需要设置成响应式数据。</p><ol start="4"><li><strong>遇到属性值为数组时，进行特殊处理</strong>，这点放到后面讲。</li></ol><p><strong>通俗的总结一下依赖收集的过程，每个数据就是一个依赖管理器，而每个使用数据的地方就是一个依赖。当访问到数据时，会将当前访问的场景作为一个依赖收集到依赖管理器中，同时也会为这个场景的依赖收集拥有的数据。</strong></p><h3 id="7-9-3-派发更新"><a href="#7-9-3-派发更新" class="headerlink" title="7.9.3 派发更新"></a>7.9.3 派发更新</h3><p>在分析依赖收集的过程中，可能会有不少困惑，为什么要维护这么多的关系？在数据更新时，这些关系会起到什么作用？带着疑惑，我们来看看派发更新的过程。<br>在数据发生改变时，会执行定义好的<code>setter</code>方法，我们先看源码。</p><pre><code class="js">Object.defineProperty(obj,key, &#123;  ···  set: function reactiveSetter (newVal) &#123;      var value = getter ? getter.call(obj) : val;      // 新值和旧值相等时，跳出操作      if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;        return      &#125;      ···      // 新值为对象时，会为新对象进行依赖收集过程      childOb = !shallow &amp;&amp; observe(newVal);      dep.notify();    &#125;&#125;)</code></pre><p>派发更新阶段会做以下几件事：</p><ul><li><strong>判断数据更改前后是否一致，如果数据相等则不进行任何派发更新操作</strong>。</li><li><strong>新值为对象时，会对该值的属性进行依赖收集过程</strong>。</li><li><strong>通知该数据收集的<code>watcher</code>依赖,遍历每个<code>watcher</code>进行数据更新</strong>,这个阶段是调用该数据依赖收集器的<code>dep.notify</code>方法进行更新的派发。</li></ul><pre><code class="js">Dep.prototype.notify = function notify () &#123;    var subs = this.subs.slice();    if (!config.async) &#123;      // 根据依赖的id进行排序      subs.sort(function (a, b) &#123; return a.id - b.id; &#125;);    &#125;    for (var i = 0, l = subs.length; i &lt; l; i++) &#123;      // 遍历每个依赖，进行更新数据操作。      subs[i].update();    &#125;  &#125;;</code></pre><ul><li><strong>更新时会将每个<code>watcher</code>推到队列中，等待下一个<code>tick</code>到来时取出每个<code>watcher</code>进行<code>run</code>操作</strong></li></ul><pre><code class="js"> Watcher.prototype.update = function update () &#123;    ···    queueWatcher(this);  &#125;;</code></pre><p><code>queueWatcher</code>方法的调用，会将数据所收集的依赖依次推到<code>queue</code>数组中,数组会在下一个事件循环<code>&#39;tick&#39;</code>中根据缓冲结果进行视图更新。而在执行视图更新过程中，难免会因为数据的改变而在渲染模板上添加新的依赖，这样又会执行<code>queueWatcher</code>的过程。所以需要有一个标志位来记录是否处于异步更新过程的队列中。这个标志位为<code>flushing</code>,当处于异步更新过程时，新增的<code>watcher</code>会插入到<code>queue</code>中。</p><pre><code class="js">function queueWatcher (watcher) &#123;    var id = watcher.id;    // 保证同一个watcher只执行一次    if (has[id] == null) &#123;      has[id] = true;      if (!flushing) &#123;        queue.push(watcher);      &#125; else &#123;        var i = queue.length - 1;        while (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123;          i--;        &#125;        queue.splice(i + 1, 0, watcher);      &#125;      ···      nextTick(flushSchedulerQueue);    &#125;  &#125;</code></pre><p><code>nextTick</code>的原理和实现先不讲，概括来说，<code>nextTick</code>会缓冲多个数据处理过程，等到下一个事件循环<code>tick</code>中再去执行<code>DOM</code>操作，<strong>它的原理，本质是利用事件循环的微任务队列实现异步更新</strong>。</p><p>当下一个<code>tick</code>到来时，会执行<code>flushSchedulerQueue</code>方法，它会拿到收集的<code>queue</code>数组(这是一个<code>watcher</code>的集合),并对数组依赖进行排序。为什么进行排序呢？源码中解释了三点：</p><blockquote><ul><li>组件创建是先父后子，所以组件的更新也是先父后子，因此需要保证父的渲染<code>watcher</code>优先于子的渲染<code>watcher</code>更新。</li><li><strong>用户自定义的<code>watcher</code>,称为<code>user watcher</code>。 <code>user watcher</code>和<code>render watcher</code>执行也有先后，由于<code>user watchers</code>比<code>render watcher</code>要先创建，所以<code>user watcher</code>要优先执行</strong>。</li><li>如果一个组件在父组件的 <code>watcher</code> 执行阶段被销毁，那么它对应的 <code>watcher</code> 执行都可以被跳过。</li></ul></blockquote><pre><code class="js">function flushSchedulerQueue () &#123;    currentFlushTimestamp = getNow();    flushing = true;    var watcher, id;    // 对queue的watcher进行排序    queue.sort(function (a, b) &#123; return a.id - b.id; &#125;);    // 循环执行queue.length，为了确保由于渲染时添加新的依赖导致queue的长度不断改变。    for (index = 0; index &lt; queue.length; index++) &#123;      watcher = queue[index];      // 如果watcher定义了before的配置，则优先执行before方法      if (watcher.before) &#123;        watcher.before();      &#125;      id = watcher.id;      has[id] = null;      watcher.run();      // in dev build, check and stop circular updates.      if (has[id] != null) &#123;        circular[id] = (circular[id] || 0) + 1;        if (circular[id] &gt; MAX_UPDATE_COUNT) &#123;          warn(            &#39;You may have an infinite update loop &#39; + (              watcher.user                ? (&quot;in watcher with expression \&quot;&quot; + (watcher.expression) + &quot;\&quot;&quot;)                : &quot;in a component render function.&quot;            ),            watcher.vm          );          break        &#125;      &#125;    &#125;    // keep copies of post queues before resetting state    var activatedQueue = activatedChildren.slice();    var updatedQueue = queue.slice();    // 重置恢复状态，清空队列    resetSchedulerState();    // 视图改变后，调用其他钩子    callActivatedHooks(activatedQueue);    callUpdatedHooks(updatedQueue);    // devtool hook    /* istanbul ignore if */    if (devtools &amp;&amp; config.devtools) &#123;      devtools.emit(&#39;flush&#39;);    &#125;  &#125;</code></pre><p><code>flushSchedulerQueue</code>阶段，重要的过程可以总结为四点：</p><blockquote><ul><li>对<code>queue</code>中的<code>watcher</code>进行排序，原因上面已经总结。</li><li>遍历<code>watcher</code>,如果当前<code>watcher</code>有<code>before</code>配置，则执行<code>before</code>方法，对应前面的渲染<code>watcher</code>:在渲染<code>watcher</code>实例化时，我们传递了<code>before</code>函数，即在下个<code>tick</code>更新视图前，会调用<code>beforeUpdate</code>生命周期钩子。</li><li>执行<code>watcher.run</code>进行修改的操作。</li><li>重置恢复状态，这个阶段会将一些流程控制的状态变量恢复为初始值，并清空记录<code>watcher</code>的队列。</li></ul></blockquote><pre><code class="js">new Watcher(vm, updateComponent, noop, &#123;  before: function before () &#123;    if (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123;      callHook(vm, &#39;beforeUpdate&#39;);    &#125;  &#125;&#125;, true /* isRenderWatcher */);</code></pre><p>重点看看<code>watcher.run()</code>的操作。</p><pre><code class="js">Watcher.prototype.run = function run () &#123;    if (this.active) &#123;      var value = this.get();      if ( value !== this.value || isObject(value) || this.deep ) &#123;        // 设置新值        var oldValue = this.value;        this.value = value;        // 针对user watcher，暂时不分析        if (this.user) &#123;          try &#123;            this.cb.call(this.vm, value, oldValue);          &#125; catch (e) &#123;            handleError(e, this.vm, (&quot;callback for watcher \&quot;&quot; + (this.expression) + &quot;\&quot;&quot;));          &#125;        &#125; else &#123;          this.cb.call(this.vm, value, oldValue);        &#125;      &#125;    &#125;  &#125;;</code></pre><p>首先会执行<code>watcher.prototype.get</code>的方法，得到数据变化后的当前值，之后会对新值做判断，如果判断满足条件，则执行<code>cb</code>,<code>cb</code>为实例化<code>watcher</code>时传入的回调。</p><p>在分析<code>get</code>方法前，回头看看<code>watcher</code>构造函数的几个属性定义</p><pre><code class="js">var watcher = function Watcher(  vm, // 组件实例  expOrFn, // 执行函数  cb, // 回调  options, // 配置  isRenderWatcher // 是否为渲染watcher) &#123;  this.vm = vm;    if (isRenderWatcher) &#123;      vm._watcher = this;    &#125;    vm._watchers.push(this);    // options    if (options) &#123;      this.deep = !!options.deep;      this.user = !!options.user;      this.lazy = !!options.lazy;      this.sync = !!options.sync;      this.before = options.before;    &#125; else &#123;      this.deep = this.user = this.lazy = this.sync = false;    &#125;    this.cb = cb;    this.id = ++uid$2; // uid for batching    this.active = true;    this.dirty = this.lazy; // for lazy watchers    this.deps = [];    this.newDeps = [];    this.depIds = new _Set();    this.newDepIds = new _Set();    this.expression = expOrFn.toString();    // parse expression for getter    if (typeof expOrFn === &#39;function&#39;) &#123;      this.getter = expOrFn;    &#125; else &#123;      this.getter = parsePath(expOrFn);      if (!this.getter) &#123;        this.getter = noop;        warn(          &quot;Failed watching path: \&quot;&quot; + expOrFn + &quot;\&quot; &quot; +          &#39;Watcher only accepts simple dot-delimited paths. &#39; +          &#39;For full control, use a function instead.&#39;,          vm        );      &#125;    &#125;    // lazy为计算属性标志，当watcher为计算watcher时，不会理解执行get方法进行求值    this.value = this.lazy      ? undefined      : this.get();  &#125;</code></pre><p>方法<code>get</code>的定义如下：</p><pre><code class="js">Watcher.prototype.get = function get () &#123;    pushTarget(this);    var value;    var vm = this.vm;    try &#123;      value = this.getter.call(vm, vm);    &#125; catch (e) &#123;     ···    &#125; finally &#123;      ···      // 把Dep.target恢复到上一个状态，依赖收集过程完成      popTarget();      this.cleanupDeps();    &#125;    return value  &#125;;</code></pre><p><code>get</code>方法会执行<code>this.getter</code>进行求值，在当前渲染<code>watcher</code>的条件下,<code>getter</code>会执行视图更新的操作。这一阶段会<strong>重新渲染页面组件</strong></p><pre><code class="js">new Watcher(vm, updateComponent, noop, &#123; before: () =&gt; &#123;&#125; &#125;, true);updateComponent = function () &#123;  vm._update(vm._render(), hydrating);&#125;;</code></pre><p>执行完<code>getter</code>方法后，最后一步会进行依赖的清除，也就是<code>cleanupDeps</code>的过程。</p><blockquote><p>关于依赖清除的作用，我们列举一个场景： 我们经常会使用<code>v-if</code>来进行模板的切换，切换过程中会执行不同的模板渲染，如果A模板监听a数据，B模板监听b数据，当渲染模板B时，如果不进行旧依赖的清除，在B模板的场景下，a数据的变化同样会引起依赖的重新渲染更新，这会造成性能的浪费。因此旧依赖的清除在优化阶段是有必要。</p></blockquote><pre><code class="js">// 依赖清除的过程  Watcher.prototype.cleanupDeps = function cleanupDeps () &#123;    var i = this.deps.length;    while (i--) &#123;      var dep = this.deps[i];      if (!this.newDepIds.has(dep.id)) &#123;        dep.removeSub(this);      &#125;    &#125;    var tmp = this.depIds;    this.depIds = this.newDepIds;    this.newDepIds = tmp;    this.newDepIds.clear();    tmp = this.deps;    this.deps = this.newDeps;    this.newDeps = tmp;    this.newDeps.length = 0;  &#125;;</code></pre><p>把上面分析的总结成依赖派发更新的最后两个点</p><ul><li><strong>执行<code>run</code>操作会执行<code>getter</code>方法,也就是重新计算新值，针对渲染<code>watcher</code>而言，会重新执行<code>updateComponent</code>进行视图更新</strong></li><li><strong>重新计算<code>getter</code>后，会进行依赖的清除</strong></li></ul><h2 id="7-10-computed"><a href="#7-10-computed" class="headerlink" title="7.10 computed"></a>7.10 computed</h2><p>计算属性设计的初衷是用于简单运算的，毕竟在模板中放入太多的逻辑会让模板过重且难以维护。在分析<code>computed</code>时，我们依旧遵循依赖收集和派发更新两个过程进行分析。</p><h3 id="7-10-1-依赖收集"><a href="#7-10-1-依赖收集" class="headerlink" title="7.10.1 依赖收集"></a>7.10.1 依赖收集</h3><p><code>computed</code>的初始化过程，**会遍历<code>computed</code>的每一个属性值，并为每一个属性实例化一个<code>computed watcher</code>**，其中<code>&#123; lazy: true&#125;</code>是<code>computed watcher</code>的标志，最终会调用<code>defineComputed</code>将数据设置为响应式数据，对应源码如下：</p><pre><code class="js">function initComputed() &#123;  ···  for(var key in computed) &#123;    watchers[key] = new Watcher(        vm,        getter || noop,        noop,        computedWatcherOptions      );  &#125;  if (!(key in vm)) &#123;    defineComputed(vm, key, userDef);  &#125;&#125;// computed watcher的标志，lazy属性为truevar computedWatcherOptions = &#123; lazy: true &#125;;</code></pre><p><code>defineComputed</code>的逻辑和分析<code>data</code>的逻辑相似，最终调用<code>Object.defineProperty</code>进行数据拦截。具体的定义如下：</p><pre><code class="js">function defineComputed (target,key,userDef) &#123;  // 非服务端渲染会对getter进行缓存  var shouldCache = !isServerRendering();  if (typeof userDef === &#39;function&#39;) &#123;    //     sharedPropertyDefinition.get = shouldCache      ? createComputedGetter(key)      : createGetterInvoker(userDef);    sharedPropertyDefinition.set = noop;  &#125; else &#123;    sharedPropertyDefinition.get = userDef.get      ? shouldCache &amp;&amp; userDef.cache !== false        ? createComputedGetter(key)        : createGetterInvoker(userDef.get)      : noop;    sharedPropertyDefinition.set = userDef.set || noop;  &#125;  if (sharedPropertyDefinition.set === noop) &#123;    sharedPropertyDefinition.set = function () &#123;      warn(        (&quot;Computed property \&quot;&quot; + key + &quot;\&quot; was assigned to but it has no setter.&quot;),        this      );    &#125;;  &#125;  Object.defineProperty(target, key, sharedPropertyDefinition);&#125;</code></pre><p>在非服务端渲染的情形，计算属性的计算结果会被缓存，缓存的意义在于，<strong>只有在相关响应式数据发生变化时，<code>computed</code>才会重新求值，其余情况多次访问计算属性的值都会返回之前计算的结果，这就是缓存的优化</strong>，<code>computed</code>属性有两种写法，一种是函数，另一种是对象，其中对象的写法需要提供<code>getter</code>和<code>setter</code>方法。</p><p>当访问到<code>computed</code>属性时，会触发<code>getter</code>方法进行依赖收集，看看<code>createComputedGetter</code>的实现。</p><pre><code class="js">function createComputedGetter (key) &#123;    return function computedGetter () &#123;      var watcher = this._computedWatchers &amp;&amp; this._computedWatchers[key];      if (watcher) &#123;        if (watcher.dirty) &#123;          watcher.evaluate();        &#125;        if (Dep.target) &#123;          watcher.depend();        &#125;        return watcher.value      &#125;    &#125;  &#125;</code></pre><p><code>createComputedGetter</code>返回的函数在执行过程中会先拿到属性的<code>computed watcher</code>,<code>dirty</code>是标志是否已经执行过计算结果，如果执行过则不会执行<code>watcher.evaluate</code>重复计算，这也是缓存的原理。</p><pre><code class="js">Watcher.prototype.evaluate = function evaluate () &#123;    // 对于计算属性而言 evaluate的作用是执行计算回调    this.value = this.get();    this.dirty = false;  &#125;;</code></pre><p><code>get</code>方法前面介绍过，会调用实例化<code>watcher</code>时传递的执行函数，在<code>computer watcher</code>的场景下，执行函数是计算属性的计算函数，他可以是一个函数，也可以是对象的<code>getter</code>方法。</p><blockquote><p>列举一个场景避免和<code>data</code>的处理脱节，<code>computed</code>在计算阶段，如果访问到<code>data</code>数据的属性值，会触发<code>data</code>数据的<code>getter</code>方法进行依赖收集，根据前面分析，<code>data</code>的<code>Dep</code>收集器会将当前<code>watcher</code>作为依赖进行收集，而这个<code>watcher</code>就是<code>computed watcher</code>，并且会为当前的<code>watcher</code>添加访问的数据<code>Dep</code></p></blockquote><p>回到计算执行函数的<code>this.get()</code>方法，<code>getter</code>执行完成后同样会进行依赖的清除，原理和目的参考<code>data</code>阶段的分析。<code>get</code>执行完毕后会进入<code>watcher.depend</code>进行依赖的收集。收集过程和<code>data</code>一致,将当前的<code>computed watcher</code>作为依赖收集到数据的依赖收集器<code>Dep</code>中。</p><p>这就是<code>computed</code>依赖收集的完整过程，对比<code>data</code>的依赖收集，<code>computed</code>会对运算的结果进行缓存，避免重复执行运算过程。</p><h3 id="7-10-2-派发更新"><a href="#7-10-2-派发更新" class="headerlink" title="7.10.2 派发更新"></a>7.10.2 派发更新</h3><p>派发更新的条件是<code>data</code>中数据发生改变，所以大部分的逻辑和分析<code>data</code>时一致，我们做一个总结。</p><ul><li>当计算属性依赖的数据发生更新时，由于数据的<code>Dep</code>收集过<code>computed watch</code>这个依赖，所以会调用<code>dep</code>的<code>notify</code>方法，对依赖进行状态更新。</li><li>此时<code>computed watcher</code>和之前介绍的<code>watcher</code>不同，它不会立刻执行依赖的更新操作，而是通过一个<code>dirty</code>进行标记。我们再回头看<code>依赖更新</code>的代码。</li></ul><pre><code class="js">Dep.prototype.notify = function() &#123;  ···   for (var i = 0, l = subs.length; i &lt; l; i++) &#123;      subs[i].update();    &#125;&#125;Watcher.prototype.update = function update () &#123;  // 计算属性分支    if (this.lazy) &#123;    this.dirty = true;  &#125; else if (this.sync) &#123;    this.run();  &#125; else &#123;    queueWatcher(this);  &#125;&#125;;</code></pre><p>由于<code>lazy</code>属性的存在，<code>update</code>过程不会执行状态更新的操作，只会将<code>dirty</code>标记为<code>true</code>。</p><ul><li>由于<code>data</code>数据拥有渲染<code>watcher</code>这个依赖，所以同时会执行<code>updateComponent</code>进行视图重新渲染,而<code>render</code>过程中会访问到计算属性,此时由于<code>this.dirty</code>值为<code>true</code>,又会对计算属性重新求值。</li></ul><h2 id="7-11-小结"><a href="#7-11-小结" class="headerlink" title="7.11 小结"></a>7.11 小结</h2><p>我们在上一节的理论基础上深入分析了<code>Vue</code>如何利用<code>data,computed</code>构建响应式系统。响应式系统的核心是利用<code>Object.defineProperty</code>对数据的<code>getter,setter</code>进行拦截处理，处理的核心是在访问数据时对数据所在场景的依赖进行收集，在数据发生更改时，通知收集过的依赖进行更新。这一节我们详细的介绍了<code>data,computed</code>对响应式的处理，两者处理逻辑存在很大的相似性但却各有的特性。源码中会<code>computed</code>的计算结果进行缓存，避免了在多个地方使用时频繁重复计算的问题。由于篇幅有限，对于用户自定义的<code>watcher</code>我们会放到下一小节分析。文章还留有一个疑惑，依赖收集时如果遇到的数据是数组时应该怎么处理，这些疑惑都会在之后的文章一一解开。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Vue </category>
          
          <category> vue2.x源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js中的深浅拷贝</title>
      <link href="/js-base/js%E4%B8%AD%E7%9A%84%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
      <url>/js-base/js%E4%B8%AD%E7%9A%84%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<p>1：深浅拷贝的区别</p><p>首先要知道一点的就是，JavaScript的数据类型的分为基本数据类型和引用类型，</p><p>对于基本数据类型的拷贝，并没有深浅拷贝的区别，我们所说的深浅拷贝都是对于<strong>引用数据类型</strong>而言的</p><p><strong>浅拷贝的概念</strong></p><p>浅拷贝的意思就是只复制引用，而未复制真正的值。</p><pre><code class="javascript">       // 定义一个数组       let arr = [1,2,3,4,5]       // 定义一个对象       let obj = &#123;a:&#39;a&#39;,b:&#39;b&#39;,c:[1,2,3,4,5],d:&#123;dd:&#39;dd&#39;&#125;&#125;           //赋值这个数组给另一个变量       let clonearr = arr       //赋值这个数组给另一个对象       let cloneobj = obj         // 打印一下拷贝的数据，嗯，是个原本来的一样的       console.log(clonearr) // [1,2,3,4,5]       console.log(cloneobj) // &#123;a:&#39;a&#39;,b:&#39;b&#39;,c:Array[3],d:&#123;dd:&#39;dd&#39;&#125;&#125;            // 这个时候操作来了，我们给这个克隆的数组添加数据 克隆的对象也修改数据        clonearr.push(6)        cloneobj.a = &#123;aa:&#39;aa&#39;&#125;        //打印2个数组   发现arr是和修改过的clonearr是一样的        console.log(arr)  // [1,2,3,4,5,6]        console.log(clonearr) // [1,2,3,4,5,6]        //打印2个对象   发现obj是和修改过的cloneobj是一样的        console.log(obj); // &#123;a:&#123;aa:&#39;aa&#39;&#125;,b:&#39;b&#39;,c:Array[3],d:&#123;dd:&#39;dd&#39;&#125;&#125;        console.log(cloneobj); // &#123;a:&#123;aa:&#39;aa&#39;&#125;,b:&#39;b&#39;,c:Array[3],d:&#123;dd:&#39;dd&#39;&#125;&#125; </code></pre><h6 id="1：深拷贝有哪些方式？"><a href="#1：深拷贝有哪些方式？" class="headerlink" title="1：深拷贝有哪些方式？"></a>1：深拷贝有哪些方式？</h6><pre><code class="javascript">深拷贝就是对目标的完全拷贝，不像浅拷贝那样只是复制了一层引用，就连值也都复制了。只要进行了深拷贝，它们老死不相往来，谁也不会影响谁。目前实现深拷贝的方法不多，主要是两种：1. 利用 `JSON` 对象中的 `parse` 和 `stringify`2. 利用递归来实现每一层都重新创建对象并赋值`JSON.stringify` 是将一个 `JavaScript` 值转成一个 `JSON` 字符串。`JSON.parse` 是将一个 `JSON` 字符串转成一个 `JavaScript` 值或对象。</code></pre><p><strong>使用JSON.stringify(obj)的缺点</strong></p><pre><code class="javascript">   确实是深拷贝，也很方便。但是，这个方法只能适用于一些简单的情况。比如下面这样的一个对象就不适用：   const obj = &#123;          name:&#39;gsq&#39;,          hello:function()&#123;              console.log(&#39;gsq&#39;);          &#125;      &#125;      const cloneobj = JSON.parse(JSON.stringify(obj))      console.log(obj) // &#123;name: &quot;gsq&quot;, hello: ƒ&#125;      console.log(cloneobj) //  &#123;name: &quot;gsq&quot;&#125;</code></pre><p><strong>注意</strong>：使用 JSON.parse(JSON.stringify(obj)) 进行深拷贝 对   <code>undefined</code>、<code>function</code>、<code>symbol</code> 会在转换过程中被忽略。。。</p><p><strong>递归的方法</strong></p><p>递归的思想就很简单了，就是对每一层的数据都实现一次 <code>创建对象-&gt;对象赋值</code> 的操作，简单粗暴上代码：</p><p><strong>这种方式就不存在<code>undefined</code>、<code>function</code>、<code>symbol</code> 被忽略了</strong></p><pre><code class="javascript">function deepClone(source)&#123;  const targetObj = source.constructor === Array ? [] : &#123;&#125;; // 判断复制的目标是数组还是对象  for(let keys in source)&#123; // 遍历目标    if(source.hasOwnProperty(keys))&#123;      if(source[keys] &amp;&amp; typeof source[keys] === &#39;object&#39;)&#123; // 如果值是对象，就递归一下        targetObj[keys] = source[keys].constructor === Array ? [] : &#123;&#125;;        targetObj[keys] = deepClone(source[keys]);      &#125;else&#123; // 如果不是，就直接赋值        targetObj[keys] = source[keys];      &#125;    &#125;   &#125;  return targetObj;&#125;</code></pre><h6 id="2：浅拷贝有哪些方式"><a href="#2：浅拷贝有哪些方式" class="headerlink" title="2：浅拷贝有哪些方式"></a>2：浅拷贝有哪些方式</h6><p>1：concat</p><pre><code class="javascript">        const arr = [1,2,3,4,5];        const clonearr = arr.concat();console.log(arr === clonearr)  // false</code></pre><p>2：slice</p><pre><code class="javascript">    let arr1 = [1,2,3,4]    let arr2 = arr1.slice()console.log(arr1 === arr2) //false</code></pre><p>3：es6之  <code>Object.assign()</code></p><pre><code class="javascript">    let obj = &#123;&#39;a&#39; : 1, &#39;b&#39; : 2&#125;    let cloneobj = Object.assign(&#123;&#125;,obj)console.log(obj === cloneobj) //false    </code></pre><p>4：es6扩展运算符 …</p><pre><code class="javascript">        let arr = [1,2,3,4]        let clonearr = [...arr]console.log(arr === clonearr) //false</code></pre><p>5：es6 from方法</p><pre><code class="javascript">        const a1 = [1, 2, 3, 4];        const a2 = Array.from(a1); console.log(a1 === a2) //false</code></pre><p>6：使用map方法</p><pre><code class="javascript">        const arr = [1,2,3,4]        let clonearr = arr.map(item =&gt; item)console.log(arr === clonearr)</code></pre><p>7：自定义函数浅拷贝</p><pre><code class="javascript">function shallowClone(source) &#123;  const targetObj = source.constructor === Array ? [] : &#123;&#125;; // 判断复制的目标是数组还是对象  for (let keys in source) &#123; // 遍历目标    if (source.hasOwnProperty(keys)) &#123;      targetObj[keys] = source[keys];    &#125;  &#125;  return targetObj;&#125;</code></pre><p><strong>总结</strong>：</p><ol><li>赋值运算符 <code>=</code> 实现的是浅拷贝，只拷贝对象的引用值；</li><li>JavaScript 中数组和对象自带的拷贝方法都是“首层深拷贝”；</li><li><code>JSON.stringify</code> 实现的是深拷贝，但是对目标对象有要求，转化的值不能是<code>function</code>，<code>undefined</code>，<code>symbol</code> ；</li><li>若想真正意义上的深拷贝，请递归。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Step.7 深入响应式系统构建-上</title>
      <link href="/computer-science/vueyuanma/dosc/7%E6%B7%B1%E5%85%A5%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA-%E4%B8%8A/"/>
      <url>/computer-science/vueyuanma/dosc/7%E6%B7%B1%E5%85%A5%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA-%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<blockquote><p>从这一小节开始，正式进入<code>Vue</code>源码的核心，也是难点之一，响应式系统的构建。这一节将作为分析响应式构建过程源码的入门，主要分为两大块,第一块是针对响应式数据<code>props,methods,data,computed,wather</code>初始化过程的分析，另一块则是在保留源码设计理念的前提下，尝试手动构建一个基础的响应式系统。有了这两个基础内容的铺垫，下一篇进行源码具体细节的分析会更加得心应手。</p></blockquote><h2 id="7-1-数据初始化"><a href="#7-1-数据初始化" class="headerlink" title="7.1 数据初始化"></a>7.1 数据初始化</h2><p>回顾一下之前的内容，我们对<code>Vue</code>源码的分析是从初始化开始，初始化<code>_init</code>会执行一系列的过程，这个过程包括了配置选项的合并，数据的监测代理，最后才是实例的挂载。而在实例挂载前还有意忽略了一个重要的过程，<strong>数据的初始化</strong>(即<code>initState(vm)</code>)。<code>initState</code>的过程，是对数据进行响应式设计的过程，过程会针对<code>props,methods,data,computed</code>和<code>watch</code>做数据的初始化处理，并将他们转换为响应式对象，接下来我们会逐步分析每一个过程。</p><pre><code class="js">function initState (vm) &#123;  vm._watchers = [];  var opts = vm.$options;  // 初始化props  if (opts.props) &#123; initProps(vm, opts.props); &#125;  // 初始化methods  if (opts.methods) &#123; initMethods(vm, opts.methods); &#125;  // 初始化data  if (opts.data) &#123;    initData(vm);  &#125; else &#123;    // 如果没有定义data，则创建一个空对象，并设置为响应式    observe(vm._data = &#123;&#125;, true /* asRootData */);  &#125;  // 初始化computed  if (opts.computed) &#123; initComputed(vm, opts.computed); &#125;  // 初始化watch  if (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;    initWatch(vm, opts.watch);  &#125;&#125;</code></pre><h2 id="7-2-initProps"><a href="#7-2-initProps" class="headerlink" title="7.2 initProps"></a>7.2 initProps</h2><p>简单回顾一下<code>props</code>的用法，父组件通过属性的形式将数据传递给子组件，子组件通过<code>props</code>属性接收父组件传递的值。</p><pre><code class="js">// 父组件&lt;child :test=&quot;test&quot;&gt;&lt;/child&gt;var vm = new Vue(&#123;  el: &#39;#app&#39;,  data() &#123;    return &#123;      test: &#39;child&#39;    &#125;  &#125;&#125;)// 子组件Vue.component(&#39;child&#39;, &#123;  template: &#39;&lt;div&gt;&#123;&#123;test&#125;&#125;&lt;/div&gt;&#39;,  props: [&#39;test&#39;]&#125;)</code></pre><p>因此分析<code>props</code>需要分析父组件和子组件的两个过程，我们先看父组件对传递值的处理。按照以往文章介绍的那样，父组件优先进行模板编译得到一个<code>render</code>函数，在解析过程中遇到子组件的属性，<code>:test=test</code>会被解析成<code>&#123; attrs: &#123;test： test&#125;&#125;</code>并作为子组件的<code>render</code>函数存在，如下所示:</p><pre><code class="js">with()&#123;..._c(&#39;child&#39;,&#123;attrs:&#123;&quot;test&quot;:test&#125;&#125;)&#125;</code></pre><p><code>render</code>解析<code>Vnode</code>的过程遇到<code>child</code>这个子占位符节点，因此会进入创建子组件<code>Vnode</code>的过程，创建子<code>Vnode</code>过程是调用<code>createComponent</code>,这个阶段我们在组件章节有分析过，在组件的高级用法也有分析过，最终会调用<code>new Vnode</code>去创建子<code>Vnode</code>。而对于<code>props</code>的处理，<code>extractPropsFromVNodeData</code>会对<code>attrs</code>属性进行规范校验后，最后会把校验后的结果以<code>propsData</code>属性的形式传入<code>Vnode</code>构造器中。总结来说，<code>props</code>传递给占位符组件的写法，会以<code>propsData</code>的形式作为子组件<code>Vnode</code>的属性存在。下面会分析具体的细节。</p><pre><code class="js">// 创建子组件过程function createComponent() &#123;  // props校验  var propsData = extractPropsFromVNodeData(data, Ctor, tag);  ···  // 创建子组件vnode  var vnode = new VNode(    (&quot;vue-component-&quot; + (Ctor.cid) + (name ? (&quot;-&quot; + name) : &#39;&#39;)),    data, undefined, undefined, undefined, context,    &#123; Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children &#125;,    asyncFactory  );&#125;</code></pre><h3 id="7-2-1-props的命名规范"><a href="#7-2-1-props的命名规范" class="headerlink" title="7.2.1 props的命名规范"></a>7.2.1 props的命名规范</h3><p>先看检测<code>props</code>规范性的过程。**<code>props</code>编译后的结果有两种，其中<code>attrs</code>前面分析过，是编译生成<code>render</code>函数针对属性的处理，而<code>props</code>是针对用户自写<code>render</code>函数的属性值。**因此需要同时对这两种方式进行校验。</p><pre><code class="js">function extractPropsFromVNodeData (data,Ctor,tag) &#123;  // Ctor为子类构造器  ···  var res = &#123;&#125;;  // 子组件props选项  var propOptions = Ctor.options.props;  // data.attrs针对编译生成的render函数，data.props针对用户自定义的render函数  var attrs = data.attrs;  var props = data.props;  if (isDef(attrs) || isDef(props)) &#123;    for (var key in propOptions) &#123;      // aB 形式转成 a-b      var altKey = hyphenate(key);      &#123;          var keyInLowerCase = key.toLowerCase();          if (            key !== keyInLowerCase &amp;&amp;            attrs &amp;&amp; hasOwn(attrs, keyInLowerCase)          ) &#123;            // 警告          &#125;        &#125;    &#125;  &#125;&#125;</code></pre><p>重点说一下源码在这一部分的处理，<strong>HTML对大小写是不敏感的，所有的浏览器会把大写字符解释为小写字符，因此我们在使用<code>DOM</code>中的模板时，cameCase(驼峰命名法)的<code>props</code>名需要使用其等价的 <code>kebab-case</code> (短横线分隔命名) 命代替</strong>。<br><strong>即： <code>&lt;child :aB=&quot;test&quot;&gt;&lt;/child&gt;</code>需要写成<code>&lt;child :a-b=&quot;test&quot;&gt;&lt;/child&gt;</code></strong></p><h3 id="7-2-2-响应式数据props"><a href="#7-2-2-响应式数据props" class="headerlink" title="7.2.2 响应式数据props"></a>7.2.2 响应式数据props</h3><p>刚才说到分析<code>props</code>需要两个过程，前面已经针对父组件对<code>props</code>的处理做了描述，而对于子组件而言，我们是通过<code>props</code>选项去接收父组件传递的值。我们再看看子组件对<code>props</code>的处理：</p><p>子组件处理<code>props</code>的过程，是发生在父组件<code>_update</code>阶段，这个阶段是<code>Vnode</code>生成真实节点的过程，期间会遇到子<code>Vnode</code>,这时会调用<code>createComponent</code>去实例化子组件。而实例化子组件的过程又回到了<code>_init</code>初始化，此时又会经历选项的合并，针对<code>props</code>选项，最终会统一成<code>&#123;props: &#123; test: &#123; type: null &#125;&#125;&#125;</code>的写法。接着会调用<code>initProps</code>, <code>initProps</code>做的事情，简单概括一句话就是，将组件的<code>props</code>数据设置为响应式数据。</p><pre><code class="js">function initProps (vm, propsOptions) &#123;  var propsData = vm.$options.propsData || &#123;&#125;;  var loop = function(key) &#123;    ···    defineReactive(props,key,value,cb)；    if (!(key in vm)) &#123;      proxy(vm, &quot;_props&quot;, key);    &#125;  &#125;  // 遍历props，执行loop设置为响应式数据。  for (var key in propsOptions) loop( key );&#125;</code></pre><p>其中<code>proxy(vm, &quot;_props&quot;, key);</code>为<code>props</code>做了一层代理，用户通过<code>vm.XXX</code>可以代理访问到<code>vm._props</code>上的值。针对<code>defineReactive</code>,本质上是利用<code>Object.defineProperty</code>对数据的<code>getter,setter</code>方法进行重写，具体的原理可以参考数据代理章节的内容，在这小节后半段也会有一个基本的实现。</p><h2 id="7-3-initMethods"><a href="#7-3-initMethods" class="headerlink" title="7.3 initMethods"></a>7.3 initMethods</h2><p><code>initMethod</code>方法和这一节介绍的响应式没有任何的关系，他的实现也相对简单，主要是保证<code>methods</code>方法定义必须是函数，且命名不能和<code>props</code>重复，最终会将定义的方法都挂载到根实例上。</p><pre><code class="js">function initMethods (vm, methods) &#123;    var props = vm.$options.props;    for (var key in methods) &#123;      &#123;        // method必须为函数形式        if (typeof methods[key] !== &#39;function&#39;) &#123;          warn(            &quot;Method \&quot;&quot; + key + &quot;\&quot; has type \&quot;&quot; + (typeof methods[key]) + &quot;\&quot; in the component definition. &quot; +            &quot;Did you reference the function correctly?&quot;,            vm          );        &#125;        // methods方法名不能和props重复        if (props &amp;&amp; hasOwn(props, key)) &#123;          warn(            (&quot;Method \&quot;&quot; + key + &quot;\&quot; has already been defined as a prop.&quot;),            vm          );        &#125;        //  不能以_ or $.这些Vue保留标志开头        if ((key in vm) &amp;&amp; isReserved(key)) &#123;          warn(            &quot;Method \&quot;&quot; + key + &quot;\&quot; conflicts with an existing Vue instance method. &quot; +            &quot;Avoid defining component methods that start with _ or $.&quot;          );        &#125;      &#125;      // 直接挂载到实例的属性上,可以通过vm[method]访问。      vm[key] = typeof methods[key] !== &#39;function&#39; ? noop : bind(methods[key], vm);    &#125;  &#125;</code></pre><h2 id="7-4-initData"><a href="#7-4-initData" class="headerlink" title="7.4 initData"></a>7.4 initData</h2><p><code>data</code>在初始化选项合并时会生成一个函数，只有在执行函数时才会返回真正的数据，所以<code>initData</code>方法会先执行拿到组件的<code>data</code>数据，并且会对对象每个属性的命名进行校验，保证不能和<code>props，methods</code>重复。最后的核心方法是<code>observe</code>,<code>observe</code>方法是将<strong>数据对象标记为响应式对象</strong>，并对对象的每个属性进行响应式处理。与此同时，和<code>props</code>的代理处理方式一样，<code>proxy</code>会对<code>data</code>做一层代理，直接通过<code>vm.XXX</code>可以代理访问到<code>vm._data</code>上挂载的对象属性。</p><pre><code class="js">function initData(vm) &#123;  var data = vm.$options.data;  // 根实例时，data是一个对象，子组件的data是一个函数，其中getData会调用函数返回data对象  data = vm._data = typeof data === &#39;function&#39;? getData(data, vm): data || &#123;&#125;;  var keys = Object.keys(data);  var props = vm.$options.props;  var methods = vm.$options.methods;  var i = keys.length;  while (i--) &#123;    var key = keys[i];    &#123;      // 命名不能和方法重复      if (methods &amp;&amp; hasOwn(methods, key)) &#123;        warn((&quot;Method \&quot;&quot; + key + &quot;\&quot; has already been defined as a data property.&quot;),vm);      &#125;    &#125;    // 命名不能和props重复    if (props &amp;&amp; hasOwn(props, key)) &#123;      warn(&quot;The data property \&quot;&quot; + key + &quot;\&quot; is already declared as a prop. &quot; + &quot;Use prop default value instead.&quot;,vm);    &#125; else if (!isReserved(key)) &#123;      // 数据代理，用户可直接通过vm实例返回data数据      proxy(vm, &quot;_data&quot;, key);    &#125;  &#125;  // observe data  observe(data, true /* asRootData */);&#125;</code></pre><p><strong>最后讲讲<code>observe</code>,<code>observe</code>具体的行为是将数据对象添加一个不可枚举的属性<code>__ob__</code>，标志对象是一个响应式对象，并且拿到每个对象的属性值，重写<code>getter,setter</code>方法，使得每个属性值都是响应式数据。详细的代码我们后面分析。</strong></p><h2 id="7-5-initComputed"><a href="#7-5-initComputed" class="headerlink" title="7.5 initComputed"></a>7.5 initComputed</h2><p>和上面的分析方法一样，<code>initComputed</code>是<code>computed</code>数据的初始化,不同之处在于以下几点：</p><ol><li><code>computed</code>可以是对象，也可以是函数，但是对象必须有<code>getter</code>方法,因此如果<code>computed</code>中的属性值是对象时需要进行验证。</li><li>针对<code>computed</code>的每个属性，要创建一个监听的依赖，也就是实例化一个<code>watcher</code>,<code>watcher</code>的定义，可以暂时理解为数据使用的依赖本身，一个<code>watcher</code>实例代表多了一个需要被监听的数据依赖。</li></ol><p>除了不同点，<code>initComputed</code>也会将每个属性设置成响应式的数据，同样的，也会对<code>computed</code>的命名做检测，防止与<code>props,data</code>冲突。</p><pre><code class="js">function initComputed (vm, computed) &#123;  ···  for (var key in computed) &#123;      var userDef = computed[key];      var getter = typeof userDef === &#39;function&#39; ? userDef : userDef.get;      // computed属性为对象时，要保证有getter方法      if (getter == null) &#123;        warn((&quot;Getter is missing for computed property \&quot;&quot; + key + &quot;\&quot;.&quot;),vm);      &#125;      if (!isSSR) &#123;        // 创建computed watcher        watchers[key] = new Watcher(vm,getter || noop,noop,computedWatcherOptions);      &#125;      if (!(key in vm)) &#123;        // 设置为响应式数据        defineComputed(vm, key, userDef);      &#125; else &#123;        // 不能和props，data命名冲突        if (key in vm.$data) &#123;          warn((&quot;The computed property \&quot;&quot; + key + &quot;\&quot; is already defined in data.&quot;), vm);        &#125; else if (vm.$options.props &amp;&amp; key in vm.$options.props) &#123;          warn((&quot;The computed property \&quot;&quot; + key + &quot;\&quot; is already defined as a prop.&quot;), vm);        &#125;      &#125;    &#125;&#125;</code></pre><p>显然<code>Vue</code>提供了很多种数据供开发者使用，但是分析完后发现每个处理的核心都是将数据转化成响应式数据，有了响应式数据，如何构建一个响应式系统呢？前面提到的<code>watcher</code>又是什么东西？构建响应式系统还需要其他的东西吗？接下来我们尝试着去实现一个极简风的响应式系统。</p><h2 id="7-6-极简风的响应式系统"><a href="#7-6-极简风的响应式系统" class="headerlink" title="7.6 极简风的响应式系统"></a>7.6 极简风的响应式系统</h2><p><code>Vue</code>的响应式系统构建是比较复杂的，直接进入源码分析构建的每一个流程会让理解变得困难，因此我觉得在尽可能保留源码的设计逻辑下,用最小的代码构建一个最基础的响应式系统是有必要的。对<code>Dep,Watcher,Observer</code>概念的初步认识，也有助于下一篇对响应式系统设计细节的分析。</p><h3 id="7-6-1-框架搭建"><a href="#7-6-1-框架搭建" class="headerlink" title="7.6.1 框架搭建"></a>7.6.1 框架搭建</h3><p>我们以<code>MyVue</code>作为类响应式框架，框架的搭建不做赘述。我们模拟<code>Vue</code>源码的实现思路，实例化<code>MyVue</code>时会传递一个选项配置，精简的代码只有一个<code>id</code>挂载元素和一个数据对象<code>data</code>。模拟源码的思路，我们在实例化时会先进行数据的初始化，这一步就是响应式的构建，我们稍后分析。数据初始化后开始进行真实<code>DOM</code>的挂载。</p><pre><code class="js">var vm = new MyVue(&#123;  id: &#39;#app&#39;,  data: &#123;    test: 12  &#125;&#125;)// myVue.js(function(global) &#123;  class MyVue &#123;      constructor(options) &#123;        this.options = options;        // 数据的初始化        this.initData(options);        let el = this.options.id;        // 实例的挂载        this.$mount(el);      &#125;      initData(options) &#123;      &#125;      $mount(el) &#123;      &#125;    &#125;&#125;(window))</code></pre><h3 id="7-6-2-设置响应式对象-Observer"><a href="#7-6-2-设置响应式对象-Observer" class="headerlink" title="7.6.2 设置响应式对象 - Observer"></a>7.6.2 设置响应式对象 - Observer</h3><p>首先引入一个类<code>Observer</code>,这个类的目的是将数据变成响应式对象，利用<code>Object.defineProperty</code>对数据的<code>getter,setter</code>方法进行改写。在数据读取<code>getter</code>阶段我们会进行<strong>依赖的收集</strong>，在数据的修改<code>setter</code>阶段，我们会进行<strong>依赖的更新</strong>(这两个概念的介绍放在后面)。因此在数据初始化阶段，我们会利用<code>Observer</code>这个类将数据对象修改为相应式对象，而这是所有流程的基础。</p><pre><code class="js">class MyVue &#123;  initData(options) &#123;    if(!options.data) return;    this.data = options.data;    // 将数据重置getter，setter方法    new Observer(options.data);  &#125;&#125;// Observer类的定义class Observer &#123;  constructor(data) &#123;    // 实例化时执行walk方法对每个数据属性重写getter，setter方法    this.walk(data)  &#125;  walk(obj) &#123;    const keys = Object.keys(obj);    for(let i = 0;i&lt; keys.length; i++) &#123;      // Object.defineProperty的处理逻辑      defineReactive(obj, keys[i])    &#125;  &#125;&#125;</code></pre><h3 id="7-6-3-依赖本身-Watcher"><a href="#7-6-3-依赖本身-Watcher" class="headerlink" title="7.6.3 依赖本身 - Watcher"></a>7.6.3 依赖本身 - Watcher</h3><p>我们可以这样理解，一个<code>Watcher</code>实例就是一个依赖，数据不管是在渲染模板时使用还是在用户计算时使用，都可以算做一个需要监听的依赖，<code>watcher</code>中记录着这个依赖监听的状态，以及如何更新操作的方法。</p><pre><code class="js">// 监听的依赖class Watcher &#123;  constructor(expOrFn, isRenderWatcher) &#123;    this.getter = expOrFn;    // Watcher.prototype.get的调用会进行状态的更新。    this.get();  &#125;  get() &#123;&#125;&#125;</code></pre><p>那么哪个时间点会实例化<code>watcher</code>并更新数据状态呢？显然在渲染数据到真实<code>DOM</code>时可以创建<code>watcher</code>。<code>$mount</code>流程前面章节介绍过，会经历模板生成<code>render</code>函数和<code>render</code>函数渲染真实<code>DOM</code>的过程。我们对代码做了精简，<code>updateView</code>浓缩了这一过程。</p><pre><code class="js">class MyVue &#123;  $mount(el) &#123;    // 直接改写innerHTML    const updateView = _ =&gt; &#123;      let innerHtml = document.querySelector(el).innerHTML;      let key = innerHtml.match(/&#123;(\w+)&#125;/)[1];      document.querySelector(el).innerHTML = this.options.data[key]    &#125;    // 创建一个渲染的依赖。    new Watcher(updateView, true)  &#125;&#125;</code></pre><h3 id="7-6-4-依赖管理-Dep"><a href="#7-6-4-依赖管理-Dep" class="headerlink" title="7.6.4 依赖管理 - Dep"></a>7.6.4 依赖管理 - Dep</h3><p><code>watcher</code>如果理解为每个数据需要监听的依赖，那么<code>Dep</code> 可以理解为对依赖的一种管理。数据可以在渲染中使用，也可以在计算属性中使用。相应的每个数据对应的<code>watcher</code>也有很多。而我们在更新数据时，如何通知到数据相关的每一个依赖，这就需要<code>Dep</code>进行通知管理了。并且浏览器同一时间只能更新一个<code>watcher</code>,所以也需要一个属性去记录当前更新的<code>watcher</code>。而<code>Dep</code>这个类只需要做两件事情，将依赖进行收集，派发依赖进行更新。</p><pre><code class="js">let uid = 0;class Dep &#123;  constructor() &#123;    this.id = uid++;    this.subs = []  &#125;  // 依赖收集  depend() &#123;    if(Dep.target) &#123;      // Dep.target是当前的watcher,将当前的依赖推到subs中      this.subs.push(Dep.target)    &#125;  &#125;  // 派发更新  notify() &#123;    const subs = this.subs.slice();    for (var i = 0, l = subs.length; i &lt; l; i++) &#123;       // 遍历dep中的依赖，对每个依赖执行更新操作      subs[i].update();    &#125;  &#125;&#125;Dep.target = null;</code></pre><h3 id="7-6-5-依赖管理过程-defineReactive"><a href="#7-6-5-依赖管理过程-defineReactive" class="headerlink" title="7.6.5 依赖管理过程 - defineReactive"></a>7.6.5 依赖管理过程 - defineReactive</h3><p>我们看看数据拦截的过程。前面的<code>Observer</code>实例化最终会调用<code>defineReactive</code>重写<code>getter,setter</code>方法。这个方法开始会实例化一个<code>Dep</code>,也就是创建一个数据的依赖管理。在重写的<code>getter</code>方法中会进行依赖的收集，也就是调用<code>dep.depend</code>的方法。在<code>setter</code>阶段，比较两个数不同后，会调用依赖的派发更新。即<code>dep.notify</code></p><pre><code class="js">const defineReactive = (obj, key) =&gt; &#123;  const dep = new Dep();  const property = Object.getOwnPropertyDescriptor(obj);  let val = obj[key]  if(property &amp;&amp; property.configurable === false) return;  Object.defineProperty(obj, key, &#123;    configurable: true,    enumerable: true,    get() &#123;      // 做依赖的收集      if(Dep.target) &#123;        dep.depend()      &#125;      return val    &#125;,    set(nval) &#123;      if(nval === val) return      // 派发更新      val = nval      dep.notify();    &#125;  &#125;)&#125;</code></pre><p>回过头来看<code>watcher</code>,实例化<code>watcher</code>时会将<code>Dep.target</code>设置为当前的<code>watcher</code>,执行完状态更新函数之后，再将<code>Dep.target</code>置空。这样在收集依赖时只要将<code>Dep.target</code>当前的<code>watcher push</code>到<code>Dep</code>的<code>subs</code>数组即可。而在派发更新阶段也只需要重新更新状态即可。</p><pre><code class="js">class Watcher &#123;  constructor(expOrFn, isRenderWatcher) &#123;    this.getter = expOrFn;    // Watcher.prototype.get的调用会进行状态的更新。    this.get();  &#125;  get() &#123;    // 当前执行的watcher    Dep.target = this    this.getter()    Dep.target = null;  &#125;  update() &#123;    this.get()  &#125;&#125;</code></pre><h3 id="7-6-6-结果"><a href="#7-6-6-结果" class="headerlink" title="7.6.6 结果"></a>7.6.6 结果</h3><p>一个极简的响应式系统搭建完成。在精简代码的同时，保持了源码设计的思想和逻辑。有了这一步的基础，接下来深入分析源码中每个环节的实现细节会更加简单。</p><h2 id="7-7-小结"><a href="#7-7-小结" class="headerlink" title="7.7 小结"></a>7.7 小结</h2><p>这一节内容，我们正式进入响应式系统的介绍，前面在数据代理章节，我们学过<code>Object.defineProperty</code>,这是一个用来进行数据拦截的方法，而响应式系统构建的基础就是数据的拦截。我们先介绍了<code>Vue</code>内部在初始化数据的过程，最终得出的结论是，不管是<code>data,computed</code>,还是其他的用户定义数据，最终都是调用<code>Object.defineProperty</code>进行数据拦截。而文章的最后，我们在保留源码设计思想和逻辑的前提下，构建出了一个简化版的响应式系统。完整的功能有助于我们下一节对源码具体实现细节的分析和思考。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Vue </category>
          
          <category> vue2.x源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Step.6 组件高级用法</title>
      <link href="/computer-science/vueyuanma/dosc/6%E7%BB%84%E4%BB%B6%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/"/>
      <url>/computer-science/vueyuanma/dosc/6%E7%BB%84%E4%BB%B6%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>我们知道，组件是<code>Vue</code>体系的核心，熟练使用组件是掌握<code>Vue</code>进行开发的基础。上一节中，我们深入了解了<code>Vue</code>组件注册到使用渲染的完整流程。这一节我们会在上一节的基础上介绍组件的两个高级用法：异步组件和函数式组件。</p></blockquote><h2 id="6-1-异步组件"><a href="#6-1-异步组件" class="headerlink" title="6.1 异步组件"></a>6.1 异步组件</h2><h3 id="6-1-1-使用场景"><a href="#6-1-1-使用场景" class="headerlink" title="6.1.1 使用场景"></a>6.1.1 使用场景</h3><p><code>Vue</code>作为单页面应用遇到最棘手的问题是首屏加载时间的问题，单页面应用会把页面脚本打包成一个文件，这个文件包含着所有业务和非业务的代码，而脚本文件过大也是造成首页渲染速度缓慢的原因。因此作为首屏性能优化的课题，最常用的处理方法是对文件的拆分和代码的分离。按需加载的概念也是在这个前提下引入的。我们往往会把一些非首屏的组件设计成异步组件，部分不影响初次视觉体验的组件也可以设计为异步组件。这个思想就是<strong>按需加载</strong>。通俗点理解，按需加载的思想让应用在需要使用某个组件时才去请求加载组件代码。我们借助<code>webpack</code>打包后的结果会更加直观。</p><p><img data-src="/images/img/6.1.png"></p><p><img data-src="/images/img/6.2.png"><br><code>webpack</code>遇到异步组件，会将其从主脚本中分离，减少脚本体积，加快首屏加载时间。当遇到场景需要使用该组件时，才会去加载组件脚本。</p><h3 id="6-1-2-工厂函数"><a href="#6-1-2-工厂函数" class="headerlink" title="6.1.2 工厂函数"></a>6.1.2 工厂函数</h3><p><code>Vue</code>中允许用户通过工厂函数的形式定义组件，这个工厂函数会异步解析组件定义，组件需要渲染的时候才会触发该工厂函数，加载结果会进行缓存，以供下一次调用组件时使用。<br>具体使用：</p><pre><code class="js">// 全局注册：Vue.component(&#39;asyncComponent&#39;, function(resolve, reject) &#123;  require([&#39;./test.vue&#39;], resolve)&#125;)// 局部注册：var vm = new Vue(&#123;  el: &#39;#app&#39;,  template: &#39;&lt;div id=&quot;app&quot;&gt;&lt;asyncComponent&gt;&lt;/asyncComponent&gt;&lt;/div&gt;&#39;,  components: &#123;    asyncComponent: (resolve, reject) =&gt; require([&#39;./test.vue&#39;], resolve),    // 另外写法    asyncComponent: () =&gt; import(&#39;./test.vue&#39;),  &#125;&#125;)</code></pre><h3 id="6-1-3-流程分析"><a href="#6-1-3-流程分析" class="headerlink" title="6.1.3 流程分析"></a>6.1.3 流程分析</h3><p>有了上一节组件注册的基础，我们来分析异步组件的实现逻辑。简单回忆一下上一节的流程，实例的挂载流程分为根据渲染函数创建<code>Vnode</code>和根据<code>Vnode</code>产生真实节点的过程。期间创建<code>Vnode</code>过程，如果遇到子的占位符节点会调用<code>creatComponent</code>,这里会为子组件做选项合并和钩子挂载的操作，并创建一个以<code>vue-component-</code>为标记的子<code>Vnode</code>,而异步组件的处理逻辑也是在这个阶段处理。</p><pre><code class="js">// 创建子组件过程  function createComponent (    Ctor, // 子类构造器    data,    context, // vm实例    children, // 子节点    tag // 子组件占位符  ) &#123;    ···    // 针对局部注册组件创建子类构造器    if (isObject(Ctor)) &#123;      Ctor = baseCtor.extend(Ctor);    &#125;    // 异步组件分支    var asyncFactory;    if (isUndef(Ctor.cid)) &#123;      // 异步工厂函数      asyncFactory = Ctor;      // 创建异步组件函数      Ctor = resolveAsyncComponent(asyncFactory, baseCtor);      if (Ctor === undefined) &#123;        return createAsyncPlaceholder(          asyncFactory,          data,          context,          children,          tag        )      &#125;    &#125;    ···    // 创建子组件vnode    var vnode = new VNode(      (&quot;vue-component-&quot; + (Ctor.cid) + (name ? (&quot;-&quot; + name) : &#39;&#39;)),      data, undefined, undefined, undefined, context,      &#123; Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children &#125;,      asyncFactory    );    return vnode  &#125;</code></pre><p><strong>工厂函数的用法使得<code>Vue.component(name, options)</code>的第二个参数不是一个对象，因此不论是全局注册还是局部注册，都不会执行<code>Vue.extend</code>生成一个子组件的构造器，</strong>所以<code>Ctor.cid</code>不会存在，代码会进入异步组件的分支。</p><p>异步组件分支的核心是<code>resolveAsyncComponent</code>,它的处理逻辑分支众多，我们先关心工厂函数处理部分。</p><pre><code class="js">function resolveAsyncComponent (    factory,    baseCtor  ) &#123;    if (!isDef(factory.owners)) &#123;      // 异步请求成功处理      var resolve = function() &#123;&#125;      // 异步请求失败处理      var reject = function() &#123;&#125;      // 创建子组件时会先执行工厂函数，并将resolve和reject传入      var res = factory(resolve, reject);      // resolved 同步返回      return factory.loading        ? factory.loadingComp        : factory.resolved    &#125;  &#125;</code></pre><p>如果经常使用<code>promise</code>进行开发，我们很容易发现，这部分代码像极了<code>promsie</code>原理内部的实现，针对异步组件工厂函数的写法，大致可以总结出以下三个步骤：</p><ol><li>定义异步请求成功的函数处理，定义异步请求失败的函数处理；</li><li>执行组件定义的工厂函数；</li><li>同步返回请求成功的函数处理。</li></ol><p><code>resolve, reject</code>的实现，都是<code>once</code>方法执行的结果，所以我们先关注一下高级函数<code>once</code>的原理。<strong>为了防止当多个地方调用异步组件时，<code>resolve,reject</code>不会重复执行，<code>once</code>函数保证了函数在代码只执行一次。也就是说，<code>once</code>缓存了已经请求过的异步组件</strong></p><pre><code class="js">// once函数保证了这个调用函数只在系统中调用一次function once (fn) &#123;  // 利用闭包特性将called作为标志位  var called = false;  return function () &#123;    // 调用过则不再调用    if (!called) &#123;      called = true;      fn.apply(this, arguments);    &#125;  &#125;&#125;</code></pre><p>成功<code>resolve</code>和失败<code>reject</code>的详细处理逻辑如下： </p><pre><code class="js">// 成功处理var resolve = once(function (res) &#123;  // 转成组件构造器，并将其缓存到resolved属性中。  factory.resolved = ensureCtor(res, baseCtor);  if (!sync) &#123;    //强制更新渲染视图    forceRender(true);  &#125; else &#123;    owners.length = 0;  &#125;&#125;);// 失败处理var reject = once(function (reason) &#123;  warn(    &quot;Failed to resolve async component: &quot; + (String(factory)) +    (reason ? (&quot;\nReason: &quot; + reason) : &#39;&#39;)  );  if (isDef(factory.errorComp)) &#123;    factory.error = true;    forceRender(true);  &#125;&#125;);</code></pre><p>异步组件加载完毕，会调用<code>resolve</code>定义的方法，方法会通过<code>ensureCtor</code>将加载完成的组件转换为组件构造器，并存储在<code>resolved</code>属性中，其中 <code>ensureCtor</code>的定义为：</p><pre><code class="js">function ensureCtor (comp, base) &#123;    if (comp.__esModule ||(hasSymbol &amp;&amp; comp[Symbol.toStringTag] === &#39;Module&#39;)) &#123;      comp = comp.default;    &#125;    // comp结果为对象时，调用extend方法创建一个子类构造器    return isObject(comp)      ? base.extend(comp)      : comp  &#125;</code></pre><p>组件构造器创建完毕，会进行一次视图的重新渲染，<strong>由于<code>Vue</code>是数据驱动视图渲染的，而组件在加载到完毕的过程中，并没有数据发生变化，因此需要手动强制更新视图。</strong><code>forceRender</code>函数的内部会拿到每个调用异步组件的实例，执行原型上的<code>$forceUpdate</code>方法，这部分的知识等到响应式系统时介绍。</p><p>异步组件加载失败后，会调用<code>reject</code>定义的方法，方法会提示并标记错误，最后同样会强制更新视图。</p><p>回到异步组件创建的流程，执行异步过程会同步为加载中的异步组件创建一个注释节点<code>Vnode</code></p><pre><code class="js">  function createComponent ()&#123;    ···    // 创建异步组件函数    Ctor = resolveAsyncComponent(asyncFactory, baseCtor);    if (Ctor === undefined) &#123;      // 创建注释节点      return createAsyncPlaceholder(asyncFactory,data,context,children,tag)    &#125;  &#125;</code></pre><p><code>createAsyncPlaceholder</code>的定义也很简单,其中<code>createEmptyVNode</code>之前有介绍过，是创建一个注释节点<code>vnode</code>，而<code>asyncFactory,asyncMeta</code>都是用来标注该节点为异步组件的临时节点和相关属性。</p><pre><code class="js">// 创建注释Vnodefunction createAsyncPlaceholder (factory,data,context,children,tag) &#123;  var node = createEmptyVNode();  node.asyncFactory = factory;  node.asyncMeta = &#123; data: data, context: context, children: children, tag: tag &#125;;  return node&#125;</code></pre><p>执行<code>forceRender</code>触发组件的重新渲染过程时，又会再次调用<code>resolveAsyncComponent</code>,这时返回值<code>Ctor</code>不再为 <code>undefined</code>了，因此会正常走组件的<code>render,patch</code>过程。这时，旧的注释节点也会被取代。</p><h3 id="6-1-4-Promise异步组件"><a href="#6-1-4-Promise异步组件" class="headerlink" title="6.1.4 Promise异步组件"></a>6.1.4 Promise异步组件</h3><p>异步组件的第二种写法是在工厂函数中返回一个<code>promise</code>对象，我们知道<code>import</code>是<code>es6</code>引入模块加载的用法，但是<code>import</code>是一个静态加载的方法，它会优先模块内的其他语句执行。因此引入了<code>import()</code>,<code>import()</code>是一个运行时加载模块的方法，可以用来类比<code>require()</code>方法，区别在于前者是一个异步方法，后者是同步的，且<code>import()</code>会返回一个<code>promise</code>对象。</p><p>具体用法：</p><pre><code class="js">Vue.component(&#39;asyncComponent&#39;, () =&gt; import(&#39;./test.vue&#39;))</code></pre><p>源码依然走着异步组件处理分支，并且大部分的处理过程还是工厂函数的逻辑处理，区别在于执行异步函数后会返回一个<code>promise</code>对象，成功加载则执行<code>resolve</code>,失败加载则执行<code>reject</code>.</p><pre><code class="js">var res = factory(resolve, reject);// res是返回的promiseif (isObject(res)) &#123;  if (isPromise(res)) &#123;    if (isUndef(factory.resolved)) &#123;      // 核心处理      res.then(resolve, reject);    &#125;  &#125;&#125;</code></pre><p>其中<code>promise</code>对象的判断最简单的是判断是否有<code>then</code>和<code>catch</code>方法：</p><pre><code class="js"> // 判断promise对象的方法  function isPromise (val) &#123;    return (isDef(val) &amp;&amp; typeof val.then === &#39;function&#39; &amp;&amp; typeof val.catch === &#39;function&#39;)  &#125;</code></pre><h3 id="6-1-5-高级异步组件"><a href="#6-1-5-高级异步组件" class="headerlink" title="6.1.5 高级异步组件"></a>6.1.5 高级异步组件</h3><p>为了在操作上更加灵活，比如使用<code>loading</code>组件处理组件加载时间过长的等待问题，使用<code>error</code>组件处理加载组件失败的错误提示等，<code>Vue</code>在2.3.0+版本新增了返回对象形式的异步组件格式，对象中可以定义需要加载的组件<code>component</code>,加载中显示的组件<code>loading</code>,加载失败的组件<code>error</code>,以及各种延时超时设置，源码同样进入异步组件分支。</p><pre><code class="js">Vue.component(&#39;asyncComponent&#39;, () =&gt; (&#123;  // 需要加载的组件 (应该是一个 `Promise` 对象)  component: import(&#39;./MyComponent.vue&#39;),  // 异步组件加载时使用的组件  loading: LoadingComponent,  // 加载失败时使用的组件  error: ErrorComponent,  // 展示加载时组件的延时时间。默认值是 200 (毫秒)  delay: 200,  // 如果提供了超时时间且组件加载也超时了，  // 则使用加载失败时使用的组件。默认值是：`Infinity`  timeout: 3000&#125;))</code></pre><p>异步组件函数执行后返回一个对象，并且对象的<code>component</code>执行会返回一个<code>promise</code>对象，因此进入高级异步组件处理分支。</p><pre><code class="js">if (isObject(res)) &#123;  if (isPromise(res)) &#123;&#125;  // 返回对象，且res.component返回一个promise对象，进入分支  // 高级异步组件处理分支  else if (isPromise(res.component)) &#123;    // 和promise异步组件处理方式相同    res.component.then(resolve, reject);    ···  &#125;&#125;</code></pre><p>异步组件会等待响应成功失败的结果，与此同时，代码继续同步执行。高级选项设置中如果设置了<code>error</code>和<code>loading</code>组件，会同时创建两个子类的构造器,</p><pre><code class="js">if (isDef(res.error)) &#123;  // 异步错误时组件的处理，创建错误组件的子类构造器，并赋值给errorComp  factory.errorComp = ensureCtor(res.error, baseCtor);&#125;if (isDef(res.loading)) &#123;  // 异步加载时组件的处理，创建错误组件的子类构造器，并赋值给errorComp  factory.loadingComp = ensureCtor(res.loading, baseCtor);&#125;</code></pre><p>如果存在<code>delay</code>属性,则通过<code>settimeout</code>设置<code>loading</code>组件显示的延迟时间。<code>factory.loading</code>属性用来标注是否是显示<code>loading</code>组件。</p><pre><code class="js">if (res.delay === 0) &#123;  factory.loading = true;&#125; else &#123;  // 超过时间会成功加载，则执行失败结果  setTimeout(function () &#123;    if (isUndef(factory.resolved) &amp;&amp; isUndef(factory.error)) &#123;      factory.loading = true;      forceRender(false);    &#125;  &#125;, res.delay || 200);&#125;</code></pre><p>如果在<code>timeout</code>时间内，异步组件还未执行<code>resolve</code>的成功结果，即<code>resolve</code>没有赋值,则进行<code>reject</code>失败处理。</p><p>接下来依然是渲染注释节点或者渲染<code>loading</code>组件，等待异步处理结果，根据处理结果重新渲染视图节点，相似过程不再阐述。</p><h3 id="6-1-6-wepack异步组件用法"><a href="#6-1-6-wepack异步组件用法" class="headerlink" title="6.1.6 wepack异步组件用法"></a>6.1.6 wepack异步组件用法</h3><p><code>webpack</code>作为<code>Vue</code>应用构建工具的标配，我们需要知道<code>Vue</code>如何结合<code>webpack </code>进行异步组件的代码分离，并且需要关注分离后的文件名，这个名字在<code>webpack</code>中称为<code>chunkName</code>。<code>webpack</code>为异步组件的加载提供了两种写法。</p><ul><li><code>require.ensure</code>:它是<code>webpack</code>传统提供给异步组件的写法，在编译时，<code>webpack</code>会静态地解析代码中的 <code>require.ensure()</code>，同时将模块添加到一个分开的 <code>chunk</code> 中，其中函数的第三个参数为分离代码块的名字。修改后的代码写法如下：</li></ul><pre><code class="js">Vue.component(&#39;asyncComponent&#39;, function (resolve, reject) &#123;   require.ensure([], function () &#123;     resolve(require(&#39;./test.vue&#39;));   &#125;, &#39;asyncComponent&#39;); // asyncComponent为chunkname&#125;)</code></pre><ul><li><code>import(/* webpackChunkName: &quot;asyncComponent&quot; */, component)</code>: 有了<code>es6</code>,<code>import</code>的写法是现今官方最推荐的做法，其中通过注释<code>webpackChunkName</code>来指定分离后组件模块的命名。修改后的写法如下：</li></ul><pre><code class="js">Vue.component(&#39;asyncComponent&#39;, () =&gt; import(/* webpackChunkName: &quot;asyncComponent&quot; */, &#39;./test.vue&#39;))</code></pre><p>至此，我们已经掌握了所有异步组件的写法，并深入了解了其内部的实现细节。我相信全面的掌握异步组件对今后单页面性能优化方面会起到积极的指导作用。</p><h2 id="6-2-函数式组件"><a href="#6-2-函数式组件" class="headerlink" title="6.2 函数式组件"></a>6.2 函数式组件</h2><p><code>Vue</code>提供了一种可以让组件变为无状态、无实例的函数化组件。从原理上说，一般子组件都会经过实例化的过程，而单纯的函数组件并没有这个过程，它可以简单理解为一个中间层，只处理数据，不创建实例，也是由于这个行为，它的渲染开销会低很多。实际的应用场景是，当我们需要在多个组件中选择一个来代为渲染，或者在将<code>children,props,data</code>等数据传递给子组件前进行数据处理时，我们都可以用函数式组件来完成，它本质上也是对组件的一个外部包装。</p><h3 id="6-2-1-使用场景"><a href="#6-2-1-使用场景" class="headerlink" title="6.2.1 使用场景"></a>6.2.1 使用场景</h3><ul><li>定义两个组件对象，<code>test1，test2</code></li></ul><pre><code class="js">var test1 = &#123;  props: [&#39;msg&#39;],  render: function (createElement, context) &#123;    return createElement(&#39;h1&#39;, this.msg)  &#125;&#125;var test2 = &#123;  props: [&#39;msg&#39;],  render: function (createElement, context) &#123;    return createElement(&#39;h2&#39;, this.msg)  &#125;&#125;</code></pre><ul><li>定义一个函数式组件，它会根据计算结果选择其中一个组件进行选项</li></ul><pre><code class="js">Vue.component(&#39;test3&#39;, &#123;  // 函数式组件的标志 functional设置为true  functional: true,  props: [&#39;msg&#39;],  render: function (createElement, context) &#123;    var get = function() &#123;      return test1    &#125;    return createElement(get(), context)  &#125;&#125;)</code></pre><ul><li>函数式组件的使用</li></ul><pre><code class="js">&lt;test3 :msg=&quot;msg&quot; id=&quot;test&quot;&gt;&lt;/test3&gt;new Vue(&#123;  el: &#39;#app&#39;,  data: &#123;    msg: &#39;test&#39;  &#125;&#125;)</code></pre><ul><li>最终渲染的结果为：</li></ul><pre><code class="js">&lt;h2&gt;test&lt;/h2&gt;</code></pre><h3 id="6-2-2-源码分析"><a href="#6-2-2-源码分析" class="headerlink" title="6.2.2 源码分析"></a>6.2.2 源码分析</h3><p>函数式组件会在组件的对象定义中，将<code>functional</code>属性设置为<code>true</code>，这个属性是区别普通组件和函数式组件的关键。同样的在遇到子组件占位符时，会进入<code>createComponent</code>进行子组件<code>Vnode</code>的创建。<strong>由于<code>functional</code>属性的存在，代码会进入函数式组件的分支中，并返回<code>createFunctionalComponent</code>调用的结果。</strong>注意，执行完<code>createFunctionalComponent</code>后，后续创建子<code>Vnode</code>的逻辑不会执行，这也是之后在创建真实节点过程中不会有子<code>Vnode</code>去实例化子组件的原因。(无实例)</p><pre><code class="js">function createComponent()&#123;  ···  if (isTrue(Ctor.options.functional)) &#123;    return createFunctionalComponent(Ctor, propsData, data, context, children)  &#125;&#125;</code></pre><p><code>createFunctionalComponent</code>方法会对传入的数据进行检测和合并，实例化<code>FunctionalRenderContext</code>，最终调用函数式组件自定义的<code>render</code>方法执行渲染过程。</p><pre><code class="js">function createFunctionalComponent(  Ctor, // 函数式组件构造器  propsData, // 传入组件的props  data, // 占位符组件传入的attr属性  context, // vue实例  children// 子节点)&#123;  // 数据检测合并  var options = Ctor.options;  var props = &#123;&#125;;  var propOptions = options.props;  if (isDef(propOptions)) &#123;    for (var key in propOptions) &#123;      props[key] = validateProp(key, propOptions, propsData || emptyObject);    &#125;  &#125; else &#123;    // 合并attrs    if (isDef(data.attrs)) &#123; mergeProps(props, data.attrs); &#125;    // 合并props    if (isDef(data.props)) &#123; mergeProps(props, data.props); &#125;  &#125;  var renderContext = new FunctionalRenderContext(data,props,children,contextVm,Ctor);  // 调用函数式组件中自定的render函数  var vnode = options.render.call(null, renderContext._c, renderContext)&#125;</code></pre><p>而<code>FunctionalRenderContext</code>这个类最终的目的是定义一个和真实组件渲染不同的<code>render</code>方法。</p><pre><code class="js">function FunctionalRenderContext() &#123;  // 省略其他逻辑  this._c = function (a, b, c, d) &#123; return createElement(contextVm, a, b, c, d, needNormalization); &#125;;&#125;</code></pre><p>执行<code>render</code>函数的过程，又会递归调用<code>createElement</code>的方法，这时的组件已经是真实的组件，开始执行正常的组件挂载流程。</p><p>问题：为什么函数式组件需要定义一个不同的<code>createElement</code>方法？- 函数式组件<code>createElement</code>和以往唯一的不同是，最后一个参数的不同，之前章节有说到，<code>createElement</code>会根据最后一个参数决定是否对子<code>Vnode</code>进行拍平，一般情况下，<code>children</code>编译生成结果都是<code>Vnode</code>类型，只有函数式组件比较特殊，它可以返回一个数组，这时候拍平就是有必要的。我们看下面的例子：</p><pre><code class="js">Vue.component(&#39;test&#39;, &#123;    functional: true,    render: function (createElement, context) &#123;      return context.slots().default    &#125;  &#125;) &lt;test&gt;      &lt;p&gt;slot1&lt;/p&gt;      &lt;p&gt;slot&lt;/p&gt; &lt;/test&gt;</code></pre><p>此时函数式组件<code>test</code>的<code>render</code>函数返回的是两个<code>slot</code>的<code>Vnode</code>，它是以数组的形式存在的,这就是需要拍平的场景。</p><p>简单总结一下函数式组件，从源码中可以看出，函数式组件并不会像普通组件那样有实例化组件的过程，因此包括组件的生命周期，组件的数据管理这些过程都没有，它只会原封不动的接收传递给组件的数据做处理，并渲染需要的内容。因此作为纯粹的函数可以也大大降低渲染的开销。</p><h2 id="6-3-小结"><a href="#6-3-小结" class="headerlink" title="6.3 小结"></a>6.3 小结</h2><p>这一小节在组件基础之上介绍了两个进阶的用法，异步组件和函数式组件。它们都是为了解决某些类型场景引入的高级组件用法。其中异步组件是首屏性能优化的一个解决方案，并且<code>Vue</code>提供了多达三种的使用方法，高级配置的用法更让异步组件的使用更加灵活。当然大部分情况下，我们会结合<code>webpack</code>进行使用。另外，函数式组件在多组件中选择渲染内容的场景作用非凡，由于是一个无实例的组件，它在渲染开销上比普通组件的性能更好。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Vue </category>
          
          <category> vue2.x源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Step.5 组件基础剖析</title>
      <link href="/computer-science/vueyuanma/dosc/5%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80%E5%89%96%E6%9E%90/"/>
      <url>/computer-science/vueyuanma/dosc/5%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p>组件是<code>Vue</code>的一个重要核心，我们在进行项目工程化时，会将页面的结构组件化。组件化意味着独立和共享,而两个结论并不矛盾，独立的组件开发可以让开发者专注于某个功能项的开发和扩展，而组件的设计理念又使得功能项更加具有复用性，不同的页面可以进行组件功能的共享。对于开发者而言，编写<code>Vue</code>组件是掌握<code>Vue</code>开发的核心基础，<code>Vue</code>官网也花了大量的篇幅介绍了组件的体系和各种使用方法。这一节内容，我们会深入<code>Vue</code>组件内部的源码，了解<strong>组件注册的实现思路，并结合上一节介绍的实例挂载分析组件渲染挂载的基本流程，最后我们将分析组件和组件之间是如何建立联系的</strong>。我相信，掌握这些底层的实现思路对于我们今后在解决<code>vue</code>组件相关问题上会有明显的帮助。</p></blockquote><h2 id="5-1-组件两种注册方式"><a href="#5-1-组件两种注册方式" class="headerlink" title="5.1 组件两种注册方式"></a>5.1 组件两种注册方式</h2><p>熟悉<code>Vue</code>开发流程的都知道，<code>Vue</code>组件在使用之前需要进行注册，而注册的方式有两种，全局注册和局部注册。在进入源码分析之前，我们先回忆一下两者的用法，以便后续掌握两者的差异。</p><h3 id="5-1-1-全局注册"><a href="#5-1-1-全局注册" class="headerlink" title="5.1.1 全局注册"></a>5.1.1 全局注册</h3><pre><code class="js">Vue.component(&#39;my-test&#39;, &#123;    template: &#39;&lt;div&gt;&#123;&#123;test&#125;&#125;&lt;/div&gt;&#39;,    data () &#123;        return &#123;            test: 1212        &#125;    &#125;&#125;)var vm = new Vue(&#123;    el: &#39;#app&#39;,    template: &#39;&lt;div id=&quot;app&quot;&gt;&lt;my-test&gt;&lt;my-test/&gt;&lt;/div&gt;&#39;&#125;)</code></pre><p><strong>其中组件的全局注册需要在全局实例化Vue前调用</strong>,注册之后可以用在任何新创建的<code>Vue</code>实例中调用。</p><h3 id="5-1-2-局部注册"><a href="#5-1-2-局部注册" class="headerlink" title="5.1.2 局部注册"></a>5.1.2 局部注册</h3><pre><code class="js">var myTest = &#123;    template: &#39;&lt;div&gt;&#123;&#123;test&#125;&#125;&lt;/div&gt;&#39;,    data () &#123;        return &#123;            test: 1212        &#125;    &#125;&#125;var vm = new Vue(&#123;    el: &#39;#app&#39;,    component: &#123;        myTest    &#125;&#125;)</code></pre><p>当只需要在某个局部用到某个组件时，可以使用局部注册的方式进行组件注册，此时局部注册的组件只能在注册该组件内部使用。</p><h3 id="5-1-3-注册过程"><a href="#5-1-3-注册过程" class="headerlink" title="5.1.3 注册过程"></a>5.1.3 注册过程</h3><p>在简单回顾组件的两种注册方式后，我们来看注册过程到底发生了什么，我们以全局组件注册为例。它通过<code>Vue.component(name, &#123;...&#125;)</code>进行组件注册，<code>Vue.component</code>是在<code>Vue</code>源码引入阶段定义的静态方法。</p><pre><code class="js">// 初始化全局apiinitAssetRegisters(Vue);var ASSET_TYPES = [    &#39;component&#39;,    &#39;directive&#39;,    &#39;filter&#39;];function initAssetRegisters(Vue)&#123;    // 定义ASSET_TYPES中每个属性的方法，其中包括component    ASSET_TYPES.forEach(function (type) &#123;    // type: component,directive,filter      Vue[type] = function (id,definition) &#123;          if (!definition) &#123;            // 直接返回注册组件的构造函数            return this.options[type + &#39;s&#39;][id]          &#125;          ...          if (type === &#39;component&#39;) &#123;            // 验证component组件名字是否合法            validateComponentName(id);          &#125;          if (type === &#39;component&#39; &amp;&amp; isPlainObject(definition)) &#123;            // 组件名称设置            definition.name = definition.name || id;            // Vue.extend() 创建子组件，返回子类构造器            definition = this.options._base.extend(definition);          &#125;          // 为Vue.options 上的component属性添加将子类构造器          this.options[type + &#39;s&#39;][id] = definition;          return definition        &#125;    &#125;);&#125;</code></pre><p><code>Vue.components</code>有两个参数，一个是需要注册组件的组件名，另一个是组件选项，如果第二个参数没有传递，则会直接返回注册过的组件选项。否则意味着需要对该组件进行注册，注册过程先会对组件名的合法性进行检测，要求组件名不允许出现非法的标签，包括<code>Vue</code>内置的组件名，如<code>slot, component</code>等。</p><pre><code class="js">function validateComponentName(name) &#123;    if (!new RegExp((&quot;^[a-zA-Z][\\-\\.0-9_&quot; + (unicodeRegExp.source) + &quot;]*$&quot;)).test(name)) &#123;      // 正则判断检测是否为非法的标签      warn(        &#39;Invalid component name: &quot;&#39; + name + &#39;&quot;. Component names &#39; +        &#39;should conform to valid custom element name in html5 specification.&#39;      );    &#125;    // 不能使用Vue自身自定义的组件名，如slot, component,不能使用html的保留标签，如 h1, svg等    if (isBuiltInTag(name) || config.isReservedTag(name)) &#123;      warn(        &#39;Do not use built-in or reserved HTML elements as component &#39; +        &#39;id: &#39; + name      );    &#125;  &#125;</code></pre><p>在经过组件名的合法性检测后，会调用<code>extend</code>方法为组件创建一个子类构造器，此时的<code>this.options._base</code>代表的就是<code>Vue</code>构造器。<code>extend</code>方法的定义在介绍选项合并章节有重点介绍过，它会<strong>基于父类去创建一个子类</strong>，此时的父类是<code>Vue</code>，并且创建过程子类会继承父类的方法，并会和父类的选项进行合并，最终返回一个子类构造器。</p><p>代码处还有一个逻辑，<code>Vue.component()</code>默认会把第一个参数作为组件名称，但是如果组件选项有<code>name</code>属性时，<code>name</code>属性值会将组件名覆盖。</p><p><strong>总结起来，全局注册组件就是<code>Vue</code>实例化前创建一个基于<code>Vue</code>的子类构造器，并将组件的信息加载到实例<code>options.components</code>对象中。</strong></p><p><strong>接下来自然而然会想到一个问题，局部注册和全局注册在实现上的区别体现在哪里？</strong>我们不急着分析局部组件的注册流程，先以全局注册的组件为基础，看看作为组件，它的挂载流程有什么不同。</p><h2 id="5-2-组件Vnode创建"><a href="#5-2-组件Vnode创建" class="headerlink" title="5.2 组件Vnode创建"></a>5.2 组件Vnode创建</h2><p>上一节内容我们介绍了<code>Vue</code>如何将一个模板，通过<code>render</code>函数的转换，最终生成一个<code>Vnode tree</code>的，在不包含组件的情况下，<code>_render</code>函数的最后一步是直接调用<code>new Vnode</code>去创建一个完整的<code>Vnode tree</code>。然而有一大部分的分支我们并没有分析，那就是遇到组件占位符的场景。执行阶段如果遇到组件，处理过程要比想像中复杂得多，我们通过一张流程图展开分析。</p><h3 id="5-2-1-Vnode创建流程图"><a href="#5-2-1-Vnode创建流程图" class="headerlink" title="5.2.1 Vnode创建流程图"></a>5.2.1 Vnode创建流程图</h3><p><img data-src="/images/img/5.1.png"></p><h3 id="5-2-2-具体流程分析"><a href="#5-2-2-具体流程分析" class="headerlink" title="5.2.2 具体流程分析"></a>5.2.2 具体流程分析</h3><p>我们结合实际的例子对照着流程图分析一下这个过程：</p><ul><li>场景</li></ul><pre><code class="js">Vue.component(&#39;test&#39;, &#123;  template: &#39;&lt;span&gt;&lt;/span&gt;&#39;&#125;)var vm = new Vue(&#123;  el: &#39;#app&#39;,  template: &#39;&lt;div&gt;&lt;test&gt;&lt;/test&gt;&lt;/div&gt;&#39;&#125;)</code></pre><ul><li>父<code>render</code>函数</li></ul><pre><code class="js">function() &#123;  with(this)&#123;return _c(&#39;div&#39;,[_c(&#39;test&#39;)],1)&#125;&#125;</code></pre><ul><li><code>Vue</code>根实例初始化会执行 <code>vm.$mount(vm.$options.el)</code>实例挂载的过程，按照之前的逻辑，完整流程会经历<code>render</code>函数生成<code>Vnode</code>,以及<code>Vnode</code>生成真实<code>DOM</code>的过程。</li><li><code>render</code>函数生成<code>Vnode</code>过程中，子会优先父执行生成<code>Vnode</code>过程,也就是<code>_c(&#39;test&#39;)</code>函数会先被执行。<code>&#39;test&#39;</code>会先判断是普通的<code>html</code>标签还是组件的占位符。</li><li>如果为一般标签，会执行<code>new Vnode</code>过程，这也是上一章节我们分析的过程；如果是组件的占位符，则会在判断组件已经被注册过的前提下进入<code>createComponent</code>创建子组件<code>Vnode</code>的过程。</li><li><code>createComponent</code>是创建组件<code>Vnode</code>的过程，创建过程会再次合并选项配置，并安装组件相关的内部钩子(后面文章会再次提到内部钩子的作用)，最后通过<code>new Vnode()</code>生成以<code>vue-component</code>开头的<code>Virtual DOM</code></li><li><code>render</code>函数执行过程也是一个循环递归调用创建<code>Vnode</code>的过程，执行3，4步之后，完整的生成了一个包含各个子组件的<code>Vnode tree</code></li></ul><p><code>_createElement</code>函数的实现之前章节分析过一部分，我们重点看看组件相关的操作。</p><pre><code class="js">// 内部执行将render函数转化为Vnode的函数function _createElement(context,tag,data,children,normalizationType) &#123;  ···  if (typeof tag === &#39;string&#39;) &#123;    // 子节点的标签为普通的html标签，直接创建Vnode    if (config.isReservedTag(tag)) &#123;      vnode = new VNode(        config.parsePlatformTagName(tag), data, children,        undefined, undefined, context      );    // 子节点标签为注册过的组件标签名，则子组件Vnode的创建过程    &#125; else if ((!data || !data.pre) &amp;&amp; isDef(Ctor = resolveAsset(context.$options, &#39;components&#39;, tag))) &#123;      // 创建子组件Vnode      vnode = createComponent(Ctor, data, context, children, tag);    &#125;  &#125;&#125;</code></pre><p><code>config.isReservedTag(tag)</code>用来判断标签是否为普通的<code>html</code>标签，如果是普通节点会直接创建<code>Vnode</code>节点，如果不是，则需要判断这个占位符组件是否已经注册到，我们可以通过<code>context.$options.components[组件名]</code>拿到注册后的组件选项。如何判断组件是否已经全局注册，看看<code>resolveAsset</code>的实现。</p><pre><code class="js">// 需要明确组件是否已经被注册  function resolveAsset (options,type,id,warnMissing) &#123;    // 标签为字符串    if (typeof id !== &#39;string&#39;) &#123;      return    &#125;    // 这里是 options.component    var assets = options[type];    // 这里的分支分别支持大小写，驼峰的命名规范    if (hasOwn(assets, id)) &#123; return assets[id] &#125;    var camelizedId = camelize(id);    if (hasOwn(assets, camelizedId)) &#123; return assets[camelizedId] &#125;    var PascalCaseId = capitalize(camelizedId);    if (hasOwn(assets, PascalCaseId)) &#123; return assets[PascalCaseId] &#125;    // fallback to prototype chain    var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];    if (warnMissing &amp;&amp; !res) &#123;      warn(        &#39;Failed to resolve &#39; + type.slice(0, -1) + &#39;: &#39; + id,        options      );    &#125;    // 最终返回子类的构造器    return res  &#125;</code></pre><p>拿到注册过的子类构造器后，调用<code>createComponent</code>方法创建子组件<code>Vnode</code></p><pre><code class="js"> // 创建子组件过程  function createComponent (    Ctor, // 子类构造器    data,    context, // vm实例    children, // 子节点    tag // 子组件占位符  ) &#123;    ···    // Vue.options里的_base属性存储Vue构造器    var baseCtor = context.$options._base;    // 针对局部组件注册场景    if (isObject(Ctor)) &#123;      Ctor = baseCtor.extend(Ctor);    &#125;    data = data || &#123;&#125;;    // 构造器配置合并    resolveConstructorOptions(Ctor);    // 挂载组件钩子    installComponentHooks(data);    // return a placeholder vnode    var name = Ctor.options.name || tag;    // 创建子组件vnode，名称以 vue-component- 开头    var vnode = new VNode((&quot;vue-component-&quot; + (Ctor.cid) + (name ? (&quot;-&quot; + name) : &#39;&#39;)),data, undefined, undefined, undefined, context,&#123; Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children &#125;,asyncFactory);    return vnode  &#125;</code></pre><p>这里将大部分的代码都拿掉了，只留下创建<code>Vnode</code>相关的代码，最终会通过<code>new Vue</code>实例化一个名称以<code>vue-component-</code>开头的<code>Vnode</code>节点。其中两个关键的步骤是配置合并和安装组件钩子函数，选项合并的内容可以查看这个系列的前两节，这里看看<code>installComponentHooks</code>安装组件钩子函数时做了哪些操作。</p><pre><code class="js">  // 组件内部自带钩子 var componentVNodeHooks = &#123;    init: function init (vnode, hydrating) &#123;    &#125;,    prepatch: function prepatch (oldVnode, vnode) &#123;    &#125;,    insert: function insert (vnode) &#123;    &#125;,    destroy: function destroy (vnode) &#123;    &#125;  &#125;;var hooksToMerge = Object.keys(componentVNodeHooks);// 将componentVNodeHooks 钩子函数合并到组件data.hook中 function installComponentHooks (data) &#123;    var hooks = data.hook || (data.hook = &#123;&#125;);    for (var i = 0; i &lt; hooksToMerge.length; i++) &#123;      var key = hooksToMerge[i];      var existing = hooks[key];      var toMerge = componentVNodeHooks[key];      // 如果钩子函数存在，则执行mergeHook$1方法合并      if (existing !== toMerge &amp;&amp; !(existing &amp;&amp; existing._merged)) &#123;        hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;      &#125;    &#125;  &#125;function mergeHook$1 (f1, f2) &#123;  // 返回一个依次执行f1,f2的函数    var merged = function (a, b) &#123;      f1(a, b);      f2(a, b);    &#125;;    merged._merged = true;    return merged  &#125;</code></pre><p>组件默认自带的这几个钩子函数会在后续<code>patch</code>过程的不同阶段执行，这部分内容不在本节的讨论范围。</p><h3 id="5-2-3-局部注册和全局注册的区别"><a href="#5-2-3-局部注册和全局注册的区别" class="headerlink" title="5.2.3 局部注册和全局注册的区别"></a>5.2.3 局部注册和全局注册的区别</h3><p>在说到全局注册和局部注册的用法时留下了一个问题，局部注册和全局注册两者的区别在哪里。其实局部注册的原理同样简单，我们使用局部注册组件时会通过在父组件选项配置中的<code>components</code>添加子组件的对象配置，这和全局注册后在<code>Vue</code>的<code>options.component</code>添加子组件构造器的结果很相似。区别在于：</p><p><strong>1.局部注册添加的对象配置是在某个组件下，而全局注册添加的子组件是在根实例下。</strong></p><p><strong>2.局部注册添加的是一个子组件的配置对象，而全局注册添加的是一个子类构造器。</strong></p><p>因此局部注册中缺少了一步构建子类构造器的过程，这个过程放在哪里进行呢？ 回到<code>createComponent</code>的源码,源码中根据选项是对象还是函数来区分局部和全局注册组件，<strong>如果选项的值是对象，则该组件是局部注册的组件，此时在创建子<code>Vnode</code>时会调用 父类的<code>extend</code>方法去创建一个子类构造器。</strong></p><pre><code class="js">function createComponent (...) &#123;  ...  var baseCtor = context.$options._base;  // 针对局部组件注册场景  if (isObject(Ctor)) &#123;      Ctor = baseCtor.extend(Ctor);  &#125;&#125;</code></pre><h2 id="5-3-组件Vnode渲染真实DOM"><a href="#5-3-组件Vnode渲染真实DOM" class="headerlink" title="5.3 组件Vnode渲染真实DOM"></a>5.3 组件Vnode渲染真实DOM</h2><p>根据前面的分析，不管是全局注册的组件还是局部注册的组件，组件并没有进行实例化，那么组件实例化的过程发生在哪个阶段呢？我们接着看<code>Vnode tree</code>渲染真实<code>DOM</code>的过程。</p><h3 id="5-3-1-真实节点渲染流程图"><a href="#5-3-1-真实节点渲染流程图" class="headerlink" title="5.3.1 真实节点渲染流程图"></a>5.3.1 真实节点渲染流程图</h3><p><img data-src="/images/img/5.2.png"></p><h3 id="5-3-2-具体流程分析"><a href="#5-3-2-具体流程分析" class="headerlink" title="5.3.2 具体流程分析"></a>5.3.2 具体流程分析</h3><ol><li>经过<code>vm._render()</code>生成完整的<code>Virtual Dom</code>树后，紧接着执行<code>Vnode</code>渲染真实<code>DOM</code>的过程,这个过程是<code>vm.update()</code>方法的执行，而其核心是<code>vm.__patch__</code>。</li><li><code>vm.__patch__</code>内部会通过 <code>createElm</code>去创建真实的<code>DOM</code>元素，期间遇到子<code>Vnode</code>会递归调用<code>createElm</code>方法。</li><li>递归调用过程中，判断该节点类型是否为组件类型是通过<code>createComponent</code>方法判断的，该方法和渲染<code>Vnode</code>阶段的方法<code>createComponent</code>不同，他会调用子组件的<code>init</code>初始化钩子函数，并完成组件的<code>DOM</code>插入。</li><li><code>init</code>初始化钩子函数的核心是<code>new</code>实例化这个子组件并将子组件进行挂载，实例化子组件的过程又回到合并配置，初始化生命周期，初始化事件中心，初始化渲染的过程。实例挂载又会执行<code>$mount</code>过程。</li><li>完成所有子组件的实例化和节点挂载后，最后才回到根节点的挂载。</li></ol><p><code>__patch__</code>核心代码是通过<code>createElm</code>创建真实节点，当创建过程中遇到子<code>vnode</code>时，会调用<code>createChildren</code>,<code>createChildren</code>的目的是对子<code>vnode</code>递归调用<code>createElm</code>创建子组件节点。</p><pre><code class="js">// 创建真实domfunction createElm (vnode,insertedVnodeQueue,parentElm,refElm,nested,ownerArray,index) &#123;  ···  // 递归创建子组件真实节点,直到完成所有子组件的渲染才进行根节点的真实节点插入  if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) &#123;    return  &#125;  ···  var children = vnode.children;  //   createChildren(vnode, children, insertedVnodeQueue);  ···  insert(parentElm, vnode.elm, refElm);&#125;function createChildren(vnode, children, insertedVnodeQueue) &#123;  for (var i = 0; i &lt; children.length; ++i) &#123;    // 遍历子节点，递归调用创建真实dom节点的方法 - createElm    createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);  &#125;&#125;</code></pre><p><code>createComponent</code>方法会对子组件<code>Vnode</code>进行处理中，还记得在<code>Vnode</code>生成阶段为子<code>Vnode</code>安装了一系列的钩子函数吗，在这个步骤我们可以通过是否拥有这些定义好的钩子来判断是否是已经注册过的子组件，如果条件满足，则执行组件的<code>init</code>钩子。</p><p><code>init</code>钩子做的事情只有两个，<strong>实例化组件构造器，执行子组件的挂载流程。</strong>(<code>keep-alive</code>分支看具体的文章分析)</p><pre><code class="js">function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) &#123;  var i = vnode.data;  // 是否有钩子函数可以作为判断是否为组件的唯一条件  if (isDef(i = i.hook) &amp;&amp; isDef(i = i.init)) &#123;    // 执行init钩子函数    i(vnode, false /* hydrating */);  &#125;  ···&#125;var componentVNodeHooks = &#123;  // 忽略keepAlive过程  // 实例化  var child = vnode.componentInstance = createComponentInstanceForVnode(vnode,activeInstance);  // 挂载  child.$mount(hydrating ? vnode.elm : undefined, hydrating);&#125;function createComponentInstanceForVnode(vnode, parent) &#123;  ···  // 实例化Vue子组件实例  return new vnode.componentOptions.Ctor(options)&#125;</code></pre><p>显然<code>Vnode</code>生成真实<code>DOM</code>的过程也是一个不断递归创建子节点的过程，<code>patch</code>过程如果遇到子<code>Vnode</code>,会优先实例化子组件，并且执行子组件的挂载流程，而挂载流程又会回到<code>_render,_update</code>的过程。在所有的子<code>Vnode</code>递归挂载后，最终才会真正挂载根节点。</p><h2 id="5-4-建立组件联系"><a href="#5-4-建立组件联系" class="headerlink" title="5.4 建立组件联系"></a>5.4 建立组件联系</h2><p>日常开发中，我们可以通过<code>vm.$parent</code>拿到父实例，也可以在父实例中通过<code>vm.$children</code>拿到实例中的子组件。显然，<code>Vue</code>在组件和组件之间建立了一层关联。接下来的内容，我们将探索如何建立组件之间的联系。</p><p>不管是父实例还是子实例，在初始化实例阶段有一个<code>initLifecycle</code>的过程。这个过程会<strong>把当前实例添加到父实例的<code>$children</code>属性中，并设置自身的<code>$parent</code>属性指向父实例。</strong>举一个具体的应用场景：</p><pre><code class="js">&lt;div id=&quot;app&quot;&gt;    &lt;component-a&gt;&lt;/component-a&gt;&lt;/div&gt;Vue.component(&#39;component-a&#39;, &#123;    template: &#39;&lt;div&gt;a&lt;/div&gt;&#39;&#125;)var vm = new Vue(&#123; el: &#39;#app&#39;&#125;)console.log(vm) // 将实例对象输出</code></pre><p>由于<code>vue</code>实例向上没有父实例，所以<code>vm.$parent</code>为<code>undefined</code>，<code>vm</code>的<code>$children</code>属性指向子组件<code>componentA</code> 的实例。</p><p><img data-src="/images/img/5.3.png"></p><p>子组件<code>componentA</code>的 <code>$parent</code>属性指向它的父级<code>vm</code>实例，它的<code>$children</code>属性指向为空</p><p><img data-src="/images/img/5.4.png"></p><p>源码解析如下: </p><pre><code class="js">function initLifecycle (vm) &#123;    var options = vm.$options;    // 子组件注册时，会把父组件的实例挂载到自身选项的parent上    var parent = options.parent;    // 如果是子组件，并且该组件不是抽象组件时，将该组件的实例添加到父组件的$parent属性上，如果父组件是抽象组件，则一直往上层寻找，直到该父级组件不是抽象组件，并将，将该组件的实例添加到父组件的$parent属性    if (parent &amp;&amp; !options.abstract) &#123;        while (parent.$options.abstract &amp;&amp; parent.$parent) &#123;        parent = parent.$parent;        &#125;        parent.$children.push(vm);    &#125;    // 将自身的$parent属性指向父实例。    vm.$parent = parent;    vm.$root = parent ? parent.$root : vm;    vm.$children = [];    vm.$refs = &#123;&#125;;    vm._watcher = null;    vm._inactive = null;    vm._directInactive = false;    // 该实例是否挂载    vm._isMounted = false;    // 该实例是否被销毁    vm._isDestroyed = false;    // 该实例是否正在被销毁    vm._isBeingDestroyed = false;&#125;</code></pre><p>最后简单讲讲抽象组件，在<code>vue</code>中有很多内置的抽象组件，例如<code>&lt;keep-alive&gt;&lt;/keep-alive&gt;,&lt;slot&gt;&lt;slot&gt;</code>等，这些抽象组件并不会出现在子父级的路径上，并且它们也不会参与<code>DOM</code>的渲染。</p><h2 id="5-5-小结"><a href="#5-5-小结" class="headerlink" title="5.5 小结"></a>5.5 小结</h2><p>这一小节，结合了实际的例子分析了组件注册流程到组件挂载渲染流程，<code>Vue</code>中我们可以定义全局的组件，也可以定义局部的组件，全局组件需要进行全局注册，核心方法是<code>Vue.component</code>,他需要在根组件实例化前进行声明注册，原因是我们需要在实例化前拿到组件的配置信息并合并到<code>options.components</code>选项中。注册的本质是调用<code>extend</code>创建一个子类构造器，全局和局部的不同是局部创建子类构造器是发生在创建子组件<code>Vnode</code>阶段。而创建子<code>Vnode</code>阶段最关键的一步是定义了很多内部使用的钩子。有了一个完整的<code>Vnode tree</code>接下来会进入真正<code>DOM</code>的生成，在这个阶段如果遇到子组件<code>Vnode</code>会进行子构造器的实例化，并完成子组件的挂载。递归完成子组件的挂载后，最终才又回到根组件的挂载。<br>  有了组件的基本知识，下一节我们重点分析一下组件的进阶用法。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Vue </category>
          
          <category> vue2.x源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Step.4 完整渲染流程</title>
      <link href="/computer-science/vueyuanma/dosc/4%E5%AE%8C%E6%95%B4%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/"/>
      <url>/computer-science/vueyuanma/dosc/4%E5%AE%8C%E6%95%B4%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>继上一节内容，我们将<code>Vue</code>复杂的挂载流程通过图解流程，代码分析的方式简单梳理了一遍，最后也讲到了模板编译的大致流程。然而在挂载的核心处，我们并没有分析模板编译后渲染函数是如何转换为可视化<code>DOM</code>节点的。因此这一章节，我们将重新回到<code>Vue</code>实例挂载的最后一个环节：渲染<code>DOM</code>节点。在渲染真实<code>DOM</code>的过程中，<code>Vue</code>引进了虚拟<code>DOM</code>的概念，这是<code>Vue</code>架构设计中另一个重要的理念。虚拟<code>DOM</code>作为<code>JS</code>对象和真实<code>DOM</code>中间的一个缓冲层，对<code>JS</code>频繁操作<code>DOM</code>的引起的性能问题有很好的缓解作用。</p></blockquote><h2 id="4-1-Virtual-DOM"><a href="#4-1-Virtual-DOM" class="headerlink" title="4.1 Virtual DOM"></a>4.1 Virtual DOM</h2><h3 id="4-1-1-浏览器的渲染流程"><a href="#4-1-1-浏览器的渲染流程" class="headerlink" title="4.1.1 浏览器的渲染流程"></a>4.1.1 浏览器的渲染流程</h3><p>当浏览器接收到一个<code>Html</code>文件时，<code>JS</code>引擎和浏览器的渲染引擎便开始工作了。从渲染引擎的角度，它首先会将<code>html</code>文件解析成一个<code>DOM</code>树，与此同时，浏览器将识别并加载<code>CSS</code>样式，并和<code>DOM</code>树一起合并为一个渲染树。有了渲染树后，渲染引擎将计算所有元素的位置信息，最后通过绘制，在屏幕上打印最终的内容。<code>JS</code>引擎和渲染引擎虽然是两个独立的线程，但是JS引擎却可以触发渲染引擎工作，当我们通过脚本去修改元素位置或外观时，<code>JS</code>引擎会利用<code>DOM</code>相关的<code>API</code>方法去操作<code>DOM</code>对象,此时渲染引擎变开始工作，渲染引擎会触发回流或者重绘。下面是回流重绘的两个概念：</p><ul><li>回流： 当我们对<code>DOM</code>的修改引发了元素尺寸的变化时，浏览器需要重新计算元素的大小和位置，最后将重新计算的结果绘制出来，这个过程称为回流。</li><li>重绘： 当我们对<code>DOM</code>的修改只单纯改变元素的颜色时，浏览器此时并不需要重新计算元素的大小和位置，而只要重新绘制新样式。这个过程称为重绘。</li></ul><p><strong>很显然回流比重绘更加耗费性能</strong>。</p><p>通过了解浏览器基本的渲染机制，我们很容易联想到当不断的通过<code>JS</code>修改<code>DOM</code>时，不经意间会触发到渲染引擎的回流或者重绘，这个性能开销是非常巨大的。因此为了降低开销，我们需要做的是尽可能减少<code>DOM</code>操作。有什么方法可以做到呢？</p><h3 id="4-1-2-缓冲层-虚拟DOM"><a href="#4-1-2-缓冲层-虚拟DOM" class="headerlink" title="4.1.2 缓冲层-虚拟DOM"></a>4.1.2 缓冲层-虚拟DOM</h3><p>虚拟<code>DOM</code>是为了解决频繁操作<code>DOM</code>引发性能问题的产物。虚拟<code>DOM</code>(下面称为<code>Virtual DOM</code>)是将页面的状态抽象为<code>JS</code>对象的形式，本质上是<code>JS</code>和真实<code>DOM</code>的中间层，当我们想用<code>JS</code>脚本大批量进行<code>DOM</code>操作时，会优先作用于<code>Virtual DOM</code>这个<code>JS</code>对象，最后通过对比将要改动的部分通知并更新到真实的<code>DOM</code>。尽管最终还是操作真实的<code>DOM</code>，但<code>Virtual DOM</code>可以将多个改动合并成一个批量的操作，从而减少 <code>DOM</code> 重排的次数，进而缩短了生成渲染树和绘制所花的时间。</p><p>我们看一个真实的<code>DOM</code>包含了什么：</p><p><img data-src="/images/img/4.1.png"><br>浏览器将一个真实<code>DOM</code>设计得很复杂，不仅包含了自身的属性描述，大小位置等定义，也囊括了<code>DOM</code>拥有的浏览器事件等。正因为如此复杂的结构，我们频繁去操作<code>DOM</code>或多或少会带来浏览器的性能问题。而作为数据和真实<code>DOM</code>之间的一层缓冲，<code>Virtual DOM</code> 只是用来映射到真实<code>DOM</code>的渲染，因此不需要包含操作 <code>DOM</code> 的方法，它只要在对象中重点关注几个属性即可。</p><pre><code class="js">// 真实DOM&lt;div id=&quot;real&quot;&gt;&lt;span&gt;dom&lt;/span&gt;&lt;/div&gt;// 真实DOM对应的JS对象&#123;    tag: &#39;div&#39;,    data: &#123;        id: &#39;real&#39;    &#125;,    children: [&#123;        tag: &#39;span&#39;,        children: &#39;dom&#39;    &#125;]&#125;</code></pre><h2 id="4-2-Vnode"><a href="#4-2-Vnode" class="headerlink" title="4.2 Vnode"></a>4.2 Vnode</h2><p><code>Vue</code>在渲染机制的优化上，同样引进了<code>virtual dom</code>的概念，它是用<code>Vnode</code>这个构造函数去描述一个<code>DOM</code>节点。</p><h3 id="4-2-1-Vnode构造函数"><a href="#4-2-1-Vnode构造函数" class="headerlink" title="4.2.1 Vnode构造函数"></a>4.2.1 Vnode构造函数</h3><pre><code class="js">var VNode = function VNode (tag,data,children,text,elm,context,componentOptions,asyncFactory) &#123;    this.tag = tag; // 标签    this.data = data;  // 数据    this.children = children; // 子节点    this.text = text;    ···    ···  &#125;;</code></pre><p><code>Vnode</code>定义的属性差不多有20几个，显然用<code>Vnode</code>对象要比真实<code>DOM</code>对象描述的内容要简单得多，它只用来单纯描述节点的关键属性，例如标签名，数据，子节点等。并没有保留跟浏览器相关的<code>DOM</code>方法。除此之外，<code>Vnode</code>也会有其他的属性用来扩展<code>Vue</code>的灵活性。</p><p>源码中也定义了创建<code>Vnode</code>的相关方法。</p><h3 id="4-2-2-创建Vnode注释节点"><a href="#4-2-2-创建Vnode注释节点" class="headerlink" title="4.2.2 创建Vnode注释节点"></a>4.2.2 创建Vnode注释节点</h3><pre><code class="js">// 创建注释vnode节点var createEmptyVNode = function (text) &#123;    if ( text === void 0 ) text = &#39;&#39;;    var node = new VNode();    node.text = text;    node.isComment = true; // 标记注释节点    return node&#125;;</code></pre><h3 id="4-2-3-创建Vnode文本节点"><a href="#4-2-3-创建Vnode文本节点" class="headerlink" title="4.2.3 创建Vnode文本节点"></a>4.2.3 创建Vnode文本节点</h3><pre><code class="js">// 创建文本vnode节点function createTextVNode (val) &#123;    return new VNode(undefined, undefined, undefined, String(val))&#125;</code></pre><h3 id="4-2-4-克隆vnode"><a href="#4-2-4-克隆vnode" class="headerlink" title="4.2.4 克隆vnode"></a>4.2.4 克隆vnode</h3><pre><code class="js">function cloneVNode (vnode) &#123;    var cloned = new VNode(      vnode.tag,      vnode.data,      vnode.children &amp;&amp; vnode.children.slice(),      vnode.text,      vnode.elm,      vnode.context,      vnode.componentOptions,      vnode.asyncFactory    );    cloned.ns = vnode.ns;    cloned.isStatic = vnode.isStatic;    cloned.key = vnode.key;    cloned.isComment = vnode.isComment;    cloned.fnContext = vnode.fnContext;    cloned.fnOptions = vnode.fnOptions;    cloned.fnScopeId = vnode.fnScopeId;    cloned.asyncMeta = vnode.asyncMeta;    cloned.isCloned = true;    return cloned  &#125;</code></pre><p><strong>注意：<code>cloneVnode</code>对<code>Vnode</code>的克隆只是一层浅拷贝，它不会对子节点进行深度克隆。</strong></p><h2 id="4-3-Virtual-DOM的创建"><a href="#4-3-Virtual-DOM的创建" class="headerlink" title="4.3 Virtual DOM的创建"></a>4.3 Virtual DOM的创建</h2><p>先简单回顾一下挂载的流程，挂载的过程是调用<code>Vue</code>实例上<code>$mount</code>方法，而<code>$mount</code>的核心是<code>mountComponent</code>函数。如果我们传递的是<code>template</code>模板，模板会先经过编译器的解析，并最终根据不同平台生成对应代码，此时对应的就是将<code>with</code>语句封装好的<code>render</code>函数;如果传递的是<code>render</code>函数，则跳过模板编译过程，直接进入下一个阶段。下一阶段是拿到<code>render</code>函数，调用<code>vm._render()</code>方法将<code>render</code>函数转化为<code>Virtual DOM</code>，并最终通过<code>vm._update()</code>方法将<code>Virtual DOM</code>渲染为真实的<code>DOM</code>节点。</p><pre><code class="js">Vue.prototype.$mount = function(el, hydrating) &#123;    ···    return mountComponent(this, el)&#125;function mountComponent() &#123;    ···    updateComponent = function () &#123;        vm._update(vm._render(), hydrating);    &#125;;&#125;</code></pre><p>我们先看看<code>vm._render()</code>方法是如何<strong>将render函数转化为Virtual DOM</strong>的。</p><p>回顾一下第一章节内容，文章介绍了<code>Vue</code>在代码引入时会定义很多属性和方法，其中有一个<code>renderMixin</code>过程，我们之前只提到了它会定义跟渲染有关的函数，实际上它只定义了两个重要的方法，<code>_render</code>函数就是其中一个。</p><pre><code class="js">// 引入Vue时，执行renderMixin方法，该方法定义了Vue原型上的几个方法，其中一个便是 _render函数renderMixin();//function renderMixin() &#123;    Vue.prototype._render = function() &#123;        var ref = vm.$options;        var render = ref.render;        ···        try &#123;            vnode = render.call(vm._renderProxy, vm.$createElement);        &#125; catch (e) &#123;            ···        &#125;        ···        return vnode    &#125;&#125;</code></pre><p>抛开其他代码，_render函数的核心是<code>render.call(vm._renderProxy, vm.$createElement)</code>部分，<code>vm._renderProxy</code>在数据代理分析过，本质上是为了做数据过滤检测，它也绑定了<code>render</code>函数执行时的<code>this</code>指向。<code>vm.$createElement</code>方法会作为<code>render</code>函数的参数传入。<strong>回忆一下，在手写<code>render</code>函数时，我们会利用<code>render</code>函数的第一个参数<code>createElement</code>进行渲染函数的编写，这里的<code>createElement</code>参数就是定义好的<code>$createElement</code>方法。</strong></p><pre><code class="js">new Vue(&#123;    el: &#39;#app&#39;,    render: function(createElement) &#123;        return createElement(&#39;div&#39;, &#123;&#125;, this.message)    &#125;,    data() &#123;        return &#123;            message: &#39;dom&#39;        &#125;    &#125;&#125;)</code></pre><p>初始化<code>_init</code>时，有一个<code>initRender</code>函数，它就是用来定义渲染函数方法的，其中就有<code>vm.$createElement</code>方法的定义，除了<code>$createElement</code>，<code>_c</code>方法的定义也类似。其中 <code>vm._c</code> 是<code>template</code>内部编译成<code>render</code>函数时调用的方法，<code>vm.$createElement</code>是手写<code>render</code>函数时调用的方法。<strong>两者的唯一区别仅仅是最后一个参数的不同。通过模板生成的<code>render</code>方法可以保证子节点都是<code>Vnode</code>，而手写的<code>render</code>需要一些检验和转换。</strong></p><pre><code class="js">function initRender(vm) &#123;    vm._c = function(a, b, c, d) &#123; return createElement(vm, a, b, c, d, false); &#125;    vm.$createElement = function (a, b, c, d) &#123; return createElement(vm, a, b, c, d, true); &#125;;&#125;</code></pre><p><code>createElement</code> 方法实际上是对 <code>_createElement</code> 方法的封装，在调用<code>_createElement</code>前，它会先对传入的参数进行处理，毕竟手写的<code>render</code>函数参数规格不统一。举一个简单的例子。</p><pre><code class="js">// 没有datanew Vue(&#123;    el: &#39;#app&#39;,    render: function(createElement) &#123;        return createElement(&#39;div&#39;, this.message)    &#125;,    data() &#123;        return &#123;            message: &#39;dom&#39;        &#125;    &#125;&#125;)// 有datanew Vue(&#123;    el: &#39;#app&#39;,    render: function(createElement) &#123;        return createElement(&#39;div&#39;, &#123;&#125;, this.message)    &#125;,    data() &#123;        return &#123;            message: &#39;dom&#39;        &#125;    &#125;&#125;)</code></pre><p>这里如果第二个参数是变量或者数组，则默认是没有传递<code>data</code>,因为<code>data</code>一般是对象形式存在。</p><pre><code class="js">function createElement (    context, // vm 实例    tag, // 标签    data, // 节点相关数据，属性    children, // 子节点    normalizationType,    alwaysNormalize // 区分内部编译生成的render还是手写render  ) &#123;    // 对传入参数做处理，如果没有data，则将第三个参数作为第四个参数使用，往上类推。    if (Array.isArray(data) || isPrimitive(data)) &#123;      normalizationType = children;      children = data;      data = undefined;    &#125;    // 根据是alwaysNormalize 区分是内部编译使用的，还是用户手写render使用的    if (isTrue(alwaysNormalize)) &#123;      normalizationType = ALWAYS_NORMALIZE;    &#125;    return _createElement(context, tag, data, children, normalizationType) // 真正生成Vnode的方法  &#125;</code></pre><h3 id="4-3-1-数据规范检测"><a href="#4-3-1-数据规范检测" class="headerlink" title="4.3.1 数据规范检测"></a>4.3.1 数据规范检测</h3><p><code>Vue</code>既然暴露给用户用<code>render</code>函数去手写渲染模板，就需要考虑用户操作带来的不确定性，因此<code>_createElement</code>在创建<code>Vnode</code>前会先数据的规范性进行检测，将不合法的数据类型错误提前暴露给用户。接下来将列举几个在实际场景中容易犯的错误，也方便我们理解源码中对这类错误的处理。</p><ol><li>用响应式对象做<code>data</code>属性</li></ol><pre><code class="js">new Vue(&#123;    el: &#39;#app&#39;,    render: function (createElement, context) &#123;       return createElement(&#39;div&#39;, this.observeData, this.show)    &#125;,    data() &#123;        return &#123;            show: &#39;dom&#39;,            observeData: &#123;                attr: &#123;                    id: &#39;test&#39;                &#125;            &#125;        &#125;    &#125;&#125;)</code></pre><ol start="2"><li>当特殊属性key的值为非字符串，非数字类型时</li></ol><pre><code class="js">new Vue(&#123;    el: &#39;#app&#39;,    render: function(createElement) &#123;        return createElement(&#39;div&#39;, &#123; key: this.lists &#125;, this.lists.map(l =&gt; &#123;           return createElement(&#39;span&#39;, l.name)        &#125;))    &#125;,    data() &#123;        return &#123;            lists: [&#123;              name: &#39;111&#39;            &#125;,            &#123;              name: &#39;222&#39;            &#125;          ],        &#125;    &#125;&#125;)</code></pre><p>这些规范都会在创建<code>Vnode</code>节点之前发现并报错，源代码如下：</p><pre><code class="js">function _createElement (context,tag,data,children,normalizationType) &#123;    // 1. 数据对象不能是定义在Vue data属性中的响应式数据。    if (isDef(data) &amp;&amp; isDef((data).__ob__)) &#123;      warn(        &quot;Avoid using observed data object as vnode data: &quot; + (JSON.stringify(data)) + &quot;\n&quot; +        &#39;Always create fresh vnode data objects in each render!&#39;,        context      );      return createEmptyVNode() // 返回注释节点    &#125;    if (isDef(data) &amp;&amp; isDef(data.is)) &#123;      tag = data.is;    &#125;    if (!tag) &#123;      // 防止动态组件 :is 属性设置为false时，需要做特殊处理      return createEmptyVNode()    &#125;    // 2. key值只能为string，number这些原始数据类型    if (isDef(data) &amp;&amp; isDef(data.key) &amp;&amp; !isPrimitive(data.key)    ) &#123;      &#123;        warn(          &#39;Avoid using non-primitive value as key, &#39; +          &#39;use string/number value instead.&#39;,          context        );      &#125;    &#125;    ···  &#125;</code></pre><p>这些规范性检测保证了后续<code>Virtual DOM tree</code>的完整生成。</p><h3 id="4-3-2-子节点children规范化"><a href="#4-3-2-子节点children规范化" class="headerlink" title="4.3.2 子节点children规范化"></a>4.3.2 子节点children规范化</h3><p><code>Virtual DOM tree</code>是由每个<code>Vnode</code>以树状形式拼成的虚拟<code>DOM</code>树，我们在转换真实节点时需要的就是这样一个完整的<code>Virtual DOM tree</code>，因此我们需要保证每一个子节点都是<code>Vnode</code>类型,这里分两种场景分析。</p><ul><li>模板编译<code>render</code>函数，理论上<code>template</code>模板通过编译生成的<code>render</code>函数都是<code>Vnode</code>类型，但是有一个例外，函数式组件返回的是一个数组(这个特殊例子，可以看函数式组件的文章分析),这个时候<code>Vue</code>的处理是将整个<code>children</code>拍平成一维数组。</li><li>用户定义<code>render</code>函数，这个时候又分为两种情况，一个是当<code>chidren</code>为文本节点时，这时候通过前面介绍的<code>createTextVNode</code> 创建一个文本节点的 <code>VNode</code>; 另一种相对复杂，当<code>children</code>中有<code>v-for</code>的时候会出现嵌套数组，这时候的处理逻辑是，遍历<code>children</code>，对每个节点进行判断，如果依旧是数组，则继续递归调用，直到类型为基础类型时，调用<code>createTextVnode</code>方法转化为<code>Vnode</code>。这样经过递归，<code>children</code>也变成了一个类型为<code>Vnode</code>的数组。</li></ul><pre><code class="js">function _createElement() &#123;    ···    if (normalizationType === ALWAYS_NORMALIZE) &#123;      // 用户定义render函数      children = normalizeChildren(children);    &#125; else if (normalizationType === SIMPLE_NORMALIZE) &#123;      // 模板编译生成的的render函数      children = simpleNormalizeChildren(children);    &#125;&#125;// 处理编译生成的render 函数function simpleNormalizeChildren (children) &#123;    for (var i = 0; i &lt; children.length; i++) &#123;        // 子节点为数组时，进行开平操作，压成一维数组。        if (Array.isArray(children[i])) &#123;        return Array.prototype.concat.apply([], children)        &#125;    &#125;    return children&#125;// 处理用户定义的render函数function normalizeChildren (children) &#123;    // 递归调用，直到子节点是基础类型，则调用创建文本节点Vnode    return isPrimitive(children)      ? [createTextVNode(children)]      : Array.isArray(children)        ? normalizeArrayChildren(children)        : undefined  &#125;// 判断是否基础类型function isPrimitive (value) &#123;    return (      typeof value === &#39;string&#39; ||      typeof value === &#39;number&#39; ||      typeof value === &#39;symbol&#39; ||      typeof value === &#39;boolean&#39;    )  &#125;</code></pre><h3 id="4-3-4-实际场景"><a href="#4-3-4-实际场景" class="headerlink" title="4.3.4 实际场景"></a>4.3.4 实际场景</h3><p>在数据检测和组件规范化后，接下来通过<code>new VNode()</code>便可以生成一棵完整的<code>VNode</code>树，注意在<code>_render</code>过程中会遇到子组件，这个时候会优先去做子组件的初始化，这部分放到组件环节专门分析。我们用一个实际的例子，结束<code>render</code>函数到<code>Virtual DOM</code>的分析。</p><ul><li><code>template</code>模板形式</li></ul><pre><code class="js">var vm = new Vue(&#123;  el: &#39;#app&#39;,  template: &#39;&lt;div&gt;&lt;span&gt;virtual dom&lt;/span&gt;&lt;/div&gt;&#39;&#125;)</code></pre><ul><li>模板编译生成<code>render</code>函数</li></ul><pre><code class="js">(function() &#123;  with(this)&#123;    return _c(&#39;div&#39;,[_c(&#39;span&#39;,[_v(&quot;virual dom&quot;)])])  &#125;&#125;)</code></pre><ul><li><code>Virtual DOM tree</code>的结果(省略版)</li></ul><pre><code class="js">&#123;  tag: &#39;div&#39;,  children: [&#123;    tag: &#39;span&#39;,    children: [&#123;      tag: undefined,      text: &#39;virtual dom&#39;    &#125;]  &#125;]&#125;</code></pre><h2 id="4-4-虚拟Vnode映射成真实DOM"><a href="#4-4-虚拟Vnode映射成真实DOM" class="headerlink" title="4.4 虚拟Vnode映射成真实DOM"></a>4.4 虚拟Vnode映射成真实DOM</h2><p>回到 <code>updateComponent</code>的最后一个过程,虚拟的<code>DOM</code>树在生成<code>virtual dom</code>后，会调用<code>Vue</code>原型上<code>_update</code>方法，将虚拟<code>DOM</code>映射成为真实的<code>DOM</code>。从源码上可以知道，<code>_update</code>的调用时机有两个，一个是发生在初次渲染阶段，另一个发生数据更新阶段。</p><pre><code class="js">updateComponent = function () &#123;    // render生成虚拟DOM，update渲染真实DOM    vm._update(vm._render(), hydrating);&#125;;</code></pre><p><code>vm._update</code>方法的定义在<code>lifecycleMixin</code>中。</p><pre><code class="js">lifecycleMixin()function lifecycleMixin() &#123;    Vue.prototype._update = function (vnode, hydrating) &#123;        var vm = this;        var prevEl = vm.$el;        var prevVnode = vm._vnode; // prevVnode为旧vnode节点        // 通过是否有旧节点判断是初次渲染还是数据更新        if (!prevVnode) &#123;            // 初次渲染            vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false)        &#125; else &#123;            // 数据更新            vm.$el = vm.__patch__(prevVnode, vnode);        &#125;&#125;</code></pre><p><code>_update</code>的核心是<code>__patch__</code>方法，如果是服务端渲染，由于没有<code>DOM</code>，<code>_patch</code>方法是一个空函数，在有<code>DOM</code>对象的浏览器环境下，<code>__patch__</code>是<code>patch</code>函数的引用。</p><pre><code>// 浏览器端才有DOM，服务端没有dom，所以patch为一个空函数  Vue.prototype.__patch__ = inBrowser ? patch : noop;</code></pre><p>而<code>patch</code>方法又是<code>createPatchFunction</code>方法的返回值，<code>createPatchFunction</code>方法传递一个对象作为参数，对象拥有两个属性，<code>nodeOps</code>和<code>modules</code>，<code>nodeOps</code>封装了一系列操作原生<code>DOM</code>对象的方法。而<code>modules</code>定义了模块的钩子函数。</p><pre><code class="js"> var patch = createPatchFunction(&#123; nodeOps: nodeOps, modules: modules &#125;);// 将操作dom对象的方法合集做冻结操作 var nodeOps = /*#__PURE__*/Object.freeze(&#123;    createElement: createElement$1,    createElementNS: createElementNS,    createTextNode: createTextNode,    createComment: createComment,    insertBefore: insertBefore,    removeChild: removeChild,    appendChild: appendChild,    parentNode: parentNode,    nextSibling: nextSibling,    tagName: tagName,    setTextContent: setTextContent,    setStyleScope: setStyleScope  &#125;);// 定义了模块的钩子函数  var platformModules = [    attrs,    klass,    events,    domProps,    style,    transition  ];var modules = platformModules.concat(baseModules);</code></pre><p>真正的<code>createPatchFunction</code>函数有一千多行代码，这里就不方便列举出来了，它的内部首先定义了一系列辅助的方法，而核心是通过调用<code>createElm</code>方法进行<code>dom</code>操作，创建节点，插入子节点，递归创建一个完整的<code>DOM</code>树并插入到<code>Body</code>中。并且在产生真实阶段阶段，会有<code>diff</code>算法来判断前后<code>Vnode</code>的差异，以求最小化改变真实阶段。后面会有一个章节的内容去讲解<code>diff</code>算法。<code>createPatchFunction</code>的过程只需要先记住一些结论，函数内部会调用封装好的<code>DOM api</code>，根据<code>Virtual DOM</code>的结果去生成真实的节点。其中如果遇到组件<code>Vnode</code>时，会递归调用子组件的挂载过程，这个过程我们也会放到后面章节去分析。</p><h2 id="4-5-小结"><a href="#4-5-小结" class="headerlink" title="4.5 小结"></a>4.5 小结</h2><p>这一节分析了<code>mountComponent</code>的两个核心方法，<code>render</code>和<code>update</code>,在分析前重点介绍了存在于<code>JS</code>操作和<code>DOM</code>渲染的桥梁：<code>Virtual DOM</code>。<code>JS</code>对<code>DOM</code>节点的批量操作会先直接反应到<code>Virtual DOM</code>这个描述对象上,最终的结果才会直接作用到真实节点上。可以说，<code>Virtual DOM</code>很大程度提高了渲染的性能。文章重点介绍了<code>render</code>函数转换成<code>Virtual DOM</code>的过程，并大致描述了<code>_update</code>函数的实现思路。其实这两个过程都牵扯到组件，所以这一节对很多环节都无法深入分析，下一节开始会进入组件的专题。我相信分析完组件后，读者会对整个渲染过程会有更深刻的理解和思考。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Vue </category>
          
          <category> vue2.x源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Step.3 实例挂载流程和模板编译</title>
      <link href="/computer-science/vueyuanma/dosc/3%E5%AE%9E%E4%BE%8B%E6%8C%82%E8%BD%BD%E6%B5%81%E7%A8%8B%E5%92%8C%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91/"/>
      <url>/computer-science/vueyuanma/dosc/3%E5%AE%9E%E4%BE%8B%E6%8C%82%E8%BD%BD%E6%B5%81%E7%A8%8B%E5%92%8C%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前面几节我们从<code>new Vue</code>创建实例开始，介绍了创建实例时执行初始化流程中的重要两步，配置选项的资源合并,以及响应式系统的核心思想，数据代理。在合并章节，我们对<code>Vue</code>丰富的选项合并策略有了基本的认知，在数据代理章节我们又对代理拦截的意义和使用场景有了深入的认识。按照<code>Vue</code>源码的设计思路，初始化过程还会进行很多操作，例如组件之间创建关联，初始化事件中心，初始化数据并建立响应式系统等，并最终将模板和数据渲染成为<code>dom</code>节点。如果直接按流程的先后顺序分析每个步骤的实现细节，会有很多概念很难理解。因此在这一章节，我们先重点分析一个概念，<strong>实例的挂载渲染流程。</strong></p></blockquote><h2 id="3-1-Runtime-Only-VS-Runtime-Compiler"><a href="#3-1-Runtime-Only-VS-Runtime-Compiler" class="headerlink" title="3.1 Runtime Only VS Runtime + Compiler"></a>3.1 Runtime Only VS Runtime + Compiler</h2><p>在正文开始之前，我们先了解一下<code>vue</code>基于源码构建的两个版本，一个是<code>runtime only</code>(一个只包含运行时的版本)，另一个是<code>runtime + compiler</code>(一个同时包含编译器和运行时的版本)。而两个版本的区别仅在于后者包含了一个编译器。</p><p>什么是编译器，百度百科这样解释道：</p><blockquote><p>简单讲，编译器就是将“一种语言（通常为高级语言）”翻译为“另一种语言（通常为低级语言）”的程序。一个现代编译器的主要工作流程：源代码 (source code) → 预处理器 (preprocessor) → 编译器 (compiler) → 目标代码 (object code) → 链接器 (Linker) → 可执行程序 (executables)。</p></blockquote><p>通俗点讲，编译器是一个提供了将<strong>源代码</strong>转化为<strong>目标代码</strong>的工具。从<code>Vue</code>的角度出发，内置的编译器实现了将<code>template</code>模板转换编译为可执行<code>javascript</code>脚本的功能。</p><h3 id="3-1-1-Runtime-Compiler"><a href="#3-1-1-Runtime-Compiler" class="headerlink" title="3.1.1 Runtime + Compiler"></a>3.1.1 Runtime + Compiler</h3><p>一个完整的<code>Vue</code>版本是包含编译器的，我们可以使用<code>template</code>进行模板编写。编译器会自动将模板字符串编译成渲染函数的代码,源码中就是<code>render</code>函数。<br>如果你需要在客户端编译模板 (比如传入一个字符串给 <code>template</code> 选项，或挂载到一个元素上并以其 <code>DOM</code> 内部的 HTML 作为模板)，就需要一个包含编译器的版本。</p><pre><code class="js">// 需要编译器的版本new Vue(&#123;  template: &#39;&lt;div&gt;&#123;&#123; hi &#125;&#125;&lt;/div&gt;&#39;&#125;)</code></pre><h3 id="3-1-2-Runtime-Only"><a href="#3-1-2-Runtime-Only" class="headerlink" title="3.1.2 Runtime Only"></a>3.1.2 Runtime Only</h3><p>只包含运行时的代码拥有创建<code>Vue</code>实例、渲染并处理<code>Virtual DOM</code>等功能，基本上就是除去编译器外的完整代码。<code>Runtime Only</code>的适用场景有两种：<br>1.我们在选项中通过手写<code>render</code>函数去定义渲染过程，这个时候并不需要包含编译器的版本便可完整执行。</p><pre><code class="js">// 不需要编译器new Vue(&#123;  render (h) &#123;    return h(&#39;div&#39;, this.hi)  &#125;&#125;)</code></pre><p>2.借助<code>vue-loader</code>这样的编译工具进行编译，当我们利用<code>webpack</code>进行<code>Vue</code>的工程化开发时，常常会利用<code>vue-loader</code>对<code>.vue</code>进行编译，尽管我们也是利用<code>template</code>模板标签去书写代码，但是此时的<code>Vue</code>已经不需要利用编译器去负责模板的编译工作了，这个过程交给了插件去实现。</p><p>很明显，编译过程对性能会造成一定的损耗，并且由于加入了编译的流程代码，<code>Vue</code>代码的总体积也更加庞大(运行时版本相比完整版体积要小大约 30%)。因此在实际开发中，我们需要借助像<code>webpack</code>的<code>vue-loader</code>这类工具进行编译，将<code>Vue</code>对模板的编译阶段合并到<code>webpack</code>的构建流程中，这样不仅减少了生产环境代码的体积，也大大提高了运行时的性能，一举两得。</p><h3 id="3-1-3-vue渲染方式：render和template的区别"><a href="#3-1-3-vue渲染方式：render和template的区别" class="headerlink" title="3.1.3 vue渲染方式：render和template的区别"></a>3.1.3 vue渲染方式：render和template的区别</h3><p>  template—-html的方式做渲染<br>  render—-js的方式做渲染</p><p>  render（提供）是一种编译方式<br>  render里有一个函数h，这个h的作用是将单文件组件进行虚拟DOM的创建，然后再通过render进行解析。<br>  h就是createElement()方法：createElement(标签名称,属性配置,children)</p><p>  template也是一种编译方式，但是template最终还是要通过render的方式再次进行编译。</p><p>1、render渲染方式可以让我们将js发挥到极致，因为render的方式其实是通过createElement()进行虚拟DOM的创建。逻辑性比较强，适合复杂的组件封装。<br>2、template是类似于html一样的模板来进行组件的封装。<br>3、render的性能比template的性能好很多<br>4、render函数优先级大于template</p><h3 id="3-1-4-render渲染在components-策略中的使用"><a href="#3-1-4-render渲染在components-策略中的使用" class="headerlink" title="3.1.4 render渲染在components 策略中的使用"></a>3.1.4 render渲染在components 策略中的使用</h3><pre><code class="javascript">1.Vue如何引入远程JS/css文件 export default &#123;  components: &#123;    &quot;remote-css&quot;: &#123;      render(createElement) &#123;        return createElement(&quot;link&quot;, &#123;          attrs: &#123; rel: &quot;stylesheet&quot;, href: this.href &#125;,        &#125;);      &#125;,      props: &#123;        href: &#123; type: String, required: true &#125;,      &#125;,    &#125;,    &quot;remote-js&quot;: &#123;      render(createElement) &#123;        return createElement(&quot;script&quot;, &#123;          attrs: &#123; type: &quot;text/javascript&quot;, src: this.src &#125;,        &#125;);      &#125;,      props: &#123;        src: &#123; type: String, required: true &#125;,      &#125;    &#125;  &#125;&#125;直接在页面中定义&lt;remote-css href=&quot;https://at.alicdn.com/t/font_2307826_i7ewj7yiv2k.css&quot;&gt;&lt;/remote-css&gt;&lt;remote-js src=&quot;https://at.alicdn.com/t/font_2307682_is3un805urb.js&quot;&gt;&lt;/remote-js&gt;</code></pre><h2 id="3-2-实例挂载的基本思路"><a href="#3-2-实例挂载的基本思路" class="headerlink" title="3.2 实例挂载的基本思路"></a>3.2 实例挂载的基本思路</h2><p>有了上面的基础，我们回头看初始化<code>_init</code>的代码，在代码中我们观察到<code>initProxy</code>后有一系列的函数调用，这些函数包括了创建组件关联，初始化事件处理，定义渲染函数，构建数据响应式系统等，最后还有一段代码,在<code>el</code>存在的情况下，实例会调用<code>$mount</code>进行实例挂载。</p><pre><code class="js">Vue.prototype._init = function (options) &#123;  ···  // 选项合并  vm.$options = mergeOptions(    resolveConstructorOptions(vm.constructor),    options || &#123;&#125;,    vm  );  // 数据代理  initProxy(vm);  vm._self = vm;  initLifecycle(vm);  // 初始化事件处理  initEvents(vm);  // 定义渲染函数  initRender(vm);  // 构建响应式系统  initState(vm);  // 等等  ···  if (vm.$options.el) &#123;    vm.$mount(vm.$options.el);  &#125;&#125;</code></pre><p>以手写<code>template</code>模板为例，理清楚什么是挂载。<strong>我们会在选项中传递<code>template</code>为属性的模板字符串，如<code>&lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;</code>，最终这个模板字符串通过中间过程将其转成真实的<code>DOM</code>节点，并挂载到选项中<code>el</code>代表的根节点上完成视图渲染。这个中间过程就是接下来要分析的挂载流程。</strong></p><p><code>Vue</code>挂载的流程是比较复杂的，接下来我将通过<strong>流程图，代码分析</strong>两种方式为大家展示挂载的真实过程。</p><h3 id="3-2-1-流程图"><a href="#3-2-1-流程图" class="headerlink" title="3.2.1 流程图"></a>3.2.1 流程图</h3><p><img data-src="/images/img/3.1.png"><br>如果用一句话概括挂载的过程，可以描述为<strong>确认挂载节点,编译模板为<code>render</code>函数，渲染函数转换<code>Virtual DOM</code>,创建真实节点。</strong></p><h3 id="3-2-2-代码分析"><a href="#3-2-2-代码分析" class="headerlink" title="3.2.2 代码分析"></a>3.2.2 代码分析</h3><p>接下来我们从代码的角度去剖析挂载的流程。挂载的代码较多，下面只提取骨架相关的部分代码。</p><pre><code class="js">// 内部真正实现挂载的方法Vue.prototype.$mount = function (el, hydrating) &#123;  el = el &amp;&amp; inBrowser ? query(el) : undefined;  // 调用mountComponent方法挂载  return mountComponent(this, el, hydrating)&#125;;// 缓存了原型上的 $mount 方法var mount = Vue.prototype.$mount;// 重新定义$mount,为包含编译器和不包含编译器的版本提供不同封装，最终调用的是缓存原型上的$mount方法Vue.prototype.$mount = function (el, hydrating) &#123;  // 获取挂载元素  el = el &amp;&amp; query(el);  // 挂载元素不能为跟节点  if (el === document.body || el === document.documentElement) &#123;    warn(      &quot;Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.&quot;    );    return this  &#125;  var options = this.$options;  // 需要编译 or 不需要编译  // render选项不存在，代表是template模板的形式，此时需要进行模板的编译过程  if (!options.render) &#123;    ···    // 使用内部编译器编译模板  &#125;  // 无论是template模板还是手写render函数最终调用缓存的$mount方法  return mount.call(this, el, hydrating)&#125;// mountComponent方法思路function mountComponent(vm, el, hydrating) &#123;  // 定义updateComponent方法，在watch回调时调用。  updateComponent = function () &#123;    // render函数渲染成虚拟DOM， 虚拟DOM渲染成真实的DOM    vm._update(vm._render(), hydrating);  &#125;;  // 实例化渲染watcher  new Watcher(vm, updateComponent, noop, &#123;&#125;)&#125;</code></pre><p>我们用语言描述挂载流程的基本思路。</p><ul><li>确定挂载的<code>DOM</code>元素,这个<code>DOM</code>需要保证不能为<code>html，body</code>这类跟节点。</li><li>我们知道渲染有两种方式，一种是通过<code>template</code>模板字符串，另一种是手写<code>render</code>函数，前面提到<code>template</code>模板需要运行时进行编译，而后一个可以直接用<code>render</code>选项作为渲染函数。因此挂载阶段会有两条分支，<code>template</code>模板会先经过模板的解析，最终编译成<code>render</code>渲染函数参与实例挂载，而手写<code>render</code>函数可以绕过编译阶段，直接调用挂载的<code>$mount</code>方法。</li><li>针对<code>template</code>而言，它会利用<code>Vue</code>内部的编译器进行模板的编译，字符串模板会转换为抽象的语法树，即<code>AST</code>树，并最终转化为一个类似<code>function()&#123;with()&#123;&#125;&#125;</code>的渲染函数，这是我们后面讨论的重点。</li><li>无论是<code>template</code>模板还是手写<code>render</code>函数，最终都将进入<code>mountComponent</code>过程,这个阶段会实例化一个渲染<code>watcher</code>,具体<code>watcher</code>的内容，另外放章节讨论。我们先知道一个结论，渲染<code>watcher</code>的回调函数有两个执行时机，一个是在初始化时执行，另一个是当<code>vm</code>实例检测到数据发生变化时会再次执行回调函数。</li><li>回调函数是执行<code>updateComponent</code>的过程，这个方法有两个阶段，一个是<code>vm._render</code>,另一个是<code>vm._update</code>。 <code>vm._render</code>会执行前面生成的<code>render</code>渲染函数，并生成一个<code>Virtual Dom tree</code>,而<code>vm._update</code>会将这个<code>Virtual Dom tree</code>转化为真实的<code>DOM</code>节点。</li></ul><h2 id="3-3-模板编译"><a href="#3-3-模板编译" class="headerlink" title="3.3 模板编译"></a>3.3 模板编译</h2><p>通过文章前半段的学习，我们对<code>Vue</code>的挂载流程有了一个初略的认识。这里有两个大的流程需要我们详细去理解，一个是<code>template</code>模板的编译，另一个是<code>updateComponent</code>的实现细节。<code>updateComponent</code>的过程，我们放到下一章节重点分析，而这一节剩余的内容我们将会围绕模板编译的设计思路展开。</p><p>(编译器的实现细节是异常复杂的，要在短篇幅内将整个编译的过程掌握是不切实际的，并且从大方向上也不需要完全理清编译的流程。因此针对模板，文章分析只是浅尝即止，更多的细节读者可以自行分析)</p><h2 id="3-3-1-template的三种写法"><a href="#3-3-1-template的三种写法" class="headerlink" title="3.3.1 template的三种写法"></a>3.3.1 template的三种写法</h2><p><code>template</code>模板的编写有三种方式，分别是：</p><ul><li>字符串模板</li></ul><pre><code class="js">var vm = new Vue(&#123;  el: &#39;#app&#39;,  template: &#39;&lt;div&gt;模板字符串&lt;/div&gt;&#39;&#125;)</code></pre><ul><li>选择符匹配元素的 <code>innerHTML</code>模板</li></ul><pre><code class="js">&lt;div id=&quot;app&quot;&gt;  &lt;div&gt;test1&lt;/div&gt;  &lt;script type=&quot;x-template&quot; id=&quot;test&quot;&gt;    &lt;p&gt;test&lt;/p&gt;  &lt;/script&gt;&lt;/div&gt;var vm = new Vue(&#123;  el: &#39;#app&#39;,  template: &#39;#test&#39;&#125;)</code></pre><ul><li><code>dom</code>元素匹配元素的<code>innerHTML</code>模板</li></ul><pre><code class="js">&lt;div id=&quot;app&quot;&gt;  &lt;div&gt;test1&lt;/div&gt;  &lt;span id=&quot;test&quot;&gt;&lt;div class=&quot;test2&quot;&gt;test2&lt;/div&gt;&lt;/span&gt;&lt;/div&gt;var vm = new Vue(&#123;  el: &#39;#app&#39;,  template: document.querySelector(&#39;#test&#39;)&#125;)</code></pre><p>模板编译的前提需要对<code>template</code>模板字符串的合法性进行检测，三种写法对应代码的三个不同分支。</p><pre><code class="js">Vue.prototype.$mount = function () &#123;  ···  if(!options.render) &#123;    var template = options.template;    if (template) &#123;      // 针对字符串模板和选择符匹配模板      if (typeof template === &#39;string&#39;) &#123;        // 选择符匹配模板，以&#39;#&#39;为前缀的选择器        if (template.charAt(0) === &#39;#&#39;) &#123;          // 获取匹配元素的innerHTML          template = idToTemplate(template);          /* istanbul ignore if */          if (!template) &#123;            warn(              (&quot;Template element not found or is empty: &quot; + (options.template)),              this            );          &#125;        &#125;      // 针对dom元素匹配      &#125; else if (template.nodeType) &#123;        // 获取匹配元素的innerHTML        template = template.innerHTML;      &#125; else &#123;        // 其他类型则判定为非法传入        &#123;          warn(&#39;invalid template option:&#39; + template, this);        &#125;        return this      &#125;    &#125; else if (el) &#123;      // 如果没有传入template模板，则默认以el元素所属的根节点作为基础模板      template = getOuterHTML(el);    &#125;  &#125;&#125;// 判断el元素是否存在function query (el) &#123;    if (typeof el === &#39;string&#39;) &#123;      var selected = document.querySelector(el);      if (!selected) &#123;        warn(          &#39;Cannot find element: &#39; + el        );        return document.createElement(&#39;div&#39;)      &#125;      return selected    &#125; else &#123;      return el    &#125;  &#125;var idToTemplate = cached(function (id) &#123;  var el = query(id);  return el &amp;&amp; el.innerHTML&#125;);</code></pre><p><strong>注意：其中X-Template模板的方式一般用于模板特别大的 demo 或极小型的应用，官方不建议在其他情形下使用，因为这会将模板和组件的其它定义分离开。</strong></p><h2 id="3-3-2-编译流程图解"><a href="#3-3-2-编译流程图解" class="headerlink" title="3.3.2 编译流程图解"></a>3.3.2 编译流程图解</h2><p><code>vue</code>源码中编译的设计思路是比较绕，涉及的函数处理逻辑比较多，实现流程中巧妙的运用了偏函数的技巧将配置项处理和编译核心逻辑抽取出来，为了理解这个设计思路，我画了一个逻辑图帮助理解。</p><p><img data-src="/images/img/3.2.png"></p><h2 id="3-3-3-逻辑解析"><a href="#3-3-3-逻辑解析" class="headerlink" title="3.3.3 逻辑解析"></a>3.3.3 逻辑解析</h2><p>即便有流程图，编译逻辑理解起来依然比较晦涩，接下来，结合代码分析每个环节的执行过程。</p><pre><code class="js">Vue.prototype.$mount = function () &#123;  ···  if(!options.render) &#123;    var template = options.template;    if (template) &#123;      var ref = compileToFunctions(template, &#123;          outputSourceRange: &quot;development&quot; !== &#39;production&#39;,          shouldDecodeNewlines: shouldDecodeNewlines,          shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,          delimiters: options.delimiters,          comments: options.comments        &#125;, this);        var render = ref.render;    &#125;    ...  &#125;&#125;</code></pre><p><code>compileToFunctions</code>有三个参数，一个是<code>template</code>模板，另一个是编译的配置信息，并且这个方法是对外暴露的编译方法，用户可以自定义配置信息进行模板的编译。最后一个参数是<code>Vue</code>实例。</p><pre><code class="js">// 将compileToFunction方法暴露给Vue作为静态方法存在Vue.compile = compileToFunctions;</code></pre><p>在<code>Vue</code>的官方文档中，<code>Vue.compile</code>只允许传递一个<code>template</code>模板参数，这是否意味着用户无法决定某些编译的行为？显然不是的，我们看回代码，有两个选项配置可以提供给用户，用户只需要在实例化<code>Vue</code>时传递选项改变配置，他们分别是：</p><p>1.<code>delimiters</code>： 该选项可以改变纯文本插入分隔符，当不传递值时，<code>Vue</code>默认的分隔符为 <code>&#123;&#123;&#125;&#125;</code>。如果我们想使用其他模板，可以通过<code>delimiters</code>修改。</p><p>2.<code>comments</code> ： 当设为 <code>true</code> 时，将会保留且渲染模板中的 <code>HTML</code>注释。默认行为是舍弃它们。</p><p><strong>注意，由于这两个选项是在完整版的编译流程读取的配置，所以在运行时版本配置这两个选项是无效的</strong></p><p>接着我们一步步寻找<code>compileToFunctions</code>的根源。</p><p>首先我们需要有一个认知，<strong>不同平台对<code>Vue</code>的编译过程是不一样的，也就是说基础的编译方法会随着平台的不同有区别，编译阶段的配置选项也因为平台的不同呈现差异。但是设计者又不希望在相同平台下编译不同模板时，每次都要传入相同的配置选项。这才有了源码中较为复杂的编译实现。</strong></p><pre><code class="js">var createCompiler = createCompilerCreator(function baseCompile (template,options) &#123;  //把模板解析成抽象的语法树  var ast = parse(template.trim(), options);  // 配置中有代码优化选项则会对Ast语法树进行优化  if (options.optimize !== false) &#123;    optimize(ast, options);  &#125;  var code = generate(ast, options);  return &#123;    ast: ast,    render: code.render,    staticRenderFns: code.staticRenderFns  &#125;&#125;);var ref$1 = createCompiler(baseOptions);var compile = ref$1.compile;var compileToFunctions = ref$1.compileToFunctions;</code></pre><p>这部分代码是在<code>Vue</code>引入阶段定义的，<code>createCompilerCreator</code>在传递了一个<code>baseCompile</code>函数作为参数后，返回了一个编译器的生成器，也就是<code>createCompiler</code>,有了这个生成器，当将编译配置选项<code>baseOptions</code>传入后,这个编译器生成器便<strong>生成了一个指定环境指定配置下的编译器</strong>，而其中编译执行函数就是返回对象的<code>compileToFunctions</code>。</p><p>这里的<code>baseCompile</code>是真正执行编译功能的地方，也就是前面说到的特定平台的编译方法。它在源码初始化时就已经作为参数的形式保存在内存变量中。我们先看看<code>baseCompile</code>的大致流程。</p><p><code>baseCompile</code>函数的参数有两个，一个是后续传入的<code>template</code>模板,另一个是编译需要的配置参数。函数实现的功能如下几个：</p><ul><li>1.把模板解析成抽象的语法树，简称<code>AST</code>，代码中对应<code>parse</code>部分。</li><li>2.可选：优化<code>AST</code>语法树，执行<code>optimize</code>方法。</li><li>3.根据不同平台将<code>AST</code>语法树转换成渲染函数，对应的<code>generate</code>函数</li></ul><p>接下来具体看看<code>createCompilerCreator</code>的实现：</p><pre><code class="js">function createCompilerCreator (baseCompile) &#123;    return function createCompiler (baseOptions) &#123;      // 内部定义compile方法      function compile (template, options) &#123;        ···      &#125;      return &#123;        compile: compile,        compileToFunctions: createCompileToFunctionFn(compile)      &#125;    &#125;  &#125; </code></pre><p><code>createCompilerCreator</code>函数只有一个作用，利用<strong>偏函数</strong>的思想将<code>baseCompile</code>这一基础的编译方法缓存，并返回一个编程器生成器，当执行<code>var ref$1 = createCompiler(baseOptions);</code>时，<code>createCompiler</code>会将内部定义的<code>compile</code>和<code>compileToFunctions</code>返回。</p><p>我们继续关注<code>compileToFunctions</code>的由来，它是<code>createCompileToFunctionFn</code>函数以<code>compile</code>为参数返回的方法，接着看<code>createCompileToFunctionFn</code>的实现逻辑。</p><pre><code class="js"> function createCompileToFunctionFn (compile) &#123;    var cache = Object.create(null);    return function compileToFunctions (template,options,vm) &#123;      options = extend(&#123;&#125;, options);      ···      // 缓存的作用：避免重复编译同个模板造成性能的浪费      if (cache[key]) &#123;        return cache[key]      &#125;      // 执行编译方法      var compiled = compile(template, options);      ···      // turn code into functions      var res = &#123;&#125;;      var fnGenErrors = [];      // 编译出的函数体字符串作为参数传递给createFunction,返回最终的render函数      res.render = createFunction(compiled.render, fnGenErrors);      res.staticRenderFns = compiled.staticRenderFns.map(function (code) &#123;        return createFunction(code, fnGenErrors)      &#125;);      ···      return (cache[key] = res)    &#125;  &#125;</code></pre><p><code>createCompileToFunctionFn</code>利用了闭包的概念，将编译过的模板进行缓存,<code>cache</code>会将之前编译过的结果保留下来，利用缓存可以避免重复编译引起的浪费性能。<code>createCompileToFunctionFn</code>最终会将<code>compileToFunctions</code>方法返回。</p><p>接下来，我们分析一下<code>compileToFunctions</code>的实现逻辑。在判断不使用缓存的编译结果后，<code>compileToFunctions</code>会执行<code>compile</code>方法，这个方法是前面分析<code>createCompiler</code>时，返回的内部<code>compile</code>方法，所以我们需要先看看<code>compile</code>的实现。</p><pre><code class="js">function createCompiler (baseOptions) &#123;  function compile (template, options) &#123;        var finalOptions = Object.create(baseOptions);        var errors = [];        var tips = [];        var warn = function (msg, range, tip) &#123;          (tip ? tips : errors).push(msg);        &#125;;        // 选项合并        if (options) &#123;          ···          // 这里会将用户传递的配置和系统自带编译配置进行合并        &#125;        finalOptions.warn = warn;        // 将剔除空格后的模板以及合并选项后的配置作为参数传递给baseCompile方法        var compiled = baseCompile(template.trim(), finalOptions);        &#123;          detectErrors(compiled.ast, warn);        &#125;        compiled.errors = errors;        compiled.tips = tips;        return compiled      &#125;      return &#123;        compile: compile,        compileToFunctions: createCompileToFunctionFn(compile)      &#125;&#125;</code></pre><p>我们看到<code>compile</code>真正执行的方法，是一开始在创建编译器生成器时，传入的基础编译方法<code>baseCompile</code>，<code>baseCompile</code>真正执行的时候，会将用户传递的编译配置和系统自带的编译配置选项合并，这也是开头提到编译器设计思想的精髓。</p><p>执行完<code>compile</code>会返回一个对象,<code>ast</code>顾名思义是模板解析成的抽象语法树，<code>render</code>是最终生成的<code>with</code>语句,<code>staticRenderFns</code>是以数组形式存在的静态<code>render</code>。</p><pre><code class="js">&#123;  ast: ast,  render: code.render,  staticRenderFns: code.staticRenderFns&#125;</code></pre><p>而<code>createCompileToFunctionFn</code>最终会返回另外两个包装过的属性<code>render, staticRenderFns</code>，他们的核心是<strong>将 <code>with</code>语句封装成执行函数。</strong></p><pre><code class="js">// 编译出的函数体字符串作为参数传递给createFunction,返回最终的render函数  res.render = createFunction(compiled.render, fnGenErrors);  res.staticRenderFns = compiled.staticRenderFns.map(function (code) &#123;    return createFunction(code, fnGenErrors)  &#125;);  function createFunction (code, errors) &#123;    try &#123;      return new Function(code)    &#125; catch (err) &#123;      errors.push(&#123; err: err, code: code &#125;);      return noop    &#125;  &#125;</code></pre><p>至此，<code>Vue</code>中关于编译器的设计思路也基本梳理清楚了，一开始看代码的时候，总觉得编译逻辑的设计特别的绕，分析完代码后发现，这正是作者思路巧妙的地方。<code>Vue</code>在不同平台上有不同的编译过程，而每个编译过程的<code>baseOptions</code>选项会有所不同，同时也提供了一些选项供用户去配置，整个设计思想深刻的应用了偏函数的设计思想，而偏函数又是闭包的应用。作者利用偏函数将不同平台的编译方式进行缓存，同时剥离出编译相关的选项合并，这些方式都是值得我们日常学习的。</p><p>编译的核心是<code>parse,generate</code>过程，这两个过程笔者并没有分析，原因是抽象语法树的解析分支较多，需要结合实际的代码场景才更好理解。这两部分的代码会在后面介绍到具体逻辑功能章节时再次提及。</p><h2 id="3-4-小结"><a href="#3-4-小结" class="headerlink" title="3.4 小结"></a>3.4 小结</h2><p>这一节的内容有两大块，首先详细的介绍了实例在挂载阶段的完整流程，当我们传入选项进行实例化时，最终的目的是将选项渲染成页面真实的可视节点。这个选项有两种形式，一个是以<code>template</code>模板字符串传入，另一个是手写<code>render</code>函数形式传入，不论哪种，最终会以<code>render</code>函数的形式参与挂载，<code>render</code>是一个用函数封装好的<code>with</code>语句。渲染真实节点前需要将<code>render</code>函数解析成虚拟<code>DOM</code>,虚拟<code>DOM</code>是<code>js</code>和真实<code>DOM</code>之间的桥梁。最终的<code>_update</code>过程让将虚拟<code>DOM</code>渲染成真实节点。第二个大块主要介绍了作者在编译器设计时巧妙的实现思路。过程大量运用了偏函数的概念，将编译过程进行缓存并且将选项合并从编译过程中剥离。这些设计理念、思想都是值得我们开发者学习和借鉴的。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Vue </category>
          
          <category> vue2.x源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Step.2 基础的数据代理检测</title>
      <link href="/computer-science/vueyuanma/dosc/2%E5%9F%BA%E7%A1%80%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%90%86%E6%A3%80%E6%B5%8B/"/>
      <url>/computer-science/vueyuanma/dosc/2%E5%9F%BA%E7%A1%80%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%90%86%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>简单回顾一下这个系列的前两节，前两节花了大量的篇幅介绍了<code>Vue</code>的选项合并，选项合并是<code>Vue</code>实例初始化的开始，<code>Vue</code>为开发者提供了丰富的选项配置，而每个选项都严格规定了合并的策略。然而这只是初始化中的第一步，这一节我们将对另一个重点的概念深入的分析，他就是<strong>数据代理</strong>，我们知道<code>Vue</code>大量利用了代理的思想，而除了响应式系统外，还有哪些场景也需要进行数据代理呢？这是我们这节分析的重点。</p></blockquote><h2 id="2-1-数据代理的含义"><a href="#2-1-数据代理的含义" class="headerlink" title="2.1 数据代理的含义"></a>2.1 数据代理的含义</h2><p>数据代理的另一个说法是数据劫持，当我们在访问或者修改对象的某个属性时，数据劫持可以拦截这个行为并进行额外的操作或者修改返回的结果。而我们知道<code>Vue</code>响应式系统的核心就是数据代理，代理使得数据在访问时进行依赖收集，在修改更新时对依赖进行更新，这是响应式系统的核心思路。而这一切离不开<code>Vue</code>对数据做了拦截代理。然而响应式并不是本节讨论的重点，这一节我们将看看数据代理在其他场景下的应用。在分析之前，我们需要掌握两种实现数据代理的方法：<br><code>Object.defineProperty</code> 和 <code>Proxy</code>。</p><h3 id="2-1-1-Object-defineProperty"><a href="#2-1-1-Object-defineProperty" class="headerlink" title="2.1.1 Object.defineProperty"></a>2.1.1 Object.defineProperty</h3><blockquote><p>官方定义：<code>Object.defineProperty()</code>方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。</p></blockquote><p>基本用法： </p><pre><code class="js">Object.defineProperty(obj, prop, descriptor)</code></pre><p><code>Object.defineProperty()</code>可以用来精确添加或修改对象的属性，只需要在<code>descriptor</code>对象中将属性特性描述清楚，<code>descriptor</code>的属性描述符有两种形式，一种是数据描述符，另一种是存取描述符，我们分别看看各自的特点。</p><ol><li>数据描述符，它拥有四个属性配置</li></ol><ul><li><code>configurable</code>：数据是否可删除，可配置</li><li><code>enumerable</code>：属性是否可枚举</li><li><code>value</code>：属性值,默认为<code>undefined</code></li><li><code>writable</code>：属性是否可读写</li></ul><ol start="2"><li>存取描述符，它同样拥有四个属性选项</li></ol><ul><li><code>configurable</code>：数据是否可删除，可配置</li><li><code>enumerable</code>：属性是否可枚举</li><li><code>get</code>:一个给属性提供 <code>getter</code> 的方法，如果没有 <code>getter</code> 则为 <code>undefined</code>。</li><li><code>set</code>:一个给属性提供 <code>setter</code> 的方法，如果没有 <code>setter</code> 则为 <code>undefined</code>。</li></ul><p><strong>需要注意的是: 数据描述符的<code>value，writable</code> 和 存取描述符中的<code>get, set</code>属性不能同时存在，否则会抛出异常。</strong><br>有了<code>Object.defineProperty</code>方法，我们可以方便的利用存取描述符中的<code>getter/setter</code>来进行数据的监听,这也是响应式构建的雏形。<code>getter</code>方法可以让我们在访问数据时做额外的操作处理，<code>setter</code>方法使得我们可以在数据更新时修改返回的结果。看看下面的例子,由于设置了数据代理，当我们访问对象<code>o</code>的<code>a</code>属性时，会触发<code>getter</code>执行钩子函数，当修改<code>a</code>属性的值时，会触发<code>setter</code>钩子函数去修改返回的结果。</p><pre><code class="js">var o = &#123;&#125;var value;Object.defineProperty(o, &#39;a&#39;, &#123;    get() &#123;        console.log(&#39;获取值&#39;)        return value    &#125;,    set(v) &#123;        console.log(&#39;设置值&#39;)        value = v    &#125;&#125;)o.a = &#39;sss&#39; // 设置值console.log(o.a)// 获取值// &#39;qqq&#39;</code></pre><p>前面说到<code>Object.defineProperty</code>的<code>get</code>和<code>set</code>方法是对对象进行监测并响应变化，那么数组类型是否也可以监测呢，参照监听属性的思路，我们用数组的下标作为属性，数组的元素作为拦截对象，看看<code>Object.defineProperty</code>是否可以对数组的数据进行监控拦截。</p><pre><code class="js">var arr = [1,2,3];arr.forEach((item, index) =&gt; &#123;    Object.defineProperty(arr, index, &#123;        get() &#123;            console.log(&#39;数组被getter拦截&#39;)            return item        &#125;,        set(value) &#123;            console.log(&#39;数组被setter拦截&#39;)            return item = value        &#125;    &#125;)&#125;)arr[1] = 4;console.log(arr)// 结果数组被setter拦截数组被getter拦截4</code></pre><p>显然，<strong>已知长度的数组是可以通过索引属性来设置属性的访问器属性的。</strong>但是数组的添加确无法进行拦截，这个也很好理解，不管是通过<code>arr.push()</code>还是<code>arr[10] = 10</code>添加的数据，数组所添加的索引值并没有预先加入数据拦截中，所以自然无法进行拦截处理。这个也是使用<code>Object.defineProperty</code>进行数据代理的弊端。为了解决这个问题，<code>Vue</code>在响应式系统中对数组的方法进行了重写，间接的解决了这个问题，详细细节可以参考后续的响应式系统分析。</p><p>另外如果需要拦截的对象属性嵌套多层，如果没有递归去调用<code>Object.defineProperty</code>进行拦截，深层次的数据也依然无法监测。</p><h3 id="2-1-2-Proxy"><a href="#2-1-2-Proxy" class="headerlink" title="2.1.2 Proxy"></a>2.1.2 Proxy</h3><p>为了解决像数组这类无法进行数据拦截，以及深层次的嵌套问题，<code>es6</code>引入了<code>Proxy</code>的概念，它是真正在语言层面对数据拦截的定义。和<code>Object.defineProperty</code>一样，<code>Proxy</code>可以修改某些操作的默认行为，但是不同的是，**<code>Proxy</code>针对目标对象会创建一个新的实例对象，并将目标对象代理到新的实例对象上，<strong>。 本质的区别是后者会创建一个新的对象对原对象做代理，外界对原对象的访问，都必须先通过这层代理进行拦截处理。而拦截的结果是</strong>我们只要通过操作新的实例对象就能间接的操作真正的目标对象了**。针对<code>Proxy</code>，下面是基础的写法:</p><pre><code class="js">var obj = &#123;&#125;var nobj = new Proxy(obj, &#123;    get(target, key, receiver) &#123;        console.log(&#39;获取值&#39;)        return Reflect.get(target, key, receiver)    &#125;,    set(target, key, value, receiver) &#123;        console.log(&#39;设置值&#39;)        return Reflect.set(target, key, value, receiver)    &#125;&#125;)nobj.a = &#39;代理&#39;console.log(obj)// 结果设置值&#123;a: &quot;代理&quot;&#125;</code></pre><p>上面的<code>get,set</code>是<code>Proxy</code>支持的拦截方法，而<code>Proxy</code> 支持的拦截操作有13种之多，具体可以参照<span class="exturl" data-url="aHR0cDovL2VzNi5ydWFueWlmZW5nLmNvbS8jZG9jcy9wcm94eQ==">ES6-Proxy</span>文档,前面提到，<code>Object.defineProperty</code>的<code>getter</code>和<code>setter</code>方法并不适合监听拦截数组的变化，那么新引入的<code>Proxy</code>又能否做到呢？我们看下面的例子。</p><pre><code class="js">var arr = [1, 2, 3]let obj = new Proxy(arr, &#123;    get: function (target, key, receiver) &#123;        // console.log(&quot;获取数组元素&quot; + key);        return Reflect.get(target, key, receiver);    &#125;,    set: function (target, key, receiver) &#123;        console.log(&#39;设置数组&#39;);        return Reflect.set(target, key, receiver);    &#125;&#125;)// 1. 改变已存在索引的数据obj[2] = 3// result: 设置数组// 2. push,unshift添加数据obj.push(4)// result: 设置数组 * 2 (索引和length属性都会触发setter)// // 3. 直接通过索引添加数组obj[5] = 5// result: 设置数组 * 2// // 4. 删除数组元素obj.splice(1, 1)</code></pre><p>显然<code>Proxy</code>完美的解决了数组的监听检测问题，针对数组添加数据，删除数据的不同方法，代理都能很好的拦截处理。另外<code>Proxy</code>也很好的解决了深层次嵌套对象的问题，具体读者可以自行举例分析。</p><h2 id="2-2-initProxy"><a href="#2-2-initProxy" class="headerlink" title="2.2 initProxy"></a>2.2 initProxy</h2><p>数据拦截的思想除了为构建响应式系统准备，它也可以为<strong>数据进行筛选过滤</strong>，我们接着往下看初始化的代码，在合并选项后，<code>vue</code>接下来会为<code>vm</code>实例设置一层代理，这层代理可以为<strong>vue在模板渲染时进行一层数据筛选</strong>，这个过程究竟怎么发生的，我们看代码的实现。</p><pre><code class="js">Vue.prototype._init = function(options) &#123;    // 选项合并    ...    &#123;        // 对vm实例进行一层代理        initProxy(vm);    &#125;    ...&#125;</code></pre><p><code>initProxy</code>的实现如下：</p><pre><code class="js">// 代理函数var initProxy = function initProxy (vm) &#123;        if (hasProxy) &#123;        var options = vm.$options;        var handlers = options.render &amp;&amp; options.render._withStripped            ? getHandler            : hasHandler;        // 代理vm实例到vm属性_renderProxy        vm._renderProxy = new Proxy(vm, handlers);    &#125; else &#123;        vm._renderProxy = vm;    &#125;&#125;;</code></pre><p>首先是判断浏览器是否支持原生的<code>proxy</code>。</p><pre><code class="js">var hasProxy =      typeof Proxy !== &#39;undefined&#39; &amp;&amp; isNative(Proxy);</code></pre><p>当浏览器支持<code>Proxy</code>时，<code>vm._renderProxy</code>会代理<code>vm</code>实例，并且代理过程也会随着参数的不同呈现不同的效果；当浏览器不支持<code>Proxy</code>时，直接将<code>vm</code>赋值给<code>vm._renderProxy</code>。</p><p>读到这里，我相信大家会有很多的疑惑。<br><strong>1. 这层代理的访问时机是什么，也就是说什么场景会触发这层代理</strong><br><strong>2. 参数<code>options.render._withStripped</code>代表着什么，<code>getHandler</code>和<code>hasHandler</code>又有什么不同。</strong><br><strong>3. 如何理解为模板数据的访问进行数据筛选过滤。到底有什么数据需要过滤。</strong><br><strong>4. 只有在支持原生<code>proxy</code>环境下才会建立这层代理，那么在旧的浏览器，非法的数据又将如何展示。</strong></p><p>带着这些疑惑，我们接着往下分析。</p><h3 id="2-2-1-触发代理"><a href="#2-2-1-触发代理" class="headerlink" title="2.2.1 触发代理"></a>2.2.1 触发代理</h3><p>源码中<code>vm._renderProxy</code>的使用出现在<code>Vue</code>实例的<code>_render</code>方法中，<code>Vue.prototype._render</code>是将渲染函数转换成<code>Virtual DOM</code>的方法，这部分是关于实例的挂载和模板引擎的解析，笔者并不会在这一章节中深入分析，我们只需要先有一个认知，**<code>Vue</code>内部在<code>js</code>和真实<code>DOM</code>节点中设立了一个中间层，这个中间层就是<code>Virtual DOM</code>，遵循<code>js -&gt; virtual -&gt; 真实dom</code>的转换过程,而<code>Vue.prototype._render</code>是前半段的转换，**当我们调用<code>render</code>函数时，代理的<code>vm._renderProxy</code>对象便会访问到。</p><pre><code class="js">Vue.prototype._render = function () &#123;    ···    // 调用vm._renderProxy    vnode = render.call(vm._renderProxy, vm.$createElement);&#125;</code></pre><p>那么代理的处理函数又是什么？我们回过头看看代理选项<code>handlers</code>的实现。<br><code>handers</code>函数会根据 <code>options.render._withStripped</code>的不同执行不同的代理函数，<strong>当使用类似<code>webpack</code>这样的打包工具时，通常会使用<code>vue-loader</code>插件进行模板的编译，这个时候<code>options.render</code>是存在的，并且<code>_withStripped</code>的属性也会设置为<code>true</code></strong>(关于编译版本和运行时版本的区别可以参考后面章节)，所以此时代理的选项是<code>hasHandler</code>,在其他场景下，代理的选项是<code>getHandler</code>。<code>getHandler,hasHandler</code>的逻辑相似，我们只分析使用<code>vue-loader</code>场景下<code>hasHandler</code>的逻辑。另外的逻辑，读者可以自行分析。</p><pre><code class="js">var hasHandler = &#123;    // key in obj或者with作用域时，会触发has的钩子    has: function has (target, key) &#123;        ···    &#125;&#125;;</code></pre><p><code>hasHandler</code>函数定义了<code>has</code>的钩子，前面介绍过,<code>proxy</code>的钩子有13个之多，而<code>has</code>是其中一个，它用来拦截<code>propKey in proxy</code>的操作，返回一个布尔值。而除了拦截 <code>in</code> 操作符外，<code>has</code>钩子同样可以用来拦截<code>with</code>语句下的作用对象。例如:</p><pre><code class="js">var obj = &#123;    a: 1&#125;var nObj = new Proxy(obj, &#123;    has(target, key) &#123;        console.log(target) // &#123; a: 1 &#125;        console.log(key) // a        return true    &#125;&#125;)with(nObj) &#123;    a = 2&#125;</code></pre><p>那么这两个触发条件是否跟<code>_render</code>过程有直接的关系呢？答案是肯定的。<code>vnode = render.call(vm._renderProxy, vm.$createElement);</code>的主体是<code>render</code>函数，而这个<code>render</code>函数就是包装成<code>with</code>的执行语句,<strong>在执行<code>with</code>语句的过程中，该作用域下变量的访问都会触发<code>has</code>钩子，这也是模板渲染时之所有会触发代理拦截的原因。</strong>我们通过代码来观察<code>render</code>函数的原形。</p><pre><code class="js">var vm = new Vue(&#123;    el: &#39;#app&#39;     &#125;)console.log(vm.$options.render)//输出, 模板渲染使用with语句ƒ anonymous() &#123;    with(this)&#123;return _c(&#39;div&#39;,&#123;attrs:&#123;&quot;id&quot;:&quot;app&quot;&#125;&#125;,[_v(_s(message)+_s(_test))])&#125;&#125;</code></pre><h3 id="2-2-2-数据过滤"><a href="#2-2-2-数据过滤" class="headerlink" title="2.2.2 数据过滤"></a>2.2.2 数据过滤</h3><p>我们已经大致知道了<code>Proxy</code>代理的访问时机，那么设置这层代理的作用又在哪里呢？首先思考一个问题，我们通过<code>data</code>选项去设置实例数据，那么这些数据可以随着个人的习惯任意命名吗？显然不是的，如果你使用<code>js</code>的关键字(像<code>Object,Array,NaN</code>)去命名,这是不被允许的。另一方面，<code>Vue</code>源码内部使用了以<code>$,_</code>作为开头的内部变量，所以以<code>$,_</code>开头的变量名也是不被允许的，这就构成了数据过滤监测的前提。接下来我们具体看<code>hasHandler</code>的细节实现。</p><pre><code class="js">var hasHandler = &#123;    has: function has (target, key) &#123;        var has = key in target;        // isAllowed用来判断模板上出现的变量是否合法。        var isAllowed = allowedGlobals(key) ||            (typeof key === &#39;string&#39; &amp;&amp; key.charAt(0) === &#39;_&#39; &amp;&amp; !(key in target.$data));            // _和$开头的变量不允许出现在定义的数据中，因为他是vue内部保留属性的开头。        // 1. warnReservedPrefix: 警告不能以$ _开头的变量        // 2. warnNonPresent: 警告模板出现的变量在vue实例中未定义        if (!has &amp;&amp; !isAllowed) &#123;            if (key in target.$data) &#123; warnReservedPrefix(target, key); &#125;            else &#123; warnNonPresent(target, key); &#125;        &#125;        return has || !isAllowed    &#125;&#125;;// 模板中允许出现的非vue实例定义的变量var allowedGlobals = makeMap(    &#39;Infinity,undefined,NaN,isFinite,isNaN,&#39; +    &#39;parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,&#39; +    &#39;Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,&#39; +    &#39;require&#39; // for Webpack/Browserify);</code></pre><p>首先<code>allowedGlobals</code>定义了<code>javascript</code>保留的关键字，这些关键字是不允许作为用户变量存在的。<code>(typeof key === &#39;string&#39; &amp;&amp; key.charAt(0) === &#39;_&#39; &amp;&amp; !(key in target.$data)</code>的逻辑对以<code>$,_</code>开头，或者是否是<code>data</code>中未定义的变量做判断过滤。这里对未定义变量的场景多解释几句，前面说到，代理的对象<code>vm.renderProxy</code>是在执行<code>_render</code>函数中访问的，而在使用了<code>template</code>模板的情况下，<code>render</code>函数是对模板的解析结果，换言之，之所以会触发数据代理拦截是因为模板中使用了变量，例如<code>&lt;div&gt;&#123;&#123;message&#125;&#125;&#125;&lt;/div&gt;</code>。而如果我们在模板中使用了未定义的变量，这个过程就被<code>proxy</code>拦截，并定义为不合法的变量使用。</p><p>我们可以看看两个报错信息的源代码(是不是很熟悉):</p><pre><code class="js">// 模板使用未定义的变量var warnNonPresent = function (target, key) &#123;    warn(    &quot;Property or method \&quot;&quot; + key + &quot;\&quot; is not defined on the instance but &quot; +    &#39;referenced during render. Make sure that this property is reactive, &#39; +    &#39;either in the data option, or for class-based components, by &#39; +    &#39;initializing the property. &#39; +    &#39;See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.&#39;,    target    );&#125;;// 使用$,_开头的变量var warnReservedPrefix = function (target, key) &#123;    warn(    &quot;Property \&quot;&quot; + key + &quot;\&quot; must be accessed with \&quot;$data.&quot; + key + &quot;\&quot; because &quot; +    &#39;properties starting with &quot;$&quot; or &quot;_&quot; are not proxied in the Vue instance to &#39; +    &#39;prevent conflicts with Vue internals&#39; +    &#39;See: https://vuejs.org/v2/api/#data&#39;,    target    );&#125;;</code></pre><p>分析到这里，前面的疑惑只剩下最后一个问题。只有在浏览器支持<code>proxy</code>的情况下，才会执行<code>initProxy</code>设置代理，那么在不支持的情况下，数据过滤就失效了，此时非法的数据定义还能正常运行吗？我们先对比下面两个结论。</p><pre><code class="js">// 模板中使用_开头的变量，且在data选项中有定义&lt;div id=&quot;app&quot;&gt;&#123;&#123;_test&#125;&#125;&lt;/div&gt;new Vue(&#123;    el: &#39;#app&#39;,    data: &#123;        _test: &#39;proxy&#39;    &#125;&#125;)</code></pre><ol><li>支持<code>proxy</code>浏览器的结果</li></ol><p><img data-src="/images/img/2.1.png"></p><ol start="2"><li>不支持<code>proxy</code>浏览器的结果</li></ol><p><img data-src="/images/img/2.2.png"></p><p>显然，在没有经过代理的情况下，使用<code>_</code>开头的变量依旧会<br>报错，但是它变成了<code>js</code>语言层面的错误，表示该变量没有被声明。但是这个报错无法在<code>Vue</code>这一层知道错误的详细信息，而这就是能使用<code>Proxy</code>的好处。接着我们会思考，既然已经在<code>data</code>选项中定义了<code>_test</code>变量，为什么访问时还是找不到变量的定义呢？<br>原来在初始化数据阶段，<code>Vue</code>已经为数据进行了一层筛选的代理。具体看<code>initData</code>对数据的代理，其他实现细节不在本节讨论范围内。</p><pre><code class="js">function initData(vm) &#123;    vm._data = typeof data === &#39;function&#39; ? getData(data, vm) : data || &#123;&#125;    if (!isReserved(key)) &#123;        // 数据代理，用户可直接通过vm实例返回data数据        proxy(vm, &quot;_data&quot;, key);    &#125;&#125;function isReserved (str) &#123;    var c = (str + &#39;&#39;).charCodeAt(0);    // 首字符是$, _的字符串    return c === 0x24 || c === 0x5F  &#125;</code></pre><p><code>vm._data</code>可以拿到最终<code>data</code>选项合并的结果，<code>isReserved</code>会过滤以<code>$,_</code>开头的变量，<code>proxy</code>会为实例数据的访问做代理，当我们访问<code>this.message</code>时，实际上访问的是<code>this._data.message</code>,而有了<code>isReserved</code>的筛选，即使<code>this._data._test</code>存在，我们依旧无法在访问<code>this._test</code>时拿到<code>_test</code>变量。这就解释了为什么会有变量没有被声明的语法错误，而<code>proxy</code>的实现，又是基于上述提到的<code>Object.defineProperty</code>来实现的。</p><pre><code class="js">function proxy (target, sourceKey, key) &#123;    sharedPropertyDefinition.get = function proxyGetter () &#123;        // 当访问this[key]时，会代理访问this._data[key]的值        return this[sourceKey][key]    &#125;;    sharedPropertyDefinition.set = function proxySetter (val) &#123;        this[sourceKey][key] = val;    &#125;;    Object.defineProperty(target, key, sharedPropertyDefinition);&#125;</code></pre><h2 id="2-3-小结"><a href="#2-3-小结" class="headerlink" title="2.3 小结"></a>2.3 小结</h2><p>这一节内容，详细的介绍了数据代理在<code>Vue</code>的实现思路和另一个应用场景，数据代理是一种设计模式，也是一种编程思想，<code>Object.defineProperty</code>和<code>Proxy</code>都可以实现数据代理，但是他们各有优劣，前者兼容性较好，但是却无法对数组或者嵌套的对象进行代理监测，而<code>Proxy</code>基本可以解决所有的问题，但是对兼容性要求很高。<code>Vue</code>中的响应式系统是以<code>Object.defineProperty</code>实现的，但是这并不代表没有<code>Proxy</code>的应用。<code>initProxy</code>就是其中的例子，这层代理会在模板渲染时对一些非法或者没有定义的变量进行筛选判断，和没有数据代理相比，非法的数据定义错误会提前到应用层捕获，这也有利于开发者对错误的排查。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Vue </category>
          
          <category> vue2.x源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>发布活动类</title>
      <link href="/computer-science/fangweix/fb/"/>
      <url>/computer-science/fangweix/fb/</url>
      
        <content type="html"><![CDATA[<h1 id="先上效果图"><a href="#先上效果图" class="headerlink" title="先上效果图"></a>先上效果图</h1><table><thead><tr><th>活动列表页</th><th>发起活动</th><th>消息通知</th><th>首页侧边栏</th><th>活动详情</th><th>后台管理列表页</th></tr></thead><tbody><tr><td><img data-src="/images/fb/1.png" alt="Image 1"></td><td><img data-src="/images/fb/2.png" alt="Image 2"></td><td><img data-src="/images/fb/3.png" alt="Image 3"></td><td><img data-src="/images/fb/4.png" alt="Image 3"></td><td><img data-src="/images/fb/5.png" alt="Image 4"></td><td><img data-src="/images/fb/6.png" alt="Image 5"></td></tr></tbody></table><h1 id="项目架构"><a href="#项目架构" class="headerlink" title="项目架构"></a>项目架构</h1><pre><code class="text">移动端：微信小程序服务端：springbootmybatis-plusmysql </code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>仿微信聊天源码解析（uniapp + springboot）</title>
      <link href="/computer-science/fangweix/fwx/"/>
      <url>/computer-science/fangweix/fwx/</url>
      
        <content type="html"><![CDATA[<h1 id="先上效果图"><a href="#先上效果图" class="headerlink" title="先上效果图"></a>先上效果图</h1><table><thead><tr><th>登录页面</th><th>消息列表</th><th>聊天列表</th><th>通讯录</th><th>发现</th><th>我的</th></tr></thead><tbody><tr><td><img data-src="/images/fwx/login.png" alt="Image 1"></td><td><img data-src="/images/fwx/1.png" alt="Image 2"></td><td><img data-src="/images/fwx/chat.png" alt="Image 3"></td><td><img data-src="/images/fwx/2.png" alt="Image 3"></td><td><img data-src="/images/fwx/3.png" alt="Image 4"></td><td><img data-src="/images/fwx/4.png" alt="Image 5"></td></tr></tbody></table><h1 id="项目架构"><a href="#项目架构" class="headerlink" title="项目架构"></a>项目架构</h1><pre><code class="text">移动端：uniapp服务端：springbootmybatis-plusmysql </code></pre><h1 id="移动端核心代码架构实现方式"><a href="#移动端核心代码架构实现方式" class="headerlink" title="移动端核心代码架构实现方式"></a>移动端核心代码架构实现方式</h1><pre><code class="javascript">import requestUrl from &#39;@/api/url.js&#39;;import $store from &#39;@/store/index.js&#39;;import noticeUtil from &#39;@/util/noticeUtil.js&#39;;import timeUtil from &#39;@/util/timeUtil.js&#39;;import userRequest from &#39;@/api/user.js&#39;;export default &#123;    //连接websocket    initConnect() &#123;        uni.closeSocket() //创建新的socket连接前确保旧的已关闭        //创建一个socket连接        uni.connectSocket(&#123;            url: requestUrl.getWebsokcetUrl() + $store.state.token,            success: res =&gt; &#123;&#125;,            fail(res) &#123;                console.log(res)            &#125;        &#125;)        //监听socket打开        uni.onSocketOpen(() =&gt; &#123;            $store.state.isSocketOpen = true            uni.showToast(&#123;                icon: &#39;success&#39;,                title: &#39;成功连接websocket！&#39;            &#125;)            //连接之后才开始获取数据            $store.dispatch(&#39;getMessage&#39;);        &#125;)        //监听socket关闭        uni.onSocketClose(() =&gt; &#123;            $store.state.isSocketOpen = false            console.log(&#39;WebSocket连接已关闭！&#39;);            //connectSocketInit(); //尝试重连        &#125;)        //监听socket错误        uni.onSocketError(() =&gt; &#123;            $store.state.isSocketOpen = false            console.log(&#39;WebSocket连接打开失败&#39;);            // 用户下线            $store.state.isSocketOpen = false;            console.log(&#39;socket连接错误&#39;)            if (!$store.state.isSocketOpen) &#123;                setTimeout(function() &#123;                    //reconnect();                &#125;, 3000);            &#125;        &#125;)        //监听socket消息        uni.onSocketMessage((res) =&gt; &#123;            let data = JSON.parse(res.data) //socket信息是字符串，需要先转成json形式再去解析内容            switch (data.type) &#123;                ////撤回消息                case &#39;person-withdraw&#39;:                    //console.log(data)                    for (let i = 0; i &lt; $store.state.personMessage.length; i++) &#123;                        if ($store.state.personMessage[i].sessionId == data.data.sessionId) &#123;                            for (let j = $store.state.personMessage[i].list.length - 1; j &gt;= 0; j--) &#123;                                if ($store.state.personMessage[i].list[j].id == data.data.messageId) &#123;                                    $store.state.personMessage[i].list[j].isWithdrawn = 1                                    break                                &#125;                            &#125;                            break;                        &#125;                    &#125;                    break;                case &#39;group-withdraw&#39;:                    //console.log(data)                    for (let i = 0; i &lt; $store.state.groupMessage.length; i++) &#123;                        if ($store.state.groupMessage[i].groupId == data.data.groupId) &#123;                            for (let j = $store.state.groupMessage[i].list.length - 1; j &gt;= 0; j--) &#123;                                if ($store.state.groupMessage[i].list[j].id == data.data.messageId) &#123;                                    $store.state.groupMessage[i].list[j].isWithdrawn = 1                                    break                                &#125;                            &#125;                            break;                        &#125;                    &#125;                    break;                case &#39;token-failed&#39;:                    uni.showToast(&#123;                        title: &#39;身份验证已过期&#39;,                        icon: &#39;none&#39;                    &#125;)                    setTimeout(() =&gt; &#123;                        uni.redirectTo(&#123;                            url: &#39;pages/login/login&#39;                        &#125;)                    &#125;, 1000)                    break;                case &#39;person-apply&#39;:                    uni.showToast(&#123;                        icon: &#39;none&#39;,                        title: &#39;你收到了一个好友请求&#39;                    &#125;)                    $store.dispatch(&#39;getNoticeList&#39;);                    if ($store.state.systemConfig.bell) &#123;                        noticeUtil.playSystemAudio();                    &#125;                    //#ifdef APP                    if ($store.state.systemConfig.vibrate) &#123;                        uni.vibrateShort()                    &#125;                    //#endif                    break;                case &#39;count&#39;:                    $store.state.onlineArray = data.data                    //console.log(data)                    // uni.showToast(&#123;                    // title:&#39;共&#39;+data.data.length+&#39;人在线&#39;,                    // icon:&#39;none&#39;                    // &#125;)                    break;                case &#39;person-apply-agree&#39;:                    //刷新一遍好友列表                    $store.dispatch(&#39;getFriendList&#39;)                    let friend = data.data                    if (friend.myId == $store.state.loginUserInfo.id) &#123;                        $store.dispatch(&#39;getNoticeList&#39;)                        ////                        console.log(&#39;这里需要向好友发送一个消息&#39;)                        let m = &#123;                            senderId: friend.myId,                            receiverId: friend.friendId,                            sendTime: timeUtil.getFormatTime(new Date()),                            content: &#39;我同意了你的好友申请~&#39;,                            messageType: &#39;text&#39;,                            sessionId: friend.sessionId                        &#125;                        let msg = &#123;                            type: &#39;person-message&#39;,                            data: m                        &#125;                        uni.sendSocketMessage(&#123;                            data: JSON.stringify(msg),                            fail() &#123;                                uni.showToast(&#123;                                    title: &#39;发送失败&#39;,                                    icon: &#39;error&#39;                                &#125;)                            &#125;                        &#125;)                        uni.showToast(&#123;                            title: &#39;添加成功！&#39;,                            icon: &#39;success&#39;                        &#125;)                    &#125;                    break;                case &#39;notice-refresh&#39;:                    $store.dispatch(&#39;getNoticeList&#39;)                    uni.showToast(&#123;                        title: data.data,                        icon: &#39;none&#39;                    &#125;)                    break;                case &#39;person-message&#39;:                    let message = data.data                    /////消息加入消息历史列表                    for (let i = 0; i &lt; $store.state.personMessage.length; i++) &#123;                        if ($store.state.personMessage[i].sessionId == message.sessionId) &#123;                            $store.state.personMessage[i].list.push(message)                            break                        &#125;                    &#125;                    ///更新消息记录                    $store.state.lastUpdateSession = &#123;                        id: message.sessionId,                        count: $store.state.lastUpdateSession.count + 1                    &#125;                    ///如果消息不是我发的 则响铃                    if (message.senderId != $store.state.loginUserInfo.id) &#123;                        if ($store.state.systemConfig.bell) &#123;                            noticeUtil.playMessageAudio();                        &#125;                        //#ifdef APP                        if ($store.state.systemConfig.vibrate) &#123;                            uni.vibrateShort()                        &#125;                        //#endif                    &#125;                    /////更新绘画列表状态                    for (let i = 0; i &lt; $store.state.sessionList.length; i++) &#123;                        if ($store.state.sessionList[i].sessionId == message.sessionId) &#123;                            $store.state.sessionList[i].updateTime = message.updateTime                            switch (message.messageType) &#123;                                case &#39;image&#39;:                                    $store.state.sessionList[i].lastMessage = &#39;【图片】&#39;;                                    break;                                case &#39;file&#39;:                                    $store.state.sessionList[i].lastMessage = &#39;【文件】&#39;;                                    break;                                case &#39;audio&#39;:                                    $store.state.sessionList[i].lastMessage = &#39;【语音】&#39;;                                    break;                                case &#39;video&#39;:                                    $store.state.sessionList[i].lastMessage = &#39;【视频】&#39;;                                    break;                                default:                                    $store.state.sessionList[i].lastMessage = message.content;                            &#125;                            //console.log()                            ////没有在这个对话 未读++                            if ($store.state.chattingUserInfo == null || $store.state.chattingUserInfo                                .sessionId != $store.state.sessionList[i].sessionId) &#123;                                if (message.senderId != $store.state.loginUserInfo.id)                                    $store.state.sessionList[i].unread++;                            &#125; else &#123; ///否则已读                                $store.dispatch(&#39;clearUnread&#39;, &#123;                                    myId: $store.state.loginUserInfo.id,                                    friendId: $store.state.chattingUserInfo.chattingUserId                                &#125;)                            &#125;                            ///需要把对话移到第一位                            let session = $store.state.sessionList.splice(i, 1);                            $store.state.sessionList = session.concat($store.state.sessionList)                            break;                        &#125;                    &#125;                    $store.dispatch(&#39;countUnreadMessage&#39;)                    break;                case &#39;join-success&#39;:                    let member = data.data                    uni.showToast(&#123;                        title: &#39;加入成功！&#39;,                        icon: &#39;success&#39;                    &#125;)                    $store.dispatch(&#39;getFriendList&#39;);                    console.log(member)                    let m = &#123;                        senderId: $store.state.loginUserInfo.id,                        senderName: $store.state.loginUserInfo.nickname,                        avatar: $store.state.loginUserInfo.avatar,                        sendTime: timeUtil.getFormatTime(new Date()),                        content: &#39;我已加入群聊&#39;,                        messageType: &#39;text&#39;,                        groupId: member.groupId //this.chattingGroupInfo.sessionId                    &#125;                    let msg = &#123;                        type: &#39;group-message&#39;,                        data: m                    &#125;                    uni.sendSocketMessage(&#123;                        data: JSON.stringify(msg),                        fail(res) &#123;                            uni.showToast(&#123;                                icon: &#39;error&#39;,                                title: &#39;发送失败&#39;                            &#125;)                        &#125;                    &#125;)                    break;                case &#39;group-message&#39;:                    let group_message = data.data                    /////消息加入消息历史列表                    for (let i = 0; i &lt; $store.state.groupMessage.length; i++) &#123;                        if ($store.state.groupMessage[i].groupId == group_message.groupId) &#123;                            $store.state.groupMessage[i].list.push(group_message)                            break                        &#125;                    &#125;                    ///更新消息记录                    $store.state.lastUpdateSession = &#123;                        id: group_message.groupId,                        count: $store.state.lastUpdateSession.count + 1                    &#125;                    ///如果消息不是我发的 则响铃                    if (group_message.senderId != $store.state.loginUserInfo.id) &#123;                        if ($store.state.systemConfig.bell) &#123;                            noticeUtil.playMessageAudio();                        &#125;                        //#ifdef APP                        if ($store.state.systemConfig.vibrate) &#123;                            uni.vibrateShort()                        &#125;                        //#endif                    &#125;                    /////更新绘画列表状态                    for (let i = 0; i &lt; $store.state.sessionList.length; i++) &#123;                        if ($store.state.sessionList[i].sessionId == group_message.groupId) &#123;                            $store.state.sessionList[i].updateTime = group_message.updateTime                            switch (group_message.messageType) &#123;                                case &#39;image&#39;:                                    $store.state.sessionList[i].lastMessage = group_message.senderName +                                    &#39;:【图片】&#39;;                                    break;                                case &#39;file&#39;:                                    $store.state.sessionList[i].lastMessage = group_message.senderName +                                    &#39;:【文件】&#39;;                                    break;                                case &#39;audio&#39;:                                    $store.state.sessionList[i].lastMessage = group_message.senderName +                                    &#39;:【语音】&#39;;                                    break;                                case &#39;video&#39;:                                    $store.state.sessionList[i].lastMessage = group_message.senderName +                                    &#39;:【视频】&#39;;                                    break;                                default:                                    $store.state.sessionList[i].lastMessage = group_message.senderName + &#39;:&#39; +                                        group_message.content;                            &#125;                            //console.log()                            ////没有在这个对话 未读++                            if ($store.state.chattingGroupInfo == null || $store.state.chattingGroupInfo                                .sessionId != $store.state.sessionList[i].sessionId) &#123;                                if (group_message.senderId != $store.state.loginUserInfo.id)                                    $store.state.sessionList[i].unread++;                            &#125; else &#123; ///否则已读                                $store.dispatch(&#39;clearGroupUnread&#39;, &#123;                                    userId: $store.state.loginUserInfo.id,                                    groupId: $store.state.chattingGroupInfo.sessionId                                &#125;)                            &#125;                            ///需要把对话移到第一位                            let session = $store.state.sessionList.splice(i, 1);                            $store.state.sessionList = session.concat($store.state.sessionList)                            break;                        &#125;                    &#125;                    $store.dispatch(&#39;countUnreadMessage&#39;)                    break;            &#125;        &#125;)    &#125;&#125;</code></pre><h1 id="服务端核心代码架构实现方式"><a href="#服务端核心代码架构实现方式" class="headerlink" title="服务端核心代码架构实现方式"></a>服务端核心代码架构实现方式</h1><pre><code class="java">package com.ddchat_server.websocket.component;import cn.hutool.json.JSONObject;import cn.hutool.json.JSONUtil;import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;import com.ddchat_server.entity.*;import com.ddchat_server.mapper.*;import com.ddchat_server.service.FriendService;import com.ddchat_server.service.MessageService;import com.ddchat_server.util.JWTUtils;import com.ddchat_server.util.SnowFlakeUtil;import com.ddchat_server.websocket.domain.SocketMessage;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import javax.websocket.*;import javax.websocket.server.PathParam;import javax.websocket.server.ServerEndpoint;import java.util.List;import java.util.Map;import java.util.Objects;import java.util.concurrent.ConcurrentHashMap;@ServerEndpoint(&quot;/socket/&#123;token&#125;&quot;)@Componentpublic class SocketServer &#123;    ///用来保存,用户的session    public static Map&lt;String, Session&gt; userSessionMap = new ConcurrentHashMap&lt;&gt;();    public static MessageMapper messageMapper;    public static NoticeMapper noticeMapper;    public static FriendMapper friendMapper;    public static FriendService friendService;    public static MessageService messageService;    public static MemberMapper memberMapper;    @Autowired    public void setMemberMapper(MemberMapper memberMapper) &#123;        SocketServer.memberMapper = memberMapper;    &#125;    @Autowired    public void setMessageService(MessageService messageService) &#123;        SocketServer.messageService = messageService;    &#125;    @Autowired    public void setFriendService(FriendService friendService) &#123;        SocketServer.friendService = friendService;    &#125;    @Autowired    public void setFriendMapper(FriendMapper friendMapper) &#123;        SocketServer.friendMapper = friendMapper;    &#125;    @Autowired    public void setMessageMapper(MessageMapper messageMapper) &#123;        SocketServer.messageMapper = messageMapper;    &#125;    @Autowired    void setNoticeMapper(NoticeMapper noticeMapper) &#123;        SocketServer.noticeMapper = noticeMapper;    &#125;    @OnOpen    public void onOpen(Session session, @PathParam(&quot;token&quot;) String token) &#123;        ///检查token是否生效        String id;        try &#123;            if (!JWTUtils.verify(token)) throw new Exception(&quot;身份验证失败&quot;);            JSONObject jsonObject = JWTUtils.parseJWT(token);            id = jsonObject.getStr(&quot;id&quot;);        &#125; catch (Exception e) &#123;            this.sendMessage(new SocketMessage&lt;&gt;(&quot;token-failed&quot;, null), session);            return;        &#125;        userSessionMap.put(id, session);        //System.out.println(&quot;用户：&quot;+id+&quot;已经上线&quot;);        this.sendToAll(new SocketMessage&lt;&gt;(&quot;count&quot;, userSessionMap.keySet().toArray()));    &#125;    @OnClose    public void onClose(Session session, @PathParam(&quot;token&quot;) String token) &#123;        String id = JWTUtils.parseJWT(token).getStr(&quot;id&quot;);        userSessionMap.remove(id);        //System.out.println(&quot;用户：&quot;+id+&quot;已经离线&quot;);        this.sendToAll(new SocketMessage&lt;&gt;(&quot;count&quot;, userSessionMap.keySet().toArray()));    &#125;    @OnError    public void onError(Session session, Throwable error, @PathParam(&quot;token&quot;) String token) &#123;        String id = JWTUtils.parseJWT(token).getStr(&quot;id&quot;);        userSessionMap.remove(id);        // System.out.println(&quot;用户：&quot;+id+&quot;已经离线&quot;);        this.sendToAll(new SocketMessage&lt;&gt;(&quot;count&quot;, userSessionMap.keySet().toArray()));    &#125;    @OnMessage    public void onMessage(String message, Session session, @PathParam(&quot;token&quot;) String token) &#123;        JSONObject m = JSONUtil.parseObj(message);        //System.out.println(m.get(&quot;type&quot;));        JSONObject data = m.getJSONObject(&quot;data&quot;);        switch (m.getStr(&quot;type&quot;)) &#123;            case &quot;person-apply&quot;:                ////构造通知消息对象                Notice notice = new Notice(null, data.getLong(&quot;senderId&quot;),                        data.getLong(&quot;receiverId&quot;),                        &quot;person-apply&quot;,                        m.getStr(&quot;data&quot;), false);                noticeMapper.insert(notice);                this.sendToUserById(data.getStr(&quot;receiverId&quot;), new SocketMessage&lt;&gt;(&quot;person-apply&quot;, m.getStr(&quot;data&quot;)));                break;            case &quot;person-apply-agree&quot;:                Notice notice1 = noticeMapper.selectById(data.getStr(&quot;id&quot;));                JSONObject jsonObject = JSONUtil.parseObj(notice1.getInformation());                ////检查两人是否为好友                if (friendService.checkIfFriend(notice1.getSenderId().toString(), notice1.getReceiverId().toString())) &#123;                    notice1.setIsRead(true);                    noticeMapper.updateById(notice1);                    this.sendToUserById(notice1.getReceiverId().toString(), new SocketMessage&lt;&gt;(&quot;notice-refresh&quot;, &quot;TA已经是你的好友了！&quot;));                    break;                &#125;                ////构造好友关系                Long sessionId = SnowFlakeUtil.getSnowFlakeId();                Friend friend1 = new Friend(null, notice1.getSenderId(), notice1.getReceiverId(),                        jsonObject.getStr(&quot;notation&quot;), sessionId, &quot;&quot;, 0, false);                Friend friend2 = new Friend(null, notice1.getReceiverId(), notice1.getSenderId(),                        jsonObject.getStr(&quot;senderName&quot;), sessionId, &quot;&quot;, 0, false);                friendMapper.insert(friend1);                friendMapper.insert(friend2);                notice1.setIsRead(true);                noticeMapper.updateById(notice1);                ///构造消息                SocketMessage&lt;Friend&gt; socketMessage = new SocketMessage&lt;&gt;(&quot;person-apply-agree&quot;, friend2);                this.sendToUserById(notice1.getSenderId().toString(), socketMessage);                this.sendToUserById(notice1.getReceiverId().toString(), socketMessage);                break;            case &quot;person-message&quot;:                ///////构造消息                Message message1 = new Message(SnowFlakeUtil.getSnowFlakeId().toString(), data.getStr(&quot;sessionId&quot;),                        data.getStr(&quot;senderId&quot;),                        data.getStr(&quot;receiverId&quot;), data.getStr(&quot;sendTime&quot;), data.getStr(&quot;content&quot;), data.getStr(&quot;messageType&quot;),                        0);                messageService.storeMessage(message1);                this.sendToUserById(message1.getSenderId(), new SocketMessage&lt;&gt;(&quot;person-message&quot;, message1));                this.sendToUserById(message1.getReceiverId(), new SocketMessage&lt;&gt;(&quot;person-message&quot;, message1));                break;            case &quot;join-group&quot;:                //////先检查该用户是否在群里                String userId = data.getStr(&quot;userId&quot;);                String groupId = data.getStr(&quot;groupId&quot;);                QueryWrapper&lt;Member&gt; queryWrapper = new QueryWrapper&lt;&gt;();                queryWrapper.eq(&quot;member_id&quot;, userId).eq(&quot;group_id&quot;, groupId).eq(&quot;is_deleted&quot;, false);                List&lt;Member&gt; members = memberMapper.selectList(queryWrapper);                if (members.size() != 0) &#123;                    Member member = members.get(0);                    this.sendToUserById(member.getMemberId().toString(), new SocketMessage&lt;&gt;(&quot;join-success&quot;, member));                    return;                &#125;                ////创建关系                Member member = new Member(null, Long.parseLong(userId), groupId, 0, &quot;&quot;, false);                memberMapper.insert(member);                this.sendToUserById(member.getMemberId().toString(), new SocketMessage&lt;&gt;(&quot;join-success&quot;, member));                break;            case &quot;group-message&quot;:                ///查找该群的全部用户                String group_id = data.getStr(&quot;groupId&quot;);                QueryWrapper&lt;Member&gt; memberQueryWrapper = new QueryWrapper&lt;&gt;();                memberQueryWrapper.eq(&quot;is_deleted&quot;, false).eq(&quot;group_id&quot;, group_id);                memberQueryWrapper.select(&quot;member_id&quot;);                ////保存聊天记录                GroupMessage groupMessage = new GroupMessage(SnowFlakeUtil.getSnowFlakeId().toString(), group_id, data.getStr(&quot;senderId&quot;), data.getStr(&quot;senderName&quot;),                        data.getStr(&quot;avatar&quot;), data.getStr(&quot;sendTime&quot;), data.getStr(&quot;content&quot;), data.getStr(&quot;messageType&quot;), 0);                messageService.StoreGroupMessage(groupMessage);                List&lt;Object&gt; ids = memberMapper.selectObjs(memberQueryWrapper);                for (Object id : ids) &#123;                    ////发送给每一个人                    this.sendToUserById(id.toString(), new SocketMessage&lt;&gt;(&quot;group-message&quot;, groupMessage));                &#125;                break;            ///收到了撤回消息            case &quot;person-withdraw&quot;:                String messageId = data.getStr(&quot;messageId&quot;);                String senderId = data.getStr(&quot;senderId&quot;);                String receiverId = data.getStr(&quot;receiverId&quot;);                ///更新数据库                messageService.withdrawMessage(messageId);                /////发送给用户                this.sendToUserById(senderId, new SocketMessage&lt;&gt;(&quot;person-withdraw&quot;, data));                this.sendToUserById(receiverId, new SocketMessage&lt;&gt;(&quot;person-withdraw&quot;, data));            case &quot;group-withdraw&quot;:                String groupMessageId = data.getStr(&quot;messageId&quot;);                String groupId1 = data.getStr(&quot;groupId&quot;);                ///更新数据库                messageService.withdrawGroupMessage(groupMessageId);                /////发送给用户                QueryWrapper&lt;Member&gt; memberQueryWrapper1 = new QueryWrapper&lt;&gt;();                memberQueryWrapper1.eq(&quot;is_deleted&quot;, false).eq(&quot;group_id&quot;, groupId1);                memberQueryWrapper1.select(&quot;member_id&quot;);                List&lt;Object&gt; ids1 = memberMapper.selectObjs(memberQueryWrapper1);                for (Object id : ids1) &#123;                    ////发送给每一个人                    this.sendToUserById(id.toString(), new SocketMessage&lt;&gt;(&quot;group-withdraw&quot;, data));                &#125;                break;        &#125;    &#125;    public void sendToAll(SocketMessage&lt;?&gt; message) &#123;        for (Session session : userSessionMap.values()) &#123;            this.sendMessage(message, session);        &#125;    &#125;    public void sendToUserById(String id, SocketMessage&lt;?&gt; message) &#123;        for (String key : userSessionMap.keySet()) &#123;            if (Objects.equals(key, id)) &#123;                this.sendMessage(message, userSessionMap.get(key));                return;            &#125;        &#125;    &#125;    public void sendMessage(SocketMessage&lt;?&gt; message, Session toSession) &#123;        try &#123;            if (toSession.isOpen()) &#123;                synchronized (toSession) &#123;                    toSession.getAsyncRemote().sendText(JSONUtil.toJsonStr(message));                &#125;            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>step.3 react-router</title>
      <link href="/computer-science/react0-1/react-router/"/>
      <url>/computer-science/react0-1/react-router/</url>
      
        <content type="html"><![CDATA[<h1 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h1><p><span class="exturl" data-url="aHR0cHM6Ly9yZWFjdHJvdXRlci5jb20v">英文文档</span><br><span class="exturl" data-url="aHR0cDovL3JlYWN0LXJvdXRlci5kb2NzY2hpbmEub3JnLw==">中文文档</span></p><h1 id="依赖库"><a href="#依赖库" class="headerlink" title="依赖库"></a>依赖库</h1><p>react-router-dom</p><h1 id="link-标签"><a href="#link-标签" class="headerlink" title="link 标签"></a>link 标签</h1><pre><code class="JavaScript">当 to 是一个字符串时，它表示链接的目标 URL。在 React Router 中，默认使用路径匹配规则进行匹配。也就是说，当用户点击 &lt;Link&gt; 组件时，React Router 将尝试与当前的 URL 进行匹配，如果找到匹配的路径，将会触发相应的路由渲染。例如，在你的示例中，to=&quot;/about&quot; 表示点击该链接时将导航到 /about 路径。当 to 是一个对象时，它可以包含以下属性：pathname：表示链接的目标路径。search：表示查询参数，可以是一个字符串或一个对象。hash：表示 URL 的哈希部分。state：表示附加的状态数据，可以在目标页面中访问到。这些属性将被组合成最终的目标 URL。&lt;Link to=&#123;&#123;  pathname: "/about",  search: "?sort=name",  hash: "#section",  state: &#123; fromDashboard: true &#125;&#125;&#125;&gt;About&lt;/Link&gt;上述代码中，点击链接后将导航到 /about?sort=name#section，并且可以通过路由状态访问 &#123; fromDashboard: true &#125;。</code></pre><h1 id="Route"><a href="#Route" class="headerlink" title="Route"></a>Route</h1><Route path="/about" component={About}/><h1 id="reactrouterV6-封装一个路由"><a href="#reactrouterV6-封装一个路由" class="headerlink" title="reactrouterV6 封装一个路由"></a>reactrouterV6 封装一个路由</h1><pre><code class="javascript">import React, &#123; lazy, Suspense, useMemo &#125; from &#39;react&#39;;import &#123; BrowserRouter as Router, Routes, Route &#125; from &#39;react-router-dom&#39;;import Tabbar from &#39;./Tabbar&#39;import Header from &#39;./Header&#39;;const indexpage = lazy(() =&gt; import(&#39;../page/index&#39;));const mypage = lazy(() =&gt; import(&#39;../page/my&#39;));// const Tab1ChildComponent = (&#123; data &#125;) =&gt; &#123;//     return &lt;div&gt;&#123;data&#125;&lt;/div&gt;;// &#125;;// const fetchData = () =&gt; &#123;//     // 模拟异步获取数据//     return new Promise((resolve) =&gt; &#123;//         setTimeout(() =&gt; &#123;//             resolve(&#39;Data&#39;);//         &#125;, 1000);//     &#125;);// &#125;;// const Tab1ContentWithMemo = () =&gt; &#123;//     const data = useMemo(() =&gt; &#123;//         return fetchData();//     &#125;, []);//     return &lt;Tab1ChildComponent data=&#123;data&#125; /&gt;;// &#125;;const Routeslay = () =&gt; &#123;    return (        &lt;Router&gt;            &lt;Header /&gt;            &lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;/div&gt;&#125;&gt;                &lt;Routes&gt;                    &lt;Route path=&quot;/&quot; Component=&#123;indexpage&#125; /&gt;                    &lt;Route path=&quot;/my&quot; Component=&#123;mypage&#125; /&gt;                &lt;/Routes&gt;            &lt;/Suspense&gt;            &lt;Tabbar /&gt;        &lt;/Router&gt;    );&#125;;export default Routeslay;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>step.1 react基础语法</title>
      <link href="/computer-science/react0-1/react%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/"/>
      <url>/computer-science/react0-1/react%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="react入门案例"><a href="#react入门案例" class="headerlink" title="react入门案例"></a>react入门案例</h1><pre><code class="html">  &lt;!-- 注意react 需要依赖这三个库 --&gt;    &lt;!-- 引入react核心库 --&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;    &lt;!-- 引入react-dom，用于支持react操作DOM --&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;    &lt;!-- 引入babel，用于将jsx转为js --&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;  &lt;!-- 准备好一个“容器” 用于挂载react的虚拟dom --&gt;    &lt;div id=&quot;test&quot;&gt;&lt;/div&gt;    &lt;script type=&quot;text/babel&quot; &gt; /* 此处一定要写babel */        //1.创建虚拟DOM        const VDOM = &lt;h1&gt;Hello,React&lt;/h1&gt; /* 此处一定不要写引号，因为不是字符串 */        //2.渲染虚拟DOM到页面        ReactDOM.render(VDOM,document.getElementById(&#39;test&#39;))    &lt;/script&gt;</code></pre><h1 id="react-虚拟dom的两种创建方式"><a href="#react-虚拟dom的两种创建方式" class="headerlink" title="react 虚拟dom的两种创建方式"></a>react 虚拟dom的两种创建方式</h1><pre><code class="html">  &lt;!-- 第一种 --&gt;  &lt;script type=&quot;text/babel&quot; &gt; /* 此处一定要写babel */        //1.创建虚拟DOM        const VDOM = (  /* 此处一定不要写引号，因为不是字符串 */            &lt;h1 id=&quot;title&quot;&gt;                &lt;span&gt;Hello,React&lt;/span&gt;            &lt;/h1&gt;        )        //2.渲染虚拟DOM到页面        ReactDOM.render(VDOM,document.getElementById(&#39;test&#39;))    &lt;/script&gt;  &lt;!-- 第二种 --&gt;   &lt;!-- 这种不需要依赖jsx  所以不需使用babel --&gt;  &lt;script type=&quot;text/javascript&quot;&gt;         //1.创建虚拟DOM        const VDOM = React.createElement(&#39;h1&#39;,&#123;id:&#39;title&#39;&#125;,React.createElement(&#39;span&#39;,&#123;&#125;,&#39;Hello,React&#39;))        1. 调用 React.createElement 函数，并传入三个参数：            第一个参数是要创建的元素类型，这里是 &#39;h1&#39;            第二个参数是一个对象，表示元素的属性，这里包含一个 &#39;id&#39; 属性，其值为 &#39;title&#39;            第三个参数是元素的子元素或文本内容，这里是另一个调用 React.createElement 函数创建的元素                2. 内部的 React.createElement(&#39;span&#39;,&#123;&#125;,&#39;Hello,React&#39;) 也是一个类似的过程，创建了一个 &#39;span&#39; 元素，没有属性，文本内容为 &#39;Hello,React&#39;。        3. 创建完内部的 &#39;span&#39; 元素后，它作为 &#39;h1&#39; 元素的子元素。        4. 最终得到一个嵌套的虚拟DOM树，其中顶层元素是 &#39;h1&#39; 元素，具有一个 &#39;id&#39; 属性和一个子元素，子元素是 &#39;span&#39; 元素，没有属性，文本内容为 &#39;Hello React&#39;。        //2.渲染虚拟DOM到页面        ReactDOM.render(VDOM,document.getElementById(&#39;test&#39;))    &lt;/script&gt;</code></pre><h1 id="jsx-语法规则"><a href="#jsx-语法规则" class="headerlink" title="jsx 语法规则"></a>jsx 语法规则</h1><ol><li>定义虚拟DOM时，不要写引号。</li><li>标签中混入JS表达式时要用{}。</li><li>样式的类名指定不要用class，要用className。</li><li>内联样式，要用style&#x3D;<code>&#123;&#123;key:value&#125;&#125;</code>的形式去写。</li><li>只有一个根标签</li><li>标签必须闭合</li><li>标签首字母<br> (1).若小写字母开头，则将该标签转为html中同名元素，若html中无该标签对应的同名元素，则报错。<br> (2).若大写字母开头，react就去渲染对应的组件，若组件没有定义，则报错。</li></ol><pre><code class="text">什么是js表达式 什么是js语句    1.表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方        下面这些都是表达式：            (1). a            (2). a+b            (3). demo(1)            (4). arr.map()             (5). function test () &#123;&#125;    2.语句(代码)：      下面这些都是语句(代码)：            (1).if()&#123;&#125;            (2).for()&#123;&#125;            (3).switch()&#123;case:xxxx&#125;</code></pre><h1 id="react-中定义组件"><a href="#react-中定义组件" class="headerlink" title="react 中定义组件"></a>react 中定义组件</h1><ol><li>函数式组件</li></ol><pre><code class="html">&lt;script type=&quot;text/babel&quot;&gt;        //1.创建函数式组件        function MyComponent()&#123;            console.log(this); //此处的this是undefined，因为babel编译后开启了严格模式            return &lt;h2&gt;我是用函数定义的组件(适用于【简单组件】的定义)&lt;/h2&gt;        &#125;        //2.渲染组件到页面        ReactDOM.render(&lt;MyComponent/&gt;,document.getElementById(&#39;test&#39;))        /*             执行了ReactDOM.render(&lt;MyComponent/&gt;.......之后，发生了什么？                    1.React解析组件标签，找到了MyComponent组件。                    2.发现组件是使用函数定义的，随后调用该函数，将返回的虚拟DOM转为真实DOM，随后呈现在页面中。        */    &lt;/script&gt;</code></pre><ol start="2"><li>类式组件</li></ol><pre><code class="html">&lt;script type=&quot;text/babel&quot;&gt;        //1.创建类式组件        class MyComponent extends React.Component &#123;            render()&#123;                //render是放在哪里的？—— MyComponent的原型对象上，供实例使用。                //render中的this是谁？—— MyComponent的实例对象 &lt;=&gt; MyComponent组件实例对象。                console.log(&#39;render中的this:&#39;,this);                return &lt;h2&gt;我是用类定义的组件(适用于【复杂组件】的定义)&lt;/h2&gt;            &#125;        &#125;        //2.渲染组件到页面        ReactDOM.render(&lt;MyComponent/&gt;,document.getElementById(&#39;test&#39;))        /*             执行了ReactDOM.render(&lt;MyComponent/&gt;.......之后，发生了什么？                    1.React解析组件标签，找到了MyComponent组件。                    2.发现组件是使用类定义的，随后new出来该类的实例，并通过该实例调用到原型上的render方法。                    3.将render返回的虚拟DOM转为真实DOM，随后呈现在页面中。        */    &lt;/script&gt;</code></pre><ol start="3"><li>2种创建方式的区别<ul><li><p>没有生命周期方法：函数组件没有像类组件那样的生命周期方法（如componentDidMount、componentDidUpdate等），这使得处理组件的挂载、更新和卸载过程相对困难。不过，函数组件可以使用 React 的钩子函数（Hooks）来模拟类似的行为。</p></li><li><p>没有内部状态管理：函数组件无法直接定义和管理内部状态（state），这意味着你无法在函数组件中使用 setState 方法来更新组件状态。但是，你可以使用 React Hooks 中的 useState 来管理局部状态。</p></li><li><p>无法使用 Refs：在函数组件内部，无法直接使用 ref 属性或 React.createRef() 创建的引用。不过，React 提供了 useRef 钩子来解决这个问题。</p></li><li><p>不适用于复杂逻辑：如果你的组件需要处理复杂的业务逻辑，包含多个生命周期方法和状态管理，函数组件可能会显得过于冗长和难以维护。在这种情况下，使用类组件可能更合适。</p></li></ul></li></ol><h1 id="react-组件的三大属性"><a href="#react-组件的三大属性" class="headerlink" title="react 组件的三大属性"></a>react 组件的三大属性</h1><h2 id="state"><a href="#state" class="headerlink" title="state"></a>state</h2><p>state 是什么?</p><p>State是React组件内部的一种机制，用于存储和管理组件的可变状态。<br>State是私有的，只能在组件内部进行修改。组件可以通过调用setState方法来更新State并重新渲染，React将自动处理UI更新。<br>在类组件中，state被定义在constructor方法中，并且可以通过this.state进行访问。</p><ol><li>非简写方式</li></ol><pre><code class="html">&lt;script type=&quot;text/babel&quot;&gt;        //1.创建组件        class Weather extends React.Component&#123;                        //构造器调用几次？ ———— 1次            constructor(props)&#123;                console.log(&#39;constructor&#39;);                super(props)                //初始化状态                this.state = &#123;isHot:false,wind:&#39;微风&#39;&#125;                //解决changeWeather中this指向问题                this.changeWeather = this.changeWeather.bind(this)            &#125;            //render调用几次？ ———— 1+n次 1是初始化的那次 n是状态更新的次数            render()&#123;                console.log(&#39;render&#39;);                //读取状态                const &#123;isHot,wind&#125; = this.state                return &lt;h1 onClick=&#123;this.changeWeather&#125;&gt;今天天气很&#123;isHot ? &#39;炎热&#39; : &#39;凉爽&#39;&#125;，&#123;wind&#125;&lt;/h1&gt;            &#125;            //changeWeather调用几次？ ———— 点几次调几次            changeWeather()&#123;                //changeWeather放在哪里？ ———— Weather的原型对象上，供实例使用                //由于changeWeather是作为onClick的回调，所以不是通过实例调用的，是直接调用                //类中的方法默认开启了局部的严格模式，所以changeWeather中的this为undefined                                console.log(&#39;changeWeather&#39;);                //获取原来的isHot值                const isHot = this.state.isHot                //严重注意：状态必须通过setState进行更新,且更新是一种合并，不是替换。                this.setState(&#123;isHot:!isHot&#125;)                console.log(this);                //严重注意：状态(state)不可直接更改，下面这行就是直接更改！！！                //this.state.isHot = !isHot //这是错误的写法            &#125;        &#125;        //2.渲染组件到页面        ReactDOM.render(&lt;Weather/&gt;,document.getElementById(&#39;test&#39;))                &lt;/script&gt;</code></pre><ol start="2"><li>简写方式</li></ol><pre><code class="html">&lt;script type=&quot;text/babel&quot;&gt;        //1.创建组件        class Weather extends React.Component&#123;            //初始化状态            state =             &#123;                isHot:false,                wind:&#39;微风&#39;            &#125;            render()&#123;                const &#123;isHot,wind&#125; = this.state                return (&lt;h1 onClick=&#123;this.changeWeather&#125;&gt;今天天气很&#123;isHot ? &#39;炎热&#39; : &#39;凉爽&#39;&#125;，&#123;wind&#125;&lt;/h1&gt;)            &#125;            //自定义方法————要用赋值语句的形式+箭头函数            changeWeather = ()=&gt;&#123;                const isHot = this.state.isHot                this.setState(&#123;isHot:!isHot&#125;)            &#125;        &#125;        //2.渲染组件到页面        ReactDOM.render(&lt;Weather/&gt;,document.getElementById(&#39;test&#39;))    &lt;/script&gt;</code></pre><h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><p>props是什么?</p><p>Props是React组件传递数据的一种机制，用于从父组件向子组件传递数据。<br>Props是只读的，子组件无法修改自己接收到的props。父组件可以通过更改传递给子组件的props来影响子组件的行为和呈现。<br>在函数组件中，props作为参数传递给组件函数。在类组件中，props可以通过this.props进行访问。</p><ol><li>props基本使用</li></ol><pre><code class="html">    &lt;!-- 准备好一个“容器” --&gt;    &lt;div id=&quot;test1&quot;&gt;&lt;/div&gt;    &lt;div id=&quot;test2&quot;&gt;&lt;/div&gt;    &lt;div id=&quot;test3&quot;&gt;&lt;/div&gt;        &lt;!-- 引入react核心库 --&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;    &lt;!-- 引入react-dom，用于支持react操作DOM --&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;    &lt;!-- 引入babel，用于将jsx转为js --&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;    &lt;script type=&quot;text/babel&quot;&gt;        //创建组件        class Person extends React.Component&#123;            render()&#123;                // console.log(this);                const &#123;name,age,sex&#125; = this.props                return (                    &lt;ul&gt;                        &lt;li&gt;姓名：&#123;name&#125;&lt;/li&gt;                        &lt;li&gt;性别：&#123;sex&#125;&lt;/li&gt;                        &lt;li&gt;年龄：&#123;age+1&#125;&lt;/li&gt;                    &lt;/ul&gt;                )            &#125;        &#125;        //渲染组件到页面        ReactDOM.render(&lt;Person name=&quot;jerry&quot; age=&#123;19&#125;  sex=&quot;男&quot;/&gt;,document.getElementById(&#39;test1&#39;))        ReactDOM.render(&lt;Person name=&quot;tom&quot; age=&#123;18&#125; sex=&quot;女&quot;/&gt;,document.getElementById(&#39;test2&#39;))        const p = &#123;name:&#39;老刘&#39;,age:18,sex:&#39;女&#39;&#125;        // console.log(&#39;@&#39;,...p);        // ReactDOM.render(&lt;Person name=&#123;p.name&#125; age=&#123;p.age&#125; sex=&#123;p.sex&#125;/&gt;,document.getElementById(&#39;test3&#39;))        ReactDOM.render(&lt;Person &#123;...p&#125;/&gt;,document.getElementById(&#39;test3&#39;))    &lt;/script&gt;</code></pre><ol start="2"><li>对props进行限制</li></ol><pre><code class="html">    &lt;!-- 准备好一个“容器” --&gt;    &lt;div id=&quot;test1&quot;&gt;&lt;/div&gt;    &lt;div id=&quot;test2&quot;&gt;&lt;/div&gt;    &lt;div id=&quot;test3&quot;&gt;&lt;/div&gt;        &lt;!-- 引入react核心库 --&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;    &lt;!-- 引入react-dom，用于支持react操作DOM --&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;    &lt;!-- 引入babel，用于将jsx转为js --&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;    &lt;!-- 引入prop-types，用于对组件标签属性进行限制 --&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/prop-types.js&quot;&gt;&lt;/script&gt;    &lt;script type=&quot;text/babel&quot;&gt;        //创建组件        class Person extends React.Component&#123;            render()&#123;                // console.log(this);                const &#123;name,age,sex&#125; = this.props                //props是只读的                //this.props.name = &#39;jack&#39; //此行代码会报错，因为props是只读的                return (                    &lt;ul&gt;                        &lt;li&gt;姓名：&#123;name&#125;&lt;/li&gt;                        &lt;li&gt;性别：&#123;sex&#125;&lt;/li&gt;                        &lt;li&gt;年龄：&#123;age+1&#125;&lt;/li&gt;                    &lt;/ul&gt;                )            &#125;        &#125;        //对标签属性进行类型、必要性的限制        Person.propTypes = &#123;            name:PropTypes.string.isRequired, //限制name必传，且为字符串            sex:PropTypes.string,//限制sex为字符串            age:PropTypes.number,//限制age为数值            speak:PropTypes.func,//限制speak为函数        &#125;        //指定默认标签属性值        Person.defaultProps = &#123;            sex:&#39;男&#39;,//sex默认值为男            age:18 //age默认值为18        &#125;        //渲染组件到页面        ReactDOM.render(&lt;Person name=&#123;100&#125; speak=&#123;speak&#125;/&gt;,document.getElementById(&#39;test1&#39;))        ReactDOM.render(&lt;Person name=&quot;tom&quot; age=&#123;18&#125; sex=&quot;女&quot;/&gt;,document.getElementById(&#39;test2&#39;))        const p = &#123;name:&#39;老刘&#39;,age:18,sex:&#39;女&#39;&#125;        // console.log(&#39;@&#39;,...p);        // ReactDOM.render(&lt;Person name=&#123;p.name&#125; age=&#123;p.age&#125; sex=&#123;p.sex&#125;/&gt;,document.getElementById(&#39;test3&#39;))        ReactDOM.render(&lt;Person &#123;...p&#125;/&gt;,document.getElementById(&#39;test3&#39;))        function speak()&#123;            console.log(&#39;我说话了&#39;);        &#125;    &lt;/script&gt;</code></pre><ol start="3"><li>props简写方式</li></ol><pre><code class="html">&lt;!-- 准备好一个“容器” --&gt;    &lt;div id=&quot;test1&quot;&gt;&lt;/div&gt;    &lt;div id=&quot;test2&quot;&gt;&lt;/div&gt;    &lt;div id=&quot;test3&quot;&gt;&lt;/div&gt;        &lt;!-- 引入react核心库 --&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;    &lt;!-- 引入react-dom，用于支持react操作DOM --&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;    &lt;!-- 引入babel，用于将jsx转为js --&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;    &lt;!-- 引入prop-types，用于对组件标签属性进行限制 --&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/prop-types.js&quot;&gt;&lt;/script&gt;    &lt;script type=&quot;text/babel&quot;&gt;        //创建组件        class Person extends React.Component&#123;            constructor(props)&#123;                //构造器是否接收props，是否传递给super，取决于：是否希望在构造器中通过this访问props                // console.log(props);                super(props)                console.log(&#39;constructor&#39;,this.props);            &#125;            //对标签属性进行类型、必要性的限制            static propTypes = &#123;                name:PropTypes.string.isRequired, //限制name必传，且为字符串                sex:PropTypes.string,//限制sex为字符串                age:PropTypes.number,//限制age为数值            &#125;            //指定默认标签属性值            static defaultProps = &#123;                sex:&#39;男&#39;,//sex默认值为男                age:18 //age默认值为18            &#125;                        render()&#123;                // console.log(this);                const &#123;name,age,sex&#125; = this.props                //props是只读的                //this.props.name = &#39;jack&#39; //此行代码会报错，因为props是只读的                return (                    &lt;ul&gt;                        &lt;li&gt;姓名：&#123;name&#125;&lt;/li&gt;                        &lt;li&gt;性别：&#123;sex&#125;&lt;/li&gt;                        &lt;li&gt;年龄：&#123;age+1&#125;&lt;/li&gt;                    &lt;/ul&gt;                )            &#125;        &#125;        //渲染组件到页面        ReactDOM.render(&lt;Person name=&quot;jerry&quot;/&gt;,document.getElementById(&#39;test1&#39;))</code></pre><ol start="4"><li>函数组件使用props</li></ol><pre><code class="html">&lt;!-- 准备好一个“容器” --&gt;    &lt;div id=&quot;test1&quot;&gt;&lt;/div&gt;    &lt;div id=&quot;test2&quot;&gt;&lt;/div&gt;    &lt;div id=&quot;test3&quot;&gt;&lt;/div&gt;        &lt;!-- 引入react核心库 --&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;    &lt;!-- 引入react-dom，用于支持react操作DOM --&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;    &lt;!-- 引入babel，用于将jsx转为js --&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;    &lt;!-- 引入prop-types，用于对组件标签属性进行限制 --&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/prop-types.js&quot;&gt;&lt;/script&gt;    &lt;script type=&quot;text/babel&quot;&gt;        //创建组件        function Person (props)&#123;            const &#123;name,age,sex&#125; = props            return (                    &lt;ul&gt;                        &lt;li&gt;姓名：&#123;name&#125;&lt;/li&gt;                        &lt;li&gt;性别：&#123;sex&#125;&lt;/li&gt;                        &lt;li&gt;年龄：&#123;age&#125;&lt;/li&gt;                    &lt;/ul&gt;                )        &#125;        Person.propTypes = &#123;            name:PropTypes.string.isRequired, //限制name必传，且为字符串            sex:PropTypes.string,//限制sex为字符串            age:PropTypes.number,//限制age为数值        &#125;        //指定默认标签属性值        Person.defaultProps = &#123;            sex:&#39;男&#39;,//sex默认值为男            age:18 //age默认值为18        &#125;        //渲染组件到页面        ReactDOM.render(&lt;Person name=&quot;jerry&quot;/&gt;,document.getElementById(&#39;test1&#39;))</code></pre><h2 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h2><p>Refs是React提供的一种访问DOM元素或组件实例的方法。</p><p>Refs主要用于以下几个方面：</p><p>访问DOM元素：通过ref属性将DOM元素与React组件关联起来，从而可以直接访问和操作该DOM元素。<br>访问组件实例：通过ref属性将组件实例与另一个组件关联起来，从而可以直接调用被关联组件的方法或访问其属性。<br>在函数组件中，可以使用useRef钩子来创建和访问引用。在类组件中，可以使用createRef方法来创建和访问引用。</p><ol><li>字符串形式的ref</li></ol><pre><code class="html">    &lt;script type=&quot;text/babel&quot;&gt;        //创建组件        class Demo extends React.Component &#123;            //展示左侧输入框的数据            showData = () =&gt; &#123;                const &#123; input1 &#125; = this.refs                alert(input1.value)            &#125;            //展示右侧输入框的数据            showData2 = () =&gt; &#123;                const &#123; input2 &#125; = this.refs                alert(input2.value)            &#125;            render() &#123;                return (                    &lt;div&gt;                        &lt;input ref=&quot;input1&quot; type=&quot;text&quot; placeholder=&quot;点击按钮提示数据&quot; /&gt;&amp;nbsp;                        &lt;button onClick=&#123;this.showData&#125;&gt;点我提示左侧的数据&lt;/button&gt;&amp;nbsp;                        &lt;input ref=&quot;input2&quot; onBlur=&#123;this.showData2&#125; type=&quot;text&quot; placeholder=&quot;失去焦点提示数据&quot; /&gt;                    &lt;/div&gt;                )            &#125;        &#125;        //渲染组件到页面        ReactDOM.render(&lt;Demo a=&quot;1&quot; b=&quot;2&quot; /&gt;, document.getElementById(&#39;test&#39;))    &lt;/script&gt;</code></pre><ol start="2"><li>回调函数形式的ref</li></ol><pre><code class="html">    &lt;script type=&quot;text/babel&quot;&gt;        //创建组件        class Demo extends React.Component&#123;            //展示左侧输入框的数据            showData = ()=&gt;&#123;                const &#123;input1&#125; = this                alert(input1.value)            &#125;            //展示右侧输入框的数据            showData2 = ()=&gt;&#123;                const &#123;input2&#125; = this                alert(input2.value)            &#125;            render()&#123;                return(                    &lt;div&gt;                        &lt;input ref=&#123;c =&gt; this.input1 = c &#125; type=&quot;text&quot; placeholder=&quot;点击按钮提示数据&quot;/&gt;&amp;nbsp;                        &lt;button onClick=&#123;this.showData&#125;&gt;点我提示左侧的数据&lt;/button&gt;&amp;nbsp;                        &lt;input onBlur=&#123;this.showData2&#125; ref=&#123;c =&gt; this.input2 = c &#125; type=&quot;text&quot; placeholder=&quot;失去焦点提示数据&quot;/&gt;&amp;nbsp;                    &lt;/div&gt;                )            &#125;        &#125;        //渲染组件到页面        ReactDOM.render(&lt;Demo a=&quot;1&quot; b=&quot;2&quot;/&gt;,document.getElementById(&#39;test&#39;))    &lt;/script&gt;</code></pre><ol start="3"><li>回调ref中回调执行次数的问题</li></ol><pre><code class="html">&lt;script type=&quot;text/babel&quot;&gt;        //创建组件        class Demo extends React.Component&#123;            state = &#123;isHot:false&#125;            showInfo = ()=&gt;&#123;                const &#123;input1&#125; = this                alert(input1.value)            &#125;            changeWeather = ()=&gt;&#123;                //获取原来的状态                const &#123;isHot&#125; = this.state                //更新状态                this.setState(&#123;isHot:!isHot&#125;)            &#125;            saveInput = (c)=&gt;&#123;                this.input1 = c;                console.log(&#39;@&#39;,c);            &#125;            render()&#123;                const &#123;isHot&#125; = this.state                return(                    &lt;div&gt;                        &lt;h2&gt;今天天气很&#123;isHot ? &#39;炎热&#39;:&#39;凉爽&#39;&#125;&lt;/h2&gt;                        &#123;/*&lt;input ref=&#123;(c)=&gt;&#123;this.input1 = c;console.log(&#39;@&#39;,c);&#125;&#125; type=&quot;text&quot;/&gt;&lt;br/&gt;&lt;br/&gt;*/&#125;                        &lt;input ref=&#123;this.saveInput&#125; type=&quot;text&quot;/&gt;&lt;br/&gt;&lt;br/&gt;                        &lt;button onClick=&#123;this.showInfo&#125;&gt;点我提示输入的数据&lt;/button&gt;                        &lt;button onClick=&#123;this.changeWeather&#125;&gt;点我切换天气&lt;/button&gt;                    &lt;/div&gt;                )            &#125;        &#125;        //渲染组件到页面        ReactDOM.render(&lt;Demo/&gt;,document.getElementById(&#39;test&#39;))&lt;/script&gt;</code></pre><ol start="4"><li>createRef</li></ol><pre><code class="html">&lt;script type=&quot;text/babel&quot;&gt;        //创建组件        class Demo extends React.Component&#123;            /*                 React.createRef调用后可以返回一个容器，该容器可以存储被ref所标识的节点,该容器是“专人专用”的             */            myRef = React.createRef()            myRef2 = React.createRef()            //展示左侧输入框的数据            showData = ()=&gt;&#123;                alert(this.myRef.current.value);            &#125;            //展示右侧输入框的数据            showData2 = ()=&gt;&#123;                alert(this.myRef2.current.value);            &#125;            render()&#123;                return(                    &lt;div&gt;                        &lt;input ref=&#123;this.myRef&#125; type=&quot;text&quot; placeholder=&quot;点击按钮提示数据&quot;/&gt;&amp;nbsp;                        &lt;button onClick=&#123;this.showData&#125;&gt;点我提示左侧的数据&lt;/button&gt;&amp;nbsp;                        &lt;input onBlur=&#123;this.showData2&#125; ref=&#123;this.myRef2&#125; type=&quot;text&quot; placeholder=&quot;失去焦点提示数据&quot;/&gt;&amp;nbsp;                    &lt;/div&gt;                )            &#125;        &#125;        //渲染组件到页面        ReactDOM.render(&lt;Demo a=&quot;1&quot; b=&quot;2&quot;/&gt;,document.getElementById(&#39;test&#39;))    &lt;/script&gt;</code></pre><h1 id="react-事件处理"><a href="#react-事件处理" class="headerlink" title="react 事件处理"></a>react 事件处理</h1><pre><code class="html">&lt;script type=&quot;text/babel&quot;&gt;        //创建组件        class Demo extends React.Component&#123;            /*                 (1).通过onXxx属性指定事件处理函数(注意大小写)                        a.React使用的是自定义(合成)事件, 而不是使用的原生DOM事件 —————— 为了更好的兼容性                        b.React中的事件是通过事件委托方式处理的(委托给组件最外层的元素) ————————为了的高效                (2).通过event.target得到发生事件的DOM元素对象 ——————————不要过度使用ref             */            //创建ref容器            myRef = React.createRef()            myRef2 = React.createRef()            //展示左侧输入框的数据            showData = (event)=&gt;&#123;                console.log(event.target);                alert(this.myRef.current.value);            &#125;            //展示右侧输入框的数据            showData2 = (event)=&gt;&#123;                alert(event.target.value);            &#125;            render()&#123;                return(                    &lt;div&gt;                        &lt;input ref=&#123;this.myRef&#125; type=&quot;text&quot; placeholder=&quot;点击按钮提示数据&quot;/&gt;&amp;nbsp;                        &lt;button onClick=&#123;this.showData&#125;&gt;点我提示左侧的数据&lt;/button&gt;&amp;nbsp;                        &lt;input onBlur=&#123;this.showData2&#125; type=&quot;text&quot; placeholder=&quot;失去焦点提示数据&quot;/&gt;&amp;nbsp;                    &lt;/div&gt;                )            &#125;        &#125;        //渲染组件到页面        ReactDOM.render(&lt;Demo a=&quot;1&quot; b=&quot;2&quot;/&gt;,document.getElementById(&#39;test&#39;))    &lt;/script&gt;</code></pre><h1 id="react-非受控组件-和-受控组件"><a href="#react-非受控组件-和-受控组件" class="headerlink" title="react 非受控组件 和 受控组件"></a>react 非受控组件 和 受控组件</h1><p>在React中，有两种常见的表单组件模式，即受控组件和非受控组件。它们之间的区别主要在于对表单数据的处理方式。</p><ol><li>非受控组件</li></ol><p>非受控组件是指将表单元素的值交由DOM本身来管理，而非由React组件状态来管理。它们依赖于对DOM节点的引用（ref）来获取表单值。</p><p>当用户输入时，可以直接通过引用访问到表单元素的当前值。通常使用ref.current.value来读取或操作表单的值。</p><pre><code class="JavaScript">class MyForm extends React.Component &#123;  inputRef = React.createRef();  handleSubmit = (event) =&gt; &#123;    event.preventDefault();    console.log(&quot;Submitted value:&quot;, this.inputRef.current.value);  &#125;  render() &#123;    return (      &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;        &lt;input type=&quot;text&quot; ref=&#123;this.inputRef&#125; /&gt;        &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;      &lt;/form&gt;    );  &#125;&#125;</code></pre><ol start="2"><li>受控组件<br>受控组件是指由React组件来管理表单元素的状态和值。通常，通过使用state来存储表单元素的值，并使用onChange事件来更新state。</li></ol><p>当用户输入时，React会更新状态并重新渲染组件，从而保持表单值与组件状态的同步。这使得可以通过this.state获取或操作表单的当前值</p><pre><code class="JavaScript">class MyForm extends React.Component &#123;  constructor(props) &#123;    super(props);    this.state = &#123;      inputValue: &quot;&quot;    &#125;;  &#125;  handleChange = (event) =&gt; &#123;    this.setState(&#123; inputValue: event.target.value &#125;);  &#125;  handleSubmit = (event) =&gt; &#123;    event.preventDefault();    console.log(&quot;Submitted value:&quot;, this.state.inputValue);  &#125;  render() &#123;    return (      &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;        &lt;input          type=&quot;text&quot;          value=&#123;this.state.inputValue&#125;          onChange=&#123;this.handleChange&#125;        /&gt;        &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;      &lt;/form&gt;    );  &#125;&#125;</code></pre><p>总结：</p><p>受控组件适用于需要在React组件中对表单值进行处理和验证的情况。它提供了更多的控制和灵活性，但需要更多的代码和状态管理。<br>非受控组件适用于独立的简单表单，将表单值的控制权交给DOM本身。它通常比较简洁，但在某些情况下可能会更难实现复杂的表单验证和自定义处理逻辑。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>step.4 redux</title>
      <link href="/computer-science/react0-1/redux/"/>
      <url>/computer-science/react0-1/redux/</url>
      
        <content type="html"><![CDATA[<h1 id="初步使用Redux"><a href="#初步使用Redux" class="headerlink" title="初步使用Redux"></a>初步使用Redux</h1><ol><li>安装Redux</li></ol><pre><code class="javascript">npm i redux</code></pre><ol start="2"><li>配置状态机(最佳实现版本)<br>store.js</li></ol><pre><code class="javascript">//引入createStore，专门用于创建redux中最为核心的store对象import &#123; createStore, applyMiddleware &#125; from &#39;redux&#39;//引入汇总之后的reducerimport reducer from &#39;./reducers&#39;//引入redux-thunk，用于支持异步actionimport thunk from &#39;redux-thunk&#39;//引入redux-devtools-extensionimport &#123; composeWithDevTools &#125; from &#39;redux-devtools-extension&#39;//暴露store export default createStore(reducer, composeWithDevTools(applyMiddleware(thunk)))</code></pre><h1 id="Redux的核心概念"><a href="#Redux的核心概念" class="headerlink" title="Redux的核心概念"></a>Redux的核心概念</h1><p><img data-src="/images/reactimg/redux%E5%8E%9F%E7%90%86%E5%9B%BE.png"></p><ol><li>工作流程</li></ol><ul><li>在store仓库中定义初始化的数据</li><li>组件中使用store.getState()获取到仓库的定义的数据，store中会自带dispatch方法（该方法中会有一个返回值，此返回值为action对象），通过store.dispatch()方法将定义好的数据传给store</li><li>action是一个通知对象（该对象中必须要有一个type属性，其他属性可以任意添加）</li><li>store中createStore有两个参数：createStore(参数一，参数二)</li></ul><ol><li>参数一是一个回调函数，可以简单理解为处理初始数据的reducer，store仓库通过reducer进行数据处理，并且再将处理后的值返回给reducer</li><li>参数二可以接收到组件传过来的数据</li></ol><ul><li>此时组件中的值也会随之发生变化。形成闭环功能</li></ul><ol start="2"><li>工作流程</li></ol><ul><li>state</li></ul><ol><li>state:状态，就是我们传递的数据</li></ol><ul><li>action</li></ul><ol><li>action是一个通知对象，里面必须有一个type属性，表示当前通知的类型，至于其他属性，你可以任意添加</li><li>可以通过store.dispatch(action对象)来更新仓库中的数据</li></ol><ul><li>reducer</li></ul><ol><li>reducer本质是一个函数，它用来响应发送过来的actions,经过处理把state发送给store</li><li>reducer函数中，需要return返回值，这样store才能接收到数据</li><li>reducer函数接收两个参数，第一个参数是初始化store,第二个参数是action</li></ol><ul><li>store</li></ul><ol><li>数据仓库，存放组件数据的地方。一个项目一般只有一个数据仓库,store可以把action和reducer联系在一起</li></ol><ul><li>主要的职责</li></ul><ol><li>维护应用的state</li><li>提供getState()方法获取state</li><li>提供dispatch()方法发送action</li><li>通过subscribe()来注册监听</li><li>通过subscribe()返回值来注销监听</li></ol><h1 id="react-redux使用"><a href="#react-redux使用" class="headerlink" title="react-redux使用"></a>react-redux使用</h1><p><img data-src="/images/reactimg/react-redux%E6%A8%A1%E5%9E%8B%E5%9B%BE.png"></p><ol><li>安装react-redux</li></ol><pre><code class="javascript">yarn add reduxyarn add react-redux//必须先安装redux插件 </code></pre><ol start="2"><li>全局注入store仓库</li></ol><pre><code class="javascript">//导入import &#123;Provider&#125; from &#39;react-redux&#39;//将跟组件App进行包裹//Provider中自带store属性，参数store为创建的store仓库文件root.render(    &lt;Provider store=&#123;store&#125;&gt;      &lt;App /&gt;    &lt;/Provider&gt;);</code></pre><ol start="3"><li>组件关联仓库</li></ol><pre><code class="javascript">import React from &#39;react&#39;import &#123; connect &#125; from &#39;react-redux&#39; function Counter() &#123;  render() &#123;    return (      &lt;div&gt;                &lt;/div&gt;    )  &#125;&#125;export default connect()(Counter)//connect是一个高阶组件，该组件中内部还有一个函数，所以写法为connect()()//第二个方法写入创建的函数组件名称//第一个方法是一个回调函数，此函数自带一个参数，该参数是从store仓库获得到的数据，在该回调函数中返回一个对象，该对象会和组件的props进行合并const mapStateToProps = (state) =&gt; &#123;    return &#123;        数据名: 从 state 中获取的数据值    &#125;&#125;export default connect(mapStateToProps)(Counter); 定义好之后就可以在组件的prop访问到对应的store仓库数据function Counter(props)    render() &#123;        return (            &lt;div&gt;                &lt;h1&gt;计数器&lt;/h1&gt;                &lt;h2&gt;&#123;props.数据名&#125;&lt;/h2&gt;            &lt;/div&gt;        )    &#125;&#125;</code></pre><h1 id="状态机的Hook"><a href="#状态机的Hook" class="headerlink" title="状态机的Hook"></a>状态机的Hook</h1><ol><li>useSelect</li></ol><pre><code class="javascript">import &#123;useSelector&#125; from &#39;react-redux&#39;export default App()&#123;    const list = useSelector((state)=&gt;&#123;        return state    &#125;)&#125;//state:store仓库中所有的初始数据</code></pre><ol start="2"><li>useDispatch</li></ol><pre><code class="javascript">import &#123;useDispatch&#125; from &#39;react-redux&#39;export default App()&#123;    const dispatch = useDispatch()    dispatch(action对象)&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>step.6 react常用hook</title>
      <link href="/computer-science/react0-1/%E5%B8%B8%E7%94%A8hook/"/>
      <url>/computer-science/react0-1/%E5%B8%B8%E7%94%A8hook/</url>
      
        <content type="html"><![CDATA[<h1 id="useEffect-用于在组件渲染后执行副作用操作。副作用操作可以包括数据获取、订阅事件、操作-DOM-元素等"><a href="#useEffect-用于在组件渲染后执行副作用操作。副作用操作可以包括数据获取、订阅事件、操作-DOM-元素等" class="headerlink" title="useEffect(用于在组件渲染后执行副作用操作。副作用操作可以包括数据获取、订阅事件、操作 DOM 元素等)"></a>useEffect(用于在组件渲染后执行副作用操作。副作用操作可以包括数据获取、订阅事件、操作 DOM 元素等)</h1><p>useEffect 的执行机制如下：</p><ol><li>组件的初始渲染和每次更新时，都会执行 useEffect 中的回调函数。</li><li>在执行回调函数之前，React 会对上一次渲染中产生的副作用进行清理（即执行上一次 useEffect 返回的清理函数）。</li><li>执行回调函数。</li><li>如果 useEffect 返回一个函数，则该函数将用作清理函数。在下一次渲染或组件卸载时，会先执行这个清理函数，然后再执行下一个 useEffect 的回调函数。</li></ol><pre><code class="javascript">import &#123; useEffect &#125; from &#39;react&#39;;function MyComponent() &#123;  useEffect(() =&gt; &#123;    // 在组件渲染完成后执行的副作用操作    console.log(&#39;Component mounted&#39;);        return () =&gt; &#123;      // 在组件卸载前执行的清理操作      console.log(&#39;Component unmounted&#39;);    &#125;;  &#125;, []); &#125;</code></pre><h1 id="useState-用于在函数组件中声明和管理状态。它返回一个数组，其中第一个元素是当前状态的值，第二个元素是更新状态的函数"><a href="#useState-用于在函数组件中声明和管理状态。它返回一个数组，其中第一个元素是当前状态的值，第二个元素是更新状态的函数" class="headerlink" title="useState(用于在函数组件中声明和管理状态。它返回一个数组，其中第一个元素是当前状态的值，第二个元素是更新状态的函数)"></a>useState(用于在函数组件中声明和管理状态。它返回一个数组，其中第一个元素是当前状态的值，第二个元素是更新状态的函数)</h1><pre><code class="javascript">import &#123; useState &#125; from &#39;react&#39;;function Counter() &#123;  const [count, setCount] = useState(0); // 初始状态为 0  const increment = () =&gt; &#123;    setCount(count + 1);  &#125;;  return (    &lt;div&gt;      &lt;p&gt;Count: &#123;count&#125;&lt;/p&gt;      &lt;button onClick=&#123;increment&#125;&gt;Increment&lt;/button&gt;    &lt;/div&gt;  );&#125;</code></pre><h1 id="useReducer-用于管理复杂的状态逻辑。它类似于-useState，但接受一个-reducer-函数和初始状态作为参数，并返回当前状态和一个发送更新请求的函数"><a href="#useReducer-用于管理复杂的状态逻辑。它类似于-useState，但接受一个-reducer-函数和初始状态作为参数，并返回当前状态和一个发送更新请求的函数" class="headerlink" title="useReducer(用于管理复杂的状态逻辑。它类似于 useState，但接受一个 reducer 函数和初始状态作为参数，并返回当前状态和一个发送更新请求的函数)"></a>useReducer(用于管理复杂的状态逻辑。它类似于 useState，但接受一个 reducer 函数和初始状态作为参数，并返回当前状态和一个发送更新请求的函数)</h1><pre><code class="javascript">import &#123; useReducer &#125; from &#39;react&#39;;const initialState = &#123; count: 0 &#125;;function reducer(state, action) &#123;  switch (action.type) &#123;    case &#39;increment&#39;:      return &#123; count: state.count + 1 &#125;;    case &#39;decrement&#39;:      return &#123; count: state.count - 1 &#125;;    default:      throw new Error();  &#125;&#125;function Counter() &#123;  const [state, dispatch] = useReducer(reducer, initialState);  const increment = () =&gt; &#123;    dispatch(&#123; type: &#39;increment&#39; &#125;);  &#125;;  const decrement = () =&gt; &#123;    dispatch(&#123; type: &#39;decrement&#39; &#125;);  &#125;;  return (    &lt;div&gt;      &lt;p&gt;Count: &#123;state.count&#125;&lt;/p&gt;      &lt;button onClick=&#123;increment&#125;&gt;Increment&lt;/button&gt;      &lt;button onClick=&#123;decrement&#125;&gt;Decrement&lt;/button&gt;    &lt;/div&gt;  );&#125;</code></pre><h1 id="useCallback-用于缓存函数引用，避免不必要的重新创建。它接收一个回调函数和依赖项数组，并返回一个缓存的回调函数"><a href="#useCallback-用于缓存函数引用，避免不必要的重新创建。它接收一个回调函数和依赖项数组，并返回一个缓存的回调函数" class="headerlink" title="useCallback(用于缓存函数引用，避免不必要的重新创建。它接收一个回调函数和依赖项数组，并返回一个缓存的回调函数)"></a>useCallback(用于缓存函数引用，避免不必要的重新创建。它接收一个回调函数和依赖项数组，并返回一个缓存的回调函数)</h1><pre><code class="javascript">import &#123; useCallback, useState &#125; from &#39;react&#39;;function MyComponent() &#123;  const [count, setCount] = useState(0);    // 当 count 发生变化时，重新创建回调函数  const handleClick = useCallback(() =&gt; &#123;    setCount(count + 1);  &#125;, [count]);  return (    &lt;div&gt;      &lt;p&gt;Count: &#123;count&#125;&lt;/p&gt;      &lt;button onClick=&#123;handleClick&#125;&gt;Increment&lt;/button&gt;    &lt;/div&gt;  );&#125;</code></pre><h1 id="useRef-用于在函数组件中创建持久性的引用。它返回一个可变的-ref-对象，对象的-current-属性可以存储任意值，并且在组件重新渲染时保持不变"><a href="#useRef-用于在函数组件中创建持久性的引用。它返回一个可变的-ref-对象，对象的-current-属性可以存储任意值，并且在组件重新渲染时保持不变" class="headerlink" title="useRef(用于在函数组件中创建持久性的引用。它返回一个可变的 ref 对象，对象的 current 属性可以存储任意值，并且在组件重新渲染时保持不变)"></a>useRef(用于在函数组件中创建持久性的引用。它返回一个可变的 ref 对象，对象的 current 属性可以存储任意值，并且在组件重新渲染时保持不变)</h1><pre><code class="javascript">import &#123; useRef &#125; from &#39;react&#39;;function MyComponent() &#123;  const inputRef = useRef();  const handleClick = () =&gt; &#123;    inputRef.current.focus();  &#125;;  return (    &lt;div&gt;      &lt;input ref=&#123;inputRef&#125; type=&quot;text&quot; /&gt;      &lt;button onClick=&#123;handleClick&#125;&gt;Focus input&lt;/button&gt;    &lt;/div&gt;  );&#125;</code></pre><h1 id="useMemo-用于进行性能优化，避免不必要的重计算。它接收一个计算函数和依赖项数组作为参数，并返回计算结果。当依赖项数组发生变化时，useMemo-会重新执行计算函数并返回新的结果；当依赖项数组未发生变化时，useMemo-会直接返回上一次的计算结果"><a href="#useMemo-用于进行性能优化，避免不必要的重计算。它接收一个计算函数和依赖项数组作为参数，并返回计算结果。当依赖项数组发生变化时，useMemo-会重新执行计算函数并返回新的结果；当依赖项数组未发生变化时，useMemo-会直接返回上一次的计算结果" class="headerlink" title="useMemo(用于进行性能优化，避免不必要的重计算。它接收一个计算函数和依赖项数组作为参数，并返回计算结果。当依赖项数组发生变化时，useMemo 会重新执行计算函数并返回新的结果；当依赖项数组未发生变化时，useMemo 会直接返回上一次的计算结果)"></a>useMemo(用于进行性能优化，避免不必要的重计算。它接收一个计算函数和依赖项数组作为参数，并返回计算结果。当依赖项数组发生变化时，useMemo 会重新执行计算函数并返回新的结果；当依赖项数组未发生变化时，useMemo 会直接返回上一次的计算结果)</h1><pre><code class="javascript">import &#123; useMemo &#125; from &#39;react&#39;;function MyComponent() &#123;  const expensiveResult = useMemo(() =&gt; &#123;    // 计算昂贵的结果    return computeExpensiveResult(dep1, dep2);  &#125;, [dep1, dep2]); // 依赖项数组  return &lt;p&gt;&#123;expensiveResult&#125;&lt;/p&gt;;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>step.5 react性能优化</title>
      <link href="/computer-science/react0-1/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/computer-science/react0-1/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="react-性能优化"><a href="#react-性能优化" class="headerlink" title="react 性能优化"></a>react 性能优化</h1><p><strong>React组件性能优化的核心是降低渲染真实DOM节点的频率，降低Virtual DOM比较的频率。如果子组件没有改变数据，则子组件不会被渲染。</strong></p><ol><li><p>使用生命周期方法优化：React 的生命周期方法提供了控制组件行为的机会。你可以使用 shouldComponentUpdate 方法来避免不必要的重新渲染。在该方法中，你可以比较前后 props 和 state 的值，决定是否需要更新组件。此外，使用 componentDidUpdate 方法可以在组件更新后执行一些必要的操作。</p></li><li><p>使用 Pure Components：Pure Components 是 React 提供的一个优化工具，它们自动帮助我们实现了 shouldComponentUpdate 方法的逻辑。相比普通的组件，Pure Components 只在其 props 或 state 发生变化时进行重新渲染。使用 Pure Components 可以有效地减少不必要的重新渲染，提高性能。</p></li><li><p>使用 React.memo()：React.memo() 是一个高阶组件，它可以记忆组件的渲染结果，当组件的 props 没有变化时，会直接返回上次的渲染结果，从而避免不必要的重新渲染。使用 React.memo() 可以提高组件的性能，特别是在函数组件中非常有用。</p></li><li><p>使用 keys 来管理列表项：在渲染列表时，给每个列表项分配一个唯一的 key 属性可以帮助 React 更好地识别和管理列表项的变化。这样，在列表项发生变化时，React 可以更准确地判断哪些项需要更新，从而避免不必要的重新渲染。</p></li><li><p>使用虚拟化技术：当渲染大量数据时，可以使用虚拟化技术来提高性能。例如，使用 react-virtualized 或 react-window 这样的库可以只渲染可见部分的数据，而不是全部渲染。这样可以有效地减少 DOM 元素的数量，提高列表的渲染性能。</p></li><li><p>使用优化后的事件处理程序：在 React 中，每次组件重新渲染时，都会创建新的事件处理程序。为了避免这种性能损耗，可以使用 useCallback() 来优化事件处理函数，并将它们作为依赖传递给子组件，以防止不必要的重新渲染。</p></li><li><p>使用 code-splitting 技术：当应用程序变得越来越庞大时，可以将应用程序拆分成多个较小的代码块，然后按需加载，以提高初始加载速度。React 提供了 React.lazy() 和 Suspense 组件来实现代码拆分和懒加载。</p></li><li><p>合理使用 Immutable 数据结构：使用不可变的数据结构可以降低 React 的重新渲染频率。当我们使用不可变的数据结构时，只需要比较引用而不是每个数据项的值。可以使用 Immutable.js 或通过手动进行浅比较来实现这一点。</p></li><li><p>使用 memoization 技术：Memoization 是一种缓存计算结果的技术，在函数组件中可以通过 useMemo() 和 useCallback() 来实现。通过将计算结果缓存起来，可以避免不必要的重复计算和重新渲染。</p></li><li><p>避免在渲染过程中执行昂贵的操作：在组件的渲染过程中，尽量避免执行昂贵的操作，例如大量的计算、网络请求或 DOM 操作。这些操作会导致组件的渲染变慢，并可能引起阻塞和性能问题。可以使用 useEffect() 来延迟执行这些操作，或者将它们放在合适的生命周期方法中执行。</p></li><li><p>使用合适的数据结构和算法：选择合适的数据结构和算法对于性能优化至关重要。例如，在处理大量数据时，使用 Set 或 Map 来替代数组可以提高查找和删除的性能。同时，选择高效的算法可以减少不必要的计算量。</p></li><li><p>懒加载组件：如果应用程序拥有很多组件，可以考虑使用懒加载的方式来优化性能。懒加载可以延迟组件的加载时间，只有在需要的时候才进行加载和渲染。</p></li></ol><pre><code class="JavaScript">1. 原来的导入方式import MyComponent from &#39;./MyComponent&#39;;替换为动态导入const MyComponent = React.lazy(() =&gt; import(&#39;./MyComponent&#39;));2. 使用 React.lazy() 函数来创建一个懒加载的组件。这个函数接收一个函数作为参数，这个函数需要返回一个 import() 方法调用，用于导入组件的模块。注意，这个返回值应该是一个 Promise 对象。3.在需要使用懒加载组件的地方，使用 &lt;React.Suspense&gt; 组件包裹起来，以便在组件加载过程中显示一些占位内容或加载指示器import React, &#123; Suspense &#125; from &#39;react&#39;;function App() &#123;  return (    &lt;div&gt;      &lt;h1&gt;My App&lt;/h1&gt;      &lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;/div&gt;&#125;&gt;        &lt;MyComponent /&gt;      &lt;/Suspense&gt;    &lt;/div&gt;  );&#125;</code></pre><ol start="13"><li>使用性能优化工具：除了上述的方法，还可以使用一些性能优化工具来帮助分析和改进 React 应用的性能。例如，React DevTools、Lighthouse、Webpack Bundle Analyzer 等工具可以提供有关性能瓶颈和优化建议的详细信息。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>step.7 react源码核心</title>
      <link href="/computer-science/react0-1/%E6%BA%90%E7%A0%81%E6%A0%B8%E5%BF%83/"/>
      <url>/computer-science/react0-1/%E6%BA%90%E7%A0%81%E6%A0%B8%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<ol><li><p>虚拟DOM（Virtual DOM）：React 使用虚拟DOM作为其核心概念。虚拟DOM是一个轻量级的JavaScript对象，它描述了实际DOM树的结构和属性。React通过比较新旧虚拟DOM之间的差异来最小化实际DOM的操作，提高性能。</p></li><li><p>组件声明：React允许开发者使用类组件或函数组件来声明UI组件。在源码中，React提供了相关的方法和类来定义和管理组件的生命周期、状态、属性等。</p></li><li><p>渲染引擎：React的渲染引擎负责将组件的虚拟DOM转化为实际DOM，并将其插入到文档中。React的渲染过程是基于协调的机制，通过比较新旧虚拟DOM的差异，仅更新需要改变的部分，从而提高渲染性能。</p></li><li><p>调度器（Scheduler）：React使用调度器来管理组件的更新和重渲染。调度器决定何时执行组件的更新并控制更新的优先级。React通过这种方式实现了批量更新和异步渲染，从而提高性能和交互响应性。</p></li><li><p>Hooks系统：React引入了Hooks系统来处理组件逻辑的复用和状态管理。Hooks允许我们在函数组件中使用状态、副作用和其他特性，避免了类组件和高阶组件的复杂性。</p></li><li><p>协调算法：React使用协调算法来比较虚拟DOM的差异，并决定哪些部分需要更新。React的协调算法是基于Diff算法的优化版本，它通过树的分层比较和启发式策略来减少比较的次数，以提高性能。</p></li><li><p>事件系统：React提供了一套事件系统，用于处理DOM事件和合成事件。这个事件系统允许开发者在组件中注册事件处理函数，并且提供了一些优化措施，如事件委托和事件池，以提高事件处理的性能和效率。</p></li><li><p>调试工具：React提供了一系列的调试工具，如React Developer Tools，用于帮助开发者分析和调试React应用。这些工具包括组件层级检查、性能分析、状态变更跟踪等功能，可以大大简化调试过程。</p></li><li><p>Fiber架构：React引入了Fiber架构来改进其内部工作方式。Fiber架构将渲染过程分解为可中断的任务单元，使得React能够在运行时调整和中断任务的优先级，从而更好地控制渲染和响应用户操作。</p></li><li><p>批量更新：React通过批量更新机制来减少不必要的渲染。在一次事件循环中，React将多个更新合并为一次更新，并且在合适的时机进行渲染，以提高性能。</p></li><li><p>Context（上下文）：React提供了Context API，用于在组件树中共享数据。Context允许开发者将数据传递给组件树中的多个层级，而不需要手动通过props进行逐层传递。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>step.2 react生命周期</title>
      <link href="/computer-science/react0-1/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/computer-science/react0-1/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="react-16-8"><a href="#react-16-8" class="headerlink" title="react 16.8"></a>react 16.8</h1><p><img data-src="/images/reactimg/2_react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F(%E6%97%A7).png"></p><ol><li>初始化阶段: 由ReactDOM.render()触发—初次渲染<ol><li>   constructor()</li><li>   componentWillMount()<br>  初始化状态和数据,发起网络请求或订阅事件, 服务端渲染(在服务器端渲染 (Server-Side Rendering, SSR) 的应用程序中，componentWillMount 可以用于在组件首次渲染之前获取所需的数据，以便服务器能够将数据注入到 HTML 中，提供给客户端使用)</li><li>   render()</li><li>   componentDidMount() &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; 常用<br>  一般在这个钩子中做一些初始化的事，例如：开启定时器、发送网络请求、订阅消息</li></ol></li><li>更新阶段: 由组件内部this.setSate()或父组件render触发<ol><li><p>   shouldComponentUpdate()<br>  shouldComponentUpdate 在组件即将更新之前被调用。<br>  它接收两个参数：nextProps 和 nextState，表示组件即将接收的新属性和新状态。<br>  默认情况下，shouldComponentUpdate 返回 true，表示组件将会更新。但是，你可以通过自定义逻辑来判断是否需要更新组件。<br>  通过在 shouldComponentUpdate 中进行逻辑判断，可以提高应用程序的性能，避免不必要的组件渲染。</p></li><li><p>   componentWillUpdate()<br>  componentWillUpdate 在组件即将更新时被调用。<br>  它接收两个参数：nextProps 和 nextState，表示组件即将接收的新属性和新状态。<br>  在 componentWillUpdate 中，你可以执行一些更新前的准备工作，但是不允许使用 setState 方法，因为组件此时还没有更新。<br><br>  具体可以做哪些操作：<br>  计算和准备数据：你可以根据当前的属性 (props) 和状态 (state)，计算并准备一些数据，以供组件的更新使用。<br><br>  缓存 DOM 元素和测量数据：如果需要对 DOM 元素进行操作或者获取其尺寸等信息，你可以在 componentWillUpdate 中缓存相关的 DOM 元素或者进行测量，并将结果保存在组件的实例变量中。<br><br>  取消订阅和清理资源：在 componentWillUpdate 中，你可以取消之前的订阅、清理定时器、关闭网络连接等操作，以避免不必要的资源占用。<br><br>  更新外部库或框架：如果你使用了其他的第三方库或框架，你可以在 componentWillUpdate 中更新这些库或框架的相关状态或数据。<br><br>  验证和处理属性的改变：通过比较 nextProps 和当前的 props，你可以检测属性的改变并进行相应的处理。例如，根据属性的改变请求新的数据或触发其他操作。</p></li><li><p>   render() &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; 必须使用的一个</p></li><li><p>   componentDidUpdate()<br>  componentDidUpdate 在组件更新之后被调用。<br>  它接收两个参数：prevProps 和 prevState，表示组件更新之前的属性和状态。<br>  在 componentDidUpdate 中，你可以执行一些更新后的操作，例如对 DOM 进行操作、发起网络请求等。<br>  需要注意的是，你必须在 componentDidUpdate 中进行条件判断，避免无限循环的更新。</p></li></ol></li><li>卸载组件: 由ReactDOM.unmountComponentAtNode()触发<ol><li>   componentWillUnmount()  &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; 常用<br>  一般在这个钩子中做一些收尾的事，例如：关闭定时器、取消订阅消息</li></ol></li></ol><h1 id="react-17"><a href="#react-17" class="headerlink" title="react 17"></a>react 17</h1><p><img data-src="/images/reactimg/3_react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F(%E6%96%B0).png"></p><ol><li>初始化阶段: 由ReactDOM.render()触发—初次渲染<ol><li><p>   constructor()</p></li><li><p>   getDerivedStateFromProps<br>  getDerivedStateFromProps 在组件接收到新的属性 (props) 时被调用。<br>  它接收两个参数：props 和 state，并返回一个对象来更新状态 (state) 或 null。<br>  你可以使用 getDerivedStateFromProps 来根据属性计算和更新状态，但是它应该被谨慎使用，因为大部分情况下使用 props 直接渲染组件更加合理。<br>  static getDerivedStateFromProps(props, state) {<br>&#x2F;&#x2F; 假设要根据传入的新属性 props 更新状态值 message<br>return {<br>  message: props.newMessage<br>};<br>  }</p><p>  static getDerivedStateFromProps(props, state) {<br>&#x2F;&#x2F; 不执行状态更新，返回 null<br>  return null;<br>  } </p></li><li><p>   render()</p></li><li><p>   componentDidMount() &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; 常用<br>一般在这个钩子中做一些初始化的事，例如：开启定时器、发送网络请求、订阅消息</p></li></ol></li><li>更新阶段: 由组件内部this.setSate()或父组件重新render触发<ol><li>   getDerivedStateFromProps</li><li>   shouldComponentUpdate()<br>  shouldComponentUpdate 在组件即将更新之前被调用。<br>  它接收两个参数：nextProps 和 nextState，表示组件即将接收的新属性和新状态。<br>  默认情况下，shouldComponentUpdate 返回 true，表示组件将会更新。但是，你可以通过自定义逻辑来判断是否需要更新组件。<br>  通过在 shouldComponentUpdate 中进行逻辑判断，可以提高应用程序的性能，避免不必要的组件渲染。</li><li>   render()</li><li>   getSnapshotBeforeUpdate<br>  getSnapshotBeforeUpdate 在组件即将更新之前被调用。<br>  它接收两个参数：prevProps 和 prevState，表示组件更新前的属性和状态。<br>  在 getSnapshotBeforeUpdate 中，你可以捕获组件更新前的 DOM 状态，并返回一个值，这个值会作为第三个参数传递给 componentDidUpdate 方法。</li><li>   componentDidUpdate()<br>  componentDidUpdate 在组件更新之后被调用。<br>  它接收两个参数：prevProps 和 prevState，表示组件更新之前的属性和状态。<br>  在 componentDidUpdate 中，你可以执行一些更新后的操作，例如对 DOM 进行操作、发起网络请求等。<br>  需要注意的是，你必须在 componentDidUpdate 中进行条件判断，避免无限循环的更新。</li></ol></li><li>卸载组件: 由ReactDOM.unmountComponentAtNode()触发<ol><li>   componentWillUnmount()  &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; 常用<br>一般在这个钩子中做一些收尾的事，例如：关闭定时器、取消订阅消息</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>step.8 react首屏优化</title>
      <link href="/computer-science/react0-1/%E9%A6%96%E5%B1%8F%E4%BC%98%E5%8C%96/"/>
      <url>/computer-science/react0-1/%E9%A6%96%E5%B1%8F%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<ol><li><p>代码拆分：使用动态导入或懒加载方式，将页面组件分割成更小的块。这样可以实现按需加载，减少首屏所需的代码量，加快页面加载速度。</p></li><li><p>SSR（服务器端渲染）：使用服务器端渲染技术，将 React 组件在服务器上预先渲染为 HTML，并在首次加载时直接返回给客户端。这可以加快首屏渲染速度，提供更好的用户体验。</p></li><li><p>避免不必要的组件渲染：通过使用 shouldComponentUpdate 或 PureComponent 确保只有发生实际变化的组件进行重新渲染，避免不必要的渲染开销。</p></li><li><p>按需加载资源：使用异步加载方式，按需加载页面所需的 JavaScript、CSS 或图片等资源。可以使用工具如 React Loadable 或动态导入语法（import()）来实现。</p></li><li><p>图片优化：对于页面中的图片，使用合适的压缩算法来减小文件大小，以提高加载速度。可以使用工具如 Webpack 的 image-loader 或使用响应式图片方案进行处理。</p></li><li><p>使用服务端缓存技术：利用适当的缓存策略，如设置合适的缓存头，使用 CDN 加速等方式，提高首屏渲染速度。</p></li><li><p>代码优化和分割：优化 JavaScript 和 CSS 代码，如压缩、合并、移除无用代码等操作，减小文件大小，加快下载和解析速度。另外，将代码按功能或模块进行分割，以实现更好的可维护性和加载效率。</p></li><li><p>使用服务端数据预取：在渲染页面之前，通过服务端获取所需的数据，并将其作为初始状态传递给 React 组件。这样可以避免页面渲染完成后再进行数据请求，提高用户感知速度。</p></li><li><p>使用浏览器缓存：合理设置缓存策略，利用浏览器缓存来存储页面资源，减少重复加载的开销。</p></li><li><p>性能监测和优化：使用工具如 Lighthouse、WebPagetest 等来测试和监测页面性能指标，并根据结果进行优化调整。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Step.1</title>
      <link href="/computer-science/Mybatis/doscmp/Mybatis-01/"/>
      <url>/computer-science/Mybatis/doscmp/Mybatis-01/</url>
      
        <content type="html"><![CDATA[<h1 id="Mybatis-01"><a href="#Mybatis-01" class="headerlink" title="Mybatis-01"></a>Mybatis-01</h1><h2 id="1-框架"><a href="#1-框架" class="headerlink" title="1. 框架"></a>1. 框架</h2><p>​框架相当于是一个脚手架，内部已经写好了很多代码，我们只要其基础上进行开发就可以提高我们的开发效率。</p><p>​</p><p>框架阶段学习：</p><p>①先去学习如何使用框架</p><p>②然后再使用熟练的情况下去猜测内部的原理</p><p>③通过源码去验证自己的猜测。</p><h2 id="2-Mybatis介绍"><a href="#2-Mybatis介绍" class="headerlink" title="2.Mybatis介绍"></a>2.Mybatis介绍</h2><ul><li><p>MyBatis 是一款优秀的持久层框架。</p></li><li><p>MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。</p></li><li><p>官网：<span class="exturl" data-url="aHR0cHM6Ly9teWJhdGlzLm9yZy9teWJhdGlzLTMvemgvIw==">https://mybatis.org/mybatis-3/zh/#</span></p></li></ul><h2 id="3-快速入门"><a href="#3-快速入门" class="headerlink" title="3. 快速入门"></a>3. 快速入门</h2><p>①数据准备</p><pre><code class="mysql">CREATE DATABASE /*!32312 IF NOT EXISTS*/`mybatis_db` /*!40100 DEFAULT CHARACTER SET utf8 */;USE `mybatis_db`;DROP TABLE IF EXISTS `user`;CREATE TABLE `user` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `username` varchar(50) DEFAULT NULL,  `age` int(11) DEFAULT NULL,  `address` varchar(50) DEFAULT NULL,  PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;insert  into `user`(`id`,`username`,`age`,`address`) values (1,&#39;UZI&#39;,19,&#39;上海&#39;),(2,&#39;PDD&#39;,25,&#39;上海&#39;);</code></pre><p>②导入依赖</p><pre><code class="xml">        &lt;!--mybatis依赖--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;3.5.4&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--mysql驱动--&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;5.1.47&lt;/version&gt;        &lt;/dependency&gt;</code></pre><p>③编写核心配置</p><p>在资源目录下创建：mybatis-config.xml 内容如下：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;environments default=&quot;development&quot;&gt;        &lt;environment id=&quot;development&quot;&gt;            &lt;transactionManager type=&quot;JDBC&quot;/&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;mappers&gt;        &lt;mapper resource=&quot;com/sangeng/dao/UserDao.xml&quot;/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><p>④定义接口及对应的xml映射文件</p><p>com.sangeng.dao.UserDao:</p><pre><code class="java">public interface UserDao &#123;    List&lt;User&gt; findAll();&#125;</code></pre><p>资源目录下：com&#x2F;sangeng&#x2F;dao&#x2F;UserDao.xml</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.sangeng.dao.UserDao&quot;&gt;    &lt;select id=&quot;findAll&quot; resultType=&quot;com.sangeng.pojo.User&quot;&gt;      select * from user    &lt;/select&gt;&lt;/mapper&gt;</code></pre><p>⑤编写测试类</p><p>获取SqlSession,通过SqlSession获取UserDao调用对应的方法</p><pre><code class="java">    public static void main(String[] args) throws IOException &#123;        //定义mybatis配置文件的路径        String resource = &quot;mybatis-config.xml&quot;;        InputStream inputStream = Resources.getResourceAsStream(resource);        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);        //获取Sqlsession对象        SqlSession sqlSession = sqlSessionFactory.openSession();        //获取UserDao实现类对象        UserDao userDao = sqlSession.getMapper(UserDao.class);        //调用方法测试        List&lt;User&gt; userList = userDao.findAll();        System.out.println(userList);        //释放资源        sqlSession.close();    &#125;</code></pre><h2 id="3-9-高效编程"><a href="#3-9-高效编程" class="headerlink" title="3.9 高效编程"></a>3.9 高效编程</h2><h3 id="3-9-1-配置代码模板"><a href="#3-9-1-配置代码模板" class="headerlink" title="3.9.1 配置代码模板"></a>3.9.1 配置代码模板</h3><p><img data-src="/images%5Cimgmybatis%5Cimage-1.png" alt="image-20210218211942452"></p><h3 id="3-9-2-Mybatis插件"><a href="#3-9-2-Mybatis插件" class="headerlink" title="3.9.2 Mybatis插件"></a>3.9.2 Mybatis插件</h3><p>​下载安装Free Mybatis plugin，安装完后重启IDEA</p><h2 id="4-参数获取"><a href="#4-参数获取" class="headerlink" title="4. 参数获取"></a>4. 参数获取</h2><h3 id="4-1-一个参数"><a href="#4-1-一个参数" class="headerlink" title="4.1 一个参数"></a>4.1 一个参数</h3><h4 id="4-1-1-基本参数"><a href="#4-1-1-基本参数" class="headerlink" title="4.1.1 基本参数"></a>4.1.1 基本参数</h4><p>​我们可以使用#{}直接来取值，写任意名字都可以获取到参数。但是一般用方法的参数名来取。</p><p>例如：</p><p>接口中方法定义如下</p><pre><code class="java">User findById(Integer id);</code></pre><p>xml中内容如下:</p><pre><code class="xml">&lt;select id=&quot;findById&quot; resultType=&quot;com.sangeng.pojo.User&quot;&gt;  select * from user where id = #&#123;id&#125;&lt;/select&gt;</code></pre><h4 id="4-1-2-POJO"><a href="#4-1-2-POJO" class="headerlink" title="4.1.2 POJO"></a>4.1.2 POJO</h4><p>​我们可以使用POJO中的属性名来获取对应的值。</p><p>例如：</p><p>接口中方法定义如下</p><pre><code class="java">User findByUser(User user);</code></pre><p>xml中内容如下：</p><pre><code class="xml">    &lt;select id=&quot;findByUser&quot; resultType=&quot;com.sangeng.pojo.User&quot;&gt;        select * from user where id = #&#123;id&#125; and username = #&#123;username&#125; and age = #&#123;age&#125; and address = #&#123;address&#125;    &lt;/select&gt;</code></pre><h4 id="4-1-3-Map"><a href="#4-1-3-Map" class="headerlink" title="4.1.3 Map"></a>4.1.3 Map</h4><p>​我们可以使用map中的key来获取对应的值。</p><p>例如：</p><p>接口中方法定义如下</p><pre><code class="java">User findByMap(Map map);</code></pre><p>xml中内容如下：</p><pre><code class="java">    &lt;select id=&quot;findByMap&quot; resultType=&quot;com.sangeng.pojo.User&quot;&gt;        select * from user where id = #&#123;id&#125; and username = #&#123;username&#125; and age = #&#123;age&#125; and address = #&#123;address&#125;    &lt;/select&gt;</code></pre><p>方法调用：</p><pre><code class="java">        Map map = new HashMap();        map.put(&quot;id&quot;,2);        map.put(&quot;username&quot;,&quot;PDD&quot;);        map.put(&quot;age&quot;,25);        map.put(&quot;address&quot;,&quot;上海&quot;);        userDao.findByMap(map);</code></pre><h3 id="4-2-多个参数"><a href="#4-2-多个参数" class="headerlink" title="4.2 多个参数"></a>4.2 多个参数</h3><p>​Mybatis会把多个参数放入一个Map集合中，默认的key是argx和paramx这种格式。</p><p>例如：</p><p>接口中方法定义如下</p><pre><code class="java">User findByCondition(Integer id,String username);</code></pre><p>最终map中的键值对如下：</p><pre><code class="java">&#123;arg1=PDD, arg0=2, param1=2, param2=PDD&#125;</code></pre><p>​我们虽然可以使用对应的默认key来获取值，但是这种方式可读性不好。我们一般在方法参数前使用@Param来设置参数名。</p><p>例如：</p><p>接口中方法定义</p><pre><code class="java">User findByCondition(@Param(&quot;id&quot;) Integer id,@Param(&quot;username&quot;) String username);</code></pre><p>最终map中的键值对如下：</p><pre><code>&#123;id=2, param1=2, username=PDD, param2=PDD&#125;</code></pre><p>所以我们就可以使用如下方式来获取参数</p><pre><code class="xml">    &lt;select id=&quot;findByCondition&quot; resultType=&quot;com.sangeng.pojo.User&quot;&gt;         select * from user where id = #&#123;id&#125; and username = #&#123;username&#125;    &lt;/select&gt;</code></pre><h3 id="4-3-总结"><a href="#4-3-总结" class="headerlink" title="4.3 总结"></a>4.3 总结</h3><p>​建议如果只有一个参数的时候不用做什么特殊处理。如果是有多个参数的情况下一定要加上@Param来设置参数名。</p><h2 id="5-核心类"><a href="#5-核心类" class="headerlink" title="5. 核心类"></a>5. 核心类</h2><h3 id="5-1-SqlSessionFactory"><a href="#5-1-SqlSessionFactory" class="headerlink" title="5.1 SqlSessionFactory"></a>5.1 SqlSessionFactory</h3><p>​SqlSessionFactory是一个SqlSession的工厂类。主要用来获取SqlSession对象。、</p><p>成员方法如下：</p><pre><code class="java">SqlSession openSession();//获取SqlSession对象，传入的参数代表创建的SqlSession是否自动提交SqlSession openSession(boolean autoCommit);</code></pre><h3 id="5-2-SqlSession"><a href="#5-2-SqlSession" class="headerlink" title="5.2 SqlSession"></a>5.2 SqlSession</h3><p>​ SqlSession 提供了在数据库执行 SQL 命令所需的所有方法 。它还提供了事务的相关操作。</p><p>成员方法如下：</p><pre><code class="java">T getMapper(Class&lt;T&gt; type);//获取mapper对象void commit();//提交事务void rollback();//回滚事务void close();//释放资源</code></pre><h2 id="6-Mybatis实现增删改查"><a href="#6-Mybatis实现增删改查" class="headerlink" title="6.Mybatis实现增删改查"></a>6.Mybatis实现增删改查</h2><h3 id="6-1-新增"><a href="#6-1-新增" class="headerlink" title="6.1 新增"></a>6.1 新增</h3><p>①接口中增加相关方法</p><pre><code class="java">void insertUser(User user);</code></pre><p>②映射文件UserDao.xml增加响应的标签</p><pre><code class="xml">    &lt;insert id=&quot;insertUser&quot;&gt;        insert into user values(null,#&#123;username&#125;,#&#123;age&#125;,#&#123;address&#125;)    &lt;/insert&gt;</code></pre><p><strong>注意：要记得提交事务。</strong></p><h3 id="6-2-删除"><a href="#6-2-删除" class="headerlink" title="6.2 删除"></a>6.2 删除</h3><p>①接口中增加相关方法</p><pre><code class="java">void deleteById(Integer id);</code></pre><p>②映射文件UserDao.xml增加响应的标签</p><pre><code class="xml">    &lt;delete id=&quot;deleteById&quot;&gt;        delete from user where id = #&#123;id&#125;    &lt;/delete&gt;</code></pre><p><strong>注意：要记得提交事务。</strong></p><h3 id="6-3-修改"><a href="#6-3-修改" class="headerlink" title="6.3 修改"></a>6.3 修改</h3><p>①接口中增加相关方法</p><pre><code class="java">void updateUser(User user);</code></pre><p>②映射文件UserDao.xml增加响应的标签</p><pre><code class="xml">    &lt;!--更新用户--&gt;    &lt;update id=&quot;updateUser&quot;&gt;        UPDATE USER SET age = #&#123;age&#125; , username = #&#123;username&#125;,address = #&#123;address&#125; WHERE id = #&#123;id&#125;    &lt;/update&gt;</code></pre><p><strong>注意：要记得提交事务。</strong></p><h3 id="6-4-根据id查询"><a href="#6-4-根据id查询" class="headerlink" title="6.4 根据id查询"></a>6.4 根据id查询</h3><p>①接口中增加相关方法</p><pre><code class="java">User findById(Integer id);</code></pre><p>②映射文件UserDao.xml增加响应的标签</p><pre><code class="xml">   &lt;select id=&quot;findById&quot; resultType=&quot;com.sangeng.pojo.User&quot;&gt;      select * from user where id = #&#123;id&#125;    &lt;/select&gt;</code></pre><h3 id="6-5-查询所有"><a href="#6-5-查询所有" class="headerlink" title="6.5 查询所有"></a>6.5 查询所有</h3><p>①接口中增加相关方法</p><pre><code class="java">List&lt;User&gt; findAll();</code></pre><p>②映射文件UserDao.xml增加响应的标签</p><pre><code class="xml">    &lt;select id=&quot;findAll&quot; resultType=&quot;com.sangeng.pojo.User&quot;&gt;      select * from user    &lt;/select&gt;</code></pre><h2 id="7-配置文件详解"><a href="#7-配置文件详解" class="headerlink" title="7. 配置文件详解"></a>7. 配置文件详解</h2><h3 id="7-1-properties"><a href="#7-1-properties" class="headerlink" title="7.1 properties"></a>7.1 properties</h3><p>​可以使用properties读取properties配置文件。使用其中的resource属性来设置配置文件的路径。</p><p>​然后使用${key}来获取配置文件中的值</p><p>例如：</p><p>在resources目录下有jdbc.properties文件，内容如下：</p><pre><code class="properties">jdbc.url=jdbc:mysql://localhost:3306/mybatis_dbjdbc.driver=com.mysql.jdbc.Driverjdbc.username=rootjdbc.password=root</code></pre><p>在mybatis-config.xml中：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;!--设置配置文件所在的路径--&gt;    &lt;properties resource=&quot;jdbc.properties&quot;&gt;&lt;/properties&gt;    &lt;environments default=&quot;development&quot;&gt;        &lt;environment id=&quot;development&quot;&gt;            &lt;transactionManager type=&quot;JDBC&quot;/&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;!--获取配置文件中配置的对应的值来设置连接相关参数--&gt;                &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;&lt;/configuration&gt;</code></pre><h3 id="7-2-settings"><a href="#7-2-settings" class="headerlink" title="7.2 settings"></a>7.2 settings</h3><p>​可以使用该标签来设置进行一些设置</p><p>例如：</p><pre><code class="xml">    &lt;settings&gt;        &lt;!--开启自动驼峰命名映射--&gt;        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;    &lt;/settings&gt;</code></pre><p>具体的设置参考：<span class="exturl" data-url="aHR0cHM6Ly9teWJhdGlzLm9yZy9teWJhdGlzLTMvemgvY29uZmlndXJhdGlvbi5odG1sI3NldHRpbmdz">https://mybatis.org/mybatis-3/zh/configuration.html#settings</span></p><h3 id="7-3-typeAliases"><a href="#7-3-typeAliases" class="headerlink" title="7.3 typeAliases"></a>7.3 typeAliases</h3><p>​可以用来设置给全类名设置别名，简化书写。一般设置一个包下的类全部具有默认别名。默认别名是类目首字母小写。例如：com.sangeng.pojo.User别名为user</p><pre><code class="java">   &lt;typeAliases&gt;        &lt;package name=&quot;com.sangeng.dao&quot;&gt;&lt;/package&gt;    &lt;/typeAliases&gt;</code></pre><h3 id="7-4-environments"><a href="#7-4-environments" class="headerlink" title="7.4 environments"></a>7.4 environments</h3><p>​配置数据库相关的环境，例如事物管理器，连接池相关参数等。</p><pre><code class="xml">    &lt;!--设置默认环境--&gt;    &lt;environments default=&quot;development&quot;&gt;                &lt;!--设置该环境的唯一标识--&gt;        &lt;environment id=&quot;development&quot;&gt;            &lt;transactionManager type=&quot;JDBC&quot;/&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;!--获取配置文件中配置的对应的值来设置连接相关参数--&gt;                &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;</code></pre><h3 id="7-5-mappers"><a href="#7-5-mappers" class="headerlink" title="7.5 mappers"></a>7.5 mappers</h3><p>​该标签的作用是加载映射的，加载方式有如下几种(<strong>主要使用第四种</strong>)：</p><p>​①使用相对于类路径的资源引用，例如：</p><pre><code class="xml">&lt;!-- 使用相对于类路径的资源引用 --&gt;&lt;mappers&gt;  &lt;mapper resource=&quot;org/mybatis/builder/AuthorMapper.xml&quot;/&gt;  &lt;mapper resource=&quot;org/mybatis/builder/BlogMapper.xml&quot;/&gt;  &lt;mapper resource=&quot;org/mybatis/builder/PostMapper.xml&quot;/&gt;&lt;/mappers&gt;</code></pre><p>​②使用完全限定资源定位符（URL），例如：</p><pre><code class="xml">&lt;!-- 使用完全限定资源定位符（URL） --&gt;&lt;mappers&gt;  &lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&gt;  &lt;mapper url=&quot;file:///var/mappers/BlogMapper.xml&quot;/&gt;  &lt;mapper url=&quot;file:///var/mappers/PostMapper.xml&quot;/&gt;&lt;/mappers&gt;</code></pre><p>​③使用映射器接口实现类的完全限定类名，例如：</p><pre><code class="xml">&lt;!-- 使用映射器接口实现类的完全限定类名 --&gt;&lt;mappers&gt;  &lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&gt;  &lt;mapper class=&quot;org.mybatis.builder.BlogMapper&quot;/&gt;  &lt;mapper class=&quot;org.mybatis.builder.PostMapper&quot;/&gt;&lt;/mappers&gt;</code></pre><p>​④将包内的映射器接口实现全部注册为映射器，例如：</p><pre><code class="xml">&lt;!-- 定义dao接口所在的包。要求xml文件存放的路径和dao接口的包名要对应 --&gt;&lt;mappers&gt;  &lt;package name=&quot;org.mybatis.builder&quot;/&gt;&lt;/mappers&gt;</code></pre><p>​</p><h2 id="8-打印日志"><a href="#8-打印日志" class="headerlink" title="8. 打印日志"></a>8. 打印日志</h2><p>①log4j配置  在resources目录下创建log4j.properties文件，内容如下：</p><pre><code class="properties">### direct log messages to stdout ###log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target=System.outlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n### direct messages to file mylog.log ###log4j.appender.file=org.apache.log4j.FileAppenderlog4j.appender.file.File=c:/mylog.loglog4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n### set log levels - for more verbose logging change &#39;info&#39; to &#39;debug&#39; ###log4j.rootLogger=debug, stdout</code></pre><p>②引入依赖</p><pre><code class="xml">        &lt;dependency&gt;            &lt;groupId&gt;log4j&lt;/groupId&gt;            &lt;artifactId&gt;log4j&lt;/artifactId&gt;            &lt;version&gt;1.2.17&lt;/version&gt;        &lt;/dependency&gt;</code></pre><h2 id="9-获取参数时-和-的区别"><a href="#9-获取参数时-和-的区别" class="headerlink" title="9.获取参数时 #{}和${}的区别"></a>9.获取参数时 #{}和${}的区别</h2><p>​如果使用#{}.他是预编译的sql可以防止SQL注入攻击<br>​如果使用${}他是直接把参数值拿来进行拼接，这样会有SQL注入的危险</p><p>如果使用的是#{}来获取参数值日志如下：<br>Preparing: select * from user where id &#x3D; <strong>?</strong> and username &#x3D; <strong>?</strong> and age &#x3D; <strong>?</strong> and address &#x3D; <strong>?</strong><br>Parameters: 2(Integer), 快乐风男(String), 29(Integer), 北京(String)</p><p>如果使用${}来获取参数值日志如下：<br>Preparing: select * from user where id &#x3D; 2 and username &#x3D; 快乐风男 and age &#x3D; 29 and address &#x3D; 北京 </p>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Mybatis </category>
          
          <category> Mybatis基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Step.3</title>
      <link href="/computer-science/Mybatis/doscmp/Mybatis-03/"/>
      <url>/computer-science/Mybatis/doscmp/Mybatis-03/</url>
      
        <content type="html"><![CDATA[<h1 id="Mybatis-3"><a href="#Mybatis-3" class="headerlink" title="Mybatis-3"></a>Mybatis-3</h1><h2 id="0-案例环境"><a href="#0-案例环境" class="headerlink" title="0. 案例环境"></a>0. 案例环境</h2><h3 id="0-1-案例数据初始化sql"><a href="#0-1-案例数据初始化sql" class="headerlink" title="0.1 案例数据初始化sql"></a>0.1 案例数据初始化sql</h3><pre><code class="mysql">CREATE DATABASE /*!32312 IF NOT EXISTS*/`mybatis_db` /*!40100 DEFAULT CHARACTER SET utf8 */;USE `mybatis_db`;DROP TABLE IF EXISTS `orders`;CREATE TABLE `orders` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `createtime` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,  `price` int(11) DEFAULT NULL COMMENT &#39;价格&#39;,  `remark` varchar(100) DEFAULT NULL COMMENT &#39;备注&#39;,  `user_id` int(11) DEFAULT NULL COMMENT &#39;用户id&#39;,  PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;insert  into `orders`(`id`,`createtime`,`price`,`remark`,`user_id`) values (1,&#39;2014-06-26 16:55:43&#39;,2000,&#39;无&#39;,2),(2,&#39;2021-02-23 16:55:57&#39;,3000,&#39;无&#39;,3),(3,&#39;2021-02-23 16:56:21&#39;,4000,&#39;无&#39;,2);DROP TABLE IF EXISTS `role`;CREATE TABLE `role` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `name` varchar(100) DEFAULT NULL COMMENT &#39;角色名&#39;,  `desc` varchar(100) DEFAULT NULL COMMENT &#39;角色描述&#39;,  PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;/*Data for the table `role` */insert  into `role`(`id`,`name`,`desc`) values (1,&#39;总经理&#39;,&#39;一人之下&#39;),(2,&#39;CFO&#39;,NULL);/*Table structure for table `user` */DROP TABLE IF EXISTS `user`;CREATE TABLE `user` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `username` varchar(50) DEFAULT NULL,  `age` int(11) DEFAULT NULL,  `address` varchar(50) DEFAULT NULL,  PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=33 DEFAULT CHARSET=utf8;/*Data for the table `user` */insert  into `user`(`id`,`username`,`age`,`address`) values (2,&#39;pdd&#39;,26,NULL),(3,&#39;UZI&#39;,19,&#39;上海11&#39;),(4,&#39;RF&#39;,19,NULL);/*Table structure for table `user_role` */DROP TABLE IF EXISTS `user_role`;CREATE TABLE `user_role` (  `user_id` int(11) DEFAULT NULL,  `role_id` int(11) DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8;/*Data for the table `user_role` */insert  into `user_role`(`user_id`,`role_id`) values (2,2),(2,1),(3,1);</code></pre><h3 id="0-2-实体类"><a href="#0-2-实体类" class="headerlink" title="0.2 实体类"></a>0.2 实体类</h3><h4 id="0-2-1-User-java"><a href="#0-2-1-User-java" class="headerlink" title="0.2.1 User.java"></a>0.2.1 User.java</h4><pre><code class="java">public class User &#123;    private Integer id;    private String username;    private Integer age;    private String address;    @Override    public String toString() &#123;        return &quot;User&#123;&quot; +                &quot;id=&quot; + id +                &quot;, username=&#39;&quot; + username + &#39;\&#39;&#39; +                &quot;, age=&quot; + age +                &quot;, address=&#39;&quot; + address + &#39;\&#39;&#39; +                &#39;&#125;&#39;;    &#125;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public String getUsername() &#123;        return username;    &#125;    public void setUsername(String username) &#123;        this.username = username;    &#125;    public Integer getAge() &#123;        return age;    &#125;    public void setAge(Integer age) &#123;        this.age = age;    &#125;    public String getAddress() &#123;        return address;    &#125;    public void setAddress(String address) &#123;        this.address = address;    &#125;    public User() &#123;    &#125;    public User(Integer id, String username, Integer age, String address) &#123;        this.id = id;        this.username = username;        this.age = age;        this.address = address;    &#125;&#125;</code></pre><h4 id="0-2-2-Order-java"><a href="#0-2-2-Order-java" class="headerlink" title="0.2.2 Order.java"></a>0.2.2 Order.java</h4><pre><code class="java">public class Order &#123;    private Integer id;    private Date createtime;    private Integer price;    private String remark;    private Integer userId;    @Override    public String toString() &#123;        return &quot;Order&#123;&quot; +                &quot;id=&quot; + id +                &quot;, createtime=&quot; + createtime +                &quot;, price=&quot; + price +                &quot;, remark=&#39;&quot; + remark + &#39;\&#39;&#39; +                &quot;, userId=&quot; + userId +                &#39;&#125;&#39;;    &#125;      public Order() &#123;    &#125;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public Date getCreatetime() &#123;        return createtime;    &#125;    public void setCreatetime(Date createtime) &#123;        this.createtime = createtime;    &#125;    public Integer getPrice() &#123;        return price;    &#125;    public void setPrice(Integer price) &#123;        this.price = price;    &#125;    public String getRemark() &#123;        return remark;    &#125;    public void setRemark(String remark) &#123;        this.remark = remark;    &#125;    public Integer getUserId() &#123;        return userId;    &#125;    public void setUserId(Integer userId) &#123;        this.userId = userId;    &#125;    public Order(Integer id, Date createtime, Integer price, String remark, Integer userId) &#123;        this.id = id;        this.createtime = createtime;        this.price = price;        this.remark = remark;        this.userId = userId;    &#125;&#125;</code></pre><h4 id="0-2-3-Role-java"><a href="#0-2-3-Role-java" class="headerlink" title="0.2.3 Role.java"></a>0.2.3 Role.java</h4><pre><code class="java">public class Role &#123;    private Integer id;    private String name;    private String desc;    @Override    public String toString() &#123;        return &quot;Role&#123;&quot; +                &quot;id=&quot; + id +                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, desc=&#39;&quot; + desc + &#39;\&#39;&#39; +                &#39;&#125;&#39;;    &#125;    public Role() &#123;    &#125;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public String getDesc() &#123;        return desc;    &#125;    public void setDesc(String desc) &#123;        this.desc = desc;    &#125;    public Role(Integer id, String name, String desc) &#123;        this.id = id;        this.name = name;        this.desc = desc;    &#125;&#125;</code></pre><h2 id="1-ResultMap"><a href="#1-ResultMap" class="headerlink" title="1. ResultMap"></a>1. ResultMap</h2><h3 id="1-1-基本使用"><a href="#1-1-基本使用" class="headerlink" title="1.1 基本使用"></a>1.1 基本使用</h3><p>​我们可以使用resultMap标签自定义结果集和实体类属性的映射规则。</p><pre><code class="xml">    &lt;!--        resultMap 用来自定义结果集和实体类的映射            属性：                id 相当于这个resultMap的唯一标识                type 用来指定映射到哪个实体类        id标签  用来指定主键列的映射规则            属性：                property 要映射的属性名                column  对应的列名        result标签 用来指定普通列的映射规则            属性：                property 要映射的属性名                column 对应的列名    --&gt;    &lt;resultMap id=&quot;orderMap&quot; type=&quot;com.sangeng.pojo.Order&quot; &gt;        &lt;id column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/id&gt;        &lt;result column=&quot;createtime&quot; property=&quot;createtime&quot;&gt;&lt;/result&gt;        &lt;result column=&quot;price&quot; property=&quot;price&quot;&gt;&lt;/result&gt;        &lt;result column=&quot;remark&quot; property=&quot;remark&quot;&gt;&lt;/result&gt;        &lt;result column=&quot;user_id&quot; property=&quot;userId&quot;&gt;&lt;/result&gt;    &lt;/resultMap&gt;    &lt;!--使用我们自定义的映射规则--&gt;    &lt;select id=&quot;findAll&quot; resultMap=&quot;orderMap&quot;&gt;        SELECT id,createtime,price,remark,user_id  FROM ORDERS    &lt;/select&gt;    </code></pre><h3 id="1-2-自动映射"><a href="#1-2-自动映射" class="headerlink" title="1.2 自动映射"></a>1.2 自动映射</h3><p>​我们定义resultMap时默认情况下自动映射是开启状态的。也就是如果结果集的列名和我们的属性名相同是会自动映射的我们只需要写特殊情况的映射关系即可。</p><p>例如：</p><p>下面这种写法和上面的写法会有相同的效果，因为其他属性的属性名和结果集的列名都是相同的会自动映射。</p><pre><code class="xml">    &lt;resultMap id=&quot;orderMap&quot; type=&quot;com.sangeng.pojo.Order&quot; &gt;        &lt;result column=&quot;user_id&quot; property=&quot;userId&quot;&gt;&lt;/result&gt;    &lt;/resultMap&gt;    &lt;!--使用我们自定义的映射规则--&gt;    &lt;select id=&quot;findAll&quot; resultMap=&quot;orderMap&quot;&gt;        SELECT id,createtime,price,remark,user_id  FROM ORDERS    &lt;/select&gt;</code></pre><p>​如有需要可以选择关闭自动映射可以把resultMap的autoMapping属性设置为false。</p><p>例如：</p><pre><code class="xml">    &lt;resultMap id=&quot;orderMap&quot; type=&quot;com.sangeng.pojo.Order&quot; autoMapping=&quot;false&quot;&gt;        &lt;id column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/id&gt;        &lt;result column=&quot;createtime&quot; property=&quot;createtime&quot;&gt;&lt;/result&gt;        &lt;result column=&quot;price&quot; property=&quot;price&quot;&gt;&lt;/result&gt;        &lt;result column=&quot;remark&quot; property=&quot;remark&quot;&gt;&lt;/result&gt;        &lt;result column=&quot;user_id&quot; property=&quot;userId&quot;&gt;&lt;/result&gt;    &lt;/resultMap&gt;</code></pre><h3 id="1-3-继承映射关系"><a href="#1-3-继承映射关系" class="headerlink" title="1.3 继承映射关系"></a>1.3 继承映射关系</h3><p>​我们可以使用resultMap 的extends属性来指定一个resultMap，从而复用重复的映射关系配置。</p><p>例如：</p><pre><code class="xml">      &lt;!--定义个父映射，供其他resultMap继承--&gt;    &lt;resultMap id=&quot;baseOrderMap&quot; type=&quot;com.sangeng.pojo.Order&quot; &gt;        &lt;id column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/id&gt;        &lt;result column=&quot;createtime&quot; property=&quot;createtime&quot;&gt;&lt;/result&gt;        &lt;result column=&quot;price&quot; property=&quot;price&quot;&gt;&lt;/result&gt;        &lt;result column=&quot;remark&quot; property=&quot;remark&quot;&gt;&lt;/result&gt;    &lt;/resultMap&gt;    &lt;!--继承baseOrderMap，然后只需要写自己特有的映射关系即可--&gt;    &lt;resultMap id=&quot;orderMap&quot; type=&quot;com.sangeng.pojo.Order&quot; autoMapping=&quot;false&quot; extends=&quot;baseOrderMap&quot;&gt;        &lt;result column=&quot;user_id&quot; property=&quot;userId&quot;&gt;&lt;/result&gt;    &lt;/resultMap&gt;</code></pre><h2 id="2-多表查询"><a href="#2-多表查询" class="headerlink" title="2. 多表查询"></a>2. 多表查询</h2><p>​有的时候我们需要查询多张表的数据才可以得到我们要的结果。</p><p>​我们可以直接写一个多表关联的SQL进行查询。也可以分步进行多次的查询来拿到我们需要的结果。    </p><p>​Mybatis就提供了对应的配置，可以让我们去更方便的进行相应的查询和对应的结果集处理。</p><h3 id="2-1-多表关联查询"><a href="#2-1-多表关联查询" class="headerlink" title="2.1 多表关联查询"></a>2.1 多表关联查询</h3><h4 id="2-1-1-一对一关系"><a href="#2-1-1-一对一关系" class="headerlink" title="2.1.1 一对一关系"></a>2.1.1 一对一关系</h4><p>​两个实体之间是一对一的关系。(例如我们需要查询订单，要求还需要下单用户的数据。这里的订单相对于用户是一对一。)</p><p>例如：</p><p>方法定义如下</p><pre><code class="java">    //根据订单id查询订单，要求把下单用户的信息也查询出来    Order findById(Integer id);</code></pre><p>因为期望Order中还能包含下单用户的数据，所以可以再Order中增加一个属性</p><pre><code class="java">private User user;</code></pre><p>SQL语句如下</p><pre><code class="mysql">SELECT     o.id,o.`createtime`,o.`price`,o.`remark`,o.`user_id`,u.`id` uid,u.`username`,u.`age`,u.`address`FROM     orders o,USER uWHERE    o.`user_id` = u.`id`    AND o.id = 2</code></pre><p>结果集</p><p><img data-src="/images%5Cimgmybatis%5Cimage-2.png" alt="image-20210224155400455"></p><p>我们可以使用如下两种方式封装结果集。</p><h5 id="2-1-1-1-使用ResultMap对所有字段进行映射"><a href="#2-1-1-1-使用ResultMap对所有字段进行映射" class="headerlink" title="2.1.1.1 使用ResultMap对所有字段进行映射"></a>2.1.1.1 使用ResultMap对所有字段进行映射</h5><p>​可以使用ResultMap设置user对象的属性的映射规则。</p><p>①resultMap定义，主要是对user对象的属性设置映射规则</p><pre><code class="xml">     &lt;resultMap id=&quot;baseOrderMap&quot; type=&quot;com.sangeng.pojo.Order&quot; &gt;        &lt;id column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/id&gt;        &lt;result column=&quot;createtime&quot; property=&quot;createtime&quot;&gt;&lt;/result&gt;        &lt;result column=&quot;price&quot; property=&quot;price&quot;&gt;&lt;/result&gt;        &lt;result column=&quot;remark&quot; property=&quot;remark&quot;&gt;&lt;/result&gt;    &lt;/resultMap&gt;    &lt;resultMap id=&quot;orderMap&quot; type=&quot;com.sangeng.pojo.Order&quot; autoMapping=&quot;false&quot; extends=&quot;baseOrderMap&quot;&gt;        &lt;result column=&quot;user_id&quot; property=&quot;userId&quot;&gt;&lt;/result&gt;    &lt;/resultMap&gt;    &lt;!--Order和User关联的映射--&gt;    &lt;resultMap id=&quot;orderUserMap&quot; type=&quot;com.sangeng.pojo.Order&quot; autoMapping=&quot;false&quot; extends=&quot;orderMap&quot;&gt;        &lt;result property=&quot;user.id&quot; column=&quot;uid&quot;&gt;&lt;/result&gt;        &lt;result property=&quot;user.username&quot; column=&quot;username&quot;&gt;&lt;/result&gt;        &lt;result property=&quot;user.age&quot; column=&quot;age&quot;&gt;&lt;/result&gt;        &lt;result property=&quot;user.address&quot; column=&quot;address&quot;&gt;&lt;/result&gt;    &lt;/resultMap&gt;</code></pre><p>②使用定义好的resultMap</p><pre><code class="xml">&lt;!--根据订单id查询订单，要求把下单用户的信息也查询出来--&gt;    &lt;select id=&quot;findById&quot; resultMap=&quot;orderUserMap&quot;&gt;        SELECT            o.`id`,o.`createtime`,o.`price`,o.`remark`,o.`user_id`,u.`id` uid,u.`username`,u.`age`,u.`address`        FROM            orders o,`user` u        WHERE            o.id = #&#123;id&#125; AND            o.`user_id`=u.`id`    &lt;/select&gt;</code></pre><h5 id="2-1-1-2-使用ResultMap中的association"><a href="#2-1-1-2-使用ResultMap中的association" class="headerlink" title="2.1.1.2 使用ResultMap中的association"></a>2.1.1.2 使用ResultMap中的association</h5><p>​可以使用ResultMap中的子标签association 来设置关联实体类的映射规则.</p><p>①定义resultMap</p><pre><code class="xml">     &lt;resultMap id=&quot;baseOrderMap&quot; type=&quot;com.sangeng.pojo.Order&quot; &gt;        &lt;id column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/id&gt;        &lt;result column=&quot;createtime&quot; property=&quot;createtime&quot;&gt;&lt;/result&gt;        &lt;result column=&quot;price&quot; property=&quot;price&quot;&gt;&lt;/result&gt;        &lt;result column=&quot;remark&quot; property=&quot;remark&quot;&gt;&lt;/result&gt;    &lt;/resultMap&gt;    &lt;resultMap id=&quot;orderMap&quot; type=&quot;com.sangeng.pojo.Order&quot; autoMapping=&quot;false&quot; extends=&quot;baseOrderMap&quot;&gt;        &lt;result column=&quot;user_id&quot; property=&quot;userId&quot;&gt;&lt;/result&gt;    &lt;/resultMap&gt;    &lt;!--Order和User关联的映射（使用association）--&gt;    &lt;resultMap id=&quot;orderUserMapUseAssociation&quot; type=&quot;com.sangeng.pojo.Order&quot; autoMapping=&quot;false&quot; extends=&quot;orderMap&quot;&gt;        &lt;association property=&quot;user&quot; javaType=&quot;com.sangeng.pojo.User&quot;&gt;            &lt;id property=&quot;id&quot; column=&quot;uid&quot;&gt;&lt;/id&gt;            &lt;result property=&quot;username&quot; column=&quot;username&quot;&gt;&lt;/result&gt;            &lt;result property=&quot;age&quot; column=&quot;age&quot;&gt;&lt;/result&gt;            &lt;result property=&quot;address&quot; column=&quot;address&quot;&gt;&lt;/result&gt;        &lt;/association&gt;    &lt;/resultMap&gt;</code></pre><p>②使用resultMap</p><pre><code class="xml">&lt;!--根据订单id查询订单，要求把下单用户的信息也查询出来--&gt;    &lt;select id=&quot;findById&quot; resultMap=&quot;orderUserMapUseAssociation&quot;&gt;        SELECT            o.`id`,o.`createtime`,o.`price`,o.`remark`,o.`user_id`,u.`id` uid,u.`username`,u.`age`,u.`address`        FROM            orders o,`user` u        WHERE            o.id = #&#123;id&#125; AND            o.`user_id`=u.`id`    &lt;/select&gt;</code></pre><h4 id="2-1-2-一对多关系"><a href="#2-1-2-一对多关系" class="headerlink" title="2.1.2 一对多关系"></a>2.1.2 一对多关系</h4><p>​两个实体之间是一对多的关系。(例如我们需要查询用户，要求还需要该用户所具有的角色信息。这里的用户相对于角色是一对多的。)</p><p>例如：</p><p>方法定义如下</p><pre><code class="java">    //根据id查询用户，并且要求把该用户所具有的角色信息也查询出来    User findById(Integer id);</code></pre><p>因为期望User中还能包含该用户所具有的角色信息，所以可以在User中增加一个属性</p><pre><code class="java">//    该用户所具有的角色    private List&lt;Role&gt; roles;</code></pre><p>SQL语句如下</p><pre><code class="mysql">SELECT     u.`id`,u.`username`,u.`age`,u.`address`,r.id rid,r.name,r.descFROM     USER u,user_role ur,role rWHERE     u.id=ur.user_id AND ur.role_id = r.id    AND u.id = 2</code></pre><p>结果集</p><p><img data-src="/images%5Cimgmybatis%5Cimage-4.png" alt="image-20210224164927461"></p><p>我们可以使用如下的方式封装结果集。</p><h5 id="2-1-2-1-使用ResultMap中的collection"><a href="#2-1-2-1-使用ResultMap中的collection" class="headerlink" title="2.1.2.1 使用ResultMap中的collection"></a>2.1.2.1 使用ResultMap中的collection</h5><p>​可以使用ResultMap中的子标签association 来设置关联实体类的映射规则.</p><p>①定义ResultMap</p><pre><code class="xml">    &lt;!--定义User基本属性映射规则--&gt;    &lt;resultMap id=&quot;userMap&quot; type=&quot;com.sangeng.pojo.User&quot;&gt;        &lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/id&gt;        &lt;result property=&quot;username&quot; column=&quot;username&quot;&gt;&lt;/result&gt;        &lt;result property=&quot;age&quot; column=&quot;age&quot;&gt;&lt;/result&gt;        &lt;result property=&quot;address&quot; column=&quot;address&quot;&gt;&lt;/result&gt;    &lt;/resultMap&gt;        &lt;resultMap id=&quot;userRoleMap&quot; type=&quot;com.sangeng.pojo.User&quot;  extends=&quot;userMap&quot;&gt;        &lt;collection property=&quot;roles&quot; ofType=&quot;com.sangeng.pojo.Role&quot; &gt;            &lt;id property=&quot;id&quot; column=&quot;rid&quot;&gt;&lt;/id&gt;            &lt;result property=&quot;name&quot; column=&quot;name&quot;&gt;&lt;/result&gt;            &lt;result property=&quot;desc&quot; column=&quot;desc&quot;&gt;&lt;/result&gt;        &lt;/collection&gt;    &lt;/resultMap&gt;</code></pre><p>②使用ResultMap</p><pre><code class="xml">        &lt;select id=&quot;findById&quot; resultMap=&quot;userRoleMap&quot; &gt;        SELECT             u.`id`,u.`username`,u.`age`,u.`address`,r.id rid,r.name,r.desc        FROM             USER u,user_role ur,role r        WHERE             u.id=ur.user_id AND ur.role_id = r.id            AND u.id = #&#123;id&#125;    &lt;/select&gt;</code></pre><p>最终封装完的结果如下：</p><p><img data-src="/images%5Cimgmybatis%5Cimage-5.png" alt="image-20210224170108202"></p><h3 id="2-2-分步查询"><a href="#2-2-分步查询" class="headerlink" title="2.2 分步查询"></a>2.2 分步查询</h3><p>​如果有需要多表查询的需求我们也可以选择用多次查询的方式来查询出我们想要的数据。Mybatis也提供了对应的配置。</p><p>​例如我们需要查询用户，要求还需要查询出该用户所具有的角色信息。我们可以选择先查询User表查询用户信息。然后在去查询关联的角色信息。</p><h4 id="2-2-1实现步骤"><a href="#2-2-1实现步骤" class="headerlink" title="2.2.1实现步骤"></a>2.2.1实现步骤</h4><p>​具体步骤如下：</p><h5 id="①定义查询方法"><a href="#①定义查询方法" class="headerlink" title="①定义查询方法"></a>①定义查询方法</h5><p>​因为我们要分两步查询: 1.查询User 2.根据用户的id查询Role  所以我们需要定义下面两个方法，并且把对应的标签也先写好</p><p>1.查询User</p><pre><code class="java">    //根据用户名查询用户，并且要求把该用户所具有的角色信息也查询出来    User findByUsername(String username);</code></pre><pre><code class="xml">    &lt;!--根据用户名查询用户--&gt;    &lt;select id=&quot;findByUsername&quot; resultType=&quot;com.sangeng.pojo.User&quot;&gt;        select id,username,age,address from user where username = #&#123;username&#125;    &lt;/select&gt;</code></pre><p>2.根据user_id查询Role</p><pre><code class="java">public interface RoleDao &#123;    //根据userId查询所具有的角色    List&lt;Role&gt; findRoleByUserId(Integer userId);&#125;</code></pre><pre><code class="xml">    &lt;!--根据userId查询所具有的角色--&gt;    &lt;select id=&quot;findRoleByUserId&quot; resultType=&quot;com.sangeng.pojo.Role&quot;&gt;        select             r.id,r.name,r.desc        from             role r,user_role ur        where             ur.role_id = r.id            and ur.user_id = #&#123;userId&#125;    &lt;/select&gt;</code></pre><h5 id="②配置分步查询"><a href="#②配置分步查询" class="headerlink" title="②配置分步查询"></a>②配置分步查询</h5><p>​我们期望的效果是调用findByUsername方法查询出来的结果中就包含角色的信息。所以我们可以设置findByUsername方法的RestltMap，指定分步查询</p><pre><code class="xml">    &lt;resultMap id=&quot;userMap&quot; type=&quot;com.sangeng.pojo.User&quot;&gt;        &lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/id&gt;        &lt;result property=&quot;username&quot; column=&quot;username&quot;&gt;&lt;/result&gt;        &lt;result property=&quot;age&quot; column=&quot;age&quot;&gt;&lt;/result&gt;        &lt;result property=&quot;address&quot; column=&quot;address&quot;&gt;&lt;/result&gt;    &lt;/resultMap&gt;    &lt;!--           select属性：指定用哪个查询来查询当前属性的数据 写法：包名.接口名.方法名           column属性：设置当前结果集中哪列的数据作为select属性指定的查询方法需要参数       --&gt;    &lt;resultMap id=&quot;userRoleMapBySelect&quot; type=&quot;com.sangeng.pojo.User&quot; extends=&quot;userMap&quot;&gt;        &lt;collection property=&quot;roles&quot;                    ofType=&quot;com.sangeng.pojo.Role&quot;                    select=&quot;com.sangeng.dao.RoleDao.findRoleByUserId&quot;                    column=&quot;id&quot;&gt;        &lt;/collection&gt;    &lt;/resultMap&gt;</code></pre><p>​指定findByUsername使用我们刚刚创建的resultMap</p><pre><code class="xml">    &lt;!--根据用户名查询用户--&gt;    &lt;select id=&quot;findByUsername&quot; resultMap=&quot;userRoleMapBySelect&quot;&gt;        select id,username,age,address from user where username = #&#123;username&#125;    &lt;/select&gt;</code></pre><h4 id="2-2-2-设置按需加载"><a href="#2-2-2-设置按需加载" class="headerlink" title="2.2.2 设置按需加载"></a>2.2.2 设置按需加载</h4><p>​我们可以设置按需加载，这样在我们代码中需要用到关联数据的时候才会去查询关联数据。</p><p>​有两种方式可以配置分别是全局配置和局部配置</p><ol><li><p>局部配置</p><p>设置fetchType属性为lazy</p><pre><code class="xml">    &lt;resultMap id=&quot;userRoleMapBySelect&quot; type=&quot;com.sangeng.pojo.User&quot; extends=&quot;userMap&quot;&gt;        &lt;collection property=&quot;roles&quot;                    ofType=&quot;com.sangeng.pojo.Role&quot;                    select=&quot;com.sangeng.dao.RoleDao.findRoleByUserId&quot;                    column=&quot;id&quot; fetchType=&quot;lazy&quot;&gt;        &lt;/collection&gt;    &lt;/resultMap&gt;</code></pre></li><li><p>全局配置</p><p>设置lazyLoadingEnabled为true</p><pre><code class="xml">    &lt;settings&gt;       &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;    &lt;/settings&gt;</code></pre></li></ol><h2 id="3-分页查询-PageHelper"><a href="#3-分页查询-PageHelper" class="headerlink" title="3.分页查询-PageHelper"></a>3.分页查询-PageHelper</h2><p>​我们可以使用PageHelper非常方便的帮我们实现分页查询的需求。不需要自己在SQL中拼接SQL相关参数，并且能非常方便的获取的总页数总条数等分页相关数据。</p><h3 id="3-1-实现步骤"><a href="#3-1-实现步骤" class="headerlink" title="3.1 实现步骤"></a>3.1 实现步骤</h3><h4 id="①定义方法查询方法以及生成对应标签"><a href="#①定义方法查询方法以及生成对应标签" class="headerlink" title="①定义方法查询方法以及生成对应标签"></a>①定义方法查询方法以及生成对应标签</h4><pre><code class="java">    List&lt;User&gt; findAll();</code></pre><pre><code class="xml">    &lt;select id=&quot;findAll&quot; resultType=&quot;com.sangeng.pojo.User&quot;&gt;        select id,username,age,address from user    &lt;/select&gt;</code></pre><h4 id="②-引入依赖"><a href="#②-引入依赖" class="headerlink" title="② 引入依赖"></a>② 引入依赖</h4><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;    &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;    &lt;version&gt;4.0.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><h4 id="③-配置Mybatis核心配置文件使用分页插件"><a href="#③-配置Mybatis核心配置文件使用分页插件" class="headerlink" title="③ 配置Mybatis核心配置文件使用分页插件"></a>③ 配置Mybatis核心配置文件使用分页插件</h4><pre><code class="xml"> &lt;plugins&gt;        &lt;!-- 注意：分页助手的插件  配置在通用馆mapper之前 --&gt;        &lt;plugin interceptor=&quot;com.github.pagehelper.PageHelper&quot;&gt;            &lt;!-- 指定方言 --&gt;            &lt;property name=&quot;dialect&quot; value=&quot;mysql&quot;/&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;</code></pre><h4 id="④-开始分页查询"><a href="#④-开始分页查询" class="headerlink" title="④ 开始分页查询"></a>④ 开始分页查询</h4><p>我们只需要在使用查询方法前设置分页参数即可</p><pre><code class="java">    //设置分页参数    UserDao userDao = session.getMapper(UserDao.class);    //设置分页查询参数    PageHelper.startPage(1,1);    List&lt;User&gt; users = userDao.findAll();    System.out.println(users.get(0));</code></pre><p>如果需要获取总页数总条数等分页相关数据，只需要创建一个PageInfo对象，把刚刚查询出的返回值做为构造方法参数传入。然后使用pageInfo对象获取即可。</p><pre><code class="java">    PageInfo&lt;User&gt; pageInfo = new PageInfo&lt;User&gt;(users);    System.out.println(&quot;总条数：&quot;+pageInfo.getTotal());    System.out.println(&quot;总页数：&quot;+pageInfo.getPages());    System.out.println(&quot;当前页：&quot;+pageInfo.getPageNum());    System.out.println(&quot;每页显示长度：&quot;+pageInfo.getPageSize());</code></pre><h3 id="3-2-一对多多表查询分页问题"><a href="#3-2-一对多多表查询分页问题" class="headerlink" title="3.2 一对多多表查询分页问题"></a>3.2 一对多多表查询分页问题</h3><p>​我们在进行一对多的多表查询时，如果使用了PageHelper进行分页。会出现关联数据不全的情况。我们可以使用分步查询的方式解决该问题。</p><h2 id="4-Mybatis缓存"><a href="#4-Mybatis缓存" class="headerlink" title="4.Mybatis缓存"></a>4.Mybatis缓存</h2><p>​Mybatis的缓存其实就是把之前查到的数据存入内存（map）,下次如果还是查相同的东西，就可以直接从缓存中取，从而提高效率。</p><p>​Mybatis有一级缓存和二级缓存之分，一级缓存（默认开启）是sqlsession级别的缓存。二级缓存相当于mapper级别的缓存。</p><h3 id="4-1-一级缓存"><a href="#4-1-一级缓存" class="headerlink" title="4.1 一级缓存"></a>4.1 一级缓存</h3><p>几种不会使用一级缓存的情况<br>    1.调用相同方法但是传入的参数不同<br>    2.调用相同方法参数也相同，但是使用的是另外一个SqlSession<br>    3.如果查询完后，对同一个表进行了增，删改的操作，都会清空这sqlSession上的缓存<br>    4.如果手动调用SqlSession的clearCache方法清除缓存了，后面也使用不了缓存</p><h3 id="4-2-二级缓存"><a href="#4-2-二级缓存" class="headerlink" title="4.2 二级缓存"></a>4.2 二级缓存</h3><p>​注意：只在sqlsession调用了close或者commit后的数据才会进入二级缓存。</p><h4 id="4-2-1-开启二级缓存"><a href="#4-2-1-开启二级缓存" class="headerlink" title="4.2.1 开启二级缓存"></a>4.2.1 开启二级缓存</h4><p>①全局开启</p><p>在Mybatis核心配置文件中配置</p><pre><code class="xml">    &lt;settings&gt;        &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;    &lt;/settings&gt;</code></pre><p>②局部开启</p><p>在要开启二级缓存的mapper映射文件中设置 cache标签</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;com.sangeng.dao.RoleDao&quot;&gt;    &lt;cache&gt;&lt;/cache&gt;&lt;/mapper&gt;</code></pre><h4 id="4-2-2-使用建议"><a href="#4-2-2-使用建议" class="headerlink" title="4.2.2 使用建议"></a>4.2.2 使用建议</h4><p>​二级缓存在实际开发中基本不会使用。</p><h2 id="5-Mybatis原理-单独专题讲解"><a href="#5-Mybatis原理-单独专题讲解" class="headerlink" title="5.Mybatis原理-单独专题讲解"></a>5.Mybatis原理-单独专题讲解</h2>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Mybatis </category>
          
          <category> Mybatis基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Step.2</title>
      <link href="/computer-science/Mybatis/doscmp/Mybatis-02/"/>
      <url>/computer-science/Mybatis/doscmp/Mybatis-02/</url>
      
        <content type="html"><![CDATA[<h1 id="Mybatis-02"><a href="#Mybatis-02" class="headerlink" title="Mybatis-02"></a>Mybatis-02</h1><h2 id="1-注解开发"><a href="#1-注解开发" class="headerlink" title="1. 注解开发"></a>1. 注解开发</h2><p>​我们也可以使用注解的形式来进行开发，用注解来替换掉xml。 使用注解来映射简单语句会使代码显得更加简洁，但对于稍微复杂一点的语句，Java 注解不仅力不从心，还会让你本就复杂的 SQL 语句更加混乱不堪。 所以我们在实际企业开发中一般都是使用XML的形式。</p><p>​</p><h3 id="1-1-步骤"><a href="#1-1-步骤" class="headerlink" title="1.1 步骤"></a>1.1 步骤</h3><p>①在核心配置文件中配置mapper接口所在的包名</p><pre><code class="xml">    &lt;mappers&gt;        &lt;package name=&quot;com.sangeng.dao&quot;&gt;&lt;/package&gt;    &lt;/mappers&gt;</code></pre><p>②在接口对应方法上使用注解来配置需要执行的sql</p><pre><code class="java">public interface UserDao &#123;    @Select(&quot;select * from user&quot;)    List&lt;User&gt; findAll();    @Insert(&quot;insert into user values(null,#&#123;username&#125;,#&#123;age&#125;,#&#123;address&#125;)&quot;)    void insertUser(User user);    @Update(&quot;UPDATE USER SET age = #&#123;age&#125; , username = #&#123;username&#125;,address = #&#123;address&#125; WHERE id = #&#123;id&#125;&quot;)    void updateUser(User user);    @Delete(&quot;delete from user where id = #&#123;id&#125;&quot;)    void deleteById(Integer id);&#125;</code></pre><p>③和之前的一样获取Mapper调用方法即可</p><pre><code class="java">    public static void main(String[] args) throws IOException &#123;        //定义mybatis配置文件的路径        String resource = &quot;mybatis-config.xml&quot;;        InputStream inputStream = Resources.getResourceAsStream(resource);        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);        //获取Sqlsession对象        SqlSession sqlSession = sqlSessionFactory.openSession();        //获取UserDao实现类对象        UserDao userDao = sqlSession.getMapper(UserDao.class);        //调用方法测试        List&lt;User&gt; userList = userDao.findAll();        System.out.println(userList);        //释放资源        sqlSession.close();    &#125;</code></pre><h2 id="2-动态SQL"><a href="#2-动态SQL" class="headerlink" title="2.动态SQL"></a>2.动态SQL</h2><p>​在实际开发中的SQL语句没有之前的这么简单，很多时候需要根据传入的参数情况动态的生成SQL语句。Mybatis提供了动态SQL相关的标签让我们使用。</p><h3 id="2-1-if"><a href="#2-1-if" class="headerlink" title="2.1  if"></a>2.1  if</h3><p>​可以使用if标签进行条件判断，条件成立才会把if标签中的内容拼接进sql语句中。</p><p>例如：</p><pre><code class="xml">    &lt;select id=&quot;findByCondition&quot; resultType=&quot;com.sangeng.pojo.User&quot;&gt;         select * from user         where  id = #&#123;id&#125;        &lt;if test=&quot;username!=null&quot;&gt;           and username = #&#123;username&#125;        &lt;/if&gt;    &lt;/select&gt;</code></pre><p>如果参数username为null则执行的sql为：<strong>select * from user where id &#x3D; ?</strong> </p><p>如果参数username不为null则执行的sql为：<strong>select * from user where id &#x3D; ? and username &#x3D; ?</strong> </p><p><strong>注意：在test属性中表示参数的时候不需要写#{}，写了会出问题。</strong></p><h3 id="2-2-trim"><a href="#2-2-trim" class="headerlink" title="2.2 trim"></a>2.2 trim</h3><p>​可以使用该标签动态的添加前缀或后缀，也可以使用该标签动态的消除前缀。</p><h4 id="2-2-1-prefixOverrides属性"><a href="#2-2-1-prefixOverrides属性" class="headerlink" title="2.2.1 prefixOverrides属性"></a>2.2.1 prefixOverrides属性</h4><p>​用来设置需要被清除的前缀,多个值可以用|分隔，注意|前后不要有空格。例如： and|or</p><p>例如：</p><pre><code class="xml">    &lt;select id=&quot;findByCondition&quot; resultType=&quot;com.sangeng.pojo.User&quot;&gt;        select * from user        &lt;trim prefixOverrides=&quot;and|or&quot; &gt;            and        &lt;/trim&gt;    &lt;/select&gt;</code></pre><p>最终执行的sql为： select * from user</p><h4 id="2-2-2-suffixOverrides属性"><a href="#2-2-2-suffixOverrides属性" class="headerlink" title="2.2.2 suffixOverrides属性"></a>2.2.2 suffixOverrides属性</h4><p>​用来设置需要被清除的后缀,多个值可以用|分隔，注意|前后不要有空格。例如： and|or</p><p>例如：</p><pre><code class="xml">    &lt;select id=&quot;findByCondition&quot; resultType=&quot;com.sangeng.pojo.User&quot;&gt;        select * from user        &lt;trim suffixOverrides=&quot;like|and&quot; &gt;            where 1=1 like        &lt;/trim&gt;    &lt;/select&gt;</code></pre><p>最终执行的sql为： select * from user  去掉了后缀like</p><h4 id="2-2-3-prefix属性"><a href="#2-2-3-prefix属性" class="headerlink" title="2.2.3 prefix属性"></a>2.2.3 prefix属性</h4><p>​用来设置动态添加的前缀，如果标签中有内容就会添加上设置的前缀</p><p>例如：</p><pre><code class="xml">    &lt;select id=&quot;findByCondition&quot; resultType=&quot;com.sangeng.pojo.User&quot;&gt;        select * from user        &lt;trim prefix=&quot;where&quot; &gt;           1=1        &lt;/trim&gt;    &lt;/select&gt;</code></pre><p>最终执行的sql为：select * from user where 1&#x3D;1   动态增加了前缀where</p><h4 id="2-2-4-suffix属性"><a href="#2-2-4-suffix属性" class="headerlink" title="2.2.4 suffix属性"></a>2.2.4 suffix属性</h4><p>​用来设置动态添加的后缀，如果标签中有内容就会添加上设置的后缀</p><pre><code class="xml">    &lt;select id=&quot;findByCondition&quot; resultType=&quot;com.sangeng.pojo.User&quot;&gt;        select * from user        &lt;trim suffix=&quot;1=1&quot; &gt;           where        &lt;/trim&gt;    &lt;/select&gt;</code></pre><p>最终执行的sql为：select * from user where 1&#x3D;1   动态增加了后缀1&#x3D;1</p><h4 id="2-2-5-动态添加前缀where-并且消除前缀and或者or"><a href="#2-2-5-动态添加前缀where-并且消除前缀and或者or" class="headerlink" title="2.2.5 动态添加前缀where 并且消除前缀and或者or"></a>2.2.5 动态添加前缀where 并且消除前缀and或者or</h4><pre><code class="java">User findByCondition(@Param(&quot;id&quot;) Integer id,@Param(&quot;username&quot;) String username);</code></pre><pre><code class="xml">    &lt;select id=&quot;findByCondition&quot; resultType=&quot;com.sangeng.pojo.User&quot;&gt;        select * from user        &lt;trim prefix=&quot;where&quot; prefixOverrides=&quot;and|or&quot; &gt;            &lt;if test=&quot;id!=null&quot;&gt;                id = #&#123;id&#125;            &lt;/if&gt;            &lt;if test=&quot;username!=null&quot;&gt;                and username = #&#123;username&#125;            &lt;/if&gt;        &lt;/trim&gt;    &lt;/select&gt;</code></pre><p>调用方法时如果传入的id和username为null则执行的SQL为：select * from user</p><p>调用方法时如果传入的id为null，username不为null，则执行的SQL为：select * from user where username &#x3D; ?</p><h3 id="2-2-where"><a href="#2-2-where" class="headerlink" title="2.2 where"></a>2.2 where</h3><p>​where标签等价于：</p><pre><code class="xml">&lt;trim prefix=&quot;where&quot; prefixOverrides=&quot;and|or&quot; &gt;&lt;/trim&gt;</code></pre><p>​可以使用where标签动态的拼接where并且去除前缀的and或者or。</p><p>例如：</p><pre><code class="xml">    &lt;select id=&quot;findByCondition&quot; resultType=&quot;com.sangeng.pojo.User&quot;&gt;        select * from user        &lt;where&gt;            &lt;if test=&quot;id!=null&quot;&gt;                id = #&#123;id&#125;            &lt;/if&gt;            &lt;if test=&quot;username!=null&quot;&gt;                and username = #&#123;username&#125;            &lt;/if&gt;        &lt;/where&gt;    &lt;/select&gt;</code></pre><p>如果id和username都为null，则执行的sql为：**select * from user **</p><p>如果id为null，username不为null，则执行的sql为：**select * from user  where username &#x3D; ? **</p><h3 id="2-3-set"><a href="#2-3-set" class="headerlink" title="2.3 set"></a>2.3 set</h3><p>​set标签等价于</p><pre><code class="xml">&lt;trim prefix=&quot;set&quot; suffixOverrides=&quot;,&quot; &gt;&lt;/trim&gt;</code></pre><p>​可以使用set标签动态的拼接set并且去除后缀的逗号。</p><p>例如：</p><pre><code class="xml">    &lt;update id=&quot;updateUser&quot;&gt;        UPDATE USER        &lt;set&gt;            &lt;if test=&quot;username!=null&quot;&gt;                username = #&#123;username&#125;,            &lt;/if&gt;            &lt;if test=&quot;age!=null&quot;&gt;                age = #&#123;age&#125;,            &lt;/if&gt;            &lt;if test=&quot;address!=null&quot;&gt;                address = #&#123;address&#125;,            &lt;/if&gt;        &lt;/set&gt;        where id = #&#123;id&#125;    &lt;/update&gt;</code></pre><p>如果调用方法时传入的User对象的id为2，username不为null，其他属性都为null则最终执行的sql为：UPDATE USER SET username &#x3D; ? where id &#x3D; ? </p><h3 id="2-4-foreach"><a href="#2-4-foreach" class="headerlink" title="2.4 foreach"></a>2.4 foreach</h3><p>​可以使用foreach标签遍历集合或者数组类型的参数，获取其中的元素拿来动态的拼接SQL语句。</p><p>例如：</p><p>方法定义如下</p><pre><code class="java">List&lt;User&gt; findByIds(@Param(&quot;ids&quot;) Integer[] ids);</code></pre><p>如果期望动态的根据实际传入的数组的长度拼接SQL语句。例如传入长度为4个数组最终执行的SQL为：</p><pre><code class="sql">select * from User WHERE id in( ? , ? , ? , ?, ? ) </code></pre><p>则在xml映射文件中可以使用以下写法</p><pre><code class="xml">    &lt;select id=&quot;findByIds&quot; resultType=&quot;com.sangeng.pojo.User&quot;&gt;        select * from User        &lt;where&gt;            &lt;foreach collection=&quot;ids&quot; open=&quot;id in(&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot;&gt;                #&#123;id&#125;            &lt;/foreach&gt;        &lt;/where&gt;    &lt;/select&gt;</code></pre><p><strong>collection：表示要遍历的参数。</strong></p><p><strong>open:表示遍历开始时拼接的语句</strong></p><p><strong>item：表示给当前遍历到的元素的取的名字</strong></p><p><strong>separator：表示每遍历完一次拼接的分隔符</strong></p><p><strong>close：表示最后一次遍历完拼接的语句</strong></p><p><strong>注意：如果方法参数是数组类型，默认的参数名是array，如果方法参数是list集合默认的参数名是list。建议遇到数组或者集合类型的参数统一使用@Param注解进行命名。</strong></p><h3 id="2-5-choose、when、otherwise"><a href="#2-5-choose、when、otherwise" class="headerlink" title="2.5 choose、when、otherwise"></a>2.5 choose、when、otherwise</h3><p>​当我们不想使用所有的条件，而只是想从多个条件中选择一个使用时。可以使用choose系列标签。类似于java中的switch。</p><p>例如:</p><p>接口中方法定义如下</p><pre><code class="java">List&lt;User&gt; selectChose(User user);</code></pre><p>期望：</p><p>​如果user对象的id不为空时就通过id查询。</p><p>​如果id为null,username不为null就通过username查询。</p><p>​如果id和username都会null就查询id为3的用户</p><p>xml映射文件如下</p><pre><code class="xml">     &lt;select id=&quot;selectChose&quot; resultType=&quot;com.sangeng.pojo.User&quot;&gt;        select * from user        &lt;where&gt;            &lt;choose&gt;                &lt;when test=&quot;id!=null&quot;&gt;                    id = #&#123;id&#125;                &lt;/when&gt;                &lt;when test=&quot;username!=null&quot;&gt;                    username = #&#123;username&#125;                &lt;/when&gt;                &lt;otherwise&gt;                    id = 3                &lt;/otherwise&gt;            &lt;/choose&gt;        &lt;/where&gt;    &lt;/select&gt;</code></pre><ul><li><p><strong>choose类似于java中的switch</strong></p></li><li><p><strong>when类似于java中的case</strong></p></li><li><p><strong>otherwise类似于java中的dufault</strong></p></li></ul><p>​一个choose标签中最多只会有一个when中的判断成立。从上到下去进行判断。如果成立了就把标签体的内容拼接到sql中，并且不会进行其它when的判断和拼接。如果所有的when都不成立则拼接otherwise中的语句。</p><h2 id="3-SQL片段抽取"><a href="#3-SQL片段抽取" class="headerlink" title="3. SQL片段抽取"></a>3. SQL片段抽取</h2><p>​我们在xml映射文件中编写SQL语句的时候可能会遇到重复的SQL片段。这种SQL片段我们可以使用sql标签来进行抽取。然后在需要使用的时候使用include标签进行使用。</p><p>例如：</p><pre><code class="xml">    &lt;sql id=&quot;baseSelect&quot; &gt;id,username,age,address&lt;/sql&gt;    &lt;select id=&quot;findAll&quot; resultType=&quot;com.sangeng.pojo.User&quot;&gt;        select &lt;include refid=&quot;baseSelect&quot;/&gt;  from user    &lt;/select&gt;</code></pre><p>最终执行的sql为： <strong>select id,username,age,address from user</strong> </p>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Mybatis </category>
          
          <category> Mybatis基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Step.1</title>
      <link href="/computer-science/spring/docssp/Spring-01/"/>
      <url>/computer-science/spring/docssp/Spring-01/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-01"><a href="#Spring-01" class="headerlink" title="Spring-01"></a>Spring-01</h1><h2 id="1-Spring简介"><a href="#1-Spring简介" class="headerlink" title="1.Spring简介"></a>1.Spring简介</h2><p>​ Spring是一个开源框架，它由[Rod Johnson](<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9Sb2Q=">https://baike.baidu.com/item/Rod</span> Johnson)创建。它是为了解决企业应用开发的复杂性而创建的。<br>​ 目前是JavaEE开发的灵魂框架。他可以简化JavaEE开发，可以非常方便整合其他框架，无侵入的进行功能增强。<br>​ Spring的核心就是 控制反转(IoC)和面向切面(AOP) 。</p><h2 id="2-IOC控制反转"><a href="#2-IOC控制反转" class="headerlink" title="2.IOC控制反转"></a>2.IOC控制反转</h2><h3 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h3><p>​控制反转，之前对象的控制权在类手上，现在反转后到了Spring手上。</p><h3 id="2-2-入门案例"><a href="#2-2-入门案例" class="headerlink" title="2.2 入门案例"></a>2.2 入门案例</h3><h4 id="①导入依赖"><a href="#①导入依赖" class="headerlink" title="①导入依赖"></a>①导入依赖</h4><p>导入SpringIOC相关依赖</p><pre><code class="xml">        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;        &lt;/dependency&gt;</code></pre><h4 id="②编写配置文件"><a href="#②编写配置文件" class="headerlink" title="②编写配置文件"></a>②编写配置文件</h4><p>在resources目录下创建applicationContext.xml文件，文件名可以任意取。但是建议叫applicationContext。<br>内容如下：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--        classs:配置类的全类名        id:配置一个唯一标识    --&gt;    &lt;bean class=&quot;com.sangeng.dao.impl.StudentDaoImpl&quot; id=&quot;studentDao&quot;  &gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><h4 id="③创建容器从容器中获取对象并测试"><a href="#③创建容器从容器中获取对象并测试" class="headerlink" title="③创建容器从容器中获取对象并测试"></a>③创建容器从容器中获取对象并测试</h4><pre><code class="java">    public static void main(String[] args) &#123;//        1.获取StudentDaoImpl对象        //创建Spring容器，指定要读取的配置文件路径        ApplicationContext app = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);        //从容器中获取对象        StudentDao studentDao = (StudentDao) app.getBean(&quot;studentDao&quot;);        //调用对象的方法进行测试        System.out.println(studentDao.getStudentById(1));    &#125;</code></pre><h3 id="2-3-Bean的常用属性配置"><a href="#2-3-Bean的常用属性配置" class="headerlink" title="2.3 Bean的常用属性配置"></a>2.3 Bean的常用属性配置</h3><h4 id="2-3-1-id"><a href="#2-3-1-id" class="headerlink" title="2.3.1 id"></a>2.3.1 id</h4><p>​bean的唯一标识，同一个Spring容器中不允许重复</p><h4 id="2-3-2-class"><a href="#2-3-2-class" class="headerlink" title="2.3.2 class"></a>2.3.2 class</h4><p>​全类名，用于反射创建对象</p><h4 id="2-3-3-scope"><a href="#2-3-3-scope" class="headerlink" title="2.3.3 scope"></a>2.3.3 scope</h4><p>​scope主要有两个值：singleton和prototype<br>​如果设置为singleton则一个容器中只会有这个一个bean对象。默认容器创建的时候就会创建该对象。<br>​如果设置为prototype则一个容器中会有多个该bean对象。每次调用getBean方法获取时都会创建一个新对象。</p><h2 id="3-DI依赖注入"><a href="#3-DI依赖注入" class="headerlink" title="3.DI依赖注入"></a>3.DI依赖注入</h2><p>​依赖注入可以理解成IoC的一种应用场景，反转的是对象间依赖关系维护权。</p><h3 id="3-1-set方法注入"><a href="#3-1-set方法注入" class="headerlink" title="3.1 set方法注入"></a>3.1 set方法注入</h3><p>在要注入属性的bean标签中进行配置。前提是该类有提供属性对应的set方法。</p><pre><code class="java">package com.sangeng.domain;public class Student &#123;    private String name;    private int id;    private int age;    private Dog dog;    public Dog getDog() &#123;        return dog;    &#125;    public void setDog(Dog dog) &#123;        this.dog = dog;    &#125;    @Override    public String toString() &#123;        return &quot;Student&#123;&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, id=&quot; + id +                &quot;, age=&quot; + age +                &#39;&#125;&#39;;    &#125;    public Student() &#123;    &#125;    public Student(String name, int id, int age) &#123;        this.name = name;        this.id = id;        this.age = age;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getId() &#123;        return id;    &#125;    public void setId(int id) &#123;        this.id = id;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;&#125;</code></pre><pre><code class="xml">    &lt;bean class=&quot;com.sangeng.domain.Dog&quot; id=&quot;dog&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;小白&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;age&quot; value=&quot;6&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean class=&quot;com.sangeng.domain.Student&quot; id=&quot;student&quot; &gt;        &lt;!--            name属性用来指定要设置哪个属性            value属性用来设置要设置的值            ref属性用来给引用类型的属性设置值，可以写上Spring容器中bean的id        --&gt;        &lt;property name=&quot;name&quot; value=&quot;东南枝&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;age&quot; value=&quot;20&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;id&quot; value=&quot;1&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;dog&quot; ref=&quot;dog&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;</code></pre><h3 id="3-2-有参构造注入"><a href="#3-2-有参构造注入" class="headerlink" title="3.2 有参构造注入"></a>3.2 有参构造注入</h3><p>在要注入属性的bean标签中进行配置。前提是该类有提供对应的有参构造。</p><pre><code class="java">public class Student &#123;    private String name;    private int id;    private int age;    private Dog dog;    public Student(String name, int id, int age, Dog dog) &#123;        this.name = name;        this.id = id;        this.age = age;        this.dog = dog;    &#125;    //.....省略其他&#125;</code></pre><pre><code class="xml">    &lt;!--使用有参构造进行注入--&gt;    &lt;bean class=&quot;com.sangeng.domain.Student&quot; id=&quot;student2&quot; &gt;        &lt;constructor-arg name=&quot;name&quot; value=&quot;自挂东南枝&quot;&gt;&lt;/constructor-arg&gt;        &lt;constructor-arg name=&quot;age&quot; value=&quot;20&quot;&gt;&lt;/constructor-arg&gt;        &lt;constructor-arg name=&quot;id&quot; value=&quot;30&quot;&gt;&lt;/constructor-arg&gt;        &lt;constructor-arg name=&quot;dog&quot; ref=&quot;dog&quot;&gt;&lt;/constructor-arg&gt;    &lt;/bean&gt;</code></pre><h3 id="3-3-复杂类型属性注入"><a href="#3-3-复杂类型属性注入" class="headerlink" title="3.3 复杂类型属性注入"></a>3.3 复杂类型属性注入</h3><p>实体类如下：</p><pre><code class="java">@Data@NoArgsConstructor@AllArgsConstructorpublic class User &#123;    private int age;    private String name;    private Phone phone;    private List&lt;String&gt; list;    private List&lt;Phone&gt; phones;    private Set&lt;String&gt; set;    private Map&lt;String, Phone&gt; map;    private int[] arr;    private Properties properties;&#125;</code></pre><pre><code class="java">@Data@NoArgsConstructor@AllArgsConstructorpublic class Phone &#123;    private double price;    private String name;    private String password;    private String path;&#125;</code></pre><p>配置如下：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean class=&quot;com.sangeng.domain.Phone&quot; id=&quot;phone&quot;&gt;        &lt;property name=&quot;price&quot; value=&quot;3999&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;name&quot; value=&quot;黑米&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;password&quot; value=&quot;123&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;path&quot; value=&quot;qqqq&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;        &lt;bean class=&quot;com.sangeng.domain.User&quot; id=&quot;user&quot;&gt;        &lt;property name=&quot;age&quot; value=&quot;10&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;name&quot; value=&quot;大队长&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;phone&quot; ref=&quot;phone&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;list&quot;&gt;            &lt;list&gt;                &lt;value&gt;三更&lt;/value&gt;                &lt;value&gt;西施&lt;/value&gt;            &lt;/list&gt;        &lt;/property&gt;        &lt;property name=&quot;phones&quot;&gt;            &lt;list&gt;                &lt;ref bean=&quot;phone&quot;&gt;&lt;/ref&gt;            &lt;/list&gt;        &lt;/property&gt;        &lt;property name=&quot;set&quot;&gt;            &lt;set&gt;                &lt;value&gt;setEle1&lt;/value&gt;                &lt;value&gt;setEle2&lt;/value&gt;            &lt;/set&gt;        &lt;/property&gt;        &lt;property name=&quot;map&quot;&gt;            &lt;map&gt;                &lt;entry key=&quot;k1&quot; value-ref=&quot;phone&quot;&gt;&lt;/entry&gt;                &lt;entry key=&quot;k2&quot; value-ref=&quot;phone&quot;&gt;&lt;/entry&gt;            &lt;/map&gt;        &lt;/property&gt;        &lt;property name=&quot;arr&quot;&gt;            &lt;array&gt;                &lt;value&gt;10&lt;/value&gt;                &lt;value&gt;11&lt;/value&gt;            &lt;/array&gt;        &lt;/property&gt;        &lt;property name=&quot;properties&quot;&gt;            &lt;props&gt;                &lt;prop key=&quot;k1&quot;&gt;v1&lt;/prop&gt;                &lt;prop key=&quot;k2&quot;&gt;v2&lt;/prop&gt;            &lt;/props&gt;        &lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><h2 id="4-Lombok"><a href="#4-Lombok" class="headerlink" title="4.Lombok"></a>4.Lombok</h2><h3 id="①导入依赖-1"><a href="#①导入依赖-1" class="headerlink" title="①导入依赖"></a>①导入依赖</h3><pre><code class="xml">        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;version&gt;1.18.16&lt;/version&gt;        &lt;/dependency&gt;</code></pre><h3 id="②增加注解"><a href="#②增加注解" class="headerlink" title="②增加注解"></a>②增加注解</h3><pre><code class="java">@Data //根据属性生成set，get方法@NoArgsConstructor //生成空参构造@AllArgsConstructor //生成全参构造public class Phone &#123;    private double price;    private String name;    private String password;    private String path;&#125;</code></pre><h2 id="5-SPEL"><a href="#5-SPEL" class="headerlink" title="5.SPEL"></a>5.SPEL</h2><p>​我们可以再配置文件中使用SPEL表达式。写法如下:</p><pre><code class="xml">        &lt;property name=&quot;age&quot; value=&quot;#&#123;20&#125;&quot;/&gt;        &lt;property name=&quot;car&quot; value=&quot;#&#123;car&#125;&quot;/&gt;</code></pre><p>​注意：SPEL需要写到value属性中，不能写到ref属性。</p><h2 id="6-配置文件"><a href="#6-配置文件" class="headerlink" title="6.配置文件"></a>6.配置文件</h2><h3 id="6-1-读取properties文件"><a href="#6-1-读取properties文件" class="headerlink" title="6.1 读取properties文件"></a>6.1 读取properties文件</h3><p>​我们可以让Spring读取properties文件中的key&#x2F;value，然后使用其中的值。</p><h4 id="①设置读取properties"><a href="#①设置读取properties" class="headerlink" title="①设置读取properties"></a>①设置读取properties</h4><p>在Spring配置文件中加入如下标签：指定要读取的文件的路径。</p><pre><code class="xml">&lt;context:property-placeholder location=&quot;classpath:filename.properties&quot;&gt;</code></pre><p>其中的classpath表示类加载路径下。</p><p>我们也会用到如下写法：classpath:**.properties  其中的*  * 表示文件名任意。</p><p><strong>注意：context命名空间的引入是否正确</strong></p><h4 id="②使用配置文件中的值"><a href="#②使用配置文件中的值" class="headerlink" title="②使用配置文件中的值"></a>②使用配置文件中的值</h4><p>在我们需要使用的时候可以使用${key}来表示具体的值。注意要再value属性中使用才可以。例如：</p><pre><code class="xml">&lt;property name=&quot;propertyName&quot; value=&quot;$&#123;key&#125;&quot;/&gt;</code></pre><h3 id="6-2-引入Spring配置文件"><a href="#6-2-引入Spring配置文件" class="headerlink" title="6.2 引入Spring配置文件"></a>6.2 引入Spring配置文件</h3><p>​我们可以在主的配置文件中通过import标签的resource属性，引入其他的xml配置文件</p><pre><code class="xml">&lt;import resource=&quot;classpath:applicationContext-book.xml&quot;/&gt;</code></pre><h2 id="7-低频知识点"><a href="#7-低频知识点" class="headerlink" title="7. 低频知识点"></a>7. 低频知识点</h2><h3 id="7-1-bean的配置"><a href="#7-1-bean的配置" class="headerlink" title="7.1 bean的配置"></a>7.1 bean的配置</h3><h4 id="7-1-1-name属性"><a href="#7-1-1-name属性" class="headerlink" title="7.1.1 name属性"></a>7.1.1 name属性</h4><p>​我们可以用name属性来给bean取名。例如：</p><pre><code class="xml">    &lt;bean class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; id=&quot;dataSource&quot; name=&quot;dataSource2,dataSource3&quot;&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;</code></pre><p>​获取的时候就可以使用这个名字来获取了</p><pre><code class="java">    public static void main(String[] args) &#123;        ApplicationContext app = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);        DruidDataSource dataSource = (DruidDataSource) app.getBean(&quot;dataSource3&quot;);        System.out.println(dataSource);    &#125;</code></pre><h4 id="7-1-2-lazy-init"><a href="#7-1-2-lazy-init" class="headerlink" title="7.1.2 lazy-init"></a>7.1.2 lazy-init</h4><p>​可以控制bean的创建时间，如果设置为true就是在第一次获取该对象的时候才去创建。</p><pre><code class="xml">    &lt;bean class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; lazy-init=&quot;true&quot;  id=&quot;dataSource&quot; name=&quot;dataSource2,dataSource3&quot;&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;</code></pre><h4 id="7-1-3-init-method"><a href="#7-1-3-init-method" class="headerlink" title="7.1.3 init-method"></a>7.1.3 init-method</h4><p>​可以用来设置初始化方法，设置完后容器创建完对象就会自动帮我们调用对应的方法。</p><pre><code class="java">@Data@NoArgsConstructor@AllArgsConstructorpublic class Student &#123;    private String name;    private int id;    private int age;    //初始化方法    public void init()&#123;        System.out.println(&quot;对学生对象进行初始化操作&quot;);    &#125;&#125;</code></pre><pre><code class="xml">&lt;bean class=&quot;com.sangeng.domain.Student&quot; id=&quot;student&quot; init-method=&quot;init&quot;&gt;&lt;/bean&gt;</code></pre><p><strong>注意：配置的初始化方法只能是空参的。</strong></p><h4 id="7-1-4-destroy-method"><a href="#7-1-4-destroy-method" class="headerlink" title="7.1.4 destroy-method"></a>7.1.4 destroy-method</h4><p>​可以用来设置销毁之前调用的方法，设置完后容器销毁对象前就会自动帮我们调用对应的方法。</p><pre><code class="xml">    &lt;bean class=&quot;com.sangeng.domain.Student&quot; id=&quot;student&quot;  destroy-method=&quot;close&quot;&gt;&lt;/bean&gt;</code></pre><pre><code class="java">@Data@NoArgsConstructor@AllArgsConstructorpublic class Student &#123;    private String name;    private int id;    private int age;    public void init()&#123;        System.out.println(&quot;对学生对象进行初始化操作&quot;);    &#125;    public void close()&#123;        System.out.println(&quot;对象销毁之前调用，用于释放资源&quot;);    &#125;&#125;</code></pre><p><strong>注意：配置的方法只能是空参的。</strong></p><h4 id="7-1-5-factory-bean-amp-factory-method"><a href="#7-1-5-factory-bean-amp-factory-method" class="headerlink" title="7.1.5 factory-bean&amp;factory-method"></a>7.1.5 factory-bean&amp;factory-method</h4><p>​当我们需要让Spring容器使用工厂类来创建对象放入Spring容器的时候可以使用factory-bean和factory-method属性。</p><h5 id="7-1-5-1-配置实例工厂创建对象"><a href="#7-1-5-1-配置实例工厂创建对象" class="headerlink" title="7.1.5.1 配置实例工厂创建对象"></a>7.1.5.1 配置实例工厂创建对象</h5><p>配置文件中进行配置</p><pre><code class="xml">    &lt;!--创建实例工厂--&gt;    &lt;bean class=&quot;com.sangeng.factory.CarFactory&quot; id=&quot;carFactory&quot;&gt;&lt;/bean&gt;    &lt;!--使用实例工厂创建Car放入容器--&gt;    &lt;!--factory-bean 用来指定使用哪个工厂对象--&gt;    &lt;!--factory-method 用来指定使用哪个工厂方法--&gt;    &lt;bean factory-bean=&quot;carFactory&quot; factory-method=&quot;getCar&quot; id=&quot;car&quot;&gt;&lt;/bean&gt;</code></pre><p>创建容器获取对象测试</p><pre><code class="java">        ClassPathXmlApplicationContext app = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);        //获取car对象        Car c = (Car) app.getBean(&quot;car&quot;);        System.out.println(c);</code></pre><h5 id="7-1-5-2-配置静态工厂创建对象"><a href="#7-1-5-2-配置静态工厂创建对象" class="headerlink" title="7.1.5.2 配置静态工厂创建对象"></a>7.1.5.2 配置静态工厂创建对象</h5><p>配置文件中进行配置</p><pre><code class="xml">    &lt;!--使用静态工厂创建Car放入容器--&gt;    &lt;bean class=&quot;com.sangeng.factory.CarStaticFactory&quot; factory-method=&quot;getCar&quot; id=&quot;car2&quot;&gt;&lt;/bean&gt;</code></pre><p>创建容器获取对象测试</p><pre><code class="java">        ClassPathXmlApplicationContext app = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);        //获取car对象        Car c = (Car) app.getBean(&quot;car2&quot;);        System.out.println(c);</code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Spring </category>
          
          <category> Spring基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Step.2</title>
      <link href="/computer-science/spring/docssp/Spring-02/"/>
      <url>/computer-science/spring/docssp/Spring-02/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-02"><a href="#Spring-02" class="headerlink" title="Spring-02"></a>Spring-02</h1><h2 id="1-注解开发"><a href="#1-注解开发" class="headerlink" title="1.注解开发"></a>1.注解开发</h2><p>​为了简化配置，Spring支持使用注解代替xml配置。</p><p>​</p><h2 id="2-Spring常用注解"><a href="#2-Spring常用注解" class="headerlink" title="2.Spring常用注解"></a>2.Spring常用注解</h2><h3 id="2-0-注解开发准备工作"><a href="#2-0-注解开发准备工作" class="headerlink" title="2.0 注解开发准备工作"></a>2.0 注解开发准备工作</h3><p>​如果要使用注解开发必须要开启组件扫描，这样加了注解的类才会被识别出来。Spring才能去解析其中的注解。</p><pre><code class="xml">&lt;!--启动组件扫描，指定对应扫描的包路径，该包及其子包下所有的类都会被扫描，加载包含指定注解的类--&gt;&lt;context:component-scan base-package=&quot;com.sangeng&quot;/&gt;</code></pre><h3 id="2-1-IOC相关注解"><a href="#2-1-IOC相关注解" class="headerlink" title="2.1 IOC相关注解"></a>2.1 IOC相关注解</h3><h4 id="2-1-1-Component-Controller-Service-Repository"><a href="#2-1-1-Component-Controller-Service-Repository" class="headerlink" title="2.1.1 @Component,@Controller,@Service ,@Repository"></a>2.1.1 @Component,@Controller,@Service ,@Repository</h4><p>​上述4个注解都是加到类上的。</p><p>​他们都可以起到类似bean标签的作用。可以把加了该注解类的对象放入Spring容器中。</p><p>​实际再使用时选择任意一个都可以。但是后3个注解是语义化注解。</p><p>​如果是Service类要求使用@Service。</p><p>​如果是Dao类要求使用@Repository</p><p>​如果是Controllerl类(SpringMVC中会学习到)要求使用@Controller</p><p>​如果是其他类可以使用@Component</p><p>例如：</p><p>配置文件如下：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;&lt;!--启动组件扫描，指定对应扫描的包路径，该包及其子包下所有的类都会被扫描，加载包含指定注解的类--&gt;    &lt;context:component-scan base-package=&quot;com.sangeng&quot;&gt;&lt;/context:component-scan&gt;&lt;/beans&gt;</code></pre><p>类如下：</p><pre><code class="java">@Repository(&quot;userDao&quot;)public class UserDaoImpl implements UserDao &#123;    public void show() &#123;        System.out.println(&quot;查询数据库，展示查询到的数据&quot;);    &#125;&#125;</code></pre><pre><code class="java">@Data@NoArgsConstructor@AllArgsConstructor@Component(&quot;phone&quot;)public class Phone &#123;    private double price;    private String name;    private String password;    private String path;&#125;</code></pre><pre><code class="java">@Service(&quot;userService&quot;)@Data@NoArgsConstructor@AllArgsConstructorpublic class UserServiceImpl implements UserService &#123;    private UserDao userDao;    private int num;    private String str;    public void show() &#123;        userDao.show();    &#125;&#125;</code></pre><p>测试类如下：</p><pre><code class="java">public class Demo &#123;    public static void main(String[] args) &#123;        //创建容器        ClassPathXmlApplicationContext app = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);        //获取对象        UserDao userDao = (UserDao) app.getBean(&quot;userDao&quot;);        Phone phone = (Phone) app.getBean(&quot;phone&quot;);        UserService userService = (UserService) app.getBean(&quot;userService&quot;);        System.out.println(phone);        System.out.println(userService);        System.out.println(userDao);    &#125;&#125;</code></pre><h3 id="2-2-DI相关注解"><a href="#2-2-DI相关注解" class="headerlink" title="2.2 DI相关注解"></a>2.2 DI相关注解</h3><p>​如果一个bean已经放入Spring容器中了。那么我们可以使用下列注解实现属性注入，让Spring容器帮我们完成属性的赋值。</p><h4 id="2-2-1-Value"><a href="#2-2-1-Value" class="headerlink" title="2.2.1 @Value"></a>2.2.1 @Value</h4><p>​主要用于String,Integer等可以直接赋值的属性注入。不依赖setter方法，支持SpEL表达式。</p><p>例如：</p><pre><code class="java">@Service(&quot;userService&quot;)@Data@NoArgsConstructor@AllArgsConstructorpublic class UserServiceImpl implements UserService &#123;    private UserDao userDao;    @Value(&quot;199&quot;)    private int num;    @Value(&quot;三更草堂&quot;)    private String str;    @Value(&quot;#&#123;19+3&#125;&quot;)    private Integer age;    public void show() &#123;        userDao.show();    &#125;&#125;</code></pre><h4 id="2-2-2-AutoWired"><a href="#2-2-2-AutoWired" class="headerlink" title="2.2.2 @AutoWired"></a>2.2.2 @AutoWired</h4><p>​Spring会给加了该注解的属性自动注入数据类型相同的对象。</p><p>例如：</p><pre><code class="java">@Service(&quot;userService&quot;)@Data@NoArgsConstructor@AllArgsConstructorpublic class UserServiceImpl implements UserService &#123;    @Autowired    private UserDao userDao;    @Value(&quot;199&quot;)    private int num;    @Value(&quot;三更草堂&quot;)    private String str;    @Value(&quot;#&#123;19+3&#125;&quot;)    private Integer age;    public void show() &#123;        userDao.show();    &#125;&#125;</code></pre><p>​<strong>required属性代表这个属性是否是必须的，默认值为true。如果是true的话Spring容器中如果找不到相同类型的对象完成属性注入就会出现异常。</strong></p><h4 id="2-2-3-Qualifier"><a href="#2-2-3-Qualifier" class="headerlink" title="2.2.3 @Qualifier"></a>2.2.3 @Qualifier</h4><p>​如果相同类型的bean在容器中有多个时，单独使用@AutoWired就不能满足要求，这时候可以再加上@Qualifier来指定bean的名字从容器中获取bean注入。</p><p>例如：</p><pre><code class="java">    @Autowired    @Qualifier(&quot;userDao2&quot;)    private UserDao userDao;</code></pre><p><strong>注意：该直接不能单独使用。单独使用没有作用</strong></p><h3 id="2-3-xml配置文件相关注解"><a href="#2-3-xml配置文件相关注解" class="headerlink" title="2.3 xml配置文件相关注解"></a>2.3 xml配置文件相关注解</h3><h4 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h4><p>​标注在类上，表示当前类是一个配置类。我们可以用注解类来完全替换掉xml配置文件。</p><p>​注意：如果使用配置类替换了xml配置，spring容器要使用：AnnotationConfigApplicationContext</p><p>例如：</p><pre><code class="java">@Configurationpublic class ApplicationConfig &#123;&#125;</code></pre><h4 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h4><p>​可以用来代替context:component-scan标签来配置组件扫描。</p><p>​basePackages属性来指定要扫描的包。</p><p>​注意要加在配置类上。</p><p>例如：</p><pre><code class="java">@Configuration@ComponentScan(basePackages = &quot;com.sangeng&quot;)//指定要扫描的包public class ApplicationConfig &#123;&#125;</code></pre><h4 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h4><p>​可以用来代替bean标签，主要用于第三方类的注入。</p><p>​使用：定义一个方法，在方法中创建对应的对象并且作为返回值返回。然后在方法上加上@Bean注解，注解的value属性来设置bean的名称。</p><p>例如：</p><pre><code class="java">@Configuration@ComponentScan(basePackages = &quot;com.sangeng&quot;)public class ApplicationConfig &#123;    @Bean(&quot;dataSource&quot;)    public DruidDataSource getDataSource()&#123;        DruidDataSource druidDataSource = new DruidDataSource();        druidDataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);        druidDataSource.setUsername(&quot;root&quot;);        druidDataSource.setUrl(&quot;jdbc:mysql://localhost:3306/mybatis_db&quot;);        druidDataSource.setPassword(&quot;root&quot;);        return druidDataSource;    &#125;&#125;</code></pre><p><strong>注意事项：如果同一种类型的对象在容器中只有一个，我们可以不设置bean的名称。</strong></p><p>具体写法如下：</p><pre><code class="java">@Configuration@ComponentScan(basePackages = &quot;com.sangeng&quot;)public class ApplicationConfig &#123;    @Bean    public DruidDataSource getDataSource()&#123;        DruidDataSource druidDataSource = new DruidDataSource();        druidDataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);        druidDataSource.setUsername(&quot;root&quot;);        druidDataSource.setUrl(&quot;jdbc:mysql://localhost:3306/mybatis_db&quot;);        druidDataSource.setPassword(&quot;root&quot;);        return druidDataSource;    &#125;&#125;</code></pre><p>获取方式如下：</p><pre><code class="java">    public static void main(String[] args) &#123;        //创建注解容器        AnnotationConfigApplicationContext app = new AnnotationConfigApplicationContext(ApplicationConfig.class);        //根据对应类的字节码对象获取        DataSource bean = app.getBean(DataSource.class);        System.out.println(userService);    &#125;</code></pre><h4 id="PropertySource"><a href="#PropertySource" class="headerlink" title="@PropertySource"></a>@PropertySource</h4><p>​可以用来代替context:property-placeholder，让Spring读取指定的properties文件。然后可以使用@Value来获取读取到的值。</p><p>​<strong>使用：在配置类上加@PropertySource注解，注解的value属性来设置properties文件的路径。</strong></p><p>​<strong>然后在配置类中定义成员变量。在成员变量上使用@Value注解来获取读到的值并给对应的成员变量赋值。</strong></p><p>例如：</p><pre><code class="properties">jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/mybatis_dbjdbc.username=rootjdbc.password=root</code></pre><p>读取文件并且获取值</p><pre><code class="java">@Configuration@ComponentScan(basePackages = &quot;com.sangeng&quot;)@PropertySource(&quot;jdbc.properties&quot;)public class ApplicationConfig &#123;    @Value(&quot;$&#123;jdbc.driver&#125;&quot;)    private String driverClassName;    @Value(&quot;$&#123;jdbc.url&#125;&quot;)    private String url;    @Value(&quot;$&#123;jdbc.username&#125;&quot;)    private String username;    @Value(&quot;$&#123;jdbc.password&#125;&quot;)    private String password;    @Bean    public DruidDataSource getDataSource()&#123;        DruidDataSource druidDataSource = new DruidDataSource();        druidDataSource.setDriverClassName(driverClassName);        druidDataSource.setUsername(username);        druidDataSource.setUrl(url);        druidDataSource.setPassword(password);        return druidDataSource;    &#125;&#125;</code></pre><p><strong>注意事项：使用@Value获取读到的properties文件中的值时使用的是${key},而不是#{key}。</strong></p><h2 id="3-如何选择"><a href="#3-如何选择" class="headerlink" title="3.如何选择"></a>3.如何选择</h2><p>①SSM  </p><p>​自己项目中的类的IOC和DI都使用注解，对第三方jar包中的类，配置组件扫描时使用xml进行配置。</p><p>②SpringBoot</p><p>​纯注解开发</p>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Spring </category>
          
          <category> Spring基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Step.3</title>
      <link href="/computer-science/spring/docssp/Spring-03/"/>
      <url>/computer-science/spring/docssp/Spring-03/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-03"><a href="#Spring-03" class="headerlink" title="Spring-03"></a>Spring-03</h1><h2 id="1-AOP"><a href="#1-AOP" class="headerlink" title="1. AOP"></a>1. AOP</h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h3><p>​ AOP为Aspect Oriented Programming的缩写，意为：面向切面编程。他是一种可以在不修改原来的核心代码的情况下给程序动态统一进行增强的一种技术。 </p><p>​<strong>SpringAOP:  批量对Spring容器中bean的方法做增强，并且这种增强不会与原来方法中的代码耦合。</strong></p><h3 id="1-2-快速入门"><a href="#1-2-快速入门" class="headerlink" title="1.2 快速入门"></a>1.2 快速入门</h3><h4 id="1-2-1-需求"><a href="#1-2-1-需求" class="headerlink" title="1.2.1 需求"></a>1.2.1 需求</h4><p>​要求让_08_SpringAOP模块中service包下所有类的所有方法在调用前都输出：方法被调用了。</p><h4 id="1-2-2-准备工作"><a href="#1-2-2-准备工作" class="headerlink" title="1.2.2 准备工作"></a>1.2.2 准备工作</h4><h5 id="①添加依赖"><a href="#①添加依赖" class="headerlink" title="①添加依赖"></a>①添加依赖</h5><p>需要添加SpringIOC相关依赖和AOP相关依赖。</p><pre><code class="xml">        &lt;!--SpringIOC相关依赖--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--AOP相关依赖--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;            &lt;version&gt;1.8.13&lt;/version&gt;        &lt;/dependency&gt;</code></pre><h5 id="②相关bean要注入容器中"><a href="#②相关bean要注入容器中" class="headerlink" title="②相关bean要注入容器中"></a>②相关bean要注入容器中</h5><p>开启组件扫描</p><pre><code class="xml">&lt;context:component-scan base-package=&quot;com.sangeng&quot;&gt;&lt;/context:component-scan&gt;</code></pre><p>加@Service注解</p><pre><code class="java">@Servicepublic class PhoneService &#123;    public void deleteAll()&#123;        System.out.println(&quot;PhoneService中deleteAll的核心代码&quot;);    &#125;&#125;</code></pre><pre><code class="java">@Servicepublic class UserService &#123;    public void deleteAll()&#123;        System.out.println(&quot;UserService中deleteAll的核心代码&quot;);    &#125;&#125;</code></pre><h4 id="1-2-3-实现AOP"><a href="#1-2-3-实现AOP" class="headerlink" title="1.2.3 实现AOP"></a>1.2.3 实现AOP</h4><h5 id="①开启AOP注解支持"><a href="#①开启AOP注解支持" class="headerlink" title="①开启AOP注解支持"></a>①开启AOP注解支持</h5><p>使用<strong>aop:aspectj-autoproxy</strong>标签</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;!--开启组件扫描--&gt;    &lt;context:component-scan base-package=&quot;com.sangeng&quot;&gt;&lt;/context:component-scan&gt;    &lt;!--开启aop注解支持--&gt;    &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;&lt;/beans&gt;</code></pre><h5 id="②创建切面类"><a href="#②创建切面类" class="headerlink" title="②创建切面类"></a>②创建切面类</h5><p>创建一个类，在类上加上@Component和@Aspect</p><p>使用@Pointcut注解来指定要被增强的方法</p><p>使用@Before注解来给我们的增强代码所在的方法进行标识，并且指定了增强代码是在被增强方法执行之前执行的。</p><pre><code class="java">@Component@Aspectpublic class MyAspect &#123;//    用Pointcut注解中的属性来指定对哪些方法进行增强    @Pointcut(&quot;execution(* com.sangeng.service.*.*(..))&quot;)    public void pt()&#123;&#125;    /*        用@Before注解来指定该方法中是增强的代码，并且是在被增强方法执行前执行的        @Before的属性写上加了@Pointcut注解的方法: 方法名()    */    @Before(&quot;pt()&quot;)    public void methodbefore()&#123;        System.out.println(&quot;方法被调用了&quot;);    &#125;&#125;</code></pre><h4 id="1-2-4-测试"><a href="#1-2-4-测试" class="headerlink" title="1.2.4 测试"></a>1.2.4 测试</h4><pre><code class="java">    public static void main(String[] args) &#123;        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);        PhoneService phoneService = applicationContext.getBean(PhoneService.class);        UserService userService = applicationContext.getBean(UserService.class);        phoneService.deleteAll();    &#125;</code></pre><h3 id="1-3-AOP核心概念"><a href="#1-3-AOP核心概念" class="headerlink" title="1.3 AOP核心概念"></a>1.3 AOP核心概念</h3><ul><li><p>Joinpoint（连接点）：所谓连接点是指那些可以被增强到的点。在spring中,这些点指的是方法，因为spring只支持方法类型的连接点</p></li><li><p><strong>Pointcut（切入点）：所谓切入点是指被增强的连接点（方法）</strong></p></li><li><p><strong>Advice（通知&#x2F; 增强）：所谓通知是指具体增强的代码</strong></p></li><li><p>Target（目标对象）：被增强的对象就是目标对象</p></li><li><p><strong>Aspect（切面）：是切入点和通知（引介）的结合</strong></p></li><li><p>Proxy （代理）：一个类被 AOP 增强后，就产生一个结果代理类</p></li></ul><h3 id="1-4-切点确定"><a href="#1-4-切点确定" class="headerlink" title="1.4 切点确定"></a>1.4 切点确定</h3><h4 id="1-4-1-切点表达式"><a href="#1-4-1-切点表达式" class="headerlink" title="1.4.1 切点表达式"></a>1.4.1 切点表达式</h4><p>​可以使用切点表达式来表示要对哪些方法进行增强。</p><p>写法：<strong>execution([修饰符] 返回值类型 包名.类名.方法名(参数))</strong></p><ul><li>访问修饰符可以省略，大部分情况下省略</li><li>返回值类型、包名、类名、方法名可以使用星号*  代表任意</li><li>包名与类名之间一个点 . 代表当前包下的类，两个点 .. 表示当前包及其子包下的类</li><li>参数列表可以使用两个点 .. 表示任意个数，任意类型的参数列表</li></ul><p>例如：</p><pre><code class="java">execution(* com.sangeng.service.*.*(..))   表示com.sangeng.service包下任意类，方法名任意，参数列表任意，返回值类型任意   execution(* com.sangeng.service..*.*(..))   表示com.sangeng.service包及其子包下任意类，方法名任意，参数列表任意，返回值类型任意    execution(* com.sangeng.service.*.*())     表示com.sangeng.service包下任意类，方法名任意，要求方法不能有参数，返回值类型任意    execution(* com.sangeng.service.*.delete*(..))     表示com.sangeng.service包下任意类，要求方法不能有参数，返回值类型任意,方法名要求已delete开头</code></pre><h4 id="1-4-2-切点函数-annotation"><a href="#1-4-2-切点函数-annotation" class="headerlink" title="1.4.2 切点函数@annotation"></a>1.4.2 切点函数@annotation</h4><p>​我们也可以在要增强的方法上加上注解。然后使用@annotation来表示对加了什么注解的方法进行增强。</p><p>写法：**@annotation(注解的全类名)**</p><p>例如：</p><p>定义注解如下</p><pre><code class="java">@Target(&#123;ElementType.METHOD&#125;)//该注解可以加在方法上@Retention(RetentionPolicy.RUNTIME)public @interface InvokeLog &#123;&#125;</code></pre><p>给需要增强的方法增加注解</p><pre><code class="java">@Servicepublic class PhoneService &#123;    @InvokeLog      public void deleteAll()&#123;        System.out.println(&quot;PhoneService中deleteAll的核心代码&quot;);    &#125;&#125;</code></pre><p>切面类中使用@annotation来确定要增强的方法</p><pre><code class="java">@Component@Aspectpublic class MyAspect &#123;//    用Pointcut注解中的属性来指定对哪些方法进行增强    @Pointcut(&quot;@annotation(com.sangeng.aspect.InvokeLog)&quot;)    public void pt()&#123;&#125;    /*        用@Before注解来指定该方法中是增强的代码，并且是在被增强方法执行前执行的        @Before的属性写上加了@Pointcut注解的方法: 方法名()    */    @Before(&quot;pt()&quot;)    public void methodbefore()&#123;        System.out.println(&quot;方法被调用了&quot;);    &#125;&#125;</code></pre><h3 id="1-5-通知分类"><a href="#1-5-通知分类" class="headerlink" title="1.5 通知分类"></a>1.5 通知分类</h3><ul><li><p>@Before：前置通知,在目标方法执行前执行</p></li><li><p>@AfterReturning： 返回后通知，在目标方法执行后执行，如果出现异常不会执行</p></li><li><p>@After：后置通知，在目标方法之后执行，无论是否出现异常都会执行 </p></li><li><p>@AfterThrowing：异常通知，在目标方法抛出异常后执行</p></li><li><p><strong>@Around：环绕通知，围绕着目标方法执行</strong></p></li></ul><p>理解不同通知执行时机。（<strong>下面的伪代码是用来理解单个通知的执行时机的，不能用来理解多个通知情况下的执行顺序。如果需要配置多个通知我们会选择使用Around通知，更加的清晰并且好用</strong>）</p><pre><code class="java">    public Object test() &#123;        before();//@Before 前置通知        try &#123;            Object ret = 目标方法();//目标方法调用            afterReturing();//@AfterReturning 返回后通知        &#125; catch (Throwable throwable) &#123;            throwable.printStackTrace();            afterThrowing();//@AfterThrowing 异常通知通知        &#125;finally &#123;            after();//@After 后置通知        &#125;        return ret;    &#125;</code></pre><p>环绕通知非常特殊，它可以对目标方法进行全方位的增强。</p><p>例如：</p><pre><code class="java">      @Around(&quot;pt()&quot;)    public void around(ProceedingJoinPoint pjp)&#123;        System.out.println(&quot;目标方法前&quot;);        try &#123;            pjp.proceed();//目标方法执行            System.out.println(&quot;目标方法后&quot;);        &#125; catch (Throwable throwable) &#123;            throwable.printStackTrace();            System.out.println(&quot;目标方法出现异常&quot;);        &#125;finally &#123;            System.out.println(&quot;finally中进行增强&quot;);        &#125;    &#125;</code></pre><h3 id="1-6-获取被增强方法相关信息"><a href="#1-6-获取被增强方法相关信息" class="headerlink" title="1.6 获取被增强方法相关信息"></a>1.6 获取被增强方法相关信息</h3><p>​我们实际对方法进行增强时往往还需要获取到被增强代码的相关信息，比如方法名，参数，返回值，异常对象等。</p><p>​我们可以在除了环绕通知外的所有通知方法中增加一个<strong>JoinPoint类型</strong>的参数。这个参数封装了被增强方法的相关信息。<strong>我们可以通过这个参数获取到除了异常对象和返回值之外的所有信息。</strong></p><p>例如：</p><pre><code class="java">    @Before(&quot;pt()&quot;)    public void methodbefore(JoinPoint jp)&#123;        Object[] args = jp.getArgs();//方法调用时传入的参数        Object target = jp.getTarget();//被代理对象        MethodSignature signature = (MethodSignature) jp.getSignature();//获取被被增强方法签名封装的对象        System.out.println(&quot;Before方法被调用了&quot;);    &#125;</code></pre><p>案例：</p><p>需求：要求让所有service包下类的所有方法被调用前都输出全类名，方法名，以及调用时传入的参数</p><pre><code class="java">@Component@Aspectpublic class PrintLogAspect &#123;    //对哪些方法增强    @Pointcut(&quot;execution(* com.sangeng.service..*.*(..))&quot;)    public void pt()&#123;&#125;    //怎么增强    @Before(&quot;pt()&quot;)    public void printLog(JoinPoint joinPoint)&#123;        //输出 被增强的方法所在的类名 方法名 调用时传入的参数   joinPoint.getSignature().getName()  joinPoint.getArgs()        MethodSignature signature = (MethodSignature) joinPoint.getSignature();        //类名        String className = signature.getDeclaringTypeName();        //方法名        String methodName = signature.getName();        //调用时传入的参数        Object[] args = joinPoint.getArgs();        System.out.println(className+&quot;==&quot;+methodName+&quot;======&quot;+ Arrays.toString(args));    &#125;&#125;</code></pre><p>​如果需要<strong>获取被增强方法中的异常对象或者返回值</strong>则需要在方法参数上增加一个对应类型的参数，并且使用注解的属性进行配置。这样Spring会把你想获取的数据赋值给对应的方法参数。</p><p>例如：</p><pre><code class="java">    @AfterReturning(value = &quot;pt()&quot;,returning = &quot;ret&quot;)//使用returning属性指定了把目标方法返回值赋值给下面方法的参数ret    public void AfterReturning(JoinPoint jp,Object ret)&#123;        System.out.println(&quot;AfterReturning方法被调用了&quot;);    &#125;</code></pre><pre><code class="java">    @AfterThrowing(value = &quot;pt()&quot;,throwing = &quot;t&quot;)//使用throwing属性指定了把出现的异常对象赋值给下面方法的参数t    public void AfterThrowing(JoinPoint jp,Throwable t)&#123;        System.out.println(&quot;AfterReturning方法被调用了&quot;);    &#125;</code></pre><p>​相信你肯定觉得上面的获取方式特别的麻烦难以理解。就可以使用下面这种万能的方法。</p><p>​直接在环绕通知方法中增加一个<strong>ProceedingJoinPoint类型</strong>的参数。这个参数封装了被增强方法的相关信息。</p><p>该参数的proceed()方法被调用相当于被增强方法被执行，调用后的返回值就相当于被增强方法的返回值。</p><p>例如：</p><pre><code class="java">    @Around(value = &quot;pt()&quot;)    public Object around(ProceedingJoinPoint pjp) &#123;        Object[] args = pjp.getArgs();//方法调用时传入的参数        Object target = pjp.getTarget();//被代理对象        MethodSignature signature = (MethodSignature) pjp.getSignature();//获取被被增强方法签名封装的对象        Object ret = null;        try &#123;            ret = pjp.proceed();//ret就是目标方法执行后的返回值        &#125; catch (Throwable throwable) &#123;            throwable.printStackTrace();//throwable就是出现异常时的异常对象        &#125;        return ret;    &#125;</code></pre><h3 id="1-7-AOP应用案例"><a href="#1-7-AOP应用案例" class="headerlink" title="1.7 AOP应用案例"></a>1.7 AOP应用案例</h3><h4 id="1-7-1-需求"><a href="#1-7-1-需求" class="headerlink" title="1.7.1 需求"></a>1.7.1 需求</h4><p>现有AI核心功能代码如下：</p><pre><code class="java">public class AIController &#123;    //AI自动回答    public String getAnswer(String question)&#123;        //AI核心代码 价值10个亿        String str = question.replace(&quot;吗&quot;, &quot;&quot;);        str = str.replace(&quot;？&quot;,&quot;!&quot;);        return str;    &#125;    //AI算命    public String fortuneTelling(String name)&#123;        //AI算命核心代码        String[] strs = &#123;&quot;女犯伤官把夫克，旱地莲花栽不活，不是吃上两家饭，也要刷上三家锅。&quot;,&quot;一朵鲜花头上戴，一年四季也不开，一心想要花开时，采花之人没到来。&quot;,&quot;此命生来脾气暴，上来一阵双脚跳，对你脾气啥都好，经常与人吵和闹。&quot;&#125;;        int index = name.hashCode() % 3;        return strs[index];    &#125;&#125;</code></pre><p>​现在为了保证数据的安全性，要求调用方法时fortuneTelling传入的姓名是经过加密的。我们需要对传入的参数进行解密后才能使用。并且要对该方法的返回值进行加密后返回。</p><p>​<strong>PS:后期也可能让其他方法进行相应的加密处理。</strong></p><p>字符串加密解密直接使用下面的工具类即可：</p><pre><code class="java">import javax.crypto.Cipher;import javax.crypto.KeyGenerator;import javax.crypto.SecretKey;import javax.crypto.spec.SecretKeySpec;import java.security.SecureRandom;public class CryptUtil &#123;    private static final String AES = &quot;AES&quot;;    private static int keysizeAES = 128;    private static String charset = &quot;utf-8&quot;;    public static String parseByte2HexStr(final byte buf[]) &#123;        final StringBuffer sb = new StringBuffer();        for (int i = 0; i &lt; buf.length; i++) &#123;            String hex = Integer.toHexString(buf[i] &amp; 0xFF);            if (hex.length() == 1) &#123;                hex = &#39;0&#39; + hex;            &#125;            sb.append(hex.toUpperCase());        &#125;        return sb.toString();    &#125;    public static byte[] parseHexStr2Byte(final String hexStr) &#123;        if (hexStr.length() &lt; 1)            return null;        final byte[] result = new byte[hexStr.length() / 2];        for (int i = 0;i&lt; hexStr.length()/2; i++) &#123;            int high = Integer.parseInt(hexStr.substring(i * 2, i * 2 + 1), 16);            int low = Integer.parseInt(hexStr.substring(i * 2 + 1, i * 2 + 2), 16);            result[i] = (byte) (high * 16 + low);        &#125;        return result;    &#125;    private static String keyGeneratorES(final String res, final String algorithm, final String key, final Integer keysize, final Boolean bEncode) &#123;        try &#123;            final KeyGenerator g = KeyGenerator.getInstance(algorithm);            if (keysize == 0) &#123;                byte[] keyBytes = charset == null ? key.getBytes() : key.getBytes(charset);                g.init(new SecureRandom(keyBytes));            &#125; else if (key == null) &#123;                g.init(keysize);            &#125; else &#123;                byte[] keyBytes = charset == null ? key.getBytes() : key.getBytes(charset);                SecureRandom random = SecureRandom.getInstance(&quot;SHA1PRNG&quot;);                random.setSeed(keyBytes);                g.init(keysize, random);            &#125;            final SecretKey sk = g.generateKey();            final SecretKeySpec sks = new SecretKeySpec(sk.getEncoded(), algorithm);            final Cipher cipher = Cipher.getInstance(algorithm);            if (bEncode) &#123;                cipher.init(Cipher.ENCRYPT_MODE, sks);                final byte[] resBytes = charset == null? res.getBytes() : res.getBytes(charset);                return parseByte2HexStr(cipher.doFinal(resBytes));            &#125; else &#123;                cipher.init(Cipher.DECRYPT_MODE, sks);                return new String(cipher.doFinal(parseHexStr2Byte(res)));            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        return null;    &#125;    public static String AESencode(final String res) &#123;        return keyGeneratorES(res, AES, &quot;aA11*-%&quot;, keysizeAES, true);    &#125;    public static String AESdecode(final String res) &#123;        return keyGeneratorES(res, AES, &quot;aA11*-%&quot;, keysizeAES, false);    &#125;    public static void main(String[] args) &#123;        System.out.println(                &quot;加密后:&quot; + AESencode(&quot;将要加密的明文&quot;)        );        System.out.println(                &quot;解密后:&quot; + AESdecode(&quot;730CAE52D85B372FB161B39D0A908B8CC6EF6DA2F7D4E595D35402134C3E18AB&quot;)        );    &#125;&#125;</code></pre><h4 id="1-7-2-实现"><a href="#1-7-2-实现" class="headerlink" title="1.7.2  实现"></a>1.7.2  实现</h4><h5 id="①导入依赖"><a href="#①导入依赖" class="headerlink" title="①导入依赖"></a>①导入依赖</h5><pre><code class="xml">        &lt;!--SpringIOC相关依赖--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--AOP相关依赖--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;            &lt;version&gt;1.8.13&lt;/version&gt;        &lt;/dependency&gt;</code></pre><h5 id="②开启AOP注解支持"><a href="#②开启AOP注解支持" class="headerlink" title="②开启AOP注解支持"></a>②开启AOP注解支持</h5><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;    &lt;!--配置组件扫描--&gt;    &lt;context:component-scan base-package=&quot;com.sangeng&quot;&gt;&lt;/context:component-scan&gt;    &lt;!--启动AOP注解支持--&gt;    &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;&lt;/beans&gt;</code></pre><p>③自定义注解</p><pre><code class="java">package com.sangeng.aspect;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface Crypt &#123;&#125;</code></pre><p>④在目标方法上增加注解 </p><p><strong>注意：目标对象一定要记得注入Spring容器中</strong></p><pre><code class="java">@Controllerpublic class AIController &#123;    //....    //AI算命    @Crypt    public String fortuneTelling(String name)&#123;        System.out.println(name);              //AI算命核心代码        String[] strs = &#123;&quot;女犯伤官把夫克，旱地莲花栽不活，不是吃上两家饭，也要刷上三家锅。&quot;,&quot;一朵鲜花头上戴，一年四季也不开，一心想要花开时，采花之人没到来。&quot;,&quot;此命生来脾气暴，上来一阵双脚跳，对你脾气啥都好，经常与人吵和闹。&quot;&#125;;        int index = name.hashCode() % 3;        return strs[index];    &#125;&#125;</code></pre><h5 id="⑤定义切面类"><a href="#⑤定义切面类" class="headerlink" title="⑤定义切面类"></a>⑤定义切面类</h5><pre><code class="java">package com.sangeng.aspect;import com.sangeng.util.CryptUtil;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Pointcut;import org.springframework.stereotype.Component;@Component@Aspectpublic class CryptAspect &#123;    //确定切点    @Pointcut(&quot;@annotation(com.sangeng.aspect.Crypt)&quot;)    public void pt()&#123;    &#125;    //定义通知    @Around(&quot;pt()&quot;)    public Object crypt(ProceedingJoinPoint pjp) &#123;        //获取去目标方法调用时的参数        Object[] args = pjp.getArgs();        //对参数进行解密  解密后传入目标方法执行        String arg = (String) args[0];        String s = CryptUtil.AESdecode(arg);//解密        args[0] = s;        Object proceed = null;        String ret = null;        try &#123;            proceed = pjp.proceed(args);//目标方法调用            //目标方法执行后需要获取到返回值            ret = (String) proceed;            //对返回值加密后进行真正的返回            ret = CryptUtil.AESencode(ret);        &#125; catch (Throwable throwable) &#123;            throwable.printStackTrace();        &#125;        return ret;    &#125;&#125;</code></pre><h3 id="1-8-xml配置AOP"><a href="#1-8-xml配置AOP" class="headerlink" title="1.8 xml配置AOP"></a>1.8 xml配置AOP</h3><h4 id="①定义切面类"><a href="#①定义切面类" class="headerlink" title="①定义切面类"></a>①定义切面类</h4><pre><code class="java">public class MyAspect &#123;    public void before(JoinPoint joinPoint)&#123;        System.out.println(&quot;before&quot;);    &#125;//    @AfterReturning(value = &quot;pt()&quot;,returning = &quot;ret&quot;)    public void afterReturning(JoinPoint joinPoint,Object ret)&#123;        System.out.println(&quot;afterReturning:&quot;+ret);    &#125;//    @After(&quot;pt()&quot;)    public void after(JoinPoint joinPoint)&#123;        System.out.println(&quot;after&quot;);    &#125;//    @AfterThrowing(value = &quot;pt()&quot;,throwing = &quot;e&quot;)    public void afterThrowing(JoinPoint joinPoint,Throwable e)&#123;        String message = e.getMessage();        System.out.println(&quot;afterThrowing:&quot;+message);    &#125;    public Object around(ProceedingJoinPoint pjp)&#123;        //获取参数        Object[] args = pjp.getArgs();        MethodSignature signature = (MethodSignature) pjp.getSignature();        Object target = pjp.getTarget();        Object ret = null;        try &#123;            ret = pjp.proceed();//目标方法的执行            //ret就是被增强方法的返回值            System.out.println(ret);        &#125; catch (Throwable throwable) &#123;            throwable.printStackTrace();            System.out.println(throwable.getMessage());        &#125;//        System.out.println(pjp);        return ret;    &#125;&#125;</code></pre><h4 id="②目标类和切面类注入容器"><a href="#②目标类和切面类注入容器" class="headerlink" title="②目标类和切面类注入容器"></a>②目标类和切面类注入容器</h4><p>在切面类和目标类上加是对应的注解。注入如果是使用注解的方式注入容器要记得开启组件扫描。</p><p>当然你也可以在xml中使用bean标签的方式注入容器。</p><pre><code class="java">@Component//把切面类注入容器public class MyAspect &#123;    //..。省略无关代码&#125;</code></pre><pre><code class="java">@Service//把目标类注入容器public class UserService &#123;    //..。省略无关代码&#125;</code></pre><h4 id="③配置AOP"><a href="#③配置AOP" class="headerlink" title="③配置AOP"></a>③配置AOP</h4><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;    &lt;!--开启组件扫描--&gt;    &lt;context:component-scan base-package=&quot;com.sangeng&quot;&gt;&lt;/context:component-scan&gt;    &lt;!--配置AOP--&gt;    &lt;aop:config&gt;        &lt;!--定义切点--&gt;        &lt;aop:pointcut id=&quot;pt1&quot; expression=&quot;execution(* com.sangeng.service..*.*(..))&quot;&gt;&lt;/aop:pointcut&gt;        &lt;aop:pointcut id=&quot;pt2&quot; expression=&quot;@annotation(com.sangeng.aspect.InvokeLog)&quot;&gt;&lt;/aop:pointcut&gt;        &lt;!--配置切面--&gt;        &lt;aop:aspect ref=&quot;myAspect&quot;&gt;            &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:before&gt;            &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:after&gt;            &lt;aop:after-returning method=&quot;afterReturning&quot; pointcut-ref=&quot;pt1&quot; returning=&quot;ret&quot;&gt;&lt;/aop:after-returning&gt;            &lt;aop:after-throwing method=&quot;afterThrowing&quot; pointcut-ref=&quot;pt2&quot; throwing=&quot;e&quot;&gt;&lt;/aop:after-throwing&gt;        &lt;/aop:aspect&gt;    &lt;/aop:config&gt;&lt;/beans&gt;</code></pre><h3 id="1-9-多切面顺序问题"><a href="#1-9-多切面顺序问题" class="headerlink" title="1.9 多切面顺序问题"></a>1.9 多切面顺序问题</h3><p>​在实际项目中我们可能会存在配置了多个切面的情况。这种情况下我们很可能需要控制切面的顺序。</p><p>​我们在默认情况下Spring有它自己的排序规则。（按照类名排序）</p><p>​默认排序规则往往不符合我们的要求，我们需要进行特殊控制。</p><p>​如果是注解方式配置的AOP可以在切面类上加**@Order注解<strong>来控制顺序。</strong>@Order中的属性越小优先级越高。**</p><p>​如果是XML方式配置的AOP,可以通过调整<strong>配置顺序</strong>来控制。</p><p>例如：</p><p>下面这种配置方式就会先使用CryptAspect里面的增强，在使用APrintLogAspect里的增强</p><pre><code class="java">@Component@Aspect@Order(2)public class APrintLogAspect &#123;    //省略无关代码&#125;@Component@Aspect@Order(1)public class CryptAspect &#123;    //省略无关代码&#125;</code></pre><h3 id="1-10-AOP原理-动态代理"><a href="#1-10-AOP原理-动态代理" class="headerlink" title="1.10 AOP原理-动态代理"></a>1.10 AOP原理-动态代理</h3><p>​实际上Spring的AOP其实底层就是使用动态代理来完成的。并且使用了两种动态代理分别是JDK的动态代理和Cglib动态代理。</p><p>​所以我们接下去来学习下这两种动态代理，理解下它们的不同点。</p><h4 id="1-10-1-JDK动态代理"><a href="#1-10-1-JDK动态代理" class="headerlink" title="1.10.1 JDK动态代理"></a>1.10.1 JDK动态代理</h4><p>​JDK的动态代理使用的java.lang.reflect.Proxy这个类来进行实现的。要求被代理（被增强）的类需要实现了接口。并且JDK动态代理也只能对接口中的方法进行增强。</p><pre><code class="java">public static void main(String[] args) &#123;        AIControllerImpl aiController = new AIControllerImpl();        //使用动态代理增强getAnswer方法        //1.JDK动态代理        //获取类加载器        ClassLoader cl = Demo.class.getClassLoader();        //被代理类所实现接口的字节码对象数组        Class&lt;?&gt;[] interfaces = AIControllerImpl.class.getInterfaces();        AIController proxy = (AIController) Proxy.newProxyInstance(cl, interfaces, new InvocationHandler() &#123;            //使用代理对象的方法时 会调用到invoke                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;                //proxy   是代理对象                //method 是当前被调用的方法封装的Method对象                //args   是调用方法时传入的参数                //调用被代理对象的对应方法                //判断 当前调用的是否是getAnswer方法                if(method.getName().equals(&quot;getAnswer&quot;))&#123;                    System.out.println(&quot;增强&quot;);                &#125;                Object ret = method.invoke(aiController, args);                return ret;            &#125;        &#125;);        String answer = proxy.getAnswer(&quot;三连了吗？&quot;);        System.out.println(answer);    &#125;</code></pre><h4 id="1-10-2-Cglib动态代理"><a href="#1-10-2-Cglib动态代理" class="headerlink" title="1.10.2 Cglib动态代理"></a>1.10.2 Cglib动态代理</h4><p>​使用的是org.springframework.cglib.proxy.Enhancer类进行实现的。</p><pre><code class="java">public class CglibDemo &#123;    public static void main(String[] args) &#123;        Enhancer enhancer = new Enhancer();        //设置父类的字节码对象        enhancer.setSuperclass(AIControllerImpl.class);        enhancer.setCallback(new MethodInterceptor() &#123;            //使用代理对象执行方法是都会调用到intercept方法            @Override            public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;                //判断当前调用的方法是不是getAnswer方法 如果是进行增强                if (&quot;getAnswer&quot;.equals(method.getName()))&#123;                    System.out.println(&quot;被增强了&quot;);                &#125;                //调用父类中对应的方法                Object ret = methodProxy.invokeSuper(o, objects);                return ret;            &#125;        &#125;);        //生成代理对象        AIControllerImpl proxy = (AIControllerImpl) enhancer.create();//        System.out.println(proxy.getAnswer(&quot;你好吗？&quot;));        System.out.println(proxy.fortuneTelling(&quot;你好吗？&quot;));    &#125;&#125;</code></pre><h4 id="1-10-3-总结"><a href="#1-10-3-总结" class="headerlink" title="1.10.3 总结"></a>1.10.3 总结</h4><p>​JDK动态代理要求被代理（被增强）的类必须要实现接口，生成的代理对象相当于是被代理对象的兄弟。</p><p>​Cglib的动态代理不要求被代理（被增强）的类要实现接口，生成的代理对象相当于被代理对象的子类对象。</p><p>​<strong>Spring的AOP默认情况下优先使用的是JDK的动态代理，如果使用不了JDK的动态代理才会使用Cglib的动态代理。</strong></p><h3 id="1-11-切换默认动态代理方式"><a href="#1-11-切换默认动态代理方式" class="headerlink" title="1.11 切换默认动态代理方式"></a>1.11 切换默认动态代理方式</h3><p>​有的时候我们需要修改AOP的代理方式。</p><p>​我们可以使用以下方式修改：</p><p>如果我们是采用注解方式配置AOP的话：</p><p>设置aop:aspectj-autoproxy标签的proxy-target-class属性为true，代理方式就会修改成Cglib</p><pre><code class="xml">&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;</code></pre><p>如果我们是采用xml方式配置AOP的话：</p><p>设置aop:config标签的proxy-target-class属性为true,代理方式就会修改成Cglib</p><pre><code class="xml">&lt;aop:config proxy-target-class=&quot;true&quot;&gt;&lt;/aop:config&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Spring </category>
          
          <category> Spring基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Step.4</title>
      <link href="/computer-science/spring/docssp/Spring-04/"/>
      <url>/computer-science/spring/docssp/Spring-04/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-04"><a href="#Spring-04" class="headerlink" title="Spring-04"></a>Spring-04</h1><h2 id="1-Spring整合Junit"><a href="#1-Spring整合Junit" class="headerlink" title="1.Spring整合Junit"></a>1.Spring整合Junit</h2><h3 id="①导入依赖"><a href="#①导入依赖" class="headerlink" title="①导入依赖"></a>①导入依赖</h3><pre><code class="xml">&lt;!-- junit --&gt;&lt;dependency&gt;    &lt;groupId&gt;junit&lt;/groupId&gt;    &lt;artifactId&gt;junit&lt;/artifactId&gt;    &lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt;&lt;!-- spring整合junit的依赖 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;    &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="②-编写测试类"><a href="#②-编写测试类" class="headerlink" title="② 编写测试类"></a>② 编写测试类</h3><p>在测试类上加上</p><p>**@RunWith(SpringJUnit4ClassRunner.class)**注解，指定让测试运行于Spring环境</p><p><strong>@ContextConfiguration注解</strong>，指定Spring容器创建需要的配置文件或者配置类</p><pre><code class="java">@RunWith(SpringJUnit4ClassRunner.class)//让测试运行与Spring测试环境@ContextConfiguration(locations = &quot;classpath:配置文件1.xml&quot;)//设置Spring配置文件或者配置类//@ContextConfiguration(classes = SpringConfig.class)public class SpringTest &#123;&#125;</code></pre><h3 id="③注入对象进行测试"><a href="#③注入对象进行测试" class="headerlink" title="③注入对象进行测试"></a>③注入对象进行测试</h3><p>在测试类中注入要测试的对象，定义测试方法，在其中使用要测试的对象。</p><pre><code class="java">@RunWith(SpringJUnit4ClassRunner.class)//让测试运行与Spring测试环境@ContextConfiguration(locations = &quot;classpath:配置文件1.xml&quot;)//设置Spring配置文件或者配置类//@ContextConfiguration(classes = SpringConfig.class)public class SpringTest &#123;        // 想测哪个对象，就注入哪个对象    @Autowired    private UserService userService;        //定义测试方法    @Test    public void testUserService() &#123;        userService.findById(10);    &#125;    &#125;</code></pre><h2 id="2-Spring整合Mybatis"><a href="#2-Spring整合Mybatis" class="headerlink" title="2.Spring整合Mybatis"></a>2.Spring整合Mybatis</h2><p>​我们如果想把Mybatis整合到Spring中需要使用一个整合包<strong>mybatis-spring</strong></p><p>​官方文档：<span class="exturl" data-url="aHR0cDovL215YmF0aXMub3JnL3NwcmluZy96aC9pbmRleC5odG1s">http://mybatis.org/spring/zh/index.html</span></p><h3 id="①导入依赖-1"><a href="#①导入依赖-1" class="headerlink" title="①导入依赖"></a>①导入依赖</h3><pre><code class="xml">    &lt;!-- spring-jdbc --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;        &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- mybatis整合到Spring的整合包 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;        &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;        &lt;version&gt;2.0.4&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--mybatis依赖--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;        &lt;version&gt;3.5.4&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--mysql驱动--&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;5.1.47&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- druid数据源 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;        &lt;artifactId&gt;druid&lt;/artifactId&gt;        &lt;version&gt;1.1.16&lt;/version&gt;    &lt;/dependency&gt;</code></pre><h3 id="②往容器中注入整合相关对象"><a href="#②往容器中注入整合相关对象" class="headerlink" title="②往容器中注入整合相关对象"></a>②往容器中注入整合相关对象</h3><pre><code class="xml">    &lt;!--读取properties文件--&gt;    &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;&gt;&lt;/context:property-placeholder&gt;    &lt;!--创建连接池注入容器--&gt;    &lt;bean class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; id=&quot;dataSource&quot;&gt;        &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;   &lt;!--spring整合mybatis后控制的创建获取SqlSessionFactory的对象--&gt;    &lt;bean class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot; id=&quot;sessionFactory&quot;&gt;        &lt;!--配置连接池--&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;        &lt;!--配置mybatis配置文件的路径--&gt;        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--mapper扫描配置，扫描到的mapper对象会被注入Spring容器中--&gt;    &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot; id=&quot;mapperScannerConfigurer&quot;&gt;        &lt;property name=&quot;basePackage&quot; value=&quot;com.sangeng.dao&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;</code></pre><p>mybatis配置文件<strong>mybatis-config.xml</strong>如下:</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;typeAliases&gt;        &lt;package name=&quot;com.sangeng.domain&quot;&gt;&lt;/package&gt;    &lt;/typeAliases&gt;&lt;/configuration&gt;</code></pre><h3 id="③从容器中获取Mapper对象进行使用"><a href="#③从容器中获取Mapper对象进行使用" class="headerlink" title="③从容器中获取Mapper对象进行使用"></a>③从容器中获取Mapper对象进行使用</h3><pre><code class="java">    @Autowired    private UserDao userDao;</code></pre><h2 id="3-Spring声明式事务"><a href="#3-Spring声明式事务" class="headerlink" title="3.Spring声明式事务"></a>3.Spring声明式事务</h2><h3 id="3-1-事务回顾"><a href="#3-1-事务回顾" class="headerlink" title="3.1 事务回顾"></a>3.1 事务回顾</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h4 id="3-1-1-事务的概念"><a href="#3-1-1-事务的概念" class="headerlink" title="3.1.1 事务的概念"></a><strong>3.1.1 事务的概念</strong></h4><p>​保证一组数据库的操作，要么同时成功，要么同时失败</p><h4 id="3-1-2-四大特性"><a href="#3-1-2-四大特性" class="headerlink" title="3.1.2 四大特性"></a>3.1.2 四大特性</h4><ul><li><p>隔离性</p><p>多个事务之间要相互隔离，不能互相干扰</p></li><li><p>原子性</p><p>指事务是一个不可分割的整体，类似一个不可分割的原子</p></li><li><p>一致性</p><p>保障事务前后这组数据的状态是一致的。要么都是成功的，要么都是失败的。</p></li><li><p>持久性</p><p>指事务一旦被提交，这组操作修改的数据就真的的发生变化了。即使接下来数据库故障也不应该对其有影响。</p></li></ul><h3 id="3-2-实现声明式事务"><a href="#3-2-实现声明式事务" class="headerlink" title="3.2 实现声明式事务"></a>3.2 实现声明式事务</h3><p>​如果我们自己去对事务进行控制的话我们就需要值原来核心代码的基础上加上事务控制相关的代码。而在我们的实际开发中这种事务控制的操作也是非常常见的。所以Spring提供了声明式事务的方式让我们去控制事务。</p><p>​只要简单的加个注解(或者是xml配置)就可以实现事务控制，不需要事务控制的时候只需要去掉相应的注解即可。</p><h4 id="3-2-0-案例环境准备"><a href="#3-2-0-案例环境准备" class="headerlink" title="3.2.0 案例环境准备"></a>3.2.0 案例环境准备</h4><p>①数据初始化</p><pre><code class="mysql">CREATE DATABASE /*!32312 IF NOT EXISTS*/`spring_db` /*!40100 DEFAULT CHARACTER SET utf8 */;USE `spring_db`;DROP TABLE IF EXISTS `account`;CREATE TABLE `account` (  `id` INT(11) NOT NULL AUTO_INCREMENT,  `name` VARCHAR(50) DEFAULT NULL,  `money` DOUBLE DEFAULT NULL,  PRIMARY KEY (`id`)) ENGINE=INNODB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;INSERT  INTO `account`(`id`,`name`,`money`) VALUES (1,&#39;三更&#39;,100),(2,&#39;草堂&#39;,100);</code></pre><p>②Spring整合Mybatis</p><p>③创建Service和Dao</p><pre><code class="java">public interface AccountService &#123;    /**     * 转账     * @param outId 转出账户的id     * @param inId 转出账户的id     * @param money 转账金额     */    public void transfer(Integer outId,Integer inId,Double money);&#125;</code></pre><pre><code class="java">@Servicepublic class AccountServiceImpl implements AccountService &#123;    @Autowired    private AccoutDao accoutDao;    public void transfer(Integer outId, Integer inId, Double money) &#123;        //增加        accoutDao.updateMoney(inId,money);        //减少        accoutDao.updateMoney(outId,-money);    &#125;&#125;</code></pre><pre><code class="java">public interface AccoutDao &#123;    void updateMoney(@Param(&quot;id&quot;) Integer id,@Param(&quot;updateMoney&quot;) Double updateMoney);&#125;</code></pre><p>AccoutDao.xml如下：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;com.sangeng.dao.AccoutDao&quot;&gt;    &lt;update id=&quot;updateMoney&quot;&gt;        update  account set money = money + #&#123;updateMoney&#125; where id = #&#123;id&#125;    &lt;/update&gt;&lt;/mapper&gt;</code></pre><h4 id="3-2-1-注解实现"><a href="#3-2-1-注解实现" class="headerlink" title="3.2.1 注解实现"></a>3.2.1 注解实现</h4><h5 id="①配置事务管理器和事务注解驱动"><a href="#①配置事务管理器和事务注解驱动" class="headerlink" title="①配置事务管理器和事务注解驱动"></a>①配置事务管理器和事务注解驱动</h5><p>在spring的配置文件中添加如下配置：</p><pre><code class="xml">    &lt;!--把事务管理器注入Spring容器，需要配置一个连接池--&gt;    &lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;    &lt;!--开启事务注解驱动，配置使用的事务管理器--&gt;    &lt;tx:annotation-driven transaction-manager=&quot;txManager&quot;/&gt;</code></pre><h5 id="②添加注解"><a href="#②添加注解" class="headerlink" title="②添加注解"></a>②添加注解</h5><p>在需要进行事务控制的方法或者类上添加@Transactional注解就可以实现事务控制。</p><pre><code class="java">    @Transactional    public void transfer(Integer outId, Integer inId, Double money) &#123;        //增加        accoutDao.updateMoney(inId,money);//        System.out.println(1/0);        //减少        accoutDao.updateMoney(outId,-money);    &#125;</code></pre><p><strong>注意：如果加在类上，这个类的所有方法都会受事务控制，如果加在方法上，就是那一个方法受事务控制。</strong></p><p>注意，因为声明式事务底层是通过AOP实现的，所以最好把AOP相关依赖都加上。</p><pre><code class="xml">       &lt;dependency&gt;            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;            &lt;version&gt;1.9.6&lt;/version&gt;        &lt;/dependency&gt;</code></pre><h4 id="3-2-2-xml方式实现"><a href="#3-2-2-xml方式实现" class="headerlink" title="3.2.2 xml方式实现"></a>3.2.2 xml方式实现</h4><h5 id="①配置事务管理器"><a href="#①配置事务管理器" class="headerlink" title="①配置事务管理器"></a>①配置事务管理器</h5><pre><code class="xml">    &lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;</code></pre><h5 id="②配置事务切面"><a href="#②配置事务切面" class="headerlink" title="②配置事务切面"></a>②配置事务切面</h5><pre><code class="xml">     &lt;!--定义事务管理的通知类--&gt;    &lt;tx:advice transaction-manager=&quot;txManager&quot; id=&quot;txAdvice&quot;&gt;        &lt;tx:attributes&gt;            &lt;tx:method name=&quot;trans*&quot;/&gt;        &lt;/tx:attributes&gt;    &lt;/tx:advice&gt;    &lt;aop:config&gt;        &lt;aop:pointcut id=&quot;pt&quot; expression=&quot;execution(* com.sangeng.service..*.*(..))&quot;&gt;&lt;/aop:pointcut&gt;        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;pt&quot;&gt;&lt;/aop:advisor&gt;    &lt;/aop:config&gt;</code></pre><p>注意，因为声明式事务底层是通过AOP实现的，所以最好把AOP相关依赖都加上。</p><pre><code class="xml">       &lt;dependency&gt;            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;            &lt;version&gt;1.9.6&lt;/version&gt;        &lt;/dependency&gt;</code></pre><h3 id="3-3-属性配置"><a href="#3-3-属性配置" class="headerlink" title="3.3 属性配置"></a>3.3 属性配置</h3><h4 id="3-3-1-事务传播行为propagation"><a href="#3-3-1-事务传播行为propagation" class="headerlink" title="3.3.1 事务传播行为propagation"></a>3.3.1 事务传播行为propagation</h4><p>​当事务方法嵌套调用时，需要控制是否开启新事务，可以使用事务传播行为来控制。</p><p>测试案例:</p><pre><code class="java">@Servicepublic class TestServiceImpl &#123;    @Autowired    AccountService accountService;    @Transactional    public void test()&#123;        accountService.transfer(1,2,10D);        accountService.log();    &#125;&#125;</code></pre><pre><code class="java">public class AccountServiceImpl implements AccountService &#123;    //...省略其他不相关代码    @Transactional    public void log() &#123;        System.out.println(&quot;打印日志&quot;);        int i = 1/0;    &#125;&#125;</code></pre><table><thead><tr><th>属性值</th><th>行为</th></tr></thead><tbody><tr><td>REQUIRED（必须要有）</td><td>外层方法有事务，内层方法就加入。外层没有，内层就新建</td></tr><tr><td>REQUIRES_NEW（必须要有新事务）</td><td>外层方法有事务，内层方法新建。外层没有，内层也新建</td></tr><tr><td>SUPPORTS（支持有）</td><td>外层方法有事务，内层方法就加入。外层没有，内层就也没有</td></tr><tr><td>NOT_SUPPORTED（支持没有）</td><td>外层方法有事务，内层方法没有。外层没有，内层也没有</td></tr><tr><td>MANDATORY（强制要求外层有）</td><td>外层方法有事务，内层方法加入。外层没有。内层就报错</td></tr><tr><td>NEVER(绝不允许有)</td><td>外层方法有事务，内层方法就报错。外层没有。内层就也没有</td></tr></tbody></table><p>例如：</p><pre><code class="java">    @Transactional(propagation = Propagation.REQUIRES_NEW)    public void transfer(Integer outId, Integer inId, Double money) &#123;        //增加        accoutDao.updateMoney(inId,money);        //减少        accoutDao.updateMoney(outId,-money);    &#125;</code></pre><h4 id="3-3-2-隔离级别isolation"><a href="#3-3-2-隔离级别isolation" class="headerlink" title="3.3.2 隔离级别isolation"></a>3.3.2 隔离级别isolation</h4><p>Isolation.DEFAULT 使用数据库默认隔离级别</p><p>Isolation.READ_UNCOMMITTED </p><p>Isolation.READ_COMMITTED</p><p>Isolation.REPEATABLE_READ</p><p>Isolation.SERIALIZABLE</p><pre><code class="java">   @Transactional(propagation = Propagation.REQUIRES_NEW,isolation = Isolation.READ_COMMITTED)    public void transfer(Integer outId, Integer inId, Double money) &#123;        //增加        accoutDao.updateMoney(inId,money);        //减少        accoutDao.updateMoney(outId,-money);    &#125;</code></pre><h4 id="3-3-3-只读readOnly"><a href="#3-3-3-只读readOnly" class="headerlink" title="3.3.3 只读readOnly"></a>3.3.3 只读readOnly</h4><p>​如果事务中的操作都是读操作，没涉及到对数据的写操作可以设置readOnly为true。这样可以提高效率。</p><pre><code class="java">    @Transactional(readOnly = true)    public void log() &#123;        System.out.println(&quot;打印日志&quot;);        int i = 1/0;    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Spring </category>
          
          <category> Spring基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Step.1 丰富的选项合并策略</title>
      <link href="/computer-science/vueyuanma/dosc/1%E4%B8%B0%E5%AF%8C%E7%9A%84%E9%80%89%E9%A1%B9%E5%90%88%E5%B9%B6%E7%AD%96%E7%95%A5/"/>
      <url>/computer-science/vueyuanma/dosc/1%E4%B8%B0%E5%AF%8C%E7%9A%84%E9%80%89%E9%A1%B9%E5%90%88%E5%B9%B6%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="1-1-Vue的引入"><a href="#1-1-Vue的引入" class="headerlink" title="1.1 Vue的引入"></a>1.1 Vue的引入</h2><p><code>Vue</code>的使用按照官方的说法支持<code>CDN</code>和<code>NPM</code>两种方式，<code>CDN</code>的方式是以<code>script</code>的方式将打包好的<code>vue.js</code>引入页面脚本中，而<code>NPM</code>的方式是和诸如 <code>webpack</code> 或 <code>Browserify</code> 模块打包器配置使用，以<code>npm install vue</code>的方式引入，这也是我们开发应用的主要形式。而从单纯分析源码思路和实现细节的角度来讲，打包后的<code>vue.js</code>在分析和提炼源码方面会更加方便，所以这个系列的源码分析，使用的是打包后的<code>vue</code>脚本，<strong>版本号是<code>v2.6.8</code></strong></p><h3 id="1-1-1-基础使用"><a href="#1-1-1-基础使用" class="headerlink" title="1.1.1 基础使用"></a>1.1.1 基础使用</h3><p>分析的开始当然是<code>vue</code>的基础使用，我们引入了<code>vue.js</code>并且<code>new</code>了一个<code>Vue</code>实例，并将它挂载到<code>#app</code>上，这是最基础的用法。</p><pre><code class="js">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.8/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt;var vm = new Vue(&#123;  el: &#39;#app&#39;,  data: &#123;    message: &#39;选项合并&#39;  &#125;,&#125;)&lt;/script&gt;</code></pre><p>虽然这一节的重点是阐述<code>Vue</code>的选项配置，从选项配置入手也是我们从零开始品读源码最容易开始的思路，但是为了分析的完整性，避免后续出现未知的概念，有必要先大致了解一下<code>vue</code>在脚本引入之后分别做了什么。</p><h3 id="1-1-2-Vue构造器"><a href="#1-1-2-Vue构造器" class="headerlink" title="1.1.2 Vue构造器"></a>1.1.2 Vue构造器</h3><p>打包后的源码是遵从<code>UMD</code>规范的，它是<code>commonjs</code>和<code>amd</code>的整合。而<code>Vue</code>的本质是一个构造器,并且它保证了只能通过<code>new</code>实例的形式去调用，而不能直接通过函数的形式使用。</p><pre><code class="js">(function (global, factory) &#123;  // 遵循UMD规范  typeof exports === &#39;object&#39; &amp;&amp; typeof module !== &#39;undefined&#39; ? module.exports = factory() :  typeof define === &#39;function&#39; &amp;&amp; define.amd ? define(factory) :  (global = global || self, global.Vue = factory());&#125;(this, function () &#123; &#39;use strict&#39;;  ···  // Vue 构造函数  function Vue (options) &#123;    // 保证了无法直接通过Vue()去调用，只能通过new的方式去创建实例    if (!(this instanceof Vue)    ) &#123;      warn(&#39;Vue is a constructor and should be called with the `new` keyword&#39;);    &#125;    this._init(options);  &#125;  return Vue&#125;))</code></pre><h3 id="1-1-3-定义原型属性方法"><a href="#1-1-3-定义原型属性方法" class="headerlink" title="1.1.3 定义原型属性方法"></a>1.1.3 定义原型属性方法</h3><p>Vue之所以能适应基础的开发场景，除了经常提到的支持组件化开发，以及完善的响应式系统等外，还有重要的一点是它提供了丰富的<code>api</code>方法，不管是静态还是原型方法，它们都丰富到足以满足我们日常基础的开发需求。所以熟练阅读<span class="exturl" data-url="aHR0cHM6Ly9jbi52dWVqcy5vcmcvdjIvYXBpLw==">vue-api</span>文档并精准使用<code>api</code>方法是迈向熟练开发的前提。接下来我们看看这些方法属性是在哪里定义的，<strong>注意，该小节会忽略大部分属性方法具体的实现，这些详细的细节会贯穿在后续系列的分析中</strong>。</p><p>首先是原型上的属性方法，在构造函数的定义之后，有这样五个函数，他们分别针对不同场景定义了<code>Vue</code>原型上的属性和方法。</p><pre><code class="js">  // 定义Vue原型上的init方法(内部方法)  initMixin(Vue);  // 定义原型上跟数据相关的属性方法  stateMixin(Vue);  //定义原型上跟事件相关的属性方法  eventsMixin(Vue);  // 定义原型上跟生命周期相关的方法  lifecycleMixin(Vue);  // 定义渲染相关的函数  renderMixin(Vue); </code></pre><pre><code class="text">initMixin: 将 init 方法添加到 Vue 实例的原型上。init 方法是 Vue 实例的内部方法，用于初始化实例的各种属性和调用其他初始化方法。stateMixin: 添加与数据相关的属性和方法到 Vue 实例的原型上。可能包括$data、$props、$watch 等一些与数据操作和监听相关的方法。eventsMixin: 添加与事件相关的属性和方法到 Vue 实例的原型上。可能包括$on、$once、$off、$emit 等一些用于事件处理的方法。lifecycleMixin: 添加与生命周期相关的方法到 Vue 实例的原型上。可能包括$mount、$destroy 等一些用于生命周期管理的方法。renderMixin: 添加与渲染相关的函数到 Vue 实例的原型上。可能包括渲染函数的生成、虚拟 DOM 的创建等一些与渲染相关的方法。</code></pre><p>我们一个个看，首先<code>initMixin</code>定义了<strong>内部在实例化<code>Vue</code>时会执行的初始化代码</strong>，它是一个内部使用的方法。</p><pre><code class="js">function initMixin (Vue) &#123;  Vue.prototype._init = function (options) &#123;&#125;&#125;_init(options) 方法：这个方法是 Vue 实例的初始化方法。它会对传入的选项 options 进行处理，并执行一系列的初始化操作，包括数据响应式处理、事件系统的初始化、生命周期钩子的注册等。$data 属性：这个属性是 Vue 实例的根数据对象。它实际上指向了 Vue 实例的 data 选项，用于访问和操作数据。$props 属性：这个属性是 Vue 实例的根属性对象。它实际上指向了 Vue 实例的 $props，用于访问和操作父组件传递的属性。$set(target, key, value) 方法：这个方法用于给响应式对象添加一个属性，并使其成为响应式。它类似于 Vue.set() 全局方法，但被绑定到了实例上，方便实例内部使用。通过将这些方法和属性混入到 Vue 的原型链上，initMixin(Vue) 实现了对 Vue 实例的初始化操作。这样，在创建 Vue 实例时，就可以使用这些方法和属性来进行数据处理、事件管理和初始化操作，让 Vue 实例能够正常地运行和响应外部的变化。</code></pre><p><code>stateMixin</code>方法会定义跟数据相关的属性方法，例如代理数据的访问，我们可以在实例上通过<code>this.$data</code>和<code>this.$props</code>访问到<code>data,props</code>的值，并且也定义了使用频率较高的<code>this.$set,this.$delte</code>等方法。</p><pre><code class="js">function stateMixin (Vue) &#123;    var dataDef = &#123;&#125;;    dataDef.get = function () &#123; return this._data &#125;;    var propsDef = &#123;&#125;;    propsDef.get = function () &#123; return this._props &#125;;    &#123;      dataDef.set = function () &#123;        warn(          &#39;Avoid replacing instance root $data. &#39; +          &#39;Use nested data properties instead.&#39;,          this        );      &#125;;      propsDef.set = function () &#123;        warn(&quot;$props is readonly.&quot;, this);      &#125;;    &#125;    // 代理了_data,_props的访问    Object.defineProperty(Vue.prototype, &#39;$data&#39;, dataDef);    Object.defineProperty(Vue.prototype, &#39;$props&#39;, propsDef);    // $set, $del    Vue.prototype.$set = set;    Vue.prototype.$delete = del;    // $watch    Vue.prototype.$watch = function (expOrFn,cb,options) &#123;&#125;;  &#125;</code></pre><p><code>eventsMixin</code>会对原型上的事件相关方法做定义，文档中提到的<code>vm.$on,vm.$once,vm.$off,vm.$emit</code>也就是在这里定义的。</p><pre><code class="js">function eventsMixin(Vue) &#123;  // 自定义事件监听  Vue.prototype.$on = function (event, fn) &#123;&#125;  // 自定义事件监听,只触发一次  Vue.prototype.$once = function (event, fn) &#123;&#125;  // 自定义事件解绑  Vue.prototype.$off = function (event, fn) &#123;&#125;  // 自定义事件通知  Vue.prototype.$emit = function (event, fn) &#123;&#125;&#125;</code></pre><p><code>lifecycleMixin,renderMixin</code>两个都可以算是对生命周期渲染方法的定义，例如<code>$forceUpdate</code>触发实例的强制刷新，<code>$nextTick</code>将回调延迟到下次 <code>DOM</code> 更新循环之后执行等。</p><pre><code class="js">// 定义跟生命周期相关的方法  function lifecycleMixin (Vue) &#123;    Vue.prototype._update = function (vnode, hydrating) &#123;&#125;;    Vue.prototype.$forceUpdate = function () &#123;&#125;;    Vue.prototype.$destroy = function () &#123;&#125;  &#125;// 定义原型上跟渲染相关的方法  function renderMixin (Vue) &#123;    Vue.prototype.$nextTick = function (fn) &#123;&#125;;    // _render函数，后面会着重讲    Vue.prototype._render = function () &#123;&#125;;  &#125;</code></pre><h3 id="1-1-4-定义静态属性方法"><a href="#1-1-4-定义静态属性方法" class="headerlink" title="1.1.4 定义静态属性方法"></a>1.1.4 定义静态属性方法</h3><p>除了原型方法外，<code>Vue</code>还提供了丰富的全局<code>api</code>方法，这些都是在<code>initGlobalAPI</code>中定义的。</p><pre><code class="js">/* 初始化构造器的api */function initGlobalAPI (Vue) &#123;    // config    var configDef = &#123;&#125;;    configDef.get = function () &#123; return config; &#125;;    &#123;      configDef.set = function () &#123;        warn(          &#39;Do not replace the Vue.config object, set individual fields instead.&#39;        );      &#125;;    &#125;    // 通过Vue.config拿到配置信息    Object.defineProperty(Vue, &#39;config&#39;, configDef);    // 工具类不作为公共暴露的API使用    Vue.util = &#123;      warn: warn,      extend: extend,      mergeOptions: mergeOptions,      defineReactive: defineReactive###1    &#125;;    // Vue.set = Vue.prototype.$set    Vue.set = set;    // Vue.delete = Vue.prototype.$delete    Vue.delete = del;    // Vue.nextTick = Vue.prototype.$nextTick    Vue.nextTick = nextTick;    // 2.6 explicit observable API    Vue.observable = function (obj) &#123;      observe(obj);      return obj    &#125;;    // 构造函数的默认选项默认为components,directive,filter, _base    Vue.options = Object.create(null);    ASSET_TYPES.forEach(function (type) &#123;      Vue.options[type + &#39;s&#39;] = Object.create(null);    &#125;);    // options里的_base属性存储Vue构造器    Vue.options._base = Vue;    extend(Vue.options.components, builtInComponents);    // Vue.use()    initUse(Vue);    // Vue.mixin()    initMixin$1(Vue);    // 定义extend扩展子类构造器的方法    // Vue.extend()    initExtend(Vue);    // Vue.components, Vue.directive, Vue.filter    initAssetRegisters(Vue);  &#125;</code></pre><p>看着源码对静态方法的定义做一个汇总。</p><ol><li>为源码里的<code>config</code>配置做一层代理，可以通过<code>Vue.config</code>拿到默认的配置，并且可以修改它的属性值，具体哪些可以配置修改，可以先参照官方文档。</li><li>定义内部使用的工具方法，例如警告提示，对象合并等。</li><li>定义<code>set,delet,nextTick</code>方法，本质上原型上也有这些方法的定义。</li><li>对<code>Vue.components,Vue.directive,Vue.filter</code>的定义，这些是默认的资源选项，后续会重点分析。</li><li>定义<code>Vue.use()</code>方法</li><li>定义<code>Vue.mixin()</code>方法</li><li>定义<code>Vue.extend()</code>方法</li></ol><p>现在我相信你已经对引入<code>Vue</code>的阶段有了一个大致的认识，在源码分析的初期阶段，我们不需要死磕每个方法，思路的实现细节，只需要对大致的结构有基本的认识。有了这些基础，我们开始进入这个章节的主线。</p><h2 id="1-2-构造器的默认选项"><a href="#1-2-构造器的默认选项" class="headerlink" title="1.2 构造器的默认选项"></a>1.2 构造器的默认选项</h2><p>我们回到最开始的例子，在实例化<code>Vue</code>时，我们会将选项对象传递给构造器进行初始化，这个选项对象描述了你想要的行为，例如以<code>data</code>定义实例中的响应式数据，以<code>computed</code>描述实例中的计算属性，以<code>components</code>来进行组件注册，甚至是定义各个阶段执行的生命周期钩子等。然而<code>Vue</code>内部本身会自带一些默认的选项，这些选项和用户自定义的选项会在后续一起参与到<code>Vue</code>实例的初始化中。</p><p>在<code>initGlobalAPI</code>方法中有几行默认选项的定义。<code>Vue</code>内部的默认选项会保留在静态的<code>options</code>属性上，从源码看<code>Vue</code>自身有四个默认配置选项，分别是<code>component，directive， filter</code>以及返回自身构造器的<code>_base</code>。</p><pre><code class="js">var ASSET_TYPES = [  &#39;component&#39;,  &#39;directive&#39;,  &#39;filter&#39;];// 原型上创建了一个指向为空对象的options属性Vue.options = Object.create(null); ASSET_TYPES.forEach(function (type) &#123;  Vue.options[type + &#39;s&#39;] = Object.create(null);&#125;);Vue.options._base = Vue;</code></pre><p>很明显我们开发者对这几个选项是非常熟悉的，<code>components</code>是需要注册的组件选项，<code>directives</code>是需要注册的指令，而<code>filter</code>则代表需要注册的过滤器。从代码的实现细节看，<code>Vue</code>为<code>components</code>提供了<code>keepAlive,transition,transitionGroup</code>的内置组件，为<code>directives</code>提供了<code>v-model,v-show</code>的内置指令，而过滤器则没有默认值。</p><pre><code class="js">// Vue内置组件var builtInComponents = &#123;  KeepAlive: KeepAlive&#125;;var platformComponents = &#123;  Transition: Transition,  TransitionGroup: TransitionGroup&#125;;// Vue 内置指令，例如： v-model, v-showvar platformDirectives = &#123;  model: directive,  show: show&#125;extend(Vue.options.components, builtInComponents); extend(Vue.options.components, platformComponents); // 扩展内置组件extend(Vue.options.directives, platformDirectives);  // 扩展内置指令</code></pre><p>其中<code>extend</code>方法实现了对象的合并，如果属性相同，则用新的属性值覆盖旧值。</p><pre><code class="js">// 将_from对象合并到to对象，属性相同时，则覆盖to对象的属性function extend (to, _from) &#123;  for (var key in _from) &#123;    to[key] = _from[key];  &#125;  return to&#125;</code></pre><p>因此做为构造器而言，<code>Vue</code>默认的资源选项配置如下：</p><pre><code class="js">Vue.options = &#123;  components: &#123;    KeepAlive: &#123;&#125;    Transition: &#123;&#125;    TransitionGroup: &#123;&#125;  &#125;,  directives: &#123;    model: &#123;inserted: ƒ, componentUpdated: ƒ&#125;    show: &#123;bind: ƒ, update: ƒ, unbind: ƒ&#125;  &#125;,  filters: &#123;&#125;  _base&#125;</code></pre><h2 id="1-3-选项检验"><a href="#1-3-选项检验" class="headerlink" title="1.3 选项检验"></a>1.3 选项检验</h2><p>介绍完<code>Vue</code>自身拥有的选项后，我们回过头来看看，实例化<code>Vue</code>的阶段发生了什么。从构造器的定义我们很容易发现，实例化<code>Vue</code>做的核心操作便是执行<code>_init</code>方法进行初始化。初始化操作会经过选项合并配置，初始化生命周期，初始化事件中心，乃至构建数据响应式系统等。而关键的第一步就是对选项的合并。合并后的选项会挂载到实例的<code>$options</code>属性中。(你可以先在实例中通过<code>this.$options</code>访问最终的选项)</p><pre><code class="js">function initMixin (Vue) &#123;  Vue.prototype._init = function (options) &#123;    var vm = this;    // a uid    // 记录实例化多少个vue对象    vm._uid = uid$3++;    // 选项合并，将合并后的选项赋值给实例的$options属性    vm.$options = mergeOptions(      resolveConstructorOptions(vm.constructor), // 返回Vue构造函数自身的配置项      options || &#123;&#125;,      vm    );  &#125;;&#125;</code></pre><p>从代码中可以看到，选项合并的重点是将用户自身传递的<code>options</code>选项和<code>Vue</code>构造函数自身的选项配置合并。我们看看<code>mergeOptions</code>函数的实现。</p><pre><code class="js">function mergeOptions (parent,child,vm) &#123;    &#123;      checkComponents(child);    &#125;    if (typeof child === &#39;function&#39;) &#123;      child = child.options;    &#125;    // props,inject,directives的校验和规范化    normalizeProps(child, vm);    normalizeInject(child, vm);    normalizeDirectives(child);        // 针对extends扩展的子类构造器    if (!child._base) &#123;      // extends      if (child.extends) &#123;        parent = mergeOptions(parent, child.extends, vm);      &#125;      // mixins      if (child.mixins) &#123;        for (var i = 0, l = child.mixins.length; i &lt; l; i++) &#123;          parent = mergeOptions(parent, child.mixins[i], vm);        &#125;      &#125;    &#125;    var options = &#123;&#125;;    var key;    for (key in parent) &#123;      mergeField(key);    &#125;    for (key in child) &#123;      if (!hasOwn(parent, key)) &#123;        mergeField(key);      &#125;    &#125;    function mergeField (key) &#123;      // 拿到各个选择指定的选项配置，如果没有则用默认的配置      var strat = strats[key] || defaultStrat;      // 执行各自的合并策略      options[key] = strat(parent[key], child[key], vm, key);    &#125;    // console.log(options)    return options  &#125;</code></pre><p><strong>选项合并过程中更多的不可控在于不知道用户传递了哪些配置选项，这些配置是否符合规范，是否达到合并配置的要求。因此每个选项的书写规则需要严格限定，原则上不允许用户脱离规则外来传递选项。</strong>因此在合并选项之前，很大的一部分工作是对选项的校验。其中<code>components,prop,inject,directive</code>等都是检验的重点。</p><h3 id="1-3-1-components规范检验"><a href="#1-3-1-components规范检验" class="headerlink" title="1.3.1 components规范检验"></a>1.3.1 components规范检验</h3><p>如果项目中需要使用到组件，我们会在<code>vue</code>实例化时传入组件选项以此来注册组件。因此，组件命名需要遵守很多规范，比如组件名不能用<code>html</code>保留的标签(如：<code>img,p</code>),也不能包含非法的字符等。这些都会在<code>validateComponentName</code>函数做校验。</p><pre><code class="js">// components规范检查函数function checkComponents (options) &#123;  // 遍历components对象，对每个属性值校验。  for (var key in options.components) &#123;    validateComponentName(key);  &#125;&#125;function validateComponentName (name) &#123;  if (!new RegExp((&quot;^[a-zA-Z][\\-\\.0-9_&quot; + (unicodeRegExp.source) + &quot;]*$&quot;)).test(name)) &#123;    // 正则判断检测是否为非法的标签，例如数字开头    warn(      &#39;Invalid component name: &quot;&#39; + name + &#39;&quot;. Component names &#39; +      &#39;should conform to valid custom element name in html5 specification.&#39;    );  &#125;  // 不能使用Vue自身自定义的组件名，如slot, component,不能使用html的保留标签，如 h1, svg等  if (isBuiltInTag(name) || config.isReservedTag(name)) &#123;    warn(      &#39;Do not use built-in or reserved HTML elements as component &#39; +      &#39;id: &#39; + name    );  &#125;&#125;</code></pre><h3 id="1-3-2-props规范检验"><a href="#1-3-2-props规范检验" class="headerlink" title="1.3.2 props规范检验"></a>1.3.2 props规范检验</h3><p><code>Vue</code>的官方文档规定了<code>props</code>选项的书写形式有两种，分别是</p><ol><li>数组形式 <code>&#123; props: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] &#125;</code>,</li><li>带校验规则的对象形式 <code>&#123; props: &#123; a: &#123; type: &#39;String&#39;, default: &#39;prop校验&#39; &#125; &#125;&#125;</code><br>从源码上看，<strong>两种形式最终都会转换成对象的形式。</strong></li></ol><pre><code class="js">// props规范校验  function normalizeProps (options, vm) &#123;    var props = options.props;    if (!props) &#123; return &#125;    var res = &#123;&#125;;    var i, val, name;    // props选项数据有两种形式，一种是[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;],一种是&#123; a: &#123; type: &#39;String&#39;, default: &#39;hahah&#39; &#125;&#125;    // 数组    if (Array.isArray(props)) &#123;      i = props.length;      while (i--) &#123;        val = props[i];        if (typeof val === &#39;string&#39;) &#123;          name = camelize(val);          // 默认将数组形式的props转换为对象形式。          res[name] = &#123; type: null &#125;;         &#125; else &#123;          // 规则：保证是字符串          warn(&#39;props must be strings when using array syntax.&#39;);        &#125;      &#125;    &#125; else if (isPlainObject(props)) &#123;      for (var key in props) &#123;        val = props[key];        name = camelize(key);        res[name] = isPlainObject(val)          ? val          : &#123; type: val &#125;;      &#125;    &#125; else &#123;      // 非数组，非对象则判定props选项传递非法      warn(        &quot;Invalid value for option \&quot;props\&quot;: expected an Array or an Object, &quot; +        &quot;but got &quot; + (toRawType(props)) + &quot;.&quot;,        vm      );    &#125;    options.props = res;  &#125;</code></pre><h3 id="1-3-3-inject的规范校验"><a href="#1-3-3-inject的规范校验" class="headerlink" title="1.3.3 inject的规范校验"></a>1.3.3 inject的规范校验</h3><p><code>provide/inject</code>这对组合在我们日常开发中可能使用得比较少，当我们需要在父组件中提供数据或者方法给后代组件使用时可以用到<code>provide/inject</code>,注意关键是后代，而不单纯指子代，这是有别于<code>props</code>的使用场景。官方把它被称为依赖注入，依赖注入使得组件后代都能访问到父代注入的数据&#x2F;方法，且后代不需要知道数据的来源。重要的一点，依赖提供的数据是非响应式的。</p><p>基本的使用如下：</p><pre><code class="js">// 父组件var Provider = &#123;  provide: &#123;    foo: &#39;bar&#39;  &#125;,  // ...&#125;// 后代组件var Child = &#123;  // 数组写法  inject: [&#39;foo&#39;],  // 对象写法  inject: &#123;    foo: &#123;      from: &#39;foo&#39;,      default: &#39;bardefault&#39;    &#125;  &#125;&#125;</code></pre><p><code>inject</code>选项有两种写法，数组的方式以及对象的方式，和<code>props</code>的校验规则一致，最终<code>inject</code>都会转换为对象的形式存在。</p><pre><code class="js">// inject的规范化function normalizeInject (options, vm) &#123;    var inject = options.inject;    if (!inject) &#123; return &#125;    var normalized = options.inject = &#123;&#125;;    //数组的形式    if (Array.isArray(inject)) &#123;      for (var i = 0; i &lt; inject.length; i++) &#123;        // from: 属性是在可用的注入内容中搜索用的 key (字符串或 Symbol)        normalized[inject[i]] = &#123; from: inject[i] &#125;;      &#125;    &#125; else if (isPlainObject(inject)) &#123;      // 对象的处理      for (var key in inject) &#123;        var val = inject[key];        normalized[key] = isPlainObject(val)          ? extend(&#123; from: key &#125;, val)          : &#123; from: val &#125;;      &#125;    &#125; else &#123;      // 非法规则      warn(        &quot;Invalid value for option \&quot;inject\&quot;: expected an Array or an Object, &quot; +        &quot;but got &quot; + (toRawType(inject)) + &quot;.&quot;,        vm      );    &#125;  &#125;</code></pre><h3 id="1-3-4-directive的规范校验"><a href="#1-3-4-directive的规范校验" class="headerlink" title="1.3.4 directive的规范校验"></a>1.3.4 directive的规范校验</h3><p>我们先看看指令选项的用法，<code>Vue</code>允许我们自定义指令，并且它提供了五个钩子函数<code>bind, inserted, update, componentUpdated, unbind</code>,具体的用法可以参考<span class="exturl" data-url="aHR0cHM6Ly9jbi52dWVqcy5vcmcvdjIvZ3VpZGUvY3VzdG9tLWRpcmVjdGl2ZS5odG1s">官方-自定义指令</span>文档,而除了可以以对象的形式去定义钩子函数外，官方还提供了一种函数的简写，例如：</p><pre><code class="js">&#123;  directives: &#123;    &#39;color-swatch&#39;: function(el, binding) &#123;        el.style.backgroundColor = binding.value    &#125;  &#125;&#125;</code></pre><p>函数的写法会在<code>bind,update</code>钩子中触发相同的行为，并且不关心其他钩子。这个行为就是定义的函数。因此在对<code>directives</code>进行规范化时，针对函数的写法会将行为赋予<code>bind,update</code>钩子。</p><pre><code class="js">function normalizeDirectives (options) &#123;    var dirs = options.directives;    if (dirs) &#123;      for (var key in dirs) &#123;        var def###1 = dirs[key];        // 函数简写同样会转换成对象的形式        if (typeof def###1 === &#39;function&#39;) &#123;          dirs[key] = &#123; bind: def###1, update: def###1 &#125;;        &#125;      &#125;    &#125;  &#125;</code></pre><h3 id="1-3-5-函数缓存"><a href="#1-3-5-函数缓存" class="headerlink" title="1.3.5 函数缓存"></a>1.3.5 函数缓存</h3><p>这个内容跟选项的规范化无关，当读到上面规范检测的代码时，笔者发现有一段函数优化的代码值得我们学习。它将每次执行函数后的值进行缓存，当再次执行的时候直接调用缓存的数据而不是重复执行函数，以此提高前端性能，这是典型的用空间换时间的优化，也是经典的偏函数应用。</p><pre><code class="js">function cached (fn) &#123;  var cache = Object.create(null); // 创建空对象作为缓存对象  return (function cachedFn (str) &#123;    var hit = cache[str];    return hit || (cache[str] = fn(str)) // 每次执行时缓存对象有值则不需要执行函数方法，没有则执行并缓存起来  &#125;)&#125;var camelizeRE = /-(\w)/g;// 缓存会保存每次进行驼峰转换的结果var camelize = cached(function (str) &#123;  // 将诸如 &#39;a-b&#39;的写法统一处理成驼峰写法&#39;aB&#39;  return str.replace(camelizeRE, function (_, c) &#123; return c ? c.toUpperCase() : &#39;&#39;; &#125;)&#125;);</code></pre><h2 id="1-4-子类构造器"><a href="#1-4-子类构造器" class="headerlink" title="1.4 子类构造器"></a>1.4 子类构造器</h2><p>选项校验介绍完后，在正式进入合并策略之前，还需要先了解一个东西：子类构造器。为什么需要先提到子类构造器呢？</p><p>按照前面的知识，<code>Vue</code>内部提供了四个默认选项，关键的三个是<code>components,directives,filter</code>。那么当我们传递一个选项配置到<code>Vue</code>进行初始化，所需要合并的选项好像也仅仅是那关键的三个默认选项而已，那么源码中大篇幅做的选项合并策略又是针对什么场景呢？答案就是这个子类构造器。</p><p><strong><code>Vue</code>提供了一个<code>Vue.extend</code>的静态方法，它是基于基础的<code>Vue</code>构造器创建一个“子类”，而这个子类所传递的选项配置会和父类的选项配置进行合并。这是选项合并场景的由来。</strong></p><p>因此有不要先了解子类构造器的实现。下面例子中，我们创建了一个<code>Child</code>的子类，它继承于父类<code>Parent</code>,最终将子类挂载到<code>#app</code>元素上。最终获取的<code>data</code>便是选项合并后的结果。</p><pre><code class="js">var Parent = Vue.extend(&#123;  data() &#123;    test: &#39;父类&#39;，    test1: &#39;父类1&#39;  &#125;&#125;)var Child = Parent.extend(&#123;  data() &#123;    test: &#39;子类&#39;,    test2: &#39;子类1&#39;  &#125;&#125;)var vm = new Child().$mount(&#39;#app&#39;);console.log(vm.$data);// 结果 &#123;  test: &#39;子类&#39;,  test1: &#39;父类1&#39;,  test2: &#39;子类1&#39;&#125;</code></pre><p><code>Vue.extend</code>的实现思路很清晰，创建了一个<code>Sub</code>的类，这个类的原型指向了父类，并且子类的<code>options</code>会和父类的<code>options</code>进行合并，<code>mergeOptions</code>的其他细节接下来会重点分析。</p><pre><code class="js">Vue.extend = function (extendOptions) &#123;  extendOptions = extendOptions || &#123;&#125;;  var Super = this;  var name = extendOptions.name || Super.options.name;  if (name) &#123;    validateComponentName(name); // 校验子类的名称是否符合规范  &#125;  // 创建子类构造器  var Sub = function VueComponent (options) &#123;    this._init(options);  &#125;;  Sub.prototype = Object.create(Super.prototype); // 子类继承于父类  Sub.prototype.constructor = Sub;  Sub.cid = cid++;  // 子类和父类构造器的配置选项进行合并  Sub.options = mergeOptions(    Super.options,    extendOptions  );  return Sub // 返回子类构造函数&#125;;</code></pre><h2 id="1-5-合并策略"><a href="#1-5-合并策略" class="headerlink" title="1.5 合并策略"></a>1.5 合并策略</h2><p>合并策略之所以是难点，其中一个是合并选项类型繁多，合并规则随着选项的不同也呈现差异。概括起来思路主要是以下两点：</p><ol><li><code>Vue</code>针对每个规定的选项都有定义好的合并策略，例如<code>data,component,mounted</code>等。如果合并的子父配置都具有相同的选项，则只需要按照规定好的策略进行选项合并即可。</li><li>由于<code>Vue</code>传递的选项是开放式的，所有也存在传递的选项没有自定义选项的情况，这时候由于选项不存在默认的合并策略，所以处理的原则是有子类配置选项则默认使用子类配置选项，没有则选择父类配置选项。</li></ol><p>我们通过这两个思想去分析源码的实现，先看看<code>mergeOptions</code>除了规范检测后的逻辑。</p><pre><code class="js">function mergeOptions ( parent, child, vm ) &#123;  ···  var options = &#123;&#125;;  var key;  for (key in parent) &#123;    mergeField(key);  &#125;  for (key in child) &#123;    if (!hasOwn(parent, key)) &#123;      mergeField(key);    &#125;  &#125;  function mergeField (key) &#123;    // 如果有自定义选项策略，则使用自定义选项策略，否则选择使用默认策略。    var strat = strats[key] || defaultStrat;     options[key] = strat(parent[key], child[key], vm, key);  &#125;  return options&#125;</code></pre><p><strong>两个<code>for</code>循环规定了合并的顺序，以自定义选项策略优先，如果没有才会使用默认策略。而<code>strats</code>下每个<code>key</code>对应的便是每个特殊选项的合并策略</strong></p><h3 id="1-5-1-默认策略"><a href="#1-5-1-默认策略" class="headerlink" title="1.5.1 默认策略"></a>1.5.1 默认策略</h3><p>我们可以用丰富的选项去定义实例的行为，大致可以分为以下几类：</p><ol><li>用<code>data,props,computed</code>等选项定义实例数据</li><li>用<code>mounted, created, destoryed</code>等定义生命周期函数</li><li>用<code>components</code>注册组件</li><li>用<code>methods</code>选项定义实例方法</li></ol><p>当然还有诸如<code>watch,inject,directives,filter</code>等选项，总而言之，<code>Vue</code>提供的配置项是丰富的。除此之外，我们也可以使用没有默认配置策略的选项，典型的例子是状态管理<code>Vuex</code>和配套路由<code>vue-router</code>的引入：</p><pre><code class="js">new Vue(&#123;  store, // vuex  router// vue-router&#125;)</code></pre><p>不管是插件也好，还是用户自定义的选项，他们的合并策略会遵循思路的第二点：<strong>子配置存在则取子配置，不存在则取父配置，即用子去覆盖父。。</strong>它的描述在<code>defaultStrat</code>中。</p><pre><code class="js">// 用户自定义选项策略var defaultStrat = function (parentVal, childVal) &#123;  // 子不存在则用父，子存在则用子配置  return childVal === undefined    ? parentVal    : childVal&#125;;</code></pre><p>接下来会进入某些具体的合并策略的分析，大致分为五类：</p><p><strong>1. 常规选项合并</strong></p><p><strong>2. 自带资源选项合并</strong></p><p><strong>3. 生命周期钩子合并</strong></p><p><strong>4. <code>watch</code>选项合并</strong></p><p><strong>5. <code>props,methods, inject, computed</code>类似选项合并</strong></p><h2 id="1-6-常规选项的合并"><a href="#1-6-常规选项的合并" class="headerlink" title="1.6 常规选项的合并"></a>1.6 常规选项的合并</h2><h3 id="1-6-1-el的合并"><a href="#1-6-1-el的合并" class="headerlink" title="1.6.1 el的合并"></a>1.6.1 el的合并</h3><p><code>el</code>提供一个在页面上已存在的 <code>DOM</code> 元素作为 <code>Vue</code> 实例的挂载目标,因此它只在创建<code>Vue</code>实例才存在，在子类或者子组件中无法定义<code>el</code>选项，因此<code>el</code>的合并策略是在保证选项只存在于根的<code>Vue</code>实例的情形下使用默认策略进行合并。</p><pre><code class="js">strats.el = function (parent, child, vm, key) &#123;  if (!vm) &#123;  // 只允许vue实例才拥有el属性，其他子类构造器不允许有el属性    warn(      &quot;option \&quot;&quot; + key + &quot;\&quot; can only be used during instance &quot; +      &#39;creation with the `new` keyword.&#39;    );  &#125;  // 默认策略  return defaultStrat(parent, child)&#125;;</code></pre><h3 id="1-6-2-data合并"><a href="#1-6-2-data合并" class="headerlink" title="1.6.2 data合并"></a>1.6.2 data合并</h3><p>常规选项的重点部分是在于<code>data</code>的合并，读完这部分源码，可能可以解开你心中的一个疑惑，为什么<code>data</code>在<code>vue</code>创建实例时传递的是一个对象，而在组件内部定义时只能传递一个函数。</p><pre><code class="js">// data的合并strats.data = function (parentVal, childVal, vm) &#123;  // vm代表是否为Vue创建的实例，否则是子父类的关系  if (!vm) &#123;    if (childVal &amp;&amp; typeof childVal !== &#39;function&#39;) &#123; // 必须保证子类的data类型是一个函数而不是一个对象      warn(&#39;The &quot;data&quot; option should be a function &#39; + &#39;that returns a per-instance value in component &#39; + &#39;definitions.&#39;,vm);      return parentVal    &#125;    return mergeDataOrFn(parentVal, childVal)  &#125;  return mergeDataOrFn(parentVal, childVal, vm); // vue实例时需要传递vm作为函数的第三个参数&#125;;</code></pre><p><code>data</code>策略最终调用的<code>mergeDataOrFn</code>方法，区别在于当前<code>vm</code>是否是实例，或者是单纯的子父类的关系。如果是子父类的关系，需要对<code>data</code>选项进行规范校验，保证它的类型是一个函数而不是对象。</p><pre><code class="js">function mergeDataOrFn ( parentVal, childVal, vm ) &#123;  // 子父类  if (!vm) &#123;    if (!childVal) &#123; // 子类不存在data选项，则合并结果为父类data选项      return parentVal    &#125;    if (!parentVal) &#123; // 父类不存在data选项，则合并结果为子类data选项      return childVal    &#125;    return function mergedDataFn () &#123; // data选项在父类和子类同时存在的情况下返回的是一个函数      // 子类实例和父类实例，分别将子类和父类实例中data函数执行后返回的对象传递给mergeData函数做数据合并      return mergeData(        typeof childVal === &#39;function&#39; ? childVal.call(this, this) : childVal,        typeof parentVal === &#39;function&#39; ? parentVal.call(this, this) : parentVal      )    &#125;  &#125; else &#123;  // Vue实例    // vue构造函数实例对象    return function mergedInstanceDataFn () &#123;      var instanceData = typeof childVal === &#39;function&#39;        ? childVal.call(vm, vm)        : childVal;      var defaultData = typeof parentVal === &#39;function&#39;        ? parentVal.call(vm, vm)        : parentVal;      if (instanceData) &#123;        // 当实例中传递data选项时，将实例的data对象和Vm构造函数上的data属性选项合并        return mergeData(instanceData, defaultData)      &#125; else &#123;        // 当实例中不传递data时，默认返回Vm构造函数上的data属性选项        return defaultData      &#125;    &#125;  &#125;&#125;</code></pre><p>从源码的实现看，<code>data</code>的合并不是简单的将两个数据对象进行合并，而是直接返回一个<code>mergedDataFn</code>或者<code>mergedInstanceDataFn</code>函数，而真正合并的时机是在后续初始化数据响应式系统的环节进行的，初始化数据响应式系统的第一步就是拿到合并后的数据，也就是执行<code>mergeData</code>逻辑。<br>(关于响应式系统的构建请移步后面的章节)</p><pre><code class="js">function mergeData (to, from) &#123;  if (!from) &#123; return to &#125;  var key, toVal, fromVal;  // Reflect.ownKeys可以拿到Symbol属性  var keys = hasSymbol    ? Reflect.ownKeys(from)    : Object.keys(from);  for (var i = 0; i &lt; keys.length; i++) &#123;    key = keys[i];    toVal = to[key];    fromVal = from[key];    if (!hasOwn(to, key)) &#123;      // 子的数据父没有，则将新增的数据加入响应式系统中。      set(to, key, fromVal);     &#125; else if (      toVal !== fromVal &amp;&amp;      isPlainObject(toVal) &amp;&amp;      isPlainObject(fromVal)    ) &#123;      // 处理深层对象，当合并的数据为多层嵌套对象时，需要递归调用mergeData进行比较合并      mergeData(toVal, fromVal);    &#125;  &#125;  return to&#125;</code></pre><p><code>mergeData</code>方法的两个参数是父<code>data</code>选项和子<code>data</code>选项的结果，也就是两个<code>data</code>对象，从源码上看数据合并的原则是，将父类的数据整合到子类的数据选项中， 如若父类数据和子类数据冲突时，保留子类数据。如果对象有深层嵌套，则需要递归调用<code>mergeData</code>进行数据合并。</p><p>最后回过头来思考一个问题，为什么<code>Vue</code>组件的<code>data</code>是一个函数，而不是一个对象呢？<br>我觉得可以这样解释：<strong>组件设计的目的是为了复用，每次通过函数创建相当于在一个独立的内存空间中生成一个<code>data</code>的副本，这样每个组件之间的数据不会互相影响。</strong></p><h2 id="1-7-自带资源选项合并"><a href="#1-7-自带资源选项合并" class="headerlink" title="1.7 自带资源选项合并"></a>1.7 自带资源选项合并</h2><p>在1.2中我们看到了<code>Vue</code>默认会带几个选项，分别是<code>components</code>组件, <code>directive</code>指令, <code>filter</code>过滤器,所有无论是根实例，还是父子实例，都需要和系统自带的资源选项进行合并。它的定义如下：</p><pre><code class="js">// 资源选项var ASSET_TYPES = [  &#39;component&#39;,  &#39;directive&#39;,  &#39;filter&#39;];// 定义资源合并的策略ASSET_TYPES.forEach(function (type) &#123;  strats[type + &#39;s&#39;] = mergeAssets; // 定义默认策略&#125;);</code></pre><p>这些资源选项的合并逻辑很简单，首先会创建一个原型指向父类资源选项的空对象，再将子类选项赋值给空对象。</p><pre><code class="js">// 资源选项自定义合并策略function mergeAssets (parentVal,childVal,vm,key) &#123;  var res = Object.create(parentVal || null); // 创建一个空对象，其原型指向父类的资源选项。  if (childVal) &#123;    assertObjectType(key, childVal, vm); // components,filters,directives选项必须为对象    return extend(res, childVal) // 子类选项赋值给空对象  &#125; else &#123;    return res  &#125;&#125;</code></pre><p>结合下面的例子，我们看具体合并后的结果：</p><pre><code class="js">var vm = new Vue(&#123;  components: &#123;    componentA: &#123;&#125;  &#125;,  directives: &#123;    &#39;v-boom&#39;: &#123;&#125;  &#125;&#125;)console.log(vm.$options.components)// 根实例的选项和资源默认选项合并后的结果&#123;  components: &#123;    componentA: &#123;&#125;,    __proto__: &#123;      KeepAlive: &#123;&#125;      Transition: &#123;&#125;      TransitionGroup: &#123;&#125;    &#125;   &#125;,  directives: &#123;    &#39;v-boom&#39;: &#123;&#125;,    __proto__: &#123;      &#39;v-show&#39;: &#123;&#125;,      &#39;v-model&#39;: &#123;&#125;    &#125;  &#125;&#125;</code></pre><p>简单总结一下，对于 <code>directives、filters</code> 以及 <code>components</code> 等资源选项，父类选项将以原型链的形式被处理。子类必须通过原型链才能查找并使用内置组件和内置指令。</p><h2 id="1-8-生命周期钩子函数的合并"><a href="#1-8-生命周期钩子函数的合并" class="headerlink" title="1.8 生命周期钩子函数的合并"></a>1.8 生命周期钩子函数的合并</h2><p>在学习<code>Vue</code>时，有一个重要的思想，生命周期。它是我们使用<code>Vue</code>高效开发组件的基础，我们可以在组件实例的不同阶段去定义需要执行的函数，让组件的功能更加丰富。在介绍生命周期钩子函数的选项合并前，我们有必要复习以下官方的生命周期图。</p><p><img data-src="/images/img/1.1.png"></p><p>然而从源码中我们可以看到<code>Vue</code>的生命周期钩子不止这些，它有多达12个之多，每个钩子的执行时机我们暂且不深究，它们会在以后的章节中逐一出现。我们关心的是：子父组件的生命周期钩子函数是遵循什么样的规则合并。</p><pre><code class="js">var LIFECYCLE_HOOKS = [  &#39;beforeCreate&#39;,  &#39;created&#39;,  &#39;beforeMount&#39;,  &#39;mounted&#39;,  &#39;beforeUpdate&#39;,  &#39;updated&#39;,  &#39;beforeDestroy&#39;,  &#39;destroyed&#39;,  &#39;activated&#39;,  &#39;deactivated&#39;,  &#39;errorCaptured&#39;,  &#39;serverPrefetch&#39;];LIFECYCLE_HOOKS.forEach(function (hook) &#123;  strats[hook] = mergeHook; // 对生命周期钩子选项的合并都执行mergeHook策略&#125;);</code></pre><p><code>mergeHook</code>是生命周期钩子合并的策略，简单的对代码进行总结，钩子函数的合并原则是：</p><ol><li>如果子类和父类都拥有相同钩子选项，则将子类选项和父类选项合并。</li><li>如果父类不存在钩子选项，子类存在时，则以数组形式返回子类钩子选项。</li><li>当子类不存在钩子选项时，则以父类选项返回。</li><li>子父合并时，是将子类选项放在数组的末尾，这样在执行钩子时，永远是父类选项优先于子类选项执行。</li></ol><pre><code class="js">// 生命周期钩子选项合并策略function mergeHook (    parentVal,    childVal  ) &#123;    // 1.如果子类和父类都拥有钩子选项，则将子类选项和父类选项合并,     // 2.如果父类不存在钩子选项，子类存在时，则以数组形式返回子类钩子选项，    // 3.当子类不存在钩子选项时，则以父类选项返回。    var res = childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;     return res      ? dedupeHooks(res)      : res  &#125;// 防止多个组件实例钩子选项相互影响  function dedupeHooks (hooks) &#123;    var res = [];    for (var i = 0; i &lt; hooks.length; i++) &#123;      if (res.indexOf(hooks[i]) === -1) &#123;        res.push(hooks[i]);      &#125;    &#125;    return res  &#125;</code></pre><p>下面结合具体的例子看合并结果。</p><pre><code class="js">var Parent = Vue.extend(&#123;  mounted() &#123;    console.log(&#39;parent&#39;)  &#125;&#125;)var Child = Parent.extend(&#123;  mounted() &#123;    console.log(&#39;child&#39;)  &#125;&#125;)var vm = new Child().$mount(&#39;#app&#39;);// 输出结果：parentchild</code></pre><p>简单总结一下：<strong>对于生命周期钩子选项，子类和父类相同的选项将合并成数组，这样在执行子类钩子函数时，父类钩子选项也会执行，并且父会优先于子执行。</strong></p><h2 id="1-9-watch选项合并"><a href="#1-9-watch选项合并" class="headerlink" title="1.9 watch选项合并"></a>1.9 watch选项合并</h2><p>在使用<code>Vue</code>进行开发时，我们有时需要自定义侦听器来响应数据的变化，当需要在数据变化时执行异步或者开销较大的操作时，<code>watch</code>往往是高效的。对于 <code>watch</code> 选项的合并处理，它类似于生命周期钩子，只要父选项有相同的观测字段，则和子的选项合并为数组，在监测字段改变时同时执行父类选项的监听代码。处理方式和生命钩子选项的区别在于，生命周期钩子选项必须是函数，而<code>watch</code>选项最终在合并的数组中可以是包含选项的对象，也可以是对应的回调函数，或者方法名。</p><pre><code class="js">strats.watch = function (parentVal,childVal,vm,key) &#123;    //火狐浏览器在Object的原型上拥有watch方法，这里对这一现象做了兼容    // var nativeWatch = (&#123;&#125;).watch;    if (parentVal === nativeWatch) &#123; parentVal = undefined; &#125;    if (childVal === nativeWatch) &#123; childVal = undefined; &#125;    // 没有子，则默认用父选项    if (!childVal) &#123; return Object.create(parentVal || null) &#125;    &#123;      // 保证watch选项是一个对象      assertObjectType(key, childVal, vm);    &#125;    // 没有父则直接用子选项    if (!parentVal) &#123; return childVal &#125;    var ret = &#123;&#125;;    extend(ret, parentVal);    for (var key$1 in childVal) &#123;      var parent = ret[key$1];      var child = childVal[key$1];      // 父的选项先转换成数组      if (parent &amp;&amp; !Array.isArray(parent)) &#123;        parent = [parent];      &#125;      ret[key$1] = parent        ? parent.concat(child)        : Array.isArray(child) ? child : [child];    &#125;    return ret  &#125;;</code></pre><p>下面结合具体的例子看合并结果：</p><pre><code class="js">var Parent = Vue.extend(&#123;  watch: &#123;    &#39;test&#39;: function() &#123;      console.log(&#39;parent change&#39;)    &#125;  &#125;&#125;)var Child = Parent.extend(&#123;  watch: &#123;    &#39;test&#39;: &#123;      handler: function() &#123;        console.log(&#39;child change&#39;)      &#125;    &#125;  &#125;,  data() &#123;    return &#123;      test: 1    &#125;  &#125;&#125;)var vm = new Child().$mount(&#39;#app&#39;);vm.test = 2;// 输出结果parent changechild change</code></pre><p>简单总结一下：<strong>对于watch选项的合并，最终和父类选项合并成数组，并且数组的选项成员，可以是回调函数，选项对象，或者函数名。</strong></p><h2 id="1-10-props-methods-inject-computed合并"><a href="#1-10-props-methods-inject-computed合并" class="headerlink" title="1.10 props methods inject computed合并"></a>1.10 props methods inject computed合并</h2><p>源码的设计将<code>props.methods,inject,computed</code>归结为一类，他们的配置策略一致，简单概括就是，如果父类不存在选项，则返回子类选项，子类父类都存在时，用子类选项去覆盖父类选项。</p><pre><code class="js">// 其他选项合并策略strats.props =strats.methods =strats.inject =strats.computed = function (parentVal,childVal,vm,key) &#123;  if (childVal &amp;&amp; &quot;development&quot; !== &#39;production&#39;) &#123;    assertObjectType(key, childVal, vm);  &#125;  if (!parentVal) &#123; return childVal &#125; // 父类不存在该选项，则返回子类的选项  var ret = Object.create(null);  extend(ret, parentVal); //   if (childVal) &#123;     // 子类选项会覆盖父类选项的值    extend(ret, childVal); &#125;   return ret&#125;;</code></pre><h2 id="1-11-小结"><a href="#1-11-小结" class="headerlink" title="1.11 小结"></a>1.11 小结</h2><p>至此，五类选项合并的策略分析到此结束，回顾一下这一章节的内容，这一节是<code>Vue</code>源码分析的起手式，所以我们从<code>Vue</code>的引入出发，先大致了解了<code>Vue</code>在代码引入阶段做的操作，主要是对静态属性方法和原型上属性方法的定义和声明，这里并不需要精确了解到每个方法的功能和实现细节，当然我也相信你已经在实战中或多或少接触过这些方法的使用。接下来到文章的重点，<code>new Vue</code>是我们正确使用<code>Vue</code>进行开发的关键，而实例化阶段会对调用<code>_init</code>方法进行初始化，选项合并是初始化的第一步。选项合并会对系统内部定义的选项和子父类的选项进行合并。而<code>Vue</code>有相当丰富的选项合并策略，不管是内部的选项还是用户自定义的选项，他们都遵循内部约定好的合并策略。有了丰富的选项和严格的合并策略，<code>Vue</code>在指导开发上才显得更加完备。下一节会分析一个重要的概念，数据代理，它也是响应式系统的基础。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> Vue </category>
          
          <category> vue2.x源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3.x常用基础</title>
      <link href="/front-end/vue3.x%E5%B8%B8%E7%94%A8%E5%9F%BA%E7%A1%80/"/>
      <url>/front-end/vue3.x%E5%B8%B8%E7%94%A8%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue3扩展"><a href="#Vue3扩展" class="headerlink" title="Vue3扩展"></a>Vue3扩展</h1><h2 id="VUE3简介"><a href="#VUE3简介" class="headerlink" title="VUE3简介"></a>VUE3简介</h2><ul><li>2020年9月18日，Vue.js发布3.0版本，代号 One Piece(海贼王)</li></ul><h2 id="Vue3带来了什么"><a href="#Vue3带来了什么" class="headerlink" title="Vue3带来了什么"></a>Vue3带来了什么</h2><ol><li>响应性系统使用了 Proxy 对象，提升了性能和功能。</li><li>引入了组合式 API，更灵活地组织和重用组件逻辑。</li><li>虚拟 DOM 重写，优化了渲染性能。</li><li>减小了包体积，采用模块化方式加载功能。</li><li>提供原生的 TypeScript 支持，增强了类型推导和编辑器支持。</li><li>引入了 Fragments（片段），允许返回多个根元素。</li><li>新增 Teleport（传送）组件，可以在页面上任意位置渲染组件内容。</li><li>提供更好的自定义渲染器 API，增强了底层渲染层交互。</li><li>性能优化，包括更高效的更新机制、更小的包体积和更快的渲染速度。</li></ol><h2 id="创建Vue3-0工程"><a href="#创建Vue3-0工程" class="headerlink" title="创建Vue3.0工程"></a>创建Vue3.0工程</h2><h3 id="使用vue-cli创建"><a href="#使用vue-cli创建" class="headerlink" title="使用vue-cli创建"></a>使用vue-cli创建</h3><pre><code class="javascript">## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上vue --version  或者 vue -V## 安装或者升级你的@vue/clinpm install -g @vue/cli## 创建vue create vue-text   /或者使用 node自带的(如果升级不了@vue/cli)    npx @vue/cli create my-app## 启动cd vue-textnpm run serve</code></pre><h3 id="使用vite创建"><a href="#使用vite创建" class="headerlink" title="使用vite创建"></a>使用vite创建</h3><pre><code class="javascript">## 什么是vite?   新一代前端构建工具## 优势1.开发环境中,无需打包操作，可快速的冷启动2.轻量快速的热重载(HMR)3.真正的按需编译，不再等待整个应用编译完成## 创建工程npm init  vite-app &lt;project-name&gt;## 进入工程目录cd &lt;project-name&gt;## 安装依赖npm install## 运行npm run dev</code></pre><h2 id="常用的Composition-API"><a href="#常用的Composition-API" class="headerlink" title="常用的Composition API"></a>常用的Composition API</h2><h3 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h3><ol><li>理解：vue3.0中的一个新的配置项。值为一个函数setup是所有Composition API(组合api) “表演的舞台”组件中所有用到的：数据，方法等等。均要配置在setup中</li><li>setup函数的两种返回值：<ul><li>若返回一个对象，则对象中的属性，方法，在模板中直接使用</li></ul></li></ol><ul><li>若返回画一个渲染函数，则可以自定义渲染内容(了解即可)</li></ul><ol start="3"><li>注意点:<ul><li>尽量不要与Vue2.x配置混用</li><li>但在setup中不能访问到Vue2.x配置(data,methsds,computed…)</li><li>如果重名，setup优先</li></ul></li><li>使用 <code>&lt;script setup&gt;</code> 语法糖 和不使用有一些本质区别：</li></ol><ul><li>Composition API： <code>&lt;script setup&gt;</code> 是 Vue 3 中引入的一个新特性，它基于 Composition API。使用 <code>&lt;script setup&gt;</code> 可以更方便地编写组件逻辑。你可以在 <code>&lt;script setup&gt;</code> 中使用 defineProps、defineEmits 和 withDefaults 等函数来定义组件的属性、事件和默认值。</li><li>单文件组件 (SFC) 的简化： <code>&lt;script setup&gt;</code> 可以让你在单个 <code>&lt;script&gt;</code> 标签中同时编写模板和脚本，从而简化了单文件组件的结构。你不再需要显式导入和设置组件选项，只需编写组件的模板和逻辑代码即可。</li><li>更好的错误提示：使用 <code>&lt;script setup&gt;</code> 可以提供更好的错误提示。由于模板和逻辑代码都在同一个上下文中编写，Vue 3 可以更准确地报告出错的位置和原因，从而帮助你更快地调试和修复问题。</li><li>也有一些限制<ol><li>生命周期钩子：在 <code>&lt;script setup&gt;</code> 中，无法直接使用传统的生命周期钩子函数（如 created、mounted 等），因为它们与 Composition API 的方式不兼容。相反，你可以使用 onMounted、onUpdated 和 onUnmounted 等 Composition API 提供的函数来实现类似的功能。</li><li>this 上下文：<code>&lt;script setup&gt;</code> 中没有访问 this 上下文的方式。如果你需要访问组件实例上的属性或方法，可以使用 getCurrentInstance() 函数来获取当前的组件实例。</li></ol></li></ul><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><ol><li>作用：定义一个响应式的数据</li><li>语法 ： const xxx &#x3D; ref(initValue)<ol><li>创建一个响应式的数据的引用对象</li></ol><ul><li>js 中需要 使用 .value 修改数据</li><li>模板中读取数据：不需要  .value  直接 <code>&lt;div&gt;&#123;&#123;xxx&#125;&#125;&lt;div/&gt;</code></li></ul></li><li>备注：<ol><li>接收数据可以是基本类型，也可以是对象类型</li></ol><ul><li>基本类型的数据：响应式依然是靠Object.defineProperty() 的get和set</li><li>对象类型的数据：内部求助了Vue3.0中的一个新的函数  - reactive</li></ul></li></ol><h3 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h3><ol><li>作用：定义一个对象类型的响应式数据(基本类型别用它，用ref函数)</li><li>语法 const 代理对象  &#x3D; reactive(被代理对象)接收一个对象或者数组,返回一个代理器对象(proxy对象)</li><li>reactive定义的响应数据是深层次的</li><li>内部基于ES6的proxy，通过代理对象对原数据内部数据都是响应式的</li></ol><h3 id="ref和reactive本质使用区别"><a href="#ref和reactive本质使用区别" class="headerlink" title="ref和reactive本质使用区别"></a>ref和reactive本质使用区别</h3><ol><li><p>ref: ref 函数用于创建一个包装器对象，将普通的数据类型（如基本类型、对象）转换为响应式数据。这个包装器对象具有 value 属性，该属性保存着实际的数据值。当对 ref 包装器对象进行访问和修改时，实际上是通过操作 value 属性来实现的。这意味着你需要通过 .value 来访问和修改 ref 包装器对象中的数据。</p></li><li><p>reactive: reactive 函数用于将普通对象转换为响应式对象。在内部，reactive 函数会使用 Proxy 对象对原始对象进行代理，从而追踪对对象的访问和修改。这样，当对响应式对象进行访问和修改时，Vue 会自动检测到并触发相应的更新。与 ref 不同的是，你可以直接访问和修改 reactive 对象中的属性，而不需要使用 .value。</p></li><li><p>其实就是reactive 直接修改对象，而ref需要 <code>.value</code></p></li></ol><h1 id="vue3-X脚手架相关"><a href="#vue3-X脚手架相关" class="headerlink" title="vue3.X脚手架相关"></a>vue3.X脚手架相关</h1><h2 id="文件的作用"><a href="#文件的作用" class="headerlink" title="文件的作用"></a>文件的作用</h2><pre><code class="javascript">/** * shims-vue.d.ts的作用 * 为了 typescript 做的适配定义文件，因为.vue 文件不是一个常规的文件类型，ts 是不能理解 vue 文件是干嘛的， * 加这一段是是告诉 ts，vue 文件是这种类型的。 * 可以把这一段删除，会发现 import 的所有 vue 类型的文件都会报错。 */declare module &#39;*.vue&#39; &#123; //declare声明宣告， 声明一个ambient module(即:没有内部实现的 module声明)   import Vue from &#39;vue&#39;  export default Vue&#125;declare module &#39;vue-echarts&#39;  // 引入vue-echarts&lt;script lang=&quot;ts&quot;&gt;    /* eslint-disable @typescript-eslint/camelcase */    import &#123; Vue, Component, Watch &#125; from &#39;vue-property-decorator&#39;    import ECharts from &#39;vue-echarts&#39; //报错,按上面的方法在shims-vue.d.ts文件中引入即可    import &#39;echarts/lib/chart/line&#39;    import &#39;echarts/lib/chart/pie&#39;    import &#39;echarts/lib/component/tooltip&#39;&lt;/script&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue2.x常用基础</title>
      <link href="/front-end/vue2.x%E5%B8%B8%E7%94%A8%E5%9F%BA%E7%A1%80/"/>
      <url>/front-end/vue2.x%E5%B8%B8%E7%94%A8%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue基础"><a href="#Vue基础" class="headerlink" title="Vue基础"></a>Vue基础</h1><h2 id="vue生命周期和生命周期钩子函数"><a href="#vue生命周期和生命周期钩子函数" class="headerlink" title="vue生命周期和生命周期钩子函数"></a>vue生命周期和生命周期钩子函数</h2><p><strong>beforecreated</strong>：在实例初始化之后，el 和 data 并未初始化（这个时期，this变量还不能使用，在data下的数据，和methods下的方法，watcher中的事件都不能获得到；）<br><strong>created</strong>:完成了 data 数据的初始化，el没有（这个时候可以操作vue实例中的数据和各种方法，但是还不能对”dom”节点进行操作；）<br><strong>beforeMount</strong>：完成了 el 和 data 初始化这里的el是虚拟的dom；<br><strong>mounted</strong> ：完成挂载，在这发起后端请求，拿回数据，配合路由钩子做一些事情（挂载完毕，这时dom节点被渲染到文档内，一些需要dom的操作在此时才能正常进行），定义定时器</p><p>以下2个生命其实对应的是vue数据发生更新的时候，操作虚拟dom更新为真实dom的2个钩子<br><strong>beforeUpdate</strong>：数据是新的，但是页面是旧的(此时虚拟 DOM 已经更新，但尚未应用到真实的 DOM 上)<br><strong>update</strong>：数据和页面保持同步了，(此时虚拟 DOM 已经更新，并且已经应用到真实的 DOM 上)</p><p><strong>beforeDestory</strong>：你确认删除定时器吗？<br><strong>destoryed</strong> ：当前组件已被删除，(其实就是页面的退出)</p><p><strong>activated</strong>：keep-alive 专属，组件被激活时调用<br><strong>deactivated</strong>：keep-alive 专属，组件失效时调用</p><p><strong>A、什么是vue生命周期？</strong><br>Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。<br><strong>B、vue生命周期的作用是什么？</strong><br>它的生命周期有多个事件钩子,让我们在控制整个Vue实例的过程时更容易形成好的逻辑。<br><strong>C、vue生命周期总共有几个阶段？</strong><br>它可以总共分为8个阶段：创建前&#x2F;后, 载入前&#x2F;后,更新前&#x2F;后,销毁前&#x2F;销毁后<br><strong>D、第一次页面加载会触发哪几个钩子？</strong><br>第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子<br><strong>E、DOM 渲染在 哪个周期中就已经完成？</strong><br>DOM 渲染在 mounted 中就已经完成了。<br><strong>F、简单描述每个周期具体适合哪些场景？</strong></p><ol><li>beforecreate:可以在加个loading事件，在加载实例是触发</li><li>created:初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用</li><li>mounted:异步请求，启动定时器，绑定自定义事件，订阅消息（这里的异步请求可能会触发重绘回流，所以性能没有在created好）</li><li>updated:执行与数据更新相关的任务，例如响应式数据的重新渲染、DOM 操作或集成第三方库（mounted只会触发一次，它可以无数次）</li><li>beforeDestroy:清除定时器，解绑自定义事件，取消订阅,一般不再这里在操作数据，即使操作了，页面也不会更新了</li></ol><h2 id="vue-生命周期执行顺序-父子组件"><a href="#vue-生命周期执行顺序-父子组件" class="headerlink" title="vue 生命周期执行顺序(父子组件)"></a>vue 生命周期执行顺序(父子组件)</h2><ol><li><p>加载渲染过程：<br>父beforecreate -&gt; 父created -&gt; 父beforemount -&gt; 父mounted -&gt; 子created -&gt; 子beforemount<br>-&gt;  子mounted -&gt; 父mounted</p></li><li><p>子组件更新过程：<br>父beforeUpdate -&gt; 子beforeUpdate -&gt; 子updated -&gt; 父updated</p></li><li><p>父组件更新过程：<br>父beforeUpdate -&gt; 父updated</p></li><li><p>销毁过程：<br>父beforedestroy -&gt; 子beforedestroy -&gt; 子destroy  -&gt; 父destroy</p></li></ol><p> 拓展:如果有缓存keep-alive。那么还会触发actived钩子，退出时触发deactived。后续再进入只会触发actived钩子了。所以说频繁触发的函数放在active里面，执行一次的放在mounted里面。</p><p>父子组件生命周期的触发顺序是:参考洋葱模型。</p><p>先是父组件的生命周期beforecreate，created，beforemount，子组件beforecreate，created，beforemount，子组件的mounted，父组件的mounted。因为要再父组件渲染前把子组件的数据渲染到父组件里面，所以在父组件dom挂载前mounted渲染前，先加载子组件的生命周期。</p><h2 id="v-show与v-if的区别"><a href="#v-show与v-if的区别" class="headerlink" title="v-show与v-if的区别"></a>v-show与v-if的区别</h2><p>v-show是css切换，v-if是完整的销毁和重新创建<br>使用频繁切换时用v-show,运行时较少改变时用v-if<br>V-if&#x3D;’false’v-if是条件渲染，当false的时候不会渲染<br>使用v-if的时候，如果值为false，那么页面将不会有这个html标签生成<br>v-show则是不管值是为true还是false，html元素都会存在，只是css中的display显示或隐藏<br>v-show 仅仅控制元素的显示方式，将 display 属性在 block 和 none 来回切换；而v-if会控制这个 DOM 节点的存在与否。当我们需要经常切换某个元素的显示&#x2F;隐藏时，使用v-show会更加节省性能上的开销；当只需要一次显示或隐藏时，使用v-if更加合理。</p><h2 id="开发中常用的指令"><a href="#开发中常用的指令" class="headerlink" title="开发中常用的指令"></a>开发中常用的指令</h2><p>v-model:一般用在表达输入，很轻松的实现表单控件和数据的双向绑定</p><pre><code class="javascript">v-html：更新元素的innerHTML&lt;p v-html=&quot;msg&quot;&gt;&lt;/p&gt;new Vue(&#123;    el : &quot;#app&quot;,    data : &#123;        msg : &quot;&lt;h1&gt;这是一个h1元素内容&lt;/h1&gt;&quot;    &#125;&#125;);</code></pre><p>v-show与v-if：条件渲染，注意二者区别<br>v-on:click:可以简写为@click,@绑定一个事件。如果事件触发了，就可以指定事件的处理函数<br>v-for：基于源数据多次渲染元素或模板<br>v-bind:当表达式的值改变时，将其产生的连带影响，响应式地作用于DOM语法<br>v-bind:title&#x3D;”msg”简写： :title&#x3D;”msg”</p><pre><code class="javascript">v-clock解决页面闪烁问题如果网速慢，而该标签内容是变量没有请求响应回来的时候，页面上先不显示该标签（vue给该标签加了css样式），当响应回来的时候改标签默认将css样式去除。此指令可以解决使用插值表达式页面闪烁问题将该指令加在html标签中时，可以在该文件中加style属性为display：none，例子如下：&lt;div class=&quot;#app&quot; v-cloak&gt;    &lt;p&gt;&#123;&#123;name&#125;&#125;&lt;/p&gt;&lt;/div&gt;[v-cloak] &#123;    display: none;&#125;</code></pre><h2 id="绑定class的数组用法"><a href="#绑定class的数组用法" class="headerlink" title="绑定class的数组用法"></a>绑定class的数组用法</h2><pre><code class="javascript">1.对象方法:class=&quot;&#123;&#39;orange&#39;:isRipe, &#39;green&#39;:isNotRipe&#125;&quot;:class=&quot;tindex == index ? &#39;aaa&#39;:&#39;bbb&#39;&quot;2.数组方法:class=&quot;[class1,class2]&quot;3.行内:style=&quot;&#123;color:color,fontSize:fontSize+&#39;px&#39;&#125;&quot;</code></pre><h2 id="计算属性和methods"><a href="#计算属性和methods" class="headerlink" title="计算属性和methods"></a>计算属性和methods</h2><pre><code class="javascript">computed:&#123;    fullName:&#123;        //get有什么作用? 当有人读取实例(data)上的数据时候,get就会被调用，返回值可以是data上的值        //get什么时候调用? 1.初次读取时，2.所依赖的数据发生变化的时候        get()&#123;  //fullName被读取时调用            return this.firstName        &#125;,        //set什么时候调用? 当fullName被修改时        set(value)&#123;//fullName被修改时调用                 //非必须写            console.log(&#39;修改fullName后的值&#39;,value)        &#125;    &#125;    //简写方式    fullNamejianxie()&#123;        return this.firstName  + &#39;jianxie&#39;    &#125;&#125;1.定义:要用的属性存在，要通过已有的属性计算而来2.计算属性的底层借助Object.defineProperty()方法提供gettter/setter3.get函数什么时候调用?   (1).初次读取时     (2).所依赖的数据发生变化的时4.优势:与methods实现相比，内部有缓存机制(复用),效率更高,调试方便5.备注:     (1).计算属性最终会出现在vm(实例)上，直接读取即可     (2).如果计算属性被修改，那必须写set去响应数据，且set中要引起计算时依赖的数据发送变化</code></pre><h2 id="computed-计算属性-和watch-监听-的对比"><a href="#computed-计算属性-和watch-监听-的对比" class="headerlink" title="computed(计算属性)和watch(监听)的对比"></a>computed(计算属性)和watch(监听)的对比</h2><p><strong>computed</strong></p><pre><code class="javascript">computed是计算属性，也就是计算值，它更多用于计算值的场景computed具有缓存性，computed的值在getter执行后是会缓存的，只有在它依赖的属性值改变之后，下一次获取computed的值时重新调用对应的getter来计算computed适用于计算比较消耗性能的计算场景</code></pre><p><strong>watch</strong></p><pre><code class="javascript">&lt;template&gt;    &lt;div class=&quot;container&quot;&gt;        &lt;!-- 1.监听实例上的基础数据类型 --&gt;        &lt;button @click=&quot;isHot = !isHot&quot;&gt;&#123;&#123;isHot&#125;&#125;&lt;/button&gt;        &lt;hr&gt;        &lt;!-- 2.监听引用类型的数据 --&gt;        &lt;button @click=&quot;obj.age++&quot;&gt;&#123;&#123;obj.age&#125;&#125;&lt;/button&gt;                &lt;hr&gt;        &lt;!-- 3.修改对象类型的数据变成字符串 --&gt;        &lt;button @click=&quot;obj = &#39;变成其他数据类型了&#39;&quot;&gt;&#123;&#123;obj&#125;&#125;&lt;/button&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        name: &#39;index&#39;,        data() &#123;            return &#123;                isHot : true,                obj :&#123;                    name: &#39;js&#39;,                    age : 18                &#125;               &#125;        &#125;,        watch:&#123;            isHot:&#123;                immediate : true, //初始化的时候，让handler调用一下                handler(newValue,oldValue)&#123; //handle什么时候调用? isHot发送变化时候                    console.log(&#39;isHot被修改了&#39;,newValue,oldValue)                &#125;            &#125;,            // &#39;obj.age&#39; :&#123;             //      handler(newValue,oldValue)&#123;             //         console.log(&#39;age被修改了&#39;,newValue,oldValue)            //     &#125;            //      //监视多级结构中某个属性的变化(不建议这么写，如果有很多个值呢？)            // &#125;,            // obj:&#123;            //     //这么写即使是age的值发送改变，也不会有任何操作。            //     //因为此时监视的是 obj下的整个对象,除非对象变成其他类型的数据才会触发            //     handler(newValue,oldValue)&#123;             //         console.log(&#39;obj被修改了&#39;,newValue,oldValue)            //     &#125;            // &#125;,            obj:&#123;                //深度监视                 //不管是obj的数据类型变了，还是里面的值变了                deep : true,                handler(newValue,oldValue)&#123;                      console.log(&#39;obj被修改了&#39;,newValue,oldValue)                &#125;            &#125;,            // 简写方式 =&gt;            // 什么时候的时候才能简写?   只需要用到handler的时候            isHot(newValue,oldValue)&#123;                console.log(&#39;isHot被修改了&#39;,newValue,oldValue)              &#125;        &#125;    &#125;&lt;/script&gt;&lt;style lang=&quot;less&quot;&gt;        .container&#123;            width: 100VW;            height: 100VH;        &#125;&lt;/style&gt;1.watch可以监听异步任务,计算属性无法开启异步任务&lt;template&gt;  &lt;div class=&quot;container&quot;&gt;    &lt;button @click=&quot;obj = &#39;变成其他数据类型了&#39;&quot;&gt;&#123;&#123; obj &#125;&#125;&lt;/button&gt;    &lt;div&gt;      &#123;&#123; ahhh &#125;&#125;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &quot;index&quot;,  data() &#123;    return &#123;      ahhh: 1,      obj: &#123;        name: &quot;js&quot;,        age: 18,      &#125;,    &#125;;  &#125;,  watch: &#123;    obj: &#123;      deep: true,      handler(newValue, oldValue) &#123;        console.log(&quot;obj被修改了&quot;, newValue, oldValue);        setTimeout(() =&gt; &#123;              //这里注意要用箭头函数(this会一层一层往外找)，不能使用普通函数（this执行windows）            //开启异步任务          console.log(&quot;this&quot;, this);          this.ahhh += 1;        &#125;, 1000);      &#125;,    &#125;,  &#125;,&#125;;&lt;/script&gt;&lt;style lang=&quot;less&quot;&gt;.container &#123;  width: 100vw;  height: 100vh;&#125;&lt;/style&gt;</code></pre><h2 id="vue组件的scoped属性的作用"><a href="#vue组件的scoped属性的作用" class="headerlink" title="vue组件的scoped属性的作用"></a>vue组件的scoped属性的作用</h2><p>在style标签上添加scoped属性，以表示它的样式作用于当下的模块，很好的实现了样式私有化的目的；<br>但是也得慎用：样式不易（可）修改，而很多时候，我们是需要对公共组件的样式做微调的；</p><p><strong>解决办法：</strong></p><pre><code class="javascript">①：使用混合型的css样式：（混合使用全局跟本地的样式） &lt;style&gt; /* 全局样式 */ &lt;/style&gt;&lt;style scoped&gt; /* 本地样式 */ &lt;/style&gt;②：深度作用选择器（&gt;&gt;&gt;）如果你希望 scoped 样式中的一个选择器能够作用得“更深”，例如影响子组件，你可以使用 &gt;&gt;&gt; 操作符：&lt;style scoped&gt;    .a &gt;&gt;&gt; .b &#123; /* ... */ &#125; &lt;/style&gt;</code></pre><h2 id="vue常用修饰符"><a href="#vue常用修饰符" class="headerlink" title="vue常用修饰符"></a>vue常用修饰符</h2><p><strong>修饰符分为：一般修饰符，事件修身符，按键、系统</strong></p><p><strong>①一般修饰符</strong></p><ol><li><p>.lazy：v-model 在每次 input 事件触发后将输入框的值与数据进行同步 。你可以添加 lazy 修饰符，从而转变为使用 change 事件进行同步</p><input v-model.lazy="msg" > </li><li><p>.number：将用户输入的内容转换为数字类型</p><input v-model.number="age" type="number"></li><li><p>.trim：如果要自动过滤用户输入的首尾空白字符</p><input v-model.trim='trim'></li></ol><p><strong>② 事件修饰符</strong></p><pre><code class="javascript">1. 阻止单击事件继续传播 &lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;  2.提交事件不再重载页面&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt; 3.添加事件监听器时使用事件捕获模式(即元素自身触发的事件先在此处处理，然后才交由内部元素进行处理)&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;   4.只当在 event.target 是当前元素自身时触发处理函数(即事件不是从内部元素触发的)&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt; 5.点击事件将只会触发一次 &lt;a v-on:click.once=&quot;doThis&quot;&gt;&lt;/a&gt;  6.vue组件添加事件&lt;Tabber @click.native=&quot;doThis&quot;&gt;&lt;/Tabbar&gt; 7.修饰符可以串联&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt; </code></pre><p><strong>③按键修饰符</strong></p><p>.enter<br>.tab<br>.delete (捕获“删除”和“退格”键)<br>.esc<br>.space<br>.up<br>.down<br>.left<br>.right<br>.ctrl<br>.alt<br>.shift<br>.meta<br><input v-on:keyup.enter="submit"> 或者 &lt;input @keyup.enter&#x3D;”submit”&gt;</p><p><strong>④系统修饰键 （可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器）</strong></p><p>.ctrl<br>.alt<br>.shift<br>.meta<br>&lt;input @keyup.alt.67&#x3D;”clear”&gt; 或者 &lt;div @click.ctrl&#x3D;”doSomething”&gt;Do something</div><!-- Ctrl + Click --></p><p><strong>⑤特殊修饰符</strong></p><p>.sync: 用于实现父组件与子组件之间的双向数据绑定<br><child-component :value.sync="parentValue"></child-component></p><pre><code class="text">子组件更新父组件的数据：当在一个子组件中需要修改父组件的数据时，可以使用 v-model 的 sync 修饰符。通过在子组件中使用 v-model:sync 绑定一个父组件的属性，子组件可以直接修改该属性的值，并且父组件中对应的数据也会更新。子组件和父组件之间的双向绑定：有时候我们需要在父组件和子组件之间实现双向数据绑定，即当子组件的值改变时，父组件的数据也要随之更新，反之亦然。在这种情况下，可以使用 v-model 的 sync 修饰符实现双向绑定。状态管理库的双向数据绑定：如果你在 Vue.js 项目中使用了像 Vuex 这样的状态管理库，你可能希望能够在组件中实现双向数据绑定到 Vuex 的状态。使用 v-model 的 sync 修饰符可以帮助你实现与 Vuex 状态之间的便捷双向数据绑定。</code></pre><h2 id="v-on可以监听多个事件处理吗？（可以的）"><a href="#v-on可以监听多个事件处理吗？（可以的）" class="headerlink" title="v-on可以监听多个事件处理吗？（可以的）"></a>v-on可以监听多个事件处理吗？（可以的）</h2><p>一个元素绑定多个事件的两种写法，一个事件绑定多个函数的两种写法，修饰符的使用。</p><pre><code class="js">&lt;a style=&quot;cursor:default&quot; v-on=&#39;&#123;click:DoSomething,mouseleave:MouseLeave&#125;&#39;&gt;doSomething&lt;/a&gt;</code></pre><p>在method方法里面分别写两个事件；</p><pre><code class="js">&lt;button @click=&quot;a(),b()&quot;&gt;点我ab&lt;/button&gt;</code></pre><h2 id="vue事件中使用event对象"><a href="#vue事件中使用event对象" class="headerlink" title="vue事件中使用event对象"></a>vue事件中使用event对象</h2><pre><code class="js">&lt;template&gt;    //不加括号的的时候，直接拿到event对象&lt;button @click=&quot;btn&quot;&gt;点击&lt;/button&gt;  &lt;/template&gt;btn(event)&#123;    console.log(&#39;event&#39;,event)&#125;//现在的需求是点击事件直接传值过来，但是也要event对象&lt;template&gt;    //加了括号&lt;button @click=&quot;btn($event,1,2)&quot;&gt;点击&lt;/button&gt;  &lt;/template&gt;btn(event,...a)&#123;    console.log(&#39;event&#39;,event)    console.log(&#39;a&#39;,a)  // [1,2]&#125;</code></pre><h2 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h2><ol><li>语法：<code>this.$nextTick(回调函数)</code></li><li>nextTick 的使用场景包括</li></ol><ul><li>在修改数据后，想要立即基于更新后的视图进行操作。</li><li>在 Vue 生命周期钩子函数中，想要等待视图更新完成后执行其他逻辑。</li><li>在使用 $refs 访问组件实例或原生 DOM 元素时，想要确保能够访问到正确的实例或元素。</li></ul><ol start="3"><li>执行原理(简单来说，nextTick 方法会延迟执行回调函数，等待当前代码块执行完成并进入下一个 DOM 更新循环时，再执行回调函数。这样可以确保在回调函数中访问到最新的 DOM 状态。)</li></ol><ul><li>当你调用 nextTick(callback) 方法时，Vue 会将这个回调函数添加到一个队列中，而不是立即执行它。</li><li>在当前 JavaScript 执行的上下文中，Vue 会尽可能快地执行队列中的所有回调函数。</li><li>在执行完成当前 JavaScript 执行上下文后（即完成当前代码片段的执行），Vue 会开始执行下一个 DOM 更新循环。</li><li>在下一个 DOM 更新循环开始时，Vue 会清空队列，并按照添加的顺序依次执行队列中的回调函数。</li></ul><pre><code class="js">比如你想让一个dom元素显示，然后下一步去获取这个元素的offsetWidth，最后你获取到的会是0。openSubmenu() &#123;    this.show = true //获取不到宽度    this.$nextTick(() =&gt;       //这里才可以 let w = this.$refs.submenu.offsetWidth;   &#125;)&#125;</code></pre><h2 id="Vue组件间传递数据的方式"><a href="#Vue组件间传递数据的方式" class="headerlink" title="Vue组件间传递数据的方式"></a>Vue组件间传递数据的方式</h2><h3 id="props配置项-父传子-or-子传父"><a href="#props配置项-父传子-or-子传父" class="headerlink" title="props配置项(父传子 or 子传父)"></a>props配置项(父传子 or 子传父)</h3><ol><li><p>功能：让组件接收外部传过来的数据</p></li><li><p>传递数据：<code>&lt;Demo name=&quot;xxx&quot;/&gt;</code></p></li><li><p>接收数据：</p><ol><li><p>第一种方式（只接收）：<code>props:[&#39;name&#39;] </code></p></li><li><p>第二种方式（限制类型）：<code>props:&#123;name:String&#125;</code></p></li><li><p>第三种方式（限制类型、限制必要性、指定默认值）：</p><pre><code class="js">props:&#123;    name:&#123;    type:String, //类型    required:true, //必要性    default:&#39;老王&#39; //默认值    &#125;&#125;</code></pre></li></ol><blockquote><p>备注：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据。</p></blockquote></li></ol><h3 id="组件的自定义事件-子传父"><a href="#组件的自定义事件-子传父" class="headerlink" title="组件的自定义事件(子传父)"></a>组件的自定义事件(子传父)</h3><ol><li><p>一种组件间通信的方式，适用于：<strong style="color:red">子组件 &#x3D;&#x3D;&#x3D;&gt; 父组件</strong></p></li><li><p>使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（<span style="color:red">事件的回调在A中</span>）。</p></li><li><p>绑定自定义事件：</p><ol><li><p>第一种方式，在父组件中：<code>&lt;Demo @dataarr=&quot;test&quot;/&gt;</code>  或 <code>&lt;Demo v-on:dataarr=&quot;test&quot;/&gt;</code></p></li><li><p>第二种方式，在父组件中：</p><pre><code class="js">&lt;Demo ref=&quot;demo&quot;/&gt;......mounted()&#123;   this.$refs.xxx.$on(&#39;dataarr&#39;,this.test)&#125;</code></pre></li><li><p>若想让自定义事件只能触发一次，可以使用<code>once</code>修饰符，或<code>$once</code>方法。</p></li></ol></li><li><p>触发自定义事件：<code>this.$emit(&#39;dataarr&#39;,数据)</code></p></li><li><p>解绑自定义事件<code>this.$off(&#39;dataarr&#39;)</code></p></li><li><p>组件上也可以绑定原生DOM事件，需要使用<code>native</code>修饰符。</p></li><li><p>注意：通过<code>this.$refs.xxx.$on(&#39;dataarr&#39;,回调)</code>绑定自定义事件时，回调<span style="color:red">要么配置在methods中</span>，<span style="color:red">要么用箭头函数</span>，否则this指向会出问题！</p></li></ol><h3 id="全局事件总线（GlobalEventBus）"><a href="#全局事件总线（GlobalEventBus）" class="headerlink" title="全局事件总线（GlobalEventBus）"></a>全局事件总线（GlobalEventBus）</h3><ol><li><p>一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。</p></li><li><p>安装全局事件总线：</p><pre><code class="js">new Vue(&#123;    ......    beforeCreate() &#123;        Vue.prototype.$bus = this //安装全局事件总线，$bus就是当前应用的vm    &#125;,    ......&#125;) </code></pre></li><li><p>使用事件总线：</p><ol><li><p>接收数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的<span style="color:red">回调留在A组件自身。</span></p><pre><code class="js">methods()&#123;  demo(data)&#123;......&#125;&#125;......mounted() &#123;  this.$bus.$on(&#39;xxxx&#39;,this.demo)&#125;</code></pre></li><li><p>提供数据：<code>this.$bus.$emit(&#39;xxxx&#39;,数据)</code></p></li></ol></li><li><p>最好在beforeDestroy钩子中，用$off去解绑<span style="color:red">当前组件所用到的</span>事件。</p></li></ol><h3 id="消息订阅与发布（pubsub）"><a href="#消息订阅与发布（pubsub）" class="headerlink" title="消息订阅与发布（pubsub）"></a>消息订阅与发布（pubsub）</h3><ol><li><p>一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。</p></li><li><p>使用步骤：</p><ol><li><p>安装pubsub：<code>npm i pubsub-js</code></p></li><li><p>引入: <code>import pubsub from &#39;pubsub-js&#39;</code></p></li><li><p>接收数据：A组件想接收数据，则在A组件中订阅消息，订阅的<span style="color:red">回调留在A组件自身。</span></p><pre><code class="js">methods()&#123;  demo(data)&#123;......&#125;&#125;......mounted() &#123;  this.pid = pubsub.subscribe(&#39;xxx&#39;,this.demo) //订阅消息&#125;</code></pre></li><li><p>提供数据：<code>pubsub.publish(&#39;xxx&#39;,数据)</code></p></li><li><p>最好在beforeDestroy钩子中，用<code>PubSub.unsubscribe(pid)</code>去<span style="color:red">取消订阅。</span></p></li></ol></li></ol><h3 id="prvide-amp-inject"><a href="#prvide-amp-inject" class="headerlink" title="prvide &amp; inject"></a>prvide &amp; inject</h3><h3 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h3><pre><code class="javascript">Vue 组件间通信只要指以下 3 类通信：父子组件通信、隔代组件通信、兄弟组件通信，下面我们分别介绍每种通信方式且会说明此种方法可适用于哪类组件间通信。（1）props / $emit 适用 父子组件通信这种方法是 Vue 组件的基础，相信大部分同学耳闻能详，所以此处就不举例展开介绍。（2）ref 与 $parent / $children适用 父子组件通信ref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例$parent / $children：访问父 / 子实例（3）EventBus （$emit / $on）适用于 父子、隔代、兄弟组件通信这种方法通过一个空的 Vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件。（4）$attrs/$listeners适用于 隔代组件通信$attrs：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 v-bind=&quot;$attrs&quot; 传入内部组件。通常配合 inheritAttrs 选项一起使用。$listeners：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=&quot;$listeners&quot; 传入内部组件（5）provide / inject适用于 隔代组件通信祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。（6）Vuex适用于 父子、隔代、兄弟组件通信Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。</code></pre><pre><code class="javascript">//父组件需要拿到子组件的数据和实例父组件调用子组件的方法 :this.$refs.yeluosen.childMethod()//子组件拿到父组件的实例 (可以处理父组件分数据和调用父组件的方法) this.$parent</code></pre><h2 id="vue更新响应式的缺陷和-set的使用"><a href="#vue更新响应式的缺陷和-set的使用" class="headerlink" title="vue更新响应式的缺陷和$set的使用"></a>vue更新响应式的缺陷和$set的使用</h2><pre><code class="javascript">&lt;template&gt;  &lt;div class=&quot;container&quot;&gt;    &lt;ul&gt;      &lt;li v-for=&quot;(item, index) in person&quot; :key=&quot;index&quot;&gt;        &#123;&#123; item &#125;&#125;      &lt;/li&gt;    &lt;/ul&gt;    &lt;button @click=&quot;addsex&quot;&gt;手动点击给对象添加属性&lt;/button&gt;    &lt;hr /&gt;    &lt;ul&gt;      &lt;li v-for=&quot;(item, index) in hobby&quot; :key=&quot;index&quot;&gt;        &#123;&#123; item &#125;&#125;      &lt;/li&gt;    &lt;/ul&gt;    &lt;button @click=&quot;addhobby&quot;&gt;手动点击给数组修改属性&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &quot;index&quot;,  data() &#123;    return &#123;      person: &#123;        name: &quot;jack&quot;,        age: 18,      &#125;,      hobby: [&quot;抽烟&quot;, &quot;喝酒&quot;, &quot;烫头&quot;],      persons: [        &#123; name: &quot;gsq&quot;, age: 18 ,status : false &#125;,        &#123; name: &quot;gsq02&quot;, age: 19,status : false &#125;,        &#123; name: &quot;gsq03&quot;, age: 20,status : false &#125;,      ],    &#125;;  &#125;,  methods: &#123;    addsex() &#123;      // 对象不能这么添加      // this.person.sex = &#39;男&#39;      //正确写法      this.$set(this.person, &quot;sex&quot;, &quot;男&quot;)    &#125;,    addhobby()&#123;      // 必须使用响应式的数组方法可以更新/或者使用this.$set      // 哪些数组是相应式的？      // push,pop,shift,unshift,splice,sort,reverse        // this.hobby.splice(0,1,&#39;哈哈&#39;)      // 或者使用      this.$set(this.hobby,0,&#39;哈哈&#39;)      &#125;  &#125;,&#125;;&lt;/script&gt;&lt;style lang=&quot;less&quot;&gt;.container &#123;  width: 100vw;  height: 100vh;&#125;&lt;/style&gt;Vue监视数据的原理：1. vue会监视data中所有层次的数据。2. 如何监测对象中的数据？通过setter实现监视，且要在new Vue时就传入要监测的数据。    (1).对象中后追加的属性，Vue默认不做响应式处理    (2).如需给后添加的属性做响应式，请使用如下API：        Vue.set(target，propertyName/index，value) 或         vm.$set(target，propertyName/index，value)3. 如何监测数组中的数据？通过包裹数组更新元素的方法实现，本质就是做了两件事：    (1).调用原生对应的方法对数组进行更新。    (2).重新解析模板，进而更新页面。4.在Vue修改数组中的某个元素一定要用如下方法：    1.使用这些API:push()、pop()、shift()、unshift()、splice()、sort()、reverse()    2.Vue.set() 或 vm.$set()特别注意：Vue.set() 和 vm.$set() 不能给vm 或 vm的根数据对象 添加属性！！！</code></pre><h2 id="Vue获取dom元素节点并操作元素的样式"><a href="#Vue获取dom元素节点并操作元素的样式" class="headerlink" title="Vue获取dom元素节点并操作元素的样式"></a>Vue获取dom元素节点并操作元素的样式</h2><pre><code class="text">$refs 获取的是组件对象$el 获取的是dom节点1.获取到元素节点(这里通过this.$refs获取元素节点)this.$refs.xxxxx.$el2.操作元素的样式this.$refs.num1Underline.$el.style.transform = &#39;scaleX(1)&#39;这种方法需要注意的是$el 用于获取vue挂载的实例的dom对象，如果不添加$el则获取不到style的属性值，会打印 TypeError: Cannot read property &#39;style&#39; of undefined 错误，这个错误大家一定都很熟悉，是类型错误，没有访问到dom元素</code></pre><h2 id="forceUpdate"><a href="#forceUpdate" class="headerlink" title="forceUpdate"></a>forceUpdate</h2><ol><li>语法：<code>this.$forceUpdate()</code></li><li>应用场景包括：</li></ol><ul><li>当组件的数据发生变化，但没有触发响应式更新时，可以使用 forceUpdate 强制组件重新渲染。这种情况通常出现在使用了非响应式数据或直接修改了响应式数据的属性（例如通过 this.$set 或直接修改数组下标访问元素）。</li><li>当你需要手动触发组件的重新渲染，而不是等待依赖的数据发生变化时，也可以使用 forceUpdate。这对于一些特殊需求或性能优化可能是必要的。</li></ul><ol start="2"><li>缺点：</li></ol><ul><li>使用 forceUpdate 会跳过虚拟 DOM 的比对过程，直接进行重新渲染。这可能会带来性能上的损耗</li></ul><h2 id="mixin-混入"><a href="#mixin-混入" class="headerlink" title="mixin(混入)"></a>mixin(混入)</h2><pre><code class="javascript">1. 功能：可以把多个组件共用的配置提取成一个混入对象2. 使用方式：   第一步定义混合：</code></pre><p>   {<br>       data(){….},<br>       methods:{….}<br>       ….<br>   }</p><pre><code>第二步使用混入：​全局混入：```Vue.mixin(xxx)```​局部混入：```mixins:[&#39;xxx&#39;]```</code></pre><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><pre><code class="javascript">1. 功能：用于增强Vue2. 本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据。3. 定义插件： // 创建一个名为 MyPlugin 的插件对象const MyPlugin = &#123;  // 在 install 方法中定义插件逻辑  install(Vue) &#123;    // 添加全局方法或属性    Vue.myGlobalMethod = function () &#123;      console.log(&#39;This is a global method&#39;);    &#125;;    // 添加一个全局指令    Vue.directive(&#39;my-directive&#39;, &#123;      bind(el, binding) &#123;        el.innerHTML = `My directive value: $&#123;binding.value&#125;`;      &#125;,    &#125;);    // 添加一个全局过滤器    Vue.filter(&#39;my-filter&#39;, function (value) &#123;      return value.toUpperCase();    &#125;);    // 添加一个全局混入    Vue.mixin(&#123;      created() &#123;        console.log(&#39;This is a global mixin&#39;);      &#125;,    &#125;);  &#125;,&#125;;// 使用插件Vue.use(MyPlugin);</code></pre><h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><ol><li><p>作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 <strong style="color:red">父组件 &#x3D;&#x3D;&#x3D;&gt; 子组件</strong> 。</p></li><li><p>分类：默认插槽、具名插槽、作用域插槽</p></li><li><p>使用方式：</p><ol><li><p>默认插槽：</p><pre><code class="vue">父组件中：        &lt;Category&gt;           &lt;div&gt;html结构1&lt;/div&gt;        &lt;/Category&gt;子组件中：        &lt;template&gt;            &lt;div&gt;               &lt;!-- 定义插槽 --&gt;               &lt;slot&gt;插槽默认内容...&lt;/slot&gt;            &lt;/div&gt;        &lt;/template&gt;</code></pre></li><li><p>具名插槽：</p><pre><code class="vue">父组件中：        &lt;Category&gt;            &lt;template slot=&quot;center&quot;&gt;              &lt;div&gt;html结构1&lt;/div&gt;            &lt;/template&gt;            &lt;template v-slot:footer&gt;               &lt;div&gt;html结构2&lt;/div&gt;            &lt;/template&gt;        &lt;/Category&gt;子组件中：        &lt;template&gt;            &lt;div&gt;               &lt;!-- 定义插槽 --&gt;               &lt;slot name=&quot;center&quot;&gt;插槽默认内容...&lt;/slot&gt;               &lt;slot name=&quot;footer&quot;&gt;插槽默认内容...&lt;/slot&gt;            &lt;/div&gt;        &lt;/template&gt;</code></pre></li><li><p>作用域插槽：</p><ol><li><p>理解：<span style="color:red">数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。</span>（games数据在Category组件中，但使用数据所遍历出来的结构由App组件决定）</p></li><li><p>具体编码：</p><pre><code class="vue">父组件中：        &lt;Category&gt;            &lt;template scope=&quot;scopeData&quot;&gt;                &lt;!-- 生成的是ul列表 --&gt;                &lt;ul&gt;                    &lt;li v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/li&gt;                &lt;/ul&gt;            &lt;/template&gt;        &lt;/Category&gt;        &lt;Category&gt;            &lt;template slot-scope=&quot;scopeData&quot;&gt;                &lt;!-- 生成的是h4标题 --&gt;                &lt;h4 v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/h4&gt;            &lt;/template&gt;        &lt;/Category&gt;子组件中：        &lt;template&gt;            &lt;div&gt;                &lt;slot :games=&quot;games&quot;&gt;&lt;/slot&gt;            &lt;/div&gt;        &lt;/template&gt;                &lt;script&gt;            export default &#123;                name:&#39;Category&#39;,                props:[&#39;title&#39;],                //数据在子组件自身                data() &#123;                    return &#123;                        games:[&#39;红色警戒&#39;,&#39;穿越火线&#39;,&#39;劲舞团&#39;,&#39;超级玛丽&#39;]                    &#125;                &#125;,            &#125;        &lt;/script&gt;</code></pre></li></ol></li></ol></li></ol><h2 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h2><ol><li>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性：</li></ol><ul><li>一般结合路由和动态组件一起使用，用于缓存组件；</li><li>提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；</li><li>对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。</li></ul><ol start="2"><li>原理<br><keep-alive> 组件的原理是通过将组件进行缓存来提高性能，避免不必要的重新渲染和销毁。</li></ol><p>当 <keep-alive> 包裹的组件第一次被渲染时，Vue 会将该组件的实例缓存起来。当组件被切换隐藏时，而不是直接销毁，它的状态和 DOM 结构会被保留在内存中。</p><p>当组件再次显示时，Vue 会复用缓存的组件实例，而不是重新创建一个新的组件。这样可以避免重复初始化组件、重新计算数据、重新挂载 DOM 的开销，从而提高应用的性能。</p><p>在缓存期间，即使组件处于隐藏状态，它的生命周期钩子函数仍然会被调用。例如，created、mounted 等钩子函数会在组件被缓存时执行一次，以及在组件再次显示时执行一次。但是，destroyed 钩子函数不会被调用，因为组件并没有被销毁。</p><p>需要注意的是，被 <keep-alive> 缓存的组件在切换显示时，并不会触发组件的重新渲染过程。但是，如果组件的数据或属性发生了变化，当组件再次展示时，会触发 activated 钩子函数，可以在该钩子函数中处理数据更新的逻辑。</p><h1 id="Vue-Router"><a href="#Vue-Router" class="headerlink" title="Vue-Router"></a>Vue-Router</h1><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><ol><li><p>安装vue-router，命令：<code>npm i vue-router</code></p></li><li><p>应用插件：<code>Vue.use(VueRouter)</code></p></li><li><p>编写router配置项:</p><pre><code class="js">//引入VueRouterimport VueRouter from &#39;vue-router&#39;//引入Luyou 组件import About from &#39;../components/About&#39;import Home from &#39;../components/Home&#39;//创建router实例对象，去管理一组一组的路由规则const router = new VueRouter(&#123;    routes:[        &#123;            path:&#39;/about&#39;,            component:About        &#125;,        &#123;            path:&#39;/home&#39;,            component:Home        &#125;    ]&#125;)//暴露routerexport default router</code></pre></li><li><p>实现切换（active-class可配置高亮样式）</p><pre><code class="vue">&lt;router-link active-class=&quot;active&quot; to=&quot;/about&quot;&gt;About&lt;/router-link&gt;</code></pre></li><li><p>指定展示位置</p><pre><code class="vue">&lt;router-view&gt;&lt;/router-view&gt;</code></pre></li></ol><h2 id="几个注意点"><a href="#几个注意点" class="headerlink" title="几个注意点"></a>几个注意点</h2><ol><li>路由组件通常存放在<code>pages</code>文件夹，一般组件通常存放在<code>components</code>文件夹。</li><li>通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。</li><li>每个组件都有自己的<code>$route</code>属性，里面存储着自己的路由信息。</li><li>整个应用只有一个router，可以通过组件的<code>$router</code>属性获取到。</li></ol><h2 id="多级路由（多级路由）"><a href="#多级路由（多级路由）" class="headerlink" title="多级路由（多级路由）"></a>多级路由（多级路由）</h2><ol><li><p>配置路由规则，使用children配置项：</p><pre><code class="js">routes:[    &#123;        path:&#39;/about&#39;,        component:About,    &#125;,    &#123;        path:&#39;/home&#39;,        component:Home,        children:[ //通过children配置子级路由            &#123;                path:&#39;news&#39;, //此处一定不要写：/news                component:News            &#125;,            &#123;                path:&#39;message&#39;,//此处一定不要写：/message                component:Message            &#125;        ]    &#125;]</code></pre></li><li><p>跳转（要写完整路径）：</p><pre><code class="vue">&lt;router-link to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt;</code></pre></li></ol><h2 id="路由的query参数"><a href="#路由的query参数" class="headerlink" title="路由的query参数"></a>路由的query参数</h2><ol><li><p>传递参数</p><pre><code class="vue">&lt;!-- 跳转并携带query参数，to的字符串写法 --&gt;&lt;router-link :to=&quot;/home/message/detail?id=666&amp;title=你好&quot;&gt;跳转&lt;/router-link&gt;                &lt;!-- 跳转并携带query参数，to的对象写法 --&gt;&lt;router-link     :to=&quot;&#123;        path:&#39;/home/message/detail&#39;,        query:&#123;           id:666,            title:&#39;你好&#39;        &#125;    &#125;&quot;&gt;跳转&lt;/router-link&gt;</code></pre></li><li><p>接收参数：</p><pre><code class="js">$route.query.id$route.query.title</code></pre></li></ol><h2 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h2><ol><li><p>作用：可以简化路由的跳转。</p></li><li><p>如何使用</p><ol><li><p>给路由命名：</p><pre><code class="js">&#123;    path:&#39;/demo&#39;,    component:Demo,    children:[        &#123;            path:&#39;test&#39;,            component:Test,            children:[                &#123;                    name:&#39;hello&#39; //给路由命名                    path:&#39;welcome&#39;,                    component:Hello,                &#125;            ]        &#125;    ]&#125;</code></pre></li><li><p>简化跳转：</p><pre><code class="vue">&lt;!--简化前，需要写完整的路径 --&gt;&lt;router-link to=&quot;/demo/test/welcome&quot;&gt;跳转&lt;/router-link&gt;&lt;!--简化后，直接通过名字跳转 --&gt;&lt;router-link :to=&quot;&#123;name:&#39;hello&#39;&#125;&quot;&gt;跳转&lt;/router-link&gt;&lt;!--简化写法配合传递参数 --&gt;&lt;router-link     :to=&quot;&#123;        name:&#39;hello&#39;,        query:&#123;           id:666,            title:&#39;你好&#39;        &#125;    &#125;&quot;&gt;跳转&lt;/router-link&gt;</code></pre></li></ol></li></ol><h2 id="路由的params参数"><a href="#路由的params参数" class="headerlink" title="路由的params参数"></a>路由的params参数</h2><ol><li><p>配置路由，声明接收params参数</p><pre><code class="js">&#123;    path:&#39;/home&#39;,    component:Home,    children:[        &#123;            path:&#39;news&#39;,            component:News        &#125;,        &#123;            component:Message,            children:[                &#123;                    name:&#39;xiangqing&#39;,                    path:&#39;detail/:id/:title&#39;, //使用占位符声明接收params参数                    component:Detail                &#125;            ]        &#125;    ]&#125;</code></pre></li><li><p>传递参数</p><pre><code class="vue">&lt;!-- 跳转并携带params参数，to的字符串写法 --&gt;&lt;router-link :to=&quot;/home/message/detail/666/你好&quot;&gt;跳转&lt;/router-link&gt;                &lt;!-- 跳转并携带params参数，to的对象写法 --&gt;&lt;router-link     :to=&quot;&#123;        name:&#39;xiangqing&#39;,        params:&#123;           id:666,            title:&#39;你好&#39;        &#125;    &#125;&quot;&gt;跳转&lt;/router-link&gt;</code></pre><blockquote><p>特别注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置！</p></blockquote></li><li><p>接收参数：</p><pre><code class="js">$route.params.id$route.params.title</code></pre></li></ol><h2 id="路由的props配置"><a href="#路由的props配置" class="headerlink" title="路由的props配置"></a>路由的props配置</h2><p>​作用：让路由组件更方便的收到参数</p><pre><code class="js">&#123;    name:&#39;xiangqing&#39;,    path:&#39;detail/:id&#39;,    component:Detail,    //第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件    // props:&#123;a:900&#125;    //第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件    // props:true        //第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件    props(route)&#123;        return &#123;            id:route.query.id,            title:route.query.title        &#125;    &#125;&#125;</code></pre><h2 id="的replace属性"><a href="#的replace属性" class="headerlink" title="的replace属性"></a><router-link>的replace属性</h2><ol><li>作用：控制路由跳转时操作浏览器历史记录的模式</li><li>浏览器的历史记录有两种写入方式：分别为<code>push</code>和<code>replace</code>，<code>push</code>是追加历史记录，<code>replace</code>是替换当前记录。路由跳转时候默认为<code>push</code></li><li>如何开启<code>replace</code>模式：<code>&lt;router-link replace .......&gt;News&lt;/router-link&gt;</code></li></ol><h2 id="编程式路由导航"><a href="#编程式路由导航" class="headerlink" title="编程式路由导航"></a>编程式路由导航</h2><ol><li><p>作用：不借助<code>&lt;router-link&gt; </code>实现路由跳转，让路由跳转更加灵活</p></li><li><p>具体编码：</p><pre><code class="js">//$router的两个APIthis.$router.push(&#123;    name:&#39;xiangqing&#39;,        params:&#123;            id:xxx,            title:xxx        &#125;&#125;)this.$router.replace(&#123;    name:&#39;xiangqing&#39;,        params:&#123;            id:xxx,            title:xxx        &#125;&#125;)this.$router.forward() //前进this.$router.back() //后退this.$router.go() //可前进也可后退</code></pre></li></ol><h2 id="缓存路由组件"><a href="#缓存路由组件" class="headerlink" title="缓存路由组件"></a>缓存路由组件</h2><ol><li><p>作用：让不展示的路由组件保持挂载，不被销毁。</p></li><li><p>具体编码：</p><pre><code class="vue">&lt;keep-alive include=&quot;News&quot;&gt;     &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;</code></pre></li></ol><h2 id="两个新的生命周期钩子"><a href="#两个新的生命周期钩子" class="headerlink" title="两个新的生命周期钩子"></a>两个新的生命周期钩子</h2><ol><li><p>作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态。</p></li><li><p>具体名字：</p><ol><li><code>activated</code>路由组件被激活时触发。</li><li><code>deactivated</code>路由组件失活时触发。</li></ol><p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。</p><pre><code class="javascript">&lt;keep-alive&gt;  &lt;component&gt;    &lt;!-- 该组件将被缓存！ --&gt;  &lt;/component&gt;&lt;/keep-alive&gt;如果只想 router-view 里面某个组件被缓存export default [  &#123;    path: &#39;/&#39;,    name: &#39;home&#39;,    component: Home,    meta: &#123;      keepAlive: true // 需要被缓存    &#125;  &#125;, &#123;    path: &#39;/:id&#39;,    name: &#39;edit&#39;,    component: Edit,    meta: &#123;      keepAlive: false // 不需要被缓存    &#125;  &#125;]&lt;keep-alive&gt;    &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;        &lt;!-- 这里是会被缓存的视图组件，比如 Home！ --&gt;    &lt;/router-view&gt;&lt;/keep-alive&gt; &lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;    &lt;!-- 这里是不被缓存的视图组件，比如 Edit！ --&gt;&lt;/router-view&gt;</code></pre></li></ol><h2 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h2><ol><li><p>作用：对路由进行权限控制</p></li><li><p>分类：全局守卫、独享守卫、组件内守卫</p></li><li><p>全局守卫:</p><pre><code class="js">//全局前置守卫：初始化时执行、每次路由切换前执行router.beforeEach((to,from,next)=&gt;&#123;    console.log(&#39;beforeEach&#39;,to,from)    if(to.meta.isAuth)&#123; //判断当前路由是否需要进行权限控制        if(localStorage.getItem(&#39;school&#39;) === &#39;atguigu&#39;)&#123; //权限控制的具体规则            next() //放行        &#125;else&#123;            alert(&#39;暂无权限查看&#39;)            // next(&#123;name:&#39;guanyu&#39;&#125;)        &#125;    &#125;else&#123;        next() //放行    &#125;&#125;)//全局后置守卫：初始化时执行、每次路由切换后执行router.afterEach((to,from)=&gt;&#123;    console.log(&#39;afterEach&#39;,to,from)    if(to.meta.title)&#123;         document.title = to.meta.title //修改网页的title    &#125;else&#123;        document.title = &#39;vue_test&#39;    &#125;&#125;)</code></pre></li><li><p>独享守卫:</p><pre><code class="js">beforeEnter(to,from,next)&#123;    console.log(&#39;beforeEnter&#39;,to,from)    if(to.meta.isAuth)&#123; //判断当前路由是否需要进行权限控制        if(localStorage.getItem(&#39;school&#39;) === &#39;atguigu&#39;)&#123;            next()        &#125;else&#123;            alert(&#39;暂无权限查看&#39;)            // next(&#123;name:&#39;guanyu&#39;&#125;)        &#125;    &#125;else&#123;        next()    &#125;&#125;</code></pre></li><li><p>组件内守卫：</p><pre><code class="js">//进入守卫：通过路由规则，进入该组件时被调用beforeRouteEnter (to, from, next) &#123;&#125;,//离开守卫：通过路由规则，离开该组件时被调用beforeRouteLeave (to, from, next) &#123;&#125;</code></pre></li></ol><h2 id="vue-router实现路由懒加载（-动态加载路由-）"><a href="#vue-router实现路由懒加载（-动态加载路由-）" class="headerlink" title="vue-router实现路由懒加载（ 动态加载路由 ）"></a>vue-router实现路由懒加载（ 动态加载路由 ）</h2><pre><code class="javascript">import Vue from &#39;vue&#39;import VueRouter from &#39;vue-router&#39;Vue.use(VueRouter)const routes = [  &#123;    path: &#39;/&#39;,    name: &#39;Home&#39;,    component: () =&gt; import( &#39;../views/Home.vue&#39;)   //使用import的方式导入组件  &#125;,  &#123;    path: &#39;/about&#39;,    name: &#39;About&#39;,    component: () =&gt; import( &#39;../views/About.vue&#39;)  &#125;]const router = new VueRouter(&#123;  mode: &#39;history&#39;,  base: process.env.BASE_URL,  routes&#125;)export default router</code></pre><h2 id="vue-router如何响应-路由参数-的变化？"><a href="#vue-router如何响应-路由参数-的变化？" class="headerlink" title="vue-router如何响应 路由参数 的变化？"></a>vue-router如何响应 路由参数 的变化？</h2><p><strong>原来的组件实例会被复用。这也意味着组件的生命周期钩子不会再被调用。你可以简单地 watch (监测变化) $route 对象：</strong></p><pre><code class="js">const User = &#123;  template: &#39;...&#39;,  watch: &#123;    &#39;$route&#39; (to, from) &#123;      // 对路由变化作出响应...    &#125;  &#125;&#125;</code></pre><h2 id="route和-router的区别是什么"><a href="#route和-router的区别是什么" class="headerlink" title="$route和$router的区别是什么"></a>$route和$router的区别是什么</h2><pre><code class="javascript">$route为当前router跳转当前路由组件里可获取name、path、query、params等$router为VueRouter实例，想要导航到不同URL，则使用$router.push方法</code></pre><h2 id="hash和history的区别"><a href="#hash和history的区别" class="headerlink" title="hash和history的区别"></a>hash和history的区别</h2><ol><li>对于一个url来说，什么是hash值？—— #及其后面的内容就是hash值。</li><li>hash值不会包含在 HTTP 请求中，即：hash值不会带给服务器。</li><li>hash模式：<ul><li>地址中永远带着#号，不美观 。</li><li>若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。</li><li>兼容性较好。</li></ul></li><li>history模式：<ul><li>地址干净，美观 。</li><li>兼容性和hash模式相比略差。</li><li>应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。</li></ul></li></ol><h2 id="vue-router-路由模式有几种？"><a href="#vue-router-路由模式有几种？" class="headerlink" title="vue-router 路由模式有几种？"></a>vue-router 路由模式有几种？</h2><pre><code class="javascript">vue-router 有 3 种路由模式：hash、history、abstract，对应的源码如下所示：switch (mode) &#123;  case &#39;history&#39;:    this.history = new HTML5History(this, options.base)    break  case &#39;hash&#39;:    this.history = new HashHistory(this, options.base, this.fallback)    break  case &#39;abstract&#39;:    this.history = new AbstractHistory(this, options.base)    break  default:    if (process.env.NODE_ENV !== &#39;production&#39;) &#123;      assert(false, `invalid mode: $&#123;mode&#125;`)    &#125;&#125;</code></pre><p>hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器；<br>history : 依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式；<br>abstract : 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.</p><p>在 hash 模式下，URL 中的路由会以 # 符号后面的路径来表示。例如，<span class="exturl" data-url="aHR0cDovL2V4YW1wbGUuY29tLyMvaG9tZSVFMyU4MCU4Mg==">http://example.com/#/home。</span><br>这种模式不会触发浏览器页面刷新，因为 # 后面的内容不会被发送到服务器。<br>在 Vue Router 中，默认使用 hash 模式，你可以通过以下方式创建 Vue Router 对象时手动指定该模式：</p><p>在 history 模式下，URL 中的路由会直接使用正常的路径，没有 # 符号。例如，<span class="exturl" data-url="aHR0cDovL2V4YW1wbGUuY29tL2hvbWUlRTMlODAlODI=">http://example.com/home。</span><br>这种模式通过使用 HTML5 History API，将路由状态保存到浏览器的历史记录中。<br>注意，使用 history 模式需要服务器配置适配，以避免用户在直接访问 URL 时出现 404 错误。<br>在 Vue Router 中，你可以通过以下方式创建 Vue Router 对象时启用 history 模式：</p><h2 id="vue-router-中常用的-hash-和-history-路由模式实现原理吗？"><a href="#vue-router-中常用的-hash-和-history-路由模式实现原理吗？" class="headerlink" title="vue-router 中常用的 hash 和 history 路由模式实现原理吗？"></a>vue-router 中常用的 hash 和 history 路由模式实现原理吗？</h2><pre><code class="javascript">（1）hash 模式的实现原理早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 ‘#search’：https://www.word.com#searchhash 路由模式的实现主要是基于下面几个特性：URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送；hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换；可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用 JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值；我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。（2）history 模式的实现原理HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示：window.history.pushState(null, null, path);window.history.replaceState(null, null, path);history 路由模式的实现主要基于存在下面几个特性：pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ；我们可以使用 popstate 事件来监听 url 的变化，从而对页面进行跳转（渲染）；history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。</code></pre><h1 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>​在Vue中实现集中式状态（数据）管理的一个Vue插件，对vue应用中多个组件的共享状态进行集中式的管理（读&#x2F;写），也是一种组件间通信的方式，且适用于任意组件间通信。</p><h2 id="何时使用？"><a href="#何时使用？" class="headerlink" title="何时使用？"></a>何时使用？</h2><p>​多个组件需要共享数据时，音乐播放、登录状态、加入购物车</p><h2 id="搭建vuex环境"><a href="#搭建vuex环境" class="headerlink" title="搭建vuex环境"></a>搭建vuex环境</h2><ol><li><p>创建文件：<code>src/store/index.js</code></p><pre><code class="js">//引入Vue核心库import Vue from &#39;vue&#39;//引入Vueximport Vuex from &#39;vuex&#39;//应用Vuex插件Vue.use(Vuex)//准备actions对象——响应组件中用户的动作const actions = &#123;&#125;//准备mutations对象——修改state中的数据const mutations = &#123;&#125;//准备state对象——保存具体的数据const state = &#123;&#125;//创建并暴露storeexport default new Vuex.Store(&#123;    actions,    mutations,    state&#125;)</code></pre></li><li><p>在<code>main.js</code>中创建vm时传入<code>store</code>配置项</p><pre><code class="js">......//引入storeimport store from &#39;./store&#39;......//创建vmnew Vue(&#123;    el:&#39;#app&#39;,    render: h =&gt; h(App),    store&#125;)</code></pre></li></ol><h2 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h2><ol><li><p>初始化数据、配置<code>actions</code>、配置<code>mutations</code>，操作文件<code>store.js</code></p><pre><code class="js">//引入Vue核心库import Vue from &#39;vue&#39;//引入Vueximport Vuex from &#39;vuex&#39;//引用VuexVue.use(Vuex)const actions = &#123;    //响应组件中加的动作    jia(context,value)&#123;        // console.log(&#39;actions中的jia被调用了&#39;,miniStore,value)        context.commit(&#39;JIA&#39;,value)    &#125;,&#125;const mutations = &#123;    //执行加    JIA(state,value)&#123;        // console.log(&#39;mutations中的JIA被调用了&#39;,state,value)        state.sum += value    &#125;&#125;//初始化数据const state = &#123;   sum:0&#125;//创建并暴露storeexport default new Vuex.Store(&#123;    actions,    mutations,    state,&#125;)</code></pre></li><li><p>组件中读取vuex中的数据：<code>$store.state.sum</code></p></li><li><p>组件中修改vuex中的数据：<code>$store.dispatch(&#39;action中的方法名&#39;,数据)</code> 或 <code>$store.commit(&#39;mutations中的方法名&#39;,数据)</code></p><blockquote><p> 备注：若没有网络请求或其他业务逻辑，组件中也可以越过actions，即不写<code>dispatch</code>，直接编写<code>commit</code></p></blockquote></li></ol><h2 id="getters的使用"><a href="#getters的使用" class="headerlink" title="getters的使用"></a>getters的使用</h2><ol><li><p>概念：当state中的数据需要经过加工后再使用时，可以使用getters加工。</p></li><li><p>在<code>store.js</code>中追加<code>getters</code>配置</p><pre><code class="js">......const getters = &#123;    bigSum(state)&#123;        return state.sum * 10    &#125;&#125;//创建并暴露storeexport default new Vuex.Store(&#123;    ......    getters&#125;)</code></pre></li><li><p>组件中读取数据：<code>$store.getters.bigSum</code></p></li></ol><h2 id="四个map方法的使用"><a href="#四个map方法的使用" class="headerlink" title="四个map方法的使用"></a>四个map方法的使用</h2><ol><li><p><strong>mapState方法：</strong>用于帮助我们映射<code>state</code>中的数据为计算属性</p><pre><code class="js">computed: &#123;    //借助mapState生成计算属性：sum、school、subject（对象写法）     ...mapState(&#123;sum:&#39;sum&#39;,school:&#39;school&#39;,subject:&#39;subject&#39;&#125;),             //借助mapState生成计算属性：sum、school、subject（数组写法）    ...mapState([&#39;sum&#39;,&#39;school&#39;,&#39;subject&#39;]),&#125;,</code></pre></li><li><p><strong>mapGetters方法：</strong>用于帮助我们映射<code>getters</code>中的数据为计算属性</p><pre><code class="js">computed: &#123;    //借助mapGetters生成计算属性：bigSum（对象写法）    ...mapGetters(&#123;bigSum:&#39;bigSum&#39;&#125;),    //借助mapGetters生成计算属性：bigSum（数组写法）    ...mapGetters([&#39;bigSum&#39;])&#125;,</code></pre></li><li><p><strong>mapActions方法：</strong>用于帮助我们生成与<code>actions</code>对话的方法，即：包含<code>$store.dispatch(xxx)</code>的函数</p><pre><code class="js">methods:&#123;    //靠mapActions生成：incrementOdd、incrementWait（对象形式）    ...mapActions(&#123;incrementOdd:&#39;jiaOdd&#39;,incrementWait:&#39;jiaWait&#39;&#125;)    //靠mapActions生成：incrementOdd、incrementWait（数组形式）    ...mapActions([&#39;jiaOdd&#39;,&#39;jiaWait&#39;])&#125;</code></pre></li><li><p><strong>mapMutations方法：</strong>用于帮助我们生成与<code>mutations</code>对话的方法，即：包含<code>$store.commit(xxx)</code>的函数</p><pre><code class="js">methods:&#123;    //靠mapActions生成：increment、decrement（对象形式）    ...mapMutations(&#123;increment:&#39;JIA&#39;,decrement:&#39;JIAN&#39;&#125;),        //靠mapMutations生成：JIA、JIAN（对象形式）    ...mapMutations([&#39;JIA&#39;,&#39;JIAN&#39;]),&#125;</code></pre></li></ol><blockquote><p>备注：mapActions与mapMutations使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象。</p></blockquote><h2 id="模块化-命名空间"><a href="#模块化-命名空间" class="headerlink" title="模块化+命名空间"></a>模块化+命名空间</h2><ol><li><p>目的：让代码更好维护，让多种数据分类更加明确。</p></li><li><p>修改<code>store.js</code></p><pre><code class="javascript">const countAbout = &#123;  namespaced:true,//开启命名空间  state:&#123;x:1&#125;,  mutations: &#123; ... &#125;,  actions: &#123; ... &#125;,  getters: &#123;    bigSum(state)&#123;       return state.sum * 10    &#125;  &#125;&#125;const personAbout = &#123;  namespaced:true,//开启命名空间  state:&#123; ... &#125;,  mutations: &#123; ... &#125;,  actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123;  modules: &#123;    countAbout,    personAbout  &#125;&#125;)</code></pre></li><li><p>开启命名空间后，组件中读取state数据：</p><pre><code class="js">//方式一：自己直接读取this.$store.state.personAbout.list//方式二：借助mapState读取：...mapState(&#39;countAbout&#39;,[&#39;sum&#39;,&#39;school&#39;,&#39;subject&#39;]),</code></pre></li><li><p>开启命名空间后，组件中读取getters数据：</p><pre><code class="js">//方式一：自己直接读取this.$store.getters[&#39;personAbout/firstPersonName&#39;]//方式二：借助mapGetters读取：...mapGetters(&#39;countAbout&#39;,[&#39;bigSum&#39;])</code></pre></li><li><p>开启命名空间后，组件中调用dispatch</p><pre><code class="js">//方式一：自己直接dispatchthis.$store.dispatch(&#39;personAbout/addPersonWang&#39;,person)//方式二：借助mapActions：...mapActions(&#39;countAbout&#39;,&#123;incrementOdd:&#39;jiaOdd&#39;,incrementWait:&#39;jiaWait&#39;&#125;)</code></pre></li><li><p>开启命名空间后，组件中调用commit</p><pre><code class="js">//方式一：自己直接committhis.$store.commit(&#39;personAbout/ADD_PERSON&#39;,person)//方式二：借助mapMutations：...mapMutations(&#39;countAbout&#39;,&#123;increment:&#39;JIA&#39;,decrement:&#39;JIAN&#39;&#125;),</code></pre></li></ol><p>##Vuex state数据的双向绑定</p><pre><code class="javascript">// 在从组件的computed中computed: &#123;    user: &#123;        get() &#123;          return this.$store.state.user        &#125;,        set(v) &#123;          // 使用vuex中的mutations中定义好的方法来改变          this.$store.commit(&#39;USER&#39;, v)        &#125;    &#125;&lt;br&gt;&#125;&lt;br&gt;// 在组件中就可以使用                     &lt;input v-modle=&quot;user&quot; /&gt;        </code></pre><h2 id="相关文档-写的比较好的文档"><a href="#相关文档-写的比较好的文档" class="headerlink" title="相关文档(写的比较好的文档)"></a>相关文档(写的比较好的文档)</h2><pre><code class="javascript">https://zhuanlan.zhihu.com/p/78981485</code></pre><h2 id="简要概括vuex"><a href="#简要概括vuex" class="headerlink" title="简要概括vuex"></a>简要概括vuex</h2><pre><code class="javascript">主要包括以下几个模块：State =&gt; 基本数据，定义了应用状态的数据结构，可以在这里设置默认的初始状态。Getter =&gt; 从基本数据派生的数据，允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。Mutation =&gt; 是唯一更改 store 中状态的方法，且必须是同步函数。Action =&gt; 像一个装饰器，包裹mutations，使之可以异步。用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。Module =&gt; 模块化Vuex，允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。</code></pre><h1 id="Vue中的开发经验"><a href="#Vue中的开发经验" class="headerlink" title="Vue中的开发经验"></a>Vue中的开发经验</h1><h2 id="搭建Vue脚手架（vue-cli）并创建一个项目"><a href="#搭建Vue脚手架（vue-cli）并创建一个项目" class="headerlink" title="搭建Vue脚手架（vue-cli）并创建一个项目"></a>搭建Vue脚手架（vue-cli）并创建一个项目</h2><pre><code class="javascript">1.安装node.js环境      [官网下载地址](https://nodejs.org/en/download/)               一路安装完成后 打开cmd                 输入 node -v               输入 npm -v               如果能看到node和npm的版本号了，说明已经安装成功                              2.安装vue-cli               有npm和cnpm两种方式，网上都说cnpm好些，所以我也用的cnpm安装，               首先利用淘宝镜像安装cnpm                     npm install cnpm -g --registry=https://registry.npm.taobao.org                      安装完成               输入 cnpm -v                                3.然后全局安装 vue-cli               输入指令 cnpm install -g vue-cli               这个命令只需要运行一次就可以了。安装上之后，以后就不用安装了。               查看vue版本号               vue -V    //注：V是大写字母V               如果提示“无法识别 ‘vue’ ” ，有可能是 npm 版本过低，需要手动更新npm的版本号，这也是上面说的为什么要保证npm版本号高的原因，npm的版本可以手动升级更新，没记错的话应该是                              npm install -g npm                                              4.使用vue-cli来创建一个基于 webpack 模板的新项目                              创建               cmd利用cd指令进入到保存项目的文件夹下，然后输入命令                          输入 vue init webpack5.安装项目所需要的依赖                                  进入新建的项目文件夹下，就是上头有一些文件的里面，输入命令                输入 指令 cnpm install6.运行项目               根据你package.json里的配置里的指令               一般情况下都是 npm run dev               7.打包资源上线               根据你package.json里的配置里的指令               一般情况下都是 npm run build                   8.具体创建项目 博客地址               https://www.cnblogs.com/coober/p/10875647.html               </code></pre><h2 id="关于不同版本的Vue"><a href="#关于不同版本的Vue" class="headerlink" title="关于不同版本的Vue"></a>关于不同版本的Vue</h2><ol><li>vue.js与vue.runtime.xxx.js的区别：<ul><li>vue.js是完整版的Vue，包含：核心功能 + 模板解析器。</li><li>vue.runtime.xxx.js是运行版的Vue，只包含：核心功能；没有模板解析器。</li></ul></li><li>因为vue.runtime.xxx.js没有模板解析器，所以不能使用template这个配置项，需要使用render函数接收到的createElement函数去指定具体内容。</li></ol><h2 id="vue-config-js配置文件"><a href="#vue-config-js配置文件" class="headerlink" title="vue.config.js配置文件"></a>vue.config.js配置文件</h2><ol><li>使用vue inspect &gt; output.js可以查看到Vue脚手架的默认配置。</li><li>使用vue.config.js可以对脚手架进行个性化定制，详情见：<span class="exturl" data-url="aHR0cHM6Ly9jbGkudnVlanMub3JnL3po">https://cli.vuejs.org/zh</span></li></ol><h2 id="vue中如何编写可复用的组件？"><a href="#vue中如何编写可复用的组件？" class="headerlink" title="vue中如何编写可复用的组件？"></a>vue中如何编写可复用的组件？</h2><p>①创建组件页面eg Toast.vue；<br>②用Vue.extend()扩展一个组件构造器,再通过实例化组件构造器,就可创造出可复用的组件<br>③将toast组件挂载到新创建的div上；<br>④把toast组件的dom添加到body里；<br>⑤修改优化达到动态控制页面显示文字跟显示时间；</p><pre><code class="javascript">import Vue from &#39;vue&#39;; import Toast from &#39;@/components/Toast&#39;;     //引入组件let ToastConstructor  = Vue.extend(Toast) // 返回一个“扩展实例构造器” let myToast = (text,duration)=&gt;&#123;    let toastDom = new ToastConstructor(&#123;        el:document.createElement(&#39;div&#39;)    //将toast组件挂载到新创建的div上    &#125;)    document.body.appendChild( toastDom.$el )   //把toast组件的dom添加到body里        toastDom.text = text;    toastDom.duration = duration;     // 在指定 duration 之后让 toast消失    setTimeout(()=&gt;&#123;        toastDom.isShow = false;      &#125;, toastDom.duration);&#125;export default myToast;</code></pre><p>点击查看 <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTYzODQ1L2FydGljbGUvZGV0YWlscy83NzUyNDkzNA==">https://blog.csdn.net/qq_38563845/article/details/77524934</span> </p><h2 id="vue父组件向子组件传对象，不实时更新解决"><a href="#vue父组件向子组件传对象，不实时更新解决" class="headerlink" title="vue父组件向子组件传对象，不实时更新解决"></a>vue父组件向子组件传对象，不实时更新解决</h2><pre><code class="javascript">思路1：就是让利用v-if的重新渲染机制1.首先考虑的就是手动刷了，给组件加个v-if=”someShow“;//  这是组件上写法 ：&lt;my-component v-if=&quot;someShow&quot;&gt;&lt;/my-component&gt; // 下边写在父组件的methods里refesh:function()&#123;    this.someShow=false;    var _this=this;    this.$nextTick(function()&#123;        _this.someShow = true;    &#125;)  &#125;// $nextTick// $nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM  这样重新渲染就会是最新数据了思路2：利用watch监听在子组件中监听你要的数据，当然别监听对象，监听了不一定好使。亲测不好使，测过好使的，可以给我留言。data:function()&#123;    return &#123;        title:&quot;&quot;,        content:&quot;&quot;,        btn:&quot;&quot;    &#125;&#125;,   methods:&#123;        changeTitle:function()&#123;            this.title=this.listTitle;            // 这里的每次变化了就复制给组件上的变量，视图也就更改了        &#125;,        changeList:function()&#123;            this.content=this.listList;        &#125;,        changeBtn:function()&#123;            this.btn=this.listBtn;        &#125;    &#125;,watch:&#123;        listTitle:&quot;changeTitle&quot;,        listList:&quot;changeList&quot;,        listBtn:&quot;changeBtn&quot;        // 冒号前边这个就是从父组件传过来的，后边的就是变化了的监听函数&#125;</code></pre><h2 id="is的用法（用于动态组件且基于-DOM-内模板的限制来工作。）"><a href="#is的用法（用于动态组件且基于-DOM-内模板的限制来工作。）" class="headerlink" title="is的用法（用于动态组件且基于 DOM 内模板的限制来工作。）"></a>is的用法（用于动态组件且基于 DOM 内模板的限制来工作。）</h2><p><strong>is用来动态切换组件，DOM模板解析</strong></p><pre><code class="js">&lt;table&gt; &lt;tr is=&quot;my-row&quot;&gt;&lt;/tr&gt; &lt;/table&gt;</code></pre><h2 id="vue脚手架配置代理"><a href="#vue脚手架配置代理" class="headerlink" title="vue脚手架配置代理"></a>vue脚手架配置代理</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>​在vue.config.js中添加如下配置：</p><pre><code class="js">devServer:&#123;  proxy:&quot;http://localhost:5000&quot;&#125;</code></pre><p>说明：</p><ol><li>优点：配置简单，请求资源时直接发给前端（8080）即可。</li><li>缺点：不能配置多个代理，不能灵活的控制请求是否走代理。</li><li>工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器 （优先匹配前端资源）</li></ol><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>​编写vue.config.js配置具体代理规则：</p><pre><code class="js">module.exports = &#123;    devServer: &#123;      proxy: &#123;      &#39;/api1&#39;: &#123;// 匹配所有以 &#39;/api1&#39;开头的请求路径        target: &#39;http://localhost:5000&#39;,// 代理目标的基础路径        changeOrigin: true,        pathRewrite: &#123;&#39;^/api1&#39;: &#39;&#39;&#125;      &#125;,      &#39;/api2&#39;: &#123;// 匹配所有以 &#39;/api2&#39;开头的请求路径        target: &#39;http://localhost:5001&#39;,// 代理目标的基础路径        changeOrigin: true,        pathRewrite: &#123;&#39;^/api2&#39;: &#39;&#39;&#125;      &#125;    &#125;  &#125;&#125;/*   changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000   changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:8080   changeOrigin默认值为true*/</code></pre><p>说明：</p><ol><li>优点：可以配置多个代理，且可以灵活的控制请求是否走代理。</li><li>缺点：配置略微繁琐，请求资源时必须加前缀。</li></ol><h2 id="1：vue-js2-x的两个核心是什么-数据驱动、组件系统。"><a href="#1：vue-js2-x的两个核心是什么-数据驱动、组件系统。" class="headerlink" title="1：vue.js2.x的两个核心是什么(数据驱动、组件系统。)"></a>1：vue.js2.x的两个核心是什么(数据驱动、组件系统。)</h2><p>数据驱动:Object.defineProperty和存储器属性: getter和setter（所以只兼容IE9及以上版本），可称为基于依赖收集的观测机制,核心是VM，即ViewModel，保证数据和视图的一致性。</p><pre><code class="javascript">            let number = 18            let person = &#123;                name : &#39;jack&#39;,                sex : &#39;男&#39;            &#125;            Object.defineProperty(person,&#39;age&#39;,&#123;                // value : 18,                // enumerable : true, //控制熟悉是否可以枚举，默认值是false                // writable : true, //控制熟悉是否可以被修改，默认值是false                // configurable : true, //控制属性是否可以被删除,默认值是false                //当有人读取person的age属性时，get函数(getter)就会被调用,且返回值就是age的值                get()&#123;                    console.log(&#39;有人读取了age&#39;)                    return number                &#125;,                //当有人修改person的age属性时，set函数(setter)就会被调用,且会收到修改的具体值                set(value)&#123;                    console.log(`有人修改了age，值为:$&#123;value&#125;`)                    number = value                &#125;            &#125;)</code></pre><p>组件系统:</p><h2 id="2：VUE数据代理的原理"><a href="#2：VUE数据代理的原理" class="headerlink" title="2：VUE数据代理的原理"></a>2：VUE数据代理的原理</h2><pre><code class="javascript">通过一个对象代理对另一个对象中的属性的操作(读写)let obj = &#123;x:100&#125;let obj2 = &#123;y:200&#125;Object.defineProperty(obj2,&#39;x&#39;,&#123;    get()&#123;        return obj.x    &#125;,    set()&#123;        obj.x = value    &#125;&#125;)1.Vue中的数据代理：    通过vm对象代理data对象中的数据(读/写)2.Vue中数据代理的好处：    更加方便的操作data中的数据3.基本原理    通过Object.defineProperty()把data对象中所有属性添加到vm上    为每一个添加到vm上的属性，都指定一个getter/setter    在getter/setter内部去操作(读/写)data中对应的属性</code></pre><h2 id="3：Vue-组件中-data-为什么必须是函数"><a href="#3：Vue-组件中-data-为什么必须是函数" class="headerlink" title="3：Vue 组件中 data 为什么必须是函数"></a>3：Vue 组件中 data 为什么必须是函数</h2><p>vue组件中data值不能为对象，因为对象是引用类型，组件可能会被多个实例同时引用。<br>如果data值为对象，将导致多个实例共享一个对象，其中一个组件改变data属性值，其它实例也会受到影响。</p><h2 id="4：Vue双向绑定的原理"><a href="#4：Vue双向绑定的原理" class="headerlink" title="4：Vue双向绑定的原理"></a>4：Vue双向绑定的原理</h2><pre><code class="javascript">如果被问到 Vue 怎么实现数据双向绑定，大家肯定都会回答 通过 Object.defineProperty() 对数据进行劫持，但是 Object.defineProperty() 只能对属性进行数据劫持，不能对整个对象进行劫持。同理无法对数组进行劫持，但是我们在使用 Vue 框架中都知道，Vue 能检测到对象和数组（部分方法的操作）的变化，那它是怎么实现的呢？我们查看相关代码如下：  /**   * Observe a list of Array items.   */  observeArray (items: Array&lt;any&gt;) &#123;    for (let i = 0, l = items.length; i &lt; l; i++) &#123;      observe(items[i])  // observe 功能为监测数据的变化    &#125;  &#125;  /**   * 对属性进行递归遍历   */  let childOb = !shallow &amp;&amp; observe(val) // observe 功能为监测数据的变化  通过以上 Vue 源码部分查看，我们就能知道 Vue 框架是通过遍历数组 和递归遍历对象，从而达到利用 Object.defineProperty() 也能对对象和数组（部分方法的操作）进行监听。  </code></pre><h2 id="5：Vue的diff算法（列表渲染key的作用和原理）"><a href="#5：Vue的diff算法（列表渲染key的作用和原理）" class="headerlink" title="5：Vue的diff算法（列表渲染key的作用和原理）"></a>5：Vue的diff算法（列表渲染key的作用和原理）</h2><pre><code class="javascript">1.虚拟DOM中key的作用:key是虚拟DOM对象的标识，当状态中的数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】随后，Vue进行【新的虚拟DOM】与【旧的虚拟DOM】的差异比较，比较规则如下2.对比规则:(1).旧虚拟DOM中找到了与新虚拟DOM相同的key:    1.若虚拟DOM中的内容没变，直接使用之前的真实DOM！    2.若虚拟DOM中的内容变了，则生成新的真实DOM，随后替换掉页面中之前的真实DOM(2).旧虚拟DOM中未找到与新虚拟DOM相同的key    1.创建新的真实DOM，随后渲染到页面3.用index作为key可能会引发的问题:    1.若对数据进行，逆序添加，逆序删除等破坏顺寻操作：        会产生没有必要的真实DOM更新 =&gt; 界面效果没问题，但是效率低    2.如果结构中还有包含输入类的DOM：        会产生错误DOM更新 =&gt; 界面有问题4.开发中如何选择key?:    1.最好使用每条数据的唯一标识作为key,比如id,手机号，身份证号，学号等唯一值    2.如果不存在对数据的逆序添加，逆序删除等破坏性顺序操作，仅用于渲染列表展示，使用index作为key是没问题的</code></pre><h2 id="6：Vue是怎么检测数据的改变的原理"><a href="#6：Vue是怎么检测数据的改变的原理" class="headerlink" title="6：Vue是怎么检测数据的改变的原理"></a>6：Vue是怎么检测数据的改变的原理</h2><pre><code class="javascript">let data = &#123;    name :&#39;jack&#39;,    age : 18&#125;//创建一个监视的实例对象，用于监视data中属性的变化const obs = new Observer(data)//准备一个vm实例对象let vm = &#123;&#125;vm._data = data = obsfunction Observer(obj)&#123;    //汇总对象中所有属性形成的数组    const keys = Object.keys(obj)    //遍历    keys.forEach((k)=&gt;&#123;        Object.defineProperty(this,k,&#123;            get()&#123;                return obj[k]            &#125;,            set(val)&#123;                console.log(`$&#123;k&#125;被改了，我要去解析模板了，生成虚拟DOM`)                obj[k] = val            &#125;        &#125;)    &#125;)&#125;  //自己实现的基本的原理，只是对第一层的基本数据类型进行检测。无法检测到里面的Vue的底层对data中的对象数据检测进行了递归，所以都能检测到，数组里的对象数据没有检测</code></pre><h2 id="7-v-model-的原理？"><a href="#7-v-model-的原理？" class="headerlink" title="7. v-model 的原理？"></a>7. v-model 的原理？</h2><h2 id="8-使用过-Vue-SSR-吗？说说-SSR？"><a href="#8-使用过-Vue-SSR-吗？说说-SSR？" class="headerlink" title="8.使用过 Vue SSR 吗？说说 SSR？"></a>8.使用过 Vue SSR 吗？说说 SSR？</h2><pre><code class="javascript">Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记&quot;激活&quot;为客户端上完全可交互的应用程序。即：SSR大致的意思就是vue在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的html 片段直接返回给客户端这个过程就叫做服务端渲染。服务端渲染 SSR 的优缺点如下：（1）服务端渲染的优点：更好的 SEO：因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；更快的内容到达时间（首屏加载更快）：SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间；（2) 服务端渲染的缺点：更多的开发条件限制：例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；更多的服务器负载：在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。</code></pre><h2 id="9-Vue-框架怎么实现对象和数组的监听？"><a href="#9-Vue-框架怎么实现对象和数组的监听？" class="headerlink" title="9. Vue 框架怎么实现对象和数组的监听？"></a>9. Vue 框架怎么实现对象和数组的监听？</h2><pre><code class="javascript">Vue 数据双向绑定主要是指：数据变化更新视图，视图变化更新数据。即：输入框内容变化时，Data 中的数据同步变化。即 View =&gt; Data 的变化。Data 中的数据变化时，文本节点的内容同步变化。即 Data =&gt; View 的变化。其中，View 变化更新 Data ，可以通过事件监听的方式来实现，所以 Vue 的数据双向绑定的工作主要是如何根据 Data 变化更新 View。Vue 主要通过以下 4 个步骤来实现数据双向绑定的：实现一个监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。实现一个解析器 Compile：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。实现一个订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。实现一个订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。</code></pre><h2 id="10-Vue-怎么用-vm-set-解决对象新增属性不能响应的问题-？"><a href="#10-Vue-怎么用-vm-set-解决对象新增属性不能响应的问题-？" class="headerlink" title="10. Vue 怎么用 vm.$set() 解决对象新增属性不能响应的问题 ？"></a>10. Vue 怎么用 vm.$set() 解决对象新增属性不能响应的问题 ？</h2><pre><code class="javascript">受现代 JavaScript 的限制 ，Vue 无法检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。但是 Vue 提供了 Vue.set (object, propertyName, value) / vm.$set (object, propertyName, value)来实现为对象添加响应式属性，那框架本身是如何实现的呢？我们查看对应的 Vue 源码：vue/src/core/instance/index.jsexport function set (target: Array&lt;any&gt; | Object, key: any, val: any): any &#123;  // target 为数组  if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;    // 修改数组的长度, 避免索引&gt;数组长度导致splcie()执行有误    target.length = Math.max(target.length, key)    // 利用数组的splice变异方法触发响应式    target.splice(key, 1, val)    return val  &#125;  // key 已经存在，直接修改属性值  if (key in target &amp;&amp; !(key in Object.prototype)) &#123;    target[key] = val    return val  &#125;  const ob = (target: any).__ob__  // target 本身就不是响应式数据, 直接赋值  if (!ob) &#123;    target[key] = val    return val  &#125;  // 对属性进行响应式处理  defineReactive(ob.value, key, val)  ob.dep.notify()  return val&#125;我们阅读以上源码可知，vm.$set 的实现原理是：如果目标是数组，直接使用数组的 splice 方法触发相应式；如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 defineReactive 方法进行响应式处理（ defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法）</code></pre><h2 id="11-虚拟-DOM-的优缺点？"><a href="#11-虚拟-DOM-的优缺点？" class="headerlink" title="11. 虚拟 DOM 的优缺点？"></a>11. 虚拟 DOM 的优缺点？</h2><pre><code class="javascript">优点：保证性能下限： 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；无需手动操作 DOM： 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；跨平台： 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。缺点:无法进行极致优化： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。</code></pre><h2 id="12-虚拟-DOM-实现原理？"><a href="#12-虚拟-DOM-实现原理？" class="headerlink" title="12. 虚拟 DOM 实现原理？"></a>12. 虚拟 DOM 实现原理？</h2><pre><code class="javascript">虚拟 DOM 的实现原理主要包括以下 3 部分：用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；diff 算法 — 比较两棵虚拟 DOM 树的差异；pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。</code></pre><h2 id="13-Vue-中的-key-有什么作用？"><a href="#13-Vue-中的-key-有什么作用？" class="headerlink" title="13. Vue 中的 key 有什么作用？"></a>13. Vue 中的 key 有什么作用？</h2><pre><code class="javascript">key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速。Vue 的 diff 过程可以概括为：oldCh 和 newCh 各有两个头尾的变量 oldStartIndex、oldEndIndex 和 newStartIndex、newEndIndex，它们会新节点和旧节点会进行两两对比，即一共有4种比较方式：newStartIndex 和oldStartIndex 、newEndIndex 和 oldEndIndex 、newStartIndex 和 oldEndIndex 、newEndIndex 和 oldStartIndex，如果以上 4 种比较都没匹配，如果设置了key，就会用 key 再进行比较，在比较的过程中，遍历会往中间靠，一旦 StartIdx &gt; EndIdx 表明 oldCh 和 newCh 至少有一个已经遍历完了，就会结束比较。所以 Vue 中 key 的作用是：key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速!更准确：因为带 key 就不是就地复用了，在 sameNode 函数 a.key === b.key 对比中可以避免就地复用的情况。所以会更加准确。更快速：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快，源码如下：function createKeyToOldIdx (children, beginIdx, endIdx) &#123;  let i, key  const map = &#123;&#125;  for (i = beginIdx; i &lt;= endIdx; ++i) &#123;    key = children[i].key    if (isDef(key)) map[key] = i  &#125;  return map&#125;</code></pre><h2 id="14-你有对-Vue-项目进行哪些优化？"><a href="#14-你有对-Vue-项目进行哪些优化？" class="headerlink" title="14. 你有对 Vue 项目进行哪些优化？"></a>14. 你有对 Vue 项目进行哪些优化？</h2><pre><code class="javascript">（1）代码层面的优化v-if 和 v-show 区分使用场景computed 和 watch 区分使用场景v-for 遍历必须为 item 添加 key，且避免同时使用 v-if长列表性能优化事件的销毁图片资源懒加载路由懒加载第三方插件的按需引入优化无限列表性能服务端渲染 SSR or 预渲染（2）Webpack 层面的优化Webpack 对图片进行压缩减少 ES6 转为 ES5 的冗余代码提取公共代码模板预编译提取组件的 CSS优化 SourceMap构建结果输出分析Vue 项目的编译优化（3）基础的 Web 技术的优化开启 gzip 压缩浏览器缓存CDN 的使用使用 Chrome Performance 查找性能瓶颈</code></pre><h2 id="15-对于-vue3-0-特性你有什么了解的吗？"><a href="#15-对于-vue3-0-特性你有什么了解的吗？" class="headerlink" title="15. 对于 vue3.0 特性你有什么了解的吗？"></a>15. 对于 vue3.0 特性你有什么了解的吗？</h2><pre><code class="javascript">Vue 3.0 的目标是让 Vue 核心变得更小、更快、更强大，因此 Vue 3.0 增加以下这些新特性：（1）监测机制的改变3.0 将带来基于代理 Proxy 的 observer 实现，提供全语言覆盖的反应性跟踪。这消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制：只能监测属性，不能监测对象检测属性的添加和删除；检测数组索引和长度的变更；支持 Map、Set、WeakMap 和 WeakSet。新的 observer 还提供了以下特性：用于创建 observable 的公开 API。这为中小规模场景提供了简单轻量级的跨组件状态管理解决方案。默认采用惰性观察。在 2.x 中，不管反应式数据有多大，都会在启动时被观察到。如果你的数据集很大，这可能会在应用启动时带来明显的开销。在 3.x 中，只观察用于渲染应用程序最初可见部分的数据。更精确的变更通知。在 2.x 中，通过 Vue.set 强制添加新属性将导致依赖于该对象的 watcher 收到变更通知。在 3.x 中，只有依赖于特定属性的 watcher 才会收到通知。不可变的 observable：我们可以创建值的“不可变”版本（即使是嵌套属性），除非系统在内部暂时将其“解禁”。这个机制可用于冻结 prop 传递或 Vuex 状态树以外的变化。更好的调试功能：我们可以使用新的 renderTracked 和 renderTriggered 钩子精确地跟踪组件在什么时候以及为什么重新渲染。（2）模板模板方面没有大的变更，只改了作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。（3）对象式的组件声明方式vue2.x 中的组件是通过声明的方式传入一系列 option，和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易。此外，vue 的源码也改用了 TypeScript 来写。其实当代码的功能复杂之后，必须有一个静态类型系统来做一些辅助管理。现在 vue3.0 也全面改用 TypeScript 来重写了，更是使得对外暴露的 api 更容易结合 TypeScript。静态类型系统对于复杂代码的维护确实很有必要。（4）其它方面的更改vue3.0 的改变是全面的，上面只涉及到主要的 3 个方面，还有一些其他的更改：支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。基于 treeshaking 优化，提供了更多的内置功能。</code></pre><h2 id="16-响应式原理（变化侦测）"><a href="#16-响应式原理（变化侦测）" class="headerlink" title="16. 响应式原理（变化侦测）"></a>16. 响应式原理（变化侦测）</h2><p><strong>使用发布订阅模式将数据劫持和模板编译结合，实现双向绑定</strong></p><pre><code class="javascript">1、observer: 封装 Object.defineProperty 方法用来劫持对象属性的getter和setter，以此来追踪数据变化。2、读取数据时触发getter来收集依赖(Watcher)到Dep。3、修改数据时触发setter，并遍历依赖列表，通知所有相关依赖（Watcher）4、Dep 类为依赖找一个存储依赖的地方，用来收集和管理依赖，在getter中收集，在setter中通知。5、Watcher 类就是收集的依赖，实际上是一个订阅器，Watcher会将自己的实例赋值给window.target（全局变量）上，然后去主动访问属性，触发属性的getter，getter中会将此Watcher收集到Dep中，Watcher的update方法会在Dep的通知方法中被调用，触发更新。6、Observer 类用来将一个对象的所有属性和子属性都变成响应式的，通过递归调用defineReactive来实现。7、由于无法侦测对象上新增/删除属性，所以提供 $set 和 $delete API5。28. Object.defineProperty怎么用， 三个参数？，有什么作用啊？Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。   obj：需要定义属性的对象     prop：需要定义的属性     &#123;&#125;：要定义或修改的属性描述符。         value: &quot;18&quot;,         // 设置默认值 （与 get() 互斥）         enumerable: true,    //这一句控制属性可以枚举 enumerable 改为true 就可以参与遍历了   默认值false         writable: true,      // 该属性是否可写   默认值false （与 set() 互斥）         configurable: true,  // 该属性是否可被删除   默认值false          get // 当有人读取 prop 的时候  get函数就会调用,并且返回就是 sss 的值          set // 当有人修改 prop 的时候  set函数就会调用, 有个参数这个参数就是修改后的值</code></pre><h2 id="17-vue2和vue3的响应式原理都有什么区别呢？"><a href="#17-vue2和vue3的响应式原理都有什么区别呢？" class="headerlink" title="17. vue2和vue3的响应式原理都有什么区别呢？"></a>17. vue2和vue3的响应式原理都有什么区别呢？</h2><pre><code class="javascript">vue2 用的是 Object.defindProperty 但是vue3用的是ProxyObject.defindProperty 缺点：一次只能对一个属性进行监听，需要遍历来对所有属性监听对于对象的新增属性，需要手动监听对于数组通过push、unshift方法增加的元素，也无法监听Proxy就没有这个问题，可以监听整个对象的数据变化，所以用vue3.0会用Proxy代替definedProperty。</code></pre><h2 id="18-Vue-模板编译原理"><a href="#18-Vue-模板编译原理" class="headerlink" title="18. Vue 模板编译原理"></a>18. Vue 模板编译原理</h2><pre><code class="javascript">模板字符串 转换成 element AST（解析器）Vue-loader 切割解析 .vue 文件（parseHTML按标签以出栈入栈形式切割（自闭合不入栈直接处理），出栈时维护父子关系）生成 AST（抽象语法树）使用大量正则匹配开始结束标签，while指针定位解析位置，对 AST 进行静态节点标记，主要用来做虚拟DOM的渲染优化（优化器）在dom更新时不需 diff 静态节点。使用 element AST 生成 render 函数代码字符串（代码生成器）Vue-template-compiler再解析成render（可执行函数字符串-with(this)=&gt;&#123;return _c(‘div’)&#125;），new Function 生成函数，传递给组件的 render在组件渲染的时候直接调用 render 即可</code></pre><h2 id="19-Vue原理总结"><a href="#19-Vue原理总结" class="headerlink" title="19. Vue原理总结"></a>19. Vue原理总结</h2><pre><code class="javascript">【模板编译】将template模板，经过编译系统后生成VNode，（模板字符串→AST→Render函数）【渲染】然后再通过渲染系统来将VNode生成真实DOM（document.createElement &amp;&amp; Mount挂载到真实DOM节点上）【响应式】通过响应式系统对数据进行监听，当数据发生改变时，触发依赖项（组件）【Diff &amp; Patch】组件内收到通知后，会通过diff算法对比VNode的变化，尽可能复用代码，找出最小差异，保证性能消耗最小。【渲染】拿到需要新增/删除/修改的VNode后，逐一去操作真实DOM进行修改（通过选择器选择到对应真实DOM节点进行修改）</code></pre><h1 id="对Vue的理解"><a href="#对Vue的理解" class="headerlink" title="对Vue的理解"></a>对Vue的理解</h1><h2 id="谈谈对MVVM的理解"><a href="#谈谈对MVVM的理解" class="headerlink" title="谈谈对MVVM的理解"></a>谈谈对MVVM的理解</h2><p>M-model，model代表数据模型，也可以在model中定义数据修改和操作的业务逻辑</p><p>V-view,view代表UI组件，它负责将数据模型转化为UI展现出来</p><p>VM-viewmodel,viewmodel监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步view和model的对象，连接model和view</p><h2 id="vue是渐进式的框架的理解：-主张最少-没有多做职责之外的事"><a href="#vue是渐进式的框架的理解：-主张最少-没有多做职责之外的事" class="headerlink" title="vue是渐进式的框架的理解：(主张最少,没有多做职责之外的事)"></a>vue是渐进式的框架的理解：(主张最少,没有多做职责之外的事)</h2><p>Vue的核心的功能，是一个视图模板引擎，但这不是说Vue就不能成为一个框架。如下图所示，这里包含了Vue的所有部件，在声明式渲染（视图模板引擎）的基础上，我们可以通过添加组件系统、客户端路由、大规模状态管理来构建一个完整的框架。更重要的是，这些功能相互独立，你可以在核心功能的基础上任意选用其他的部件，不一定要全部整合在一起。可以看到，所说的“渐进式”，其实就是Vue的使用方式，同时也体现了Vue的设计的理念<br>在我看来，渐进式代表的含义是：主张最少。视图模板引擎<br>每个框架都不可避免会有自己的一些特点，从而会对使用者有一定的要求，这些要求就是主张，主张有强有弱，它的强势程度会影响在业务开发中的使用方式。<br>比如说，Angular，它两个版本都是强主张的，如果你用它，必须接受以下东西：<br>必须使用它的模块机制- 必须使用它的依赖注入- 必须使用它的特殊形式定义组件（这一点每个视图框架都有，难以避免）<br>所以Angular是带有比较强的排它性的，如果你的应用不是从头开始，而是要不断考虑是否跟其他东西集成，这些主张会带来一些困扰。<br>Vue可能有些方面是不如React，不如Angular，但它是渐进的，没有强主张，你可以在原有大系统的上面，把一两个组件改用它实现，当jQuery用；也可以整个用它全家桶开发，当Angular用；还可以用它的视图，搭配你自己设计的整个下层用。也可以函数式，都可以，它只是个轻量视图而已，只做了自己该做的事，没有做不该做的事，仅此而已。<br><strong>渐进式的含义，我的理解是：没有多做职责之外的事。</strong></p><h2 id="SPA-单页面应用及其优缺点"><a href="#SPA-单页面应用及其优缺点" class="headerlink" title="SPA 单页面应用及其优缺点"></a>SPA 单页面应用及其优缺点</h2><p><strong>缺点：</strong></p><p>不支持低版本的浏览器，最低只支持到IE9；<br>不利于SEO的优化（如果要支持SEO，建议通过服务端来进行渲染组件）；<br>第一次加载首页耗时相对长一些；<br>不可以使用浏览器的导航按钮需要自行实现前进、后退。</p><p><strong>优点：</strong></p><p>无刷新体验,提升了用户体验；<br>前端开发不再以页面为单位，更多地采用组件化的思想，代码结构和组织方式更加规范化，便于修改和调整；<br>API 共享，同一套后端程序代码不用修改就可以用于Web界面、手机、平板等多种客户端<br>用户体验好、快，内容的改变不需要重新加载整个页面。</p><h2 id="怎样理解-Vue-的单向数据流？"><a href="#怎样理解-Vue-的单向数据流？" class="headerlink" title="怎样理解 Vue 的单向数据流？"></a>怎样理解 Vue 的单向数据流？</h2><pre><code class="javascript">所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Express + vue搭建SSR</title>
      <link href="/performance-optimization/Express%20+%20vue%E6%90%AD%E5%BB%BASSR/"/>
      <url>/performance-optimization/Express%20+%20vue%E6%90%AD%E5%BB%BASSR/</url>
      
        <content type="html"><![CDATA[<h2 id="Express-vue搭建SSR"><a href="#Express-vue搭建SSR" class="headerlink" title="Express + vue搭建SSR"></a><strong>Express + vue搭建SSR</strong></h2><p>最近简单的研究了一下<code>SSR</code>，对<code>SSR</code>已经有了一个简单的认知，主要应用于单页面应用，<code>Nuxt</code>是<code>SSR</code>很不错的框架。也有过调研，简单的用了一下，感觉还是很不错。但是还是想知道若不依赖于框架又应该如果处理<code>SSR</code>,研究一下做个笔记。</p><h3 id="什么是SSR"><a href="#什么是SSR" class="headerlink" title="什么是SSR"></a><strong>什么是SSR</strong></h3><p>把<code>Vue</code>组件渲染为服务器端的<code>HTML</code>字符串，将他们直接发送到浏览器，最后将静态标记<code>混合</code>为客户端上完全交互的应用程序。</p><h3 id="为什么要使用SSR"><a href="#为什么要使用SSR" class="headerlink" title="为什么要使用SSR"></a><strong>为什么要使用SSR</strong></h3><p>更好的SEO，搜索引擎爬虫爬取工具可以直接查看完全渲染的页面 更宽的内容达到时间（time-to-content），当权请求页面的时候，服务端渲染完数据之后，把渲染好的页面直接发送给浏览器，并进行渲染。浏览器只需要解析<code>html</code>不需要去解析<code>js</code>。</p><h3 id="SSR弊端"><a href="#SSR弊端" class="headerlink" title="SSR弊端"></a><strong>SSR弊端</strong></h3><p>开发条件受限，<code>Vue</code>组件的某些生命周期钩子函数不能使用 开发环境基于<code>Node.js</code> 会造成服务端更多的负载。在<code>Node.js</code>中渲染完整的应用程序，显然会比仅仅提供静态文件<code>server</code>更加占用<code>CPU</code>资源，因此如果你在预料在高流量下使用，请准备响应的服务负载，并明智的采用缓存策略。</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a><strong>准备工作</strong></h3><p>在正式开始之前，在<code>vue</code>官网找到了一张这个图片，图中详细的讲述了<code>vue</code>中对<code>ssr</code>的实现思路。如下图简单的说一下。</p><p>下图中很重要的一点就是<code>webpack</code>，在项目过程中会用到<code>webpack</code>的配置，从最左边开始就是我们所写入的源码文件，所有的文件都有一个公共的入口文件<code>app.js</code>，然后就进入了<code>server-entry</code>(服务端入口)和<code>client-entry</code>(客户端入口)，两个入口文件都要经过<code>webpack</code>，当访问<code>node</code>端的时候，使用的是服务端渲染，在服务端渲染的时候，会生成一个<code>server-Bender</code>，最后通过<code>server-Bundle</code>可以渲染出<code>HTML</code>页面，若在客户端访问的时候则是使用客户端渲染，通过<code>client-Bundle</code>在以后渲染出<code>HTML</code>页面。so~通过这个图可以很清晰的看出来，接下来会用到两个文件，一个<code>server</code>入口，一个<code>client</code>入口，最后由<code>webpack</code>生成<code>server-Bundle</code>和<code>client-Bundle</code>，最终当去请求页面的时候，<code>node</code>中的<code>server-Bundle</code>会生成<code>HTML</code>界面通过<code>client-Bundle</code>混合到<code>html</code>页面中即可。</p><html><pre><code>&lt;img src=&quot;https://pic.xiaohuochai.site/blogssr1.png&quot;/&gt;</code></pre></html><p>对于<code>vue</code>中使用<code>ssr</code>做了一些简单的了解之后，那么就开始我们要做的第一步吧，首先要创建一个项目，创建一个文件夹，名字不重要，但是最好不要使用中文。</p><pre><code>mkdir domecd domenpm init</code></pre><p><code>npm init</code>命令用来初始化<code>package.json</code>文件：</p><pre><code>&#123;  &quot;name&quot;: &quot;dome&quot;,   //  项目名称  &quot;version&quot;: &quot;1.0.0&quot;,   //  版本号  &quot;description&quot;: &quot;&quot;,    //  描述  &quot;main&quot;: &quot;index.js&quot;,   //  入口文件  &quot;scripts&quot;: &#123;          //  命令行执行命令 如：npm run test    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;  &#125;,  &quot;author&quot;: &quot;Aaron&quot;,     //  作者  &quot;license&quot;: &quot;ISC&quot;      //  许可证&#125;</code></pre><p>初始化完成之后接下来需要安装，项目所需要依赖的包，所有依赖项如下：</p><pre><code>npm install express --save-devnpm install vue --save-devnpm install vue-server-renderer --save-devnpm install vue-router --save-dev</code></pre><p>如上所有依赖项一一安装即可，安装完成之后就可以进行下一步了。前面说过<code>SSR</code>是服务端预渲染，所以当然要创建一个<code>Node</code>服务来支撑。在<code>dome</code>文件夹下面创建一个<code>index.js</code>文件，并使用<code>express</code>创建一个服务。</p><p>代码如下：</p><pre><code>const express = require(&quot;express&quot;);const app = express();app.get(&#39;*&#39;,(request,respones) =&gt; &#123;    respones.end(&quot;ok&quot;);&#125;)app.listen(3000,() =&gt; &#123;    console.log(&quot;服务已启动&quot;)&#125;);</code></pre><p>完成上述代码之后，为了方便我们需要在<code>package.json</code>添加一个命令，方便后续开发启动项目。</p><pre><code>&#123;  &quot;scripts&quot;: &#123;    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,    &quot;start&quot;: &quot;node index.js&quot;  &#125;&#125;</code></pre><p>创建好之后，在命令行直接输入<code>npm start</code>即可，当控制台显示<code>服务已启动</code>则表示该服务已经启动成功了。接下来需要打开浏览器看一下渲染的结果。在浏览器地址栏输入<code>locahost:3000</code>则可以看到<code>ok</code>两个字。</p><h3 id="SSR渲染手动搭建"><a href="#SSR渲染手动搭建" class="headerlink" title="SSR渲染手动搭建"></a><strong>SSR渲染手动搭建</strong></h3><p>前面的准备工作已经做好了，千万不要完了我们的主要目的不是为了渲染文字，主要的目标是为了渲染<code>*.vue</code>文件或<code>html</code>所以。接下来就是做我们想要做的事情了。接下来就是要修改<code>index.js</code>文件，将之前安装的<code>vue</code>和<code>vue-server-renderer</code>引入进来。</p><p>由于返回的不再是文字，而是<code>html</code>模板，所以我们要对响应头进行更改，告诉浏览器我们渲染的是什么，否则浏览器是不知道该如何渲染服务器返回的数据。</p><p>在<code>index.js</code>中引入了<code>vue-server-renderer</code>之后，在使用的时候，我们需要执行一下<code>vue-server-renderer</code>其中的<code>createRenderer</code>方法，这个方法的作用就是会将<code>vue</code>的实例转换成<code>html</code>的形式。</p><p>既然有了<code>vue-server-renderer</code>的方法，接下来就需要引入主角了<code>vue</code>,引入之后然后接着在下面创建一个<code>vue</code>实例，在<code>web</code>端使用<code>vue</code>的时候需要传一些参数给<code>Vue</code>然而在服务端也是如此也可以传递一些参数给<code>Vue</code>实例，这个实例也就是后续添加的那些<code>*.vue</code>文件。为了防止用户访问的时候页面数据不会互相干扰，暂时需要把实例放到<code>get</code>请求中，每次有访问的时候就会创建一个新的实例，渲染新的模板。</p><p><code>creteRender</code>方法能够把<code>vue</code>的实例转成<code>html</code>字符串传递到浏览器。那么接下来由应该怎么做？在<code>vueServerRender</code>方法下面有一个<code>renderToString</code>方法，这个方法就可以帮助我们完成这步操作。这个方法接受的第一个参数是<code>vue</code>的实例，第二个参数是一个回调函数，如果不想使用回调函数的话，这个方法也返回了一个<code>Promise</code>对象，当方法执行成功之后，会在<code>then</code>函数里面返回<code>html</code>结构。</p><p>index.js改动如下：</p><pre><code>const express = require(&quot;express&quot;);const Vue = require(&quot;vue&quot;);const vueServerRender = require(&quot;vue-server-renderer&quot;).createRenderer();const app = express();app.get(&#39;*&#39;,(request,respones) =&gt; &#123;    const vueApp = new Vue(&#123;        data:&#123;            message:&quot;Hello,Vue SSR!&quot;        &#125;,        template:`&lt;h1&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt;`     &#125;);    respones.status(200);    respones.setHeader(&quot;Content-Type&quot;,&quot;text/html;charset-utf-8;&quot;);    vueServerRender.renderToString(vueApp).then((html) =&gt; &#123;        respones.end(html);    &#125;).catch(error =&gt; console.log(error));&#125;)app.listen(3000,() =&gt; &#123;    console.log(&quot;服务已启动&quot;)&#125;);</code></pre><p>上述操作完成之后，一定要记得保存，然后重启服务器，继续访问一下<code>locahost:3000</code>，就会看到在服务端写入的<code>HTML</code>结构了。这样做好像给我们添加了大量的工作，到底与在<code>web</code>端直接使用有什么区别么？</p><p>接下来见证奇迹的时刻到了。在网页中右键<code>查看源代码</code>就会发现与之前的在<code>web</code>端使用的时候完全不同，可以看到渲染的模板了。如果细心的就会发现一件很有意思的事情，在<code>h1</code>标签上会有一个<code>data-server-rendered=true</code>这样的属性，这个可以告诉我们这个页面是通过服务端渲染来做的。大家可以去其他各大网站看看哦。没准会有其他的收获。</p><p>上面的案例中，虽然已经实现了服务端预渲染，但是会有一个很大的缺陷，就是我们所渲染的这个网页并不完整，没有文档声明，<code>head</code>等等等，当然可能会有一个其他的想法，就是使用<code>es6</code>的模板字符串做拼接就好了啊。确实，这样也是行的通的，但是这个仍是饮鸩止渴不能彻底的解决问题，如果做过传统<code>MVC</code>开发的话，就应该知道，<code>MVC</code>开发模式全是基于模板的，现在这种与<code>MVC</code>有些相似的地方，同理也是可以使用模板的。在<code>dome</code>文件夹下创建<code>index.html</code>，并创建好<code>HTML</code>模板。</p><p>模板现在有了该如何使用？在<code>createRenderer</code>函数可以接收一个对象作为配置参数。配置参数中有一项为<code>template</code>,这项配置的就是我们即将使用的<code>Html</code>模板。这个接收的不是一个单纯的路径，我们需要使用<code>fs</code>模块将<code>html</code>模板读取出来。</p><p>其配置如下：</p><pre><code>let path = require(&quot;path&quot;);const vueServerRender = require(&quot;vue-server-renderer&quot;).createRenderer(&#123;    template:require(&quot;fs&quot;).readFileSync(path.join(__dirname,&quot;./index.html&quot;),&quot;utf-8&quot;)&#125;);</code></pre><p>现在模板已经有了，在<code>web</code>端进行开发的时候，需要挂在一个<code>el</code>的挂载点，这样<code>Vue</code>才知道把这些<code>template</code>渲染在哪，服务端渲染也是如此，同样也需要告诉<code>Vue</code>将<code>template</code>渲染到什么地方。接下来要做的事情就是在<code>index.html</code>中做手脚。来通知<code>createRenderer</code>把<code>template</code>添加到什么地方。</p><p>更改<code>index.html</code>文件：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html &gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;&lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;!--vue-ssr-outlet--&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>可以发现，在<code>html</code>的<code>body</code>里面添加了一段注释，当将<code>vueServerRender</code>编译好的<code>html</code>传到模板当中之后这个地方将被替换成服务端预编译的模板内容，这样也算是完成一个简单的服务端预渲染了。虽然写入的只是简单的<code>html</code>渲染，没有数据交互也没有页面交互，也算是一个不小的进展了。</p><p>使用<code>SSR</code>搭建项目我们继续延续上个项目继续向下开发，大家平时在使用<code>vue-cli</code>搭建项目的时候，都是在<code>src</code>文件夹下面进行开发的，为了和<code>vue</code>项目结构保持一致，同样需要创建一个<code>src</code>文件夹，并在<code>src</code>文件夹创建<code>conponents,router,utils,view</code>,暂定项目结构就这样，随着代码的编写会逐渐向项目里面添加内容。</p><pre><code>└─src|   ├─components|   ├─router|   ├─utils|   ├─view|   └─app.js└─index.js</code></pre><p>初始的目录结构已经搭建好了之后，接下来需要继续向下进行，首先要做的就是要在<code>router</code>目录中添加一个<code>index.js</code>文件，用来创建路由信息（在使用路由的时候一定要确保路由已经安装）。路由在项目中所起到的作用应该是重要的，路由会通过路径把页面和组件之间建立联系，并且一一的对应起来，完成路由的渲染。</p><p>接下来在<code>router</code>下面的<code>index.js</code>文件中写入如下配置：</p><pre><code>const vueRouter = require(&quot;vue-router&quot;);const Vue = require(&quot;vue&quot;);Vue.use(vueRouter);module.exports = () =&gt; &#123;    return new vueRouter(&#123;        mode:&quot;history&quot;,        routes:[            &#123;                path:&quot;/&quot;,                component:&#123;                    template:`&lt;h1&gt;这里是首页&lt;/h1&gt;`                &#125;,                name:&quot;home&quot;            &#125;,            &#123;                path:&quot;/about&quot;,                component:&#123;                    template:`&lt;h1&gt;这里是关于我&lt;/h1&gt;`                &#125;,                name:&quot;about&quot;            &#125;        ]    &#125;)&#125;</code></pre><p>上面的代码中，仔细观察的话，和平时在<code>vue-cli</code>中所导出的方式是不一样的，这里采用了工厂方法，这里为什么要这样？记得在雏形里面说过，为了保证用户每次访问都要生成一个新的路由，防止用户与用户之间相互影响，也就是说Vue实例是新的，我们的<code>vue-router</code>的实例也应该保证它是一个全新的。</p><p>现在<code>Vue</code>实例和服务端混在一起，这样对于项目的维护是很不好的，所以也需要把<code>Vue</code>从服务端单独抽离出来，放到<code>app.js</code>中去。这里采用和<code>router</code>同样的方式使用工厂方式，以保证每次被访问都是一个全新的<code>vue</code>实例。在<code>app.js</code>导入刚刚写好的路由，在每次触发工厂的时候，创建一个新的路由实例，并绑定到<code>vue</code>实例里面，这样用户在访问路径的时候无论是<code>vue</code>实例还是<code>router</code>都是全新的了。</p><p>app.js：</p><pre><code>const Vue = require(&quot;vue&quot;);const createRouter = require(&quot;../router&quot;)module.exports = (context) =&gt; &#123;    const router = createRouter();    return new Vue(&#123;        router,        data:&#123;            message:&quot;Hello,Vue SSR!&quot;        &#125;,        template:`            &lt;div&gt;                &lt;div&gt;                    &lt;h1&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt;                    &lt;ul&gt;                        &lt;li&gt;                            &lt;router-link to=&quot;/&quot;&gt;首页&lt;/router-link&gt;                        &lt;/li&gt;                        &lt;li&gt;                            &lt;router-link to=&quot;/about&quot;&gt;关于我&lt;/router-link&gt;                        &lt;/li&gt;                    &lt;/ul&gt;                &lt;/div&gt;                &lt;router-view&gt;&lt;/router-view&gt;            &lt;/div&gt;        `     &#125;);&#125;</code></pre><p>做完这些东西貌似好像就能用了一样，但是还是不行，仔细想想好像忘了一些什么操作，刚刚把<code>vue</code>实例从<code>index.js</code>中抽离出来了，但是却没有在任何地方使用它，哈哈，好像是一件很尴尬的事情。</p><p>修改<code>index.js</code>文件：</p><pre><code>const express = require(&quot;express&quot;);const vueApp = require(&quot;./src/app.js&quot;);let path = require(&quot;path&quot;);const vueServerRender = require(&quot;vue-server-renderer&quot;).createRenderer(&#123;  template:require(&quot;fs&quot;).readFileSync(path.join(__dirname,&quot;./index.html&quot;),&quot;utf-8&quot;)&#125;);const app = express();app.get(&#39;*&#39;,(request,respones) =&gt; &#123;        //  这里可以传递给vue实例一些参数    let vm = vueApp(&#123;&#125;)        respones.status(200);    respones.setHeader(&quot;Content-Type&quot;,&quot;text/html;charset-utf-8;&quot;);    vueServerRender.renderToString(vm).then((html) =&gt; &#123;        respones.end(html);    &#125;).catch(error =&gt; console.log(error));&#125;)app.listen(3000,() =&gt; &#123;    console.log(&quot;服务已启动&quot;)&#125;);</code></pre><p>准备工作都已经做好啦，完事具备只欠东风啦。现在运行一下<code>npm start</code>可以去页面上看一下效果啦。看到页面中已经渲染出来了，但是好像是少了什么？虽然导航内容已经都显示出来了，但是路由对应的组件好像没得渲染噻。具体是什么原因导致的呢，<code>vue-router</code>是由前端控制渲染的，当访问路由的时候其实，在做首屏渲染的时候并没有授权给服务端让其去做渲染路由的工作。(⊙﹏⊙)，是的我就是这么懒…</p><p>这个问题解决方案也提供了相对应的操作，不然就知道该怎么写下去了。既然在做渲染的时候分为服务端渲染和客户端渲染两种，那么我们就需要两个入口文件，分别对应的服务端渲染的入口文件，另个是客户端渲染的入口文件。</p><p>在<code>src</code>文件夹下面添加两个<code>.js</code>文件(当然也可以放到其他地方，这里只是为了方便),<code>entry-client.js</code>这个文件用户客户端的入口文件，<code>entry-server.js</code>那么这个文件则就作为服务端的入口文件。既然入口文件已经确定了，接下来就是要解决刚才的问题了,首先解决的是服务端渲染，在服务端这里需要把用户所访问的路径传递给<code>vue-router</code>，如果不传递给<code>vue-router</code>的话，<code>vue-router</code>会一脸懵逼的看着你，你什么都不给我，我怎么知道渲染什么？</p><p>在<code>entry-server</code>中需要做的事情就是需要把<code>app.js</code>导入进来，这里可以向上翻一下<code>app.js</code>中保存的是创建vue实例的方法。首先在里面写入一个函数，至于为什么就不多说了（同样也是为了保证每次访问都有一个新的实例），这个函数接收一个参数（<code>[object]</code>），由于这里考虑到可能会有异步操作(如懒加载)，在这个函数中使用了<code>Promise</code>，在<code>Promise</code>中首先要拿到连个东西，不用猜也是能想到的，很重要的<code>vue</code>实例和<code>router</code>实例，so~但是在<code>app</code>中好像只导出了<code>vue</code>实例，还要根据当前所需要的去更改<code>app.js</code>。</p><p>app.js:</p><pre><code>const Vue = require(&quot;vue&quot;);const createRouter = require(&quot;../router&quot;)module.exports = (context) =&gt; &#123;    const router = createRouter();    const app = new Vue(&#123;        router,        data:&#123;            message:&quot;Hello,Vue SSR!&quot;        &#125;,        template:`            &lt;div&gt;                &lt;div&gt;                    &lt;h1&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt;                    &lt;ul&gt;                        &lt;li&gt;                            &lt;router-link to=&quot;/&quot;&gt;首页&lt;/router-link&gt;                        &lt;/li&gt;                        &lt;li&gt;                            &lt;router-link to=&quot;/about&quot;&gt;关于我&lt;/router-link&gt;                        &lt;/li&gt;                    &lt;/ul&gt;                &lt;/div&gt;                &lt;router-view&gt;&lt;/router-view&gt;            &lt;/div&gt;        `     &#125;);    return &#123;        app,        router    &#125;&#125;</code></pre><p>通过上面的改造之后，就可以在<code>entry-server.js</code>中轻松的拿到<code>vue</code>和<code>router</code>的实例了，现在查看一下当前<code>entry-server.js</code>中有那些可用参数，<code>vue</code>,<code>router</code>,提及到的<code>URL</code>从哪里来？既然这个函数是给服务端使用的，那么当服务端去执行这个函数的时候，就可以通过参数形式传递进来，获取到我们想要的参数，我们假设这个参数叫做<code>url</code>，我们需要让路由去做的就是跳转到对应的路由中（这一步很重要），然后再把对<code>router</code>的实例挂载到<code>vue</code>实例中，然后再把<code>vue</code>实例返回出去，供<code>vueServerRender</code>消费。那么就需要导出这个函数，以供服务端使用。</p><p>由于我们不能预测到用户所访问的路由就是在<code>vue-router</code>中所配置的，所以需要在<code>onReady</code>的时候进行处理，我们可以通过<code>router</code>的<code>getMatchedComponents</code>这个方法，获取到我们所导入的组件，这些有个我们就可通过判断组件对匹配结果进行渲染。</p><p>entry-server.js</p><pre><code>const createApp = require(&quot;./app.js&quot;);module.exports = (context) =&gt; &#123;    return new Promise((reslove,reject) =&gt; &#123;        let &#123;url&#125; = context;        let &#123;app,router&#125; = createApp(context);        router.push(url);        //  router回调函数        //  当所有异步请求完成之后就会触发        router.onReady(() =&gt; &#123;            let matchedComponents = router.getMatchedComponents();            if(!matchedComponents.length)&#123;                return reject(&#123;                    code:404,                &#125;);            &#125;            reslove(app);        &#125;,reject)    &#125;)&#125;</code></pre><p>既然实例又发生了变化，需要对应发生变化的<code>index.js</code>同样也需要做出对应的改动。把刚才的引入<code>vue</code>实例的路径改为<code>entey-server.js</code>，由于这里返回的是一个<code>Promise</code>对象，这里使用<code>async/await</code>处理接收一下，并拿到<code>vue</code>实例。不要忘了把<code>router</code>所需要的<code>url</code>参数传递进去。</p><p>index.js:</p><pre><code>const express = require(&quot;express&quot;);const App = require(&quot;./src/entry-server.js&quot;);let path = require(&quot;path&quot;);const vueServerRender = require(&quot;vue-server-renderer&quot;).createRenderer(&#123;  template:require(&quot;fs&quot;).readFileSync(path.join(__dirname,&quot;./index.html&quot;),&quot;utf-8&quot;)&#125;);const app = express();app.get(&#39;*&#39;,async (request,respones) =&gt; &#123;    respones.status(200);    respones.setHeader(&quot;Content-Type&quot;,&quot;text/html;charset-utf-8;&quot;);    let &#123;url&#125; = request;    //  这里可以传递给vue实例一些参数    let vm = await App(&#123;url&#125;);    vueServerRender.renderToString(vm).then((html) =&gt; &#123;        respones.end(html);    &#125;).catch(error =&gt; console.log(error));&#125;)app.listen(3000,() =&gt; &#123;    console.log(&quot;服务已启动&quot;)&#125;);</code></pre><p>这下子就完成了，启动项目吧，当访问根路径的时候，就会看到刚才缺少的组件也已经渲染出来了，当然我们也可以切换路由，也是没有问题的。大功告成。。。好像并没有emmmmmmmmm，为什么，细心的话应该会发现，当我们切换路由的时候，地址栏旁边的刷新按钮一直在闪动，这也就是说，我们所做出来的并不是一个单页应用（手动笑哭），出现这样的问题也是难怪的，毕竟我们没有配置前端路由，我们把所有路由的控制权都交给了服务端，每次访问一个路由的时候，都会向服务端发送一个请求，返回路由对应的页面。想要解决这个问题，当处于前端的时候我们需要让服务端把路由的控制权交还给前端路由，让前端去控制路由的跳转。</p><p>之前在<code>src</code>文件夹下面添加了两个文件，只用到了服务端的文件，为了在客户端能够交还路由控制权，要对<code>web</code>端路由进行配置。由于在客户端在使用<code>vue</code>的时候需要挂载一个<code>document</code>，因为<code>vue</code>的实例已经创建完成了，所以，这里需要使用<code>$mount</code>这个钩子函数，来完成客户端的挂载。同样为了解决懒加载这种类似的问题so~同样需要使用<code>onReady</code>里进行路由的处理，只有当<code>vue-router</code>加载完成以后再去挂载。</p><p>在客户端是使用的时候很简单，只需要把路由挂载到<code>app</code>里面就可以了。</p><p>entry-client.js</p><pre><code>const createApp = require(&quot;./app.js&quot;);let &#123;app,router&#125; = createApp(&#123;&#125;);router.onReady(() =&gt; &#123;    app.$mount(&quot;#app&quot;)&#125;);</code></pre><p>整个项目的雏形也就这样了，由于服务端把路由控制权交还给客户端，需要复杂的<code>webpack</code>配置，so~不再赘述了，下面直接使用<code>vue-cli</code>继续（做的是使用需要用到上面的代码）。</p><h3 id="vue-cli项目搭建"><a href="#vue-cli项目搭建" class="headerlink" title="vue-cli项目搭建"></a><strong>vue-cli项目搭建</strong></h3><p>在做准备工作的时候简单讲述了<code>vue</code>中使用<code>ssr</code>的运行思路，里面提及了一个很重要的<code>webpack</code>，因此这里需要借助<code>vue-cli</code>脚手架，直接更改原有的<code>webpack</code>就可以了，这样会方便很多。</p><p>这里建议大家返回顶部再次看一下<code>vue</code>服务端渲染的流程，在介绍中的<code>client-bundle</code>和<code>server-bundle</code>，，所以需要构建两个配置，分别是服务端配置和客户端的配置。</p><p>如想要实现服务端渲染需要对<code>vue-cli</code>中个<code>js</code>文件中的配置进行修改。以下只展示更改部分的代码，不展示全部。</p><p>文件分别是：</p><p>webpack.server.conf.js - 服务端webpack配置 dev-server.js - 获取服务端bundle server.js - 创建后端服务 webpack.dev.conf.js - 客户端的bundle webpack.base.conf - 修改入口文件</p><p><strong>客户端配置</strong></p><p>客户端生成一份客户端构建清单，记录客户端的资源，最终会将客户端构建清单中记录的文件，注入到执行的执行的模板中，这个清单与服务端类似，同样也会生成一份<code>json</code>文件，这个文件的名字是<code>vue-ssr-client-manifest.json</code>（项目启动以后可以通过地址&#x2F;文件名访问到），当然必不可少的是，同样也需要引入一个叫做<code>vue-server-renderer/client-plugin</code>模块，作为<code>webpack</code>的插件供其使用。</p><p>首先要安装一下<code>vue-server-renderer</code>这个模块，这个是整个服务端渲染的核心，没有整个<code>ssr</code>是没有任何灵魂的。</p><pre><code>npm install vue-server-renderer -S</code></pre><p>安装完成之后，首先要找到<code>webpack.dev.conf.js</code>，首先要对其进行相关配置。</p><p>webpack.dev.conf.js</p><pre><code>//  添加引入  vue-server-render/client-plugin  模块const vueSSRClientPlugin = require(&quot;vue-server-renderer/client-plugin&quot;);const devWebpackConfig = merge(baseWebpackConfig,&#123;    plugins:[        new vueSSRClientPlugin()    ] &#125;);</code></pre><p>添加了这个配置以后，重新启动项目通过地址就可以访问到<code>vue-ssr-client-manifest.json</code>（<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4MDgwL3Z1ZS1zc3ItY2xpZW50LW1hbmlmZXN0Lmpzb24lRUYlQkMlODklRUYlQkMlOEMlRTklQTElQjUlRTklOUQlQTIlRTQlQjglQUQlRTUlODclQkElRTclOEUlQjAlRTclOUElODQlRTUlODYlODUlRTUlQUUlQjklRTUlQjAlQjElRTYlOTglQUYlRTYlODklODAlRTklOUMlODAlRTglQTYlODElRTclOUElODQlNjBjbGllbnQtYnVuZGxlJTYwJUUzJTgwJTgy">http://localhost:8080/vue-ssr-client-manifest.json），页面中出现的内容就是所需要的`client-bundle`。</span></p><p><strong>服务端配置</strong></p><p>服务端会默认生成一个<code>vue-ssr-server-bundle.json</code>文件，在文件中会记录整个服务端整个输出，怎么才能生成这个文件呢？要在这个<code>json</code>文件，必须要引入<code>vue-server-renderer/server-plugin</code>,并将其作为<code>webpack</code>的插件。</p><p>在开始服务端配置之前，需要在<code>src</code>文件夹下面创建三个文件，<code>app.js</code>，<code>entry-client.js</code>，<code>entry-server.js</code>，创建完成之后需要对其写入相关代码。</p><p>src&#x2F;router&#x2F;index.js</p><pre><code>import vueRouter from &quot;vue-router&quot;;import Vue from &quot;vue&quot;;import HelloWorld from &quot;@/components/HelloWorld&quot;;Vue.use(vueRouter);export default () =&gt; &#123;    return new vueRouter(&#123;        mode:&quot;history&quot;,        routes:[            &#123;                path:&quot;/&quot;,                component:HelloWorld,                name:&quot;HelloWorld&quot;            &#125;        ]    &#125;)&#125;</code></pre><p>app.js</p><pre><code>import Vue from &quot;vue&quot;;import createRouter from &quot;./router&quot;;import App from &quot;./App.vue&quot;;export default (context) =&gt; &#123;    const router = createRouter();    const app = new Vue(&#123;        router,        components: &#123; App &#125;,        template: &#39;&lt;App/&gt;&#39;    &#125;);    return &#123;        app,        router    &#125;&#125;</code></pre><p>entry-server.js</p><pre><code>import createApp from &quot;./app.js&quot;;export default (context) =&gt; &#123;    return new Promise((reslove,reject) =&gt; &#123;        let &#123;url&#125; = context;        let &#123;app,router&#125; = createApp(context);        router.push(url);        router.onReady(() =&gt; &#123;            let matchedComponents = router.getMatchedComponents();            if(!matchedComponents.length)&#123;                return reject(&#123;                    code:404,                &#125;);            &#125;            reslove(app);        &#125;,reject)    &#125;)&#125;</code></pre><p>entry-client.js</p><pre><code>import createApp from &quot;./app.js&quot;;let &#123;app,router&#125; = createApp();router.onReady(() =&gt; &#123;    app.$mount(&quot;#app&quot;);&#125;);</code></pre><p>webpack.base.conf.js</p><pre><code>module.exports = &#123;    entry:&#123;        app:&quot;./src/entry-client.js&quot;    &#125;,    output:&#123;        publicPath:&quot;http://localhost:8080/&quot;    &#125;&#125;;</code></pre><p>webpack.server.conf.js(手动创建)</p><pre><code>const webpack = require(&quot;webpack&quot;);const merge = require(&quot;webpack-merge&quot;);const base = require(&quot;./webpack.base.conf&quot;);//  手动安装//  在服务端渲染中，所需要的文件都是使用require引入，不需要把node_modules文件打包const webapckNodeExternals = require(&quot;webpack-node-externals&quot;);const vueSSRServerPlugin = require(&quot;vue-server-renderer/server-plugin&quot;);module.exports = merge(base,&#123;    //  告知webpack，需要在node端运行    target:&quot;node&quot;,    entry:&quot;./src/entry-server.js&quot;,    devtool:&quot;source-map&quot;,    output:&#123;        filename:&#39;server-buldle.js&#39;,        libraryTarget: &quot;commonjs2&quot;    &#125;,    externals:[        webapckNodeExternals()    ],    plugins:[        new webpack.DefinePlugin(&#123;            &#39;process.env.NODE_ENV&#39;:&#39;&quot;devlopment&quot;&#39;,            &#39;process.ent.VUE_ENV&#39;: &#39;&quot;server&quot;&#39;        &#125;),        new vueSSRServerPlugin()    ]&#125;);</code></pre><p>dev-server.js(手动创建)</p><pre><code>const serverConf = require(&quot;./webpack.server.conf&quot;);const webpack = require(&quot;webpack&quot;);const fs = require(&quot;fs&quot;);const path = require(&quot;path&quot;);//  读取内存中的.json文件//  这个模块需要手动安装const Mfs = require(&quot;memory-fs&quot;);const axios = require(&quot;axios&quot;);module.exports = (cb) =&gt; &#123;    const webpackComplier = webpack(serverConf);    var mfs = new Mfs();        webpackComplier.outputFileSystem = mfs;        webpackComplier.watch(&#123;&#125;,async (error,stats) =&gt; &#123;        if(error) return console.log(error);        stats = stats.toJson();        stats.errors.forEach(error =&gt; console.log(error));        stats.warnings.forEach(warning =&gt; console.log(warning));        //  获取server bundle的json文件        let serverBundlePath = path.join(serverConf.output.path,&#39;vue-ssr-server-bundle.json&#39;);        let serverBundle = JSON.parse(mfs.readFileSync(serverBundlePath,&quot;utf-8&quot;));        //  获取client bundle的json文件        let clientBundle = await axios.get(&quot;http://localhost:8080/vue-ssr-client-manifest.json&quot;);        //  获取模板        let template = fs.readFileSync(path.join(__dirname,&quot;..&quot;,&quot;index.html&quot;),&quot;utf-8&quot;);        cb &amp;&amp; cb(serverBundle,clientBundle,template);    &#125;)&#125;;</code></pre><p>根目录&#x2F;server.js(手动创建)</p><pre><code>const devServer = require(&quot;./build/dev-server.js&quot;);const express = require(&quot;express&quot;);const app = express();const vueRender = require(&quot;vue-server-renderer&quot;);app.get(&#39;*&#39;,(request,respones) =&gt; &#123;    respones.status(200);    respones.setHeader(&quot;Content-Type&quot;,&quot;text/html;charset-utf-8;&quot;);    devServer((serverBundle,clientBundle,template) =&gt; &#123;        let render = vueRender.createBundleRenderer(serverBundle,&#123;            template,            clientManifest:clientBundle.data,            //  每次创建一个独立的上下文            renInNewContext:false        &#125;);         render.renderToString(&#123;            url:request.url        &#125;).then((html) =&gt; &#123;            respones.end(html);        &#125;).catch(error =&gt; console.log(error));    &#125;);&#125;)app.listen(5000,() =&gt; &#123;    console.log(&quot;服务已启动&quot;)&#125;);</code></pre><p>index.html</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html &gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;&lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div &gt;        &lt;!--vue-ssr-outlet--&gt;    &lt;/div&gt;    &lt;!-- built files will be auto injected --&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>以上就是所有要更改和添加的配置项，配置完所有地方就可以完成服务端渲染。此时需要在<code>package.json</code>中的<code>sctipt</code>中添加启动项：<code>http:node server.js</code>，就可以正常运行项目了。注意一定要去访问服务端设置的端口，同时要保证你的客户端也是在线的。</p><h3 id="nuxt是一个基于-Vue-js-的通用应用框架，它提供了一种简单而强大的方式来创建服务器渲染的-Vue-js-应用"><a href="#nuxt是一个基于-Vue-js-的通用应用框架，它提供了一种简单而强大的方式来创建服务器渲染的-Vue-js-应用" class="headerlink" title="nuxt是一个基于 Vue.js 的通用应用框架，它提供了一种简单而强大的方式来创建服务器渲染的 Vue.js 应用"></a>nuxt是一个基于 Vue.js 的通用应用框架，它提供了一种简单而强大的方式来创建服务器渲染的 Vue.js 应用</h3><ol><li><p>服务器端渲染（SSR）：Nuxt.js 提供了内置的服务器端渲染支持，可以在服务器端生成完整的 HTML 页面，并将其发送给客户端展示。这样可以提供更快的首次加载速度和更好的搜索引擎优化。同时，Nuxt.js 还为前端开发人员隐藏了大部分 SSR 的复杂性，使得开发 SSR 应用变得更加简单。</p></li><li><p>自动路由配置：Nuxt.js 根据项目目录结构自动生成路由配置，无需手动配置每个页面的路由信息。只需按照约定的目录结构组织代码即可实现自动路由匹配。这样可以极大地提高开发效率。</p></li><li><p>强大的异步数据处理：Nuxt.js 提供了一个特殊的 asyncData 方法，可以在页面组件中获取和处理异步数据。这样，在渲染页面之前，可以先获取页面所需的数据，并将数据注入到组件中。这种方式简化了前后端数据交互的过程，同时也提供了更好的性能和用户体验。</p></li><li><p>插件机制：Nuxt.js 提供了插件机制，可以方便地扩展和集成第三方库。通过插件，可以在项目中引入和使用其他 Vue.js 生态系统中的工具和功能。</p></li><li><p>静态文件服务：Nuxt.js 能够自动处理静态文件，例如图片、样式表和字体等。它提供了一个特殊的目录（static），其中的文件将被直接复制到构建目录中，使得这些文件可以通过 HTTP 服务器直接访问。</p></li><li><p>开发和调试工具：Nuxt.js 集成了很多开发和调试工具，例如热重载、代码分割和错误定位等。这些工具可以提高开发效率，并帮助开发人员更快地找到和解决问题。</p></li><li><p>生态系统支持：Nuxt.js 基于 Vue.js 生态系统，可以充分利用 Vue.js 的丰富生态系统，包括 Vue 组件、Vue 插件和 Vue CLI 等。这样开发者可以通过 Nuxt.js 构建出更加强大和灵活的应用程序。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> 前端性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue首屏优化</title>
      <link href="/performance-optimization/Vue%E9%A6%96%E5%B1%8F%E4%BC%98%E5%8C%96/"/>
      <url>/performance-optimization/Vue%E9%A6%96%E5%B1%8F%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<ol><li>代码压缩和优化：使用工具（如Webpack、UglifyJS等）对代码进行压缩和优化，减少不必要的空格、注释和代码体积，以提高加载速度。<br><strong>优化的方向</strong></li></ol><ul><li>移除注释和空格：工具会删除代码中的多余注释和空格，以减小文件体积。</li><li>变量重命名：工具会对代码中的变量和函数进行重命名，使用更短、没有语义的名称，以缩小文件大小。这种压缩技术称为代码混淆。</li><li>语法转换：工具可以将一些较新版本的JavaScript语法转换为较旧版本，以增加代码的兼容性，并使之在更多的浏览器中运行。</li><li>静态资源优化：工具可以对图片、字体等静态资源进行优化，如压缩、缓存等，以减小静态资源的大小和提高加载速度。</li><li>代码拆分：工具可以将代码拆分成多个模块或块，按需加载，以避免一次性加载过多的代码，提高页面的首次加载速度。</li><li>依赖管理：工具可以分析代码中的依赖关系，将多个文件合并为一个或多个较小的文件，以减少网络请求和优化加载顺序。<br><strong>具体操作</strong></li><li>uglifyjs-webpack-plugin（或terser-webpack-plugin）：这是一个用于压缩JavaScript代码的插件。它可以移除注释、空格，并对代码进行混淆和压缩，以减小文件体积。</li><li>html-webpack-plugin：该插件用于生成HTML文件，并自动将打包后的脚本和样式文件引入HTML文件中。它还可以配置参数，如压缩HTML、添加哈希值等。</li><li>mini-css-extract-plugin：这个插件用于提取CSS代码到单独的文件中，并通过link标签将其引入HTML文件，以减少页面加载时的样式闪烁问题。</li><li>optimize-css-assets-webpack-plugin：该插件用于压缩提取出的CSS代码，以减小文件体积。</li><li>splitChunks方法：这是Webpack的内置方法，用于分割代码块。它根据配置策略将公共模块提取到一个单独的文件中，以避免重复加载，提高页面加载速度。</li><li>Tree Shaking：这是一种通过静态分析技术删除未使用的代码的方法。Webpack利用Tree Shaking来识别和删除项目中未使用的代码，进一步减小文件体积。</li><li>webpack-bundle-analyzer：这是一个用于可视化分析打包后文件大小的插件。它可以生成交互式的报告，帮助你了解哪些模块占用了大量的空间，并优化你的打包配置。</li></ul><ol start="2"><li>使用CDN：将静态资源（如Vue库、UI框架、图片等）托管到CDN（内容分发网络）上，利用CDN的全球节点分布加速静态资源的下载。</li></ol><ul><li>选择合适的CDN提供商：根据项目需求和预算，选择一个可靠的CDN提供商。常见的CDN提供商包括阿里云CDN、腾讯云CDN、华为云CDN等。</li><li>创建CDN加速域名：在CDN提供商的控制台上创建一个新的CDN加速域名。将你的域名绑定到CDN上，例如cdn.yourdomain.com。</li><li>上传静态资源到CDN：将需要加速的静态资源（如Vue库、UI框架、图片等）上传到CDN提供商的存储空间中，一般称为CDN源站或CDN加速源。</li><li>配置CDN缓存规则：在CDN提供商的控制台上，根据需要配置适当的缓存规则。可以设置缓存时间、缓存策略等，以实现最佳的缓存效果。</li><li>刷新CDN缓存：如果有更新的静态资源，需要手动刷新CDN缓存，以确保新的资源能够及时生效。CDN提供商一般会提供相应的刷新缓存接口或工具。</li><li>修改网页代码：将原来引用静态资源的链接修改为CDN加速域名的链接。例如，将原来引用Vue库的链接从<span class="exturl" data-url="aHR0cHM6Ly9jZG4uZXhhbXBsZS5jb20vdnVlLmpzJUU0JUJGJUFFJUU2JTk0JUI5JUU0JUI4JUJBaHR0cHM6Ly9jZG4ueW91cmRvbWFpbi5jb20vdnVlLmpzJUUzJTgwJTgy">https://cdn.example.com/vue.js修改为https://cdn.yourdomain.com/vue.js。</span></li><li>测试CDN加速效果：在你的网站上进行测试，确保静态资源能够从CDN上加载，并且加载速度有所提升。</li></ul><ol start="3"><li>按需加载：结合Vue的异步组件和路由懒加载功能，将页面中的组件和路由按需加载，而不是一次性全部加载。这样可以减少首次加载需要下载的资源量。</li></ol><pre><code class="javascript">1. 路由懒加载import &#123; createRouter, createWebHistory &#125; from &#39;vue-router&#39;;const router = createRouter(&#123;  history: createWebHistory(),  routes: [    &#123;      path: &#39;/&#39;,      name: &#39;Home&#39;,      component: () =&gt; import(&#39;./views/Home.vue&#39;) // 首页组件使用懒加载    &#125;,    &#123;      path: &#39;/about&#39;,      name: &#39;About&#39;,      component: () =&gt; import(&#39;./views/About.vue&#39;) // 关于页面组件使用懒加载    &#125;,    // 其他路由...  ]&#125;);2. 异步组件import Vue from &#39;vue&#39;;import VueRouter from &#39;vue-router&#39;;Vue.use(VueRouter);const router = new VueRouter(&#123;  routes: [    &#123;      path: &#39;/about&#39;,      name: &#39;About&#39;,      component: function (resolve) &#123;        // 使用Webpack的require.ensure方法实现异步加载        require.ensure([&#39;./views/About.vue&#39;], function () &#123;          resolve(require(&#39;./views/About.vue&#39;));        &#125;);      &#125;    &#125;,    // 其他路由...  ]&#125;);</code></pre><ol start="4"><li>图片优化：对页面中的图片进行压缩和优化，可以选择合适的图片格式、调整图片大小和质量，以减少图片的文件大小和加载时间。</li></ol><ul><li>选择合适的图片格式：不同的图片格式适用于不同类型的图片。常见的图片格式有JPEG、PNG和WebP。一般情况下，JPEG适用于照片和复杂图像，PNG适用于图标和透明背景的图像，而WebP是一种新的高效图片格式，具有更好的压缩率和质量。根据图片的特性选择适当的格式有助于减小文件大小。</li><li>调整图片尺寸和分辨率：根据实际需要，调整图片的尺寸和分辨率。将图片调整为适合在网页上展示的尺寸，避免使用过大的图片，这样可以减少文件大小和加载时间。可以使用图像处理工具（如Photoshop、GIMP）或在线压缩工具来调整图片尺寸。</li><li>降低图片质量：对于照片和复杂图像，适度降低图片的质量可以显著减小文件大小。选择合适的压缩质量，在保持视觉质量的同时减小文件大小。可以使用图像处理工具或在线压缩工具来降低图片质量。</li><li>使用图片压缩工具：使用专门的图片压缩工具，如TinyPNG、JPEG Optimizer等，可以自动优化和压缩图片。这些工具使用各种优化算法来减小文件大小，而不会显著降低视觉质量。</li><li>使用响应式图片：对于移动设备和不同屏幕尺寸，可以使用响应式图片来提供适合不同设备的图片。通过使用<picture>标签或CSS媒体查询可以根据不同设备加载适当尺寸的图片，从而减少加载时间和带宽消耗。</li><li>使用懒加载：对于页面中的大量图片，可以使用懒加载技术。懒加载意味着只有当图片进入视口时才加载它们，而不是一次性加载所有图片。这样可以减少初始加载时间，提高页面的性能和用户体验。</li></ul><ol start="5"><li><p>服务端渲染（SSR）：使用Vue的服务端渲染技术，将页面的初始渲染工作放到服务端完成，使得浏览器在收到页面时能够立即显示内容，缩短首次加载时间。</p></li><li><p>Prefetch和Preload：使用Vue Router的Prefetch和HTML标签的Preload技术，在页面加载完成后，提前预加载一些未访问过但可能会用到的资源，加快后续页面切换时的加载速度。<br><strong>Prefetch（Vue Router</strong></p><ul><li>在Vue Router中，可以使用<code>&lt;router-link&gt;</code>组件的<code>prefetch</code>属性来启用预加载。</li><li>在定义路由时，将<code>prefetch</code>属性设置为<code>true</code>，表示该路由的组件将在后台被异步地下载。</li><li>例如：<pre><code>javascriptCopy Codeconst routes = [  &#123;    path: &#39;/example&#39;,    component: () =&gt; import(&#39;@/views/Example.vue&#39;),    prefetch: true  &#125;,  // 其他路由...]</code></pre></li><li>当用户浏览到其他路由时，Vue Router会自动触发预加载，将与当前路由相关的组件及其所需的资源异步加载到浏览器中。</li></ul></li></ol><p><strong>Preload（HTML标签）</strong></p><ul><li>使用HTML标签的Preload技术可以在页面加载完成后预加载一些资源，包括脚本、样式表和图片等。</li><li>可以使用<code>&lt;link&gt;</code>标签的<code>rel</code>属性设置为<code>preload</code>，并使用<code>as</code>属性指定资源的类型。</li><li>例如：<pre><code>htmlCopy Code&lt;link rel=&quot;preload&quot; href=&quot;/path/to/resource.js&quot; as=&quot;script&quot;&gt;&lt;link rel=&quot;preload&quot; href=&quot;/path/to/resource.css&quot; as=&quot;style&quot;&gt;&lt;link rel=&quot;preload&quot; href=&quot;/path/to/resource.jpg&quot; as=&quot;image&quot;&gt;</code></pre></li><li>这样，在页面加载完成后，浏览器会预加载指定的资源，以便在后续需要使用时能够更快地加载。</li></ul><ol start="9"><li>缓存策略：利用浏览器缓存机制，合理设置静态资源的缓存策略，使得在用户再次访问时能够直接使用本地缓存，减少服务器请求和下载时间。</li></ol><ul><li>强缓存</li><li>协商缓存</li><li>离线缓存</li></ul><ol start="10"><li>代码分割：将代码按照功能模块或路由进行分割，使得每个页面只加载当前需要的代码，而不是整个应用的所有代码。可以使用Webpack的代码分割功能来实现。</li></ol><ul><li>splitChunks方法：这是Webpack的内置方法，用于分割代码块。它根据配置策略将公共模块提取到一个单独的文件中，以避免重复加载，提高页面加载速度。</li></ul><ol start="11"><li><p>使用Vue CLI的生产模式构建：在项目部署前，使用Vue CLI的生产模式构建项目，该构建过程会自动进行代码压缩、优化和哈希命名等操作，以减小文件大小和提高加载速度。</p></li><li><p>性能监测和优化：使用工具（如Lighthouse、WebPageTest、Chrome开发者工具等）对项目进行性能监测和分析，找出存在的性能问题并进行相应优化。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> 前端性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html 加载优化</title>
      <link href="/performance-optimization/html%E9%A6%96%E5%B1%8F%E4%BC%98%E5%8C%96/"/>
      <url>/performance-optimization/html%E9%A6%96%E5%B1%8F%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<ol><li><p>压缩和合并文件：压缩和合并HTML、CSS和JavaScript文件可以减少文件大小，从而加快下载速度。使用压缩工具（如UglifyJS和Terser）来压缩JavaScript代码，使用CSS压缩工具（如CSSNano和csso）来压缩CSS代码。</p></li><li><p>使用浏览器缓存：通过设置适当的缓存头，浏览器可以缓存静态资源，使得再次访问时不需要重新下载。确保你的服务器返回正确的缓存控制头，例如设置Cache-Control和Expires头。</p></li><li><p>延迟加载非关键资源：将非关键的资源，如图片、视频、社交媒体插件等，延迟加载。可以使用懒加载技术或在用户滚动到相应区域时再加载这些资源。</p></li><li><p>使用异步加载脚本：将JavaScript脚本标记为异步加载（通过添加async属性）或延迟加载（通过添加defer属性）。这样可以防止脚本阻塞页面的渲染，使得首屏内容能够更快呈现给用户。</p></li><li><p>优化CSS和JavaScript的渲染顺序：将关键的CSS和JavaScript放在HTML文档的头部，并将非关键的CSS和JavaScript放在文档底部。这可以确保浏览器优先加载和渲染关键的内容。</p></li><li><p>使用图像优化技术：使用合适的图片格式（如JPEG、PNG和WebP）和压缩，同时提供多种大小的图像，以便在不同设备上显示最佳质量的图片。</p></li><li><p>减少HTTP请求：减少页面中的资源数量，如合并和内联CSS和JavaScript，选择使用CSS Sprites来减少图片请求等。</p></li><li><p>使用字体子集：如果使用了自定义字体，可以通过创建字体子集来减少字体文件的大小，只包含页面所需的字符。</p></li><li><p>响应式设计：使用响应式设计来适配不同的设备和屏幕尺寸，以提供更好的用户体验。</p></li><li><p>使用服务端渲染：对于大型应用程序，考虑使用服务端渲染（Server-side Rendering，SSR）来生成首屏内容，以减少客户端渲染的时间和工作量。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> 前端性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jquery原理</title>
      <link href="/front-end/Jquery/"/>
      <url>/front-end/Jquery/</url>
      
        <content type="html"><![CDATA[<p>jQuery是一个基于JavaScript的快速、小巧且功能强大的JavaScript库。它主要用于简化针对HTML文档操作、处理事件、执行动画和进行AJAX等常见任务的     JavaScript码。</p><pre><code class="text">1. jQuery的原理可以总结为以下几个方面：    - 封装DOM操作：jQuery通过封装浏览器提供的DOM（文档对象模型）接口，提供了一组简洁且易于使用的方法，使开发者能够轻松地对HTML元素进行选择、创建、修改和删除等操作。它通过选择器引擎，类似于CSS选择器语法，快速定位到指定的元素集合。    - 事件处理：jQuery提供了统一的事件处理机制，可以方便地绑定和解绑事件，支持各种常见的事件类型（如点击、鼠标移入移出、键盘按下释放等）。它的事件处理功能兼容不同浏览器，并提供了一套一致的跨浏览器解决方案。    - 动画效果：jQuery通过提供一些内置的动画方法和效果，使得开发者能够轻松地在页面上实现各种动画效果，如淡入淡出、滑动、展开收起等。这些动画效果可以通过调用方法来实现，也可以通过设置CSS属性实现。    - AJAX封装：jQuery通过封装XMLHttpRequest对象和其他相关API，简化了进行AJAX交互的过程。开发者可以使用jQuery提供的ajax()方法来发送HTTP请求、处理响应、实现异步加载等，而无需直接操作底层XMLHttpRequest对象。    - 扩展性和插件机制：jQuery提供了丰富的插件生态系统，开发者可以方便地使用现有的插件来扩展和增强jQuery的功能。插件可以是一些已经实现的功能模块，也可以是一些自定义的功能代码。</code></pre><p>简单实现原理</p><pre><code class="javascript">function jQuery(selector) &#123;    this.elements = []    this.querySelectorAll(selector)&#125;jQuery.prototype = &#123;    querySelectorAll(selector) &#123;        this.elements = document.querySelectorAll(selector)        return this    &#125;,    attr(key, value) &#123;        /**         * 第一种情况 只有key         * 也就是取元素的属性值         * 取值就返回属性值 不需要返回this         */        if ( value === void 0 ) &#123;            var el = this.elements[0]            return el &amp;&amp; el.getAttribute(key)        &#125;        /**         * 第二种情况 key + value         * 也就是给元素添加属性         * 返回this         */        this.elements.forEach(function(el) &#123;            el.setAttribute(key, value)        &#125;)        return this    &#125;&#125;window.$ = function(selector) &#123;    return new jQuery(selector)&#125;/** * 使用 */$(&#39;div&#39;).attr(&#39;a&#39;, 1).attr(&#39;b&#39;, 2).attr(&#39;c&#39;, 3)</code></pre><h1 id="jQuery或zepto源码有哪些写的好的地⽅"><a href="#jQuery或zepto源码有哪些写的好的地⽅" class="headerlink" title="jQuery或zepto源码有哪些写的好的地⽅"></a>jQuery或zepto源码有哪些写的好的地⽅</h1><pre><code class="javascript">jquery源码封装在⼀个匿名函数的⾃执⾏环境中，有助于防⽌变量的全局污染，然后通过传⼊window对象参数，可以使window对象作为局部变量使⽤，好处是当jquery中访问window对象的时候，就不⽤将作⽤域链退回到顶层作⽤域了，从⽽可以更快的访问window对象。同样，传⼊undefined参数，可以缩短查找undefined时的作⽤域链(function( window, undefined ) &#123; //⽤⼀个函数域包起来，就是所谓的沙箱 //在这⾥边var定义的变量，属于这个函数域内的局部变量，避免污染全局 //把当前沙箱需要的外部变量通过函数参数引⼊进来 //只要保证参数对内提供的接⼝的⼀致性，你还可以随意替换传进来的这个参数 window.jQuery = window.$ = jQuery; &#125;)( window );jquery将⼀些原型属性和⽅法封装在了jquery.prototype中，为了缩短名称，⼜赋值给了jquery.fn，这是很形象的写法有⼀些数组或对象的⽅法经常能使⽤到，jQuery将其保存为局部变量以提⾼访问速度jquery实现的链式调⽤可以节约代码，所返回的都是同⼀个对象，可以提⾼代码效率</code></pre><h1 id="jQuery-fn-的-init-⽅法返回的-this-指的是什么对象"><a href="#jQuery-fn-的-init-⽅法返回的-this-指的是什么对象" class="headerlink" title="jQuery.fn 的 init ⽅法返回的 this 指的是什么对象"></a>jQuery.fn 的 init ⽅法返回的 this 指的是什么对象</h1><pre><code class="text">jQuery.fn 的 init ⽅法 返回的 this 就是 jQuery 对象⽤户使⽤ jQuery() 或 $() 即可初始化 jQuery 对象，不需要动态的去调⽤ init ⽅法</code></pre><h1 id="jQuery-extend-与-jQuery-fn-extend-的区别"><a href="#jQuery-extend-与-jQuery-fn-extend-的区别" class="headerlink" title="jQuery.extend 与 jQuery.fn.extend 的区别"></a>jQuery.extend 与 jQuery.fn.extend 的区别</h1><ol><li><p>$.fn.extend() 和 $.extend() 是 jQuery 为扩展插件提拱了两个⽅法</p></li><li><p>$.extend(object) ; &#x2F;&#x2F; 为jQuery添加“静态⽅法”（⼯具⽅法）</p></li></ol><pre><code class="javascript">$.extend(&#123;min: function(a, b) &#123; return a &lt; b ? a : b; &#125;,max: function(a, b) &#123; return a &gt; b ? a : b; &#125;&#125;);$.min(2,3); // 2$.max(4,5); // 5</code></pre><ol start="3"><li>$.extend([true,] targetObject, object1[, object2]); &#x2F;&#x2F; 对targt对象进⾏扩展</li></ol><pre><code class="javascript">var settings = &#123;validate:false, limit:5&#125;;var options = &#123;validate:true, name:&quot;bar&quot;&#125;;$.extend(settings, options); // 注意：不⽀持第⼀个参数传 false// settings == &#123;validate:true, limit:5, name:&quot;bar&quot;&#125;</code></pre><ol start="4"><li>$.fn.extend(json) ; &#x2F;&#x2F; 为jQuery添加“成员函数”（实例⽅法）</li></ol><pre><code class="javascript">$.fn.extend(&#123;    alertValue: function() &#123;    $(this).click(function()&#123;    alert($(this).val());&#125;);&#125;);$(&quot;#email&quot;).alertValue();</code></pre><h1 id="jQuery-的属性拷⻉-extend-的实现原理是什么，如何实现深拷⻉"><a href="#jQuery-的属性拷⻉-extend-的实现原理是什么，如何实现深拷⻉" class="headerlink" title="jQuery 的属性拷⻉(extend)的实现原理是什么，如何实现深拷⻉"></a>jQuery 的属性拷⻉(extend)的实现原理是什么，如何实现深拷⻉</h1><ol><li>浅拷⻉（只复制⼀份原始对象的引⽤） var newObject &#x3D; $.extend({}, oldObject);</li><li>深拷⻉（对原始对象属性所引⽤的对象进⾏进⾏递归拷⻉） var newObject &#x3D; $.extend(true, {}, oldObject);</li></ol><h1 id="jQuery-的队列是如何实现的"><a href="#jQuery-的队列是如何实现的" class="headerlink" title="jQuery 的队列是如何实现的"></a>jQuery 的队列是如何实现的</h1><ol><li><p>jQuery 核⼼中有⼀组队列控制⽅法，由 queue()&#x2F;dequeue()&#x2F;clearQueue() 三个⽅法组成。</p></li><li><p>主要应⽤于 animate() ， ajax ，其他要按时间顺序执⾏的事件中</p></li></ol><pre><code class="javascript">var func1 = function()&#123;alert(&#39;事件1&#39;);&#125;var func2 = function()&#123;alert(&#39;事件2&#39;);&#125;var func3 = function()&#123;alert(&#39;事件3&#39;);&#125;var func4 = function()&#123;alert(&#39;事件4&#39;);&#125;// ⼊栈队列事件$(&#39;#box&#39;).queue(&quot;queue1&quot;, func1); // push func1 to queue1$(&#39;#box&#39;).queue(&quot;queue1&quot;, func2); // push func2 to queue1// 替换队列事件$(&#39;#box&#39;).queue(&quot;queue1&quot;, []); // delete queue1 with empty array$(&#39;#box&#39;).queue(&quot;queue1&quot;, [func3, func4]); // replace queue1// 获取队列事件（返回⼀个函数数组）$(&#39;#box&#39;).queue(&quot;queue1&quot;); // [func3(), func4()]// 出栈队列事件并执⾏$(&#39;#box&#39;).dequeue(&quot;queue1&quot;); // return func3 and do func3$(&#39;#box&#39;).dequeue(&quot;queue1&quot;); // return func4 and do func4// 清空整个队列$(&#39;#box&#39;).clearQueue(&quot;queue1&quot;); // delete queue1 with clearQueue</code></pre><h1 id="jQuery-中的-bind-live-delegate-on-的区别"><a href="#jQuery-中的-bind-live-delegate-on-的区别" class="headerlink" title="jQuery 中的 bind(), live(), delegate(), on()的区别"></a>jQuery 中的 bind(), live(), delegate(), on()的区别</h1><ol><li>bind() 直接绑定在⽬标元素上</li><li>live() 通过冒泡传播事件，默认 document 上，⽀持动态数据</li><li>delegate() 更精确的⼩范围使⽤事件代理，性能优于 live</li><li>on() 是最新的 1.9 版本整合了之前的三种⽅式的新事件绑定机制</li></ol><h1 id="是否知道⾃定义事件"><a href="#是否知道⾃定义事件" class="headerlink" title="是否知道⾃定义事件"></a>是否知道⾃定义事件</h1><ol><li><p>事件即“发布&#x2F;订阅”模式，⾃定义事件即“消息发布”，事件的监听即“订阅订阅”</p></li><li><p>JS 原⽣⽀持⾃定义事件，示例：</p></li></ol><pre><code class="javascript"> document.createEvent(type); // 创建事件 event.initEvent(eventType, canBubble, prevent); // 初始化事件 target.addEventListener(&#39;dataavailable&#39;, handler, false); // 监听事件 target.dispatchEvent(e); // 触发事件</code></pre><ol start="3"><li>jQuery ⾥的 fire 函数⽤于调⽤ jQuery ⾃定义事件列表中的事件</li></ol><h1 id="jQuery-通过哪个⽅法和-Sizzle-选择器结合的"><a href="#jQuery-通过哪个⽅法和-Sizzle-选择器结合的" class="headerlink" title="jQuery 通过哪个⽅法和 Sizzle 选择器结合的"></a>jQuery 通过哪个⽅法和 Sizzle 选择器结合的</h1><ol><li>Sizzle 选择器采取 Right To Left 的匹配模式，先搜寻所有匹配标签，再判断它的⽗节点</li><li>jQuery 通过 $(selecter).find(selecter); 和 Sizzle 选择器结合</li></ol><h1 id="jQuery-中如何将数组转化为-JSON-字符串，然后再转化回来"><a href="#jQuery-中如何将数组转化为-JSON-字符串，然后再转化回来" class="headerlink" title="jQuery 中如何将数组转化为 JSON 字符串，然后再转化回来"></a>jQuery 中如何将数组转化为 JSON 字符串，然后再转化回来</h1><pre><code class="javascript">// 通过原⽣ JSON.stringify/JSON.parse 扩展 jQuery 实现 $.array2json = function(array) &#123; return JSON.stringify(array);&#125; $.json2array = function(array) &#123; // $.parseJSON(array); // 3.0 开始，已过时 return JSON.parse(array);&#125;// 调⽤var json = $.array2json([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]);var array = $.json2array(json);</code></pre><h1 id="jQuery-⼀个对象可以同时绑定多个事件，这是如何实现的"><a href="#jQuery-⼀个对象可以同时绑定多个事件，这是如何实现的" class="headerlink" title="jQuery ⼀个对象可以同时绑定多个事件，这是如何实现的"></a>jQuery ⼀个对象可以同时绑定多个事件，这是如何实现的</h1><pre><code class="javascript">$(&quot;#btn&quot;).on(&quot;mouseover mouseout&quot;, func); $(&quot;#btn&quot;).on(&#123; mouseover: func1, mouseout: func2, click: func3 &#125;);</code></pre><h1 id="针对-jQuery-的优化⽅法"><a href="#针对-jQuery-的优化⽅法" class="headerlink" title="针对 jQuery 的优化⽅法"></a>针对 jQuery 的优化⽅法</h1><ol><li>缓存频繁操作 DOM 对象</li><li>尽量使⽤ id 选择器代替 class 选择器</li><li>总是从 #id 选择器来继承</li><li>尽量使⽤链式操作</li><li>使⽤时间委托 on 绑定事件</li><li>采⽤ jQuery 的内部函数 data() 来存储数据</li><li>使⽤最新版本的 jQuery</li></ol><h1 id="jQuery-的-slideUp-动画，当⿏标快速连续触发-动画会滞后反复执⾏，该如何处理呢"><a href="#jQuery-的-slideUp-动画，当⿏标快速连续触发-动画会滞后反复执⾏，该如何处理呢" class="headerlink" title="jQuery 的 slideUp 动画，当⿏标快速连续触发, 动画会滞后反复执⾏，该如何处理呢"></a>jQuery 的 slideUp 动画，当⿏标快速连续触发, 动画会滞后反复执⾏，该如何处理呢</h1><ol><li>在触发元素上的事件设置为延迟处理：使⽤ JS 原⽣ setTimeout ⽅法</li><li>在触发元素的事件时预先停⽌所有的动画，再执⾏相应的动画事件： $(‘.tab’).stop().slideUp();</li></ol><h1 id="jQuery-UI-如何⾃定义组件"><a href="#jQuery-UI-如何⾃定义组件" class="headerlink" title="jQuery UI 如何⾃定义组件"></a>jQuery UI 如何⾃定义组件</h1><ol><li>通过向 $.widget() 传递组件名称和⼀个原型对象来完成</li><li>$.widget(“ns.widgetName”, [baseWidget], widgetPrototype);</li></ol><h1 id="jQuery-与-jQuery-UI、jQuery-Mobile-区别"><a href="#jQuery-与-jQuery-UI、jQuery-Mobile-区别" class="headerlink" title="jQuery 与 jQuery UI、jQuery Mobile 区别"></a>jQuery 与 jQuery UI、jQuery Mobile 区别</h1><ol><li>jQuery 是 JS 库，兼容各种PC浏览器，主要⽤作更⽅便地处理 DOM 、事件、动画、AJAX</li><li>jQuery UI 是建⽴在 jQuery 库上的⼀组⽤户界⾯交互、特效、⼩部件及主题</li><li>jQuery Mobile 以 jQuery 为基础，⽤于创建“移动Web应⽤”的框架</li></ol><h1 id="jQuery-和-Zepto-的区别？-各⾃的使⽤场景"><a href="#jQuery-和-Zepto-的区别？-各⾃的使⽤场景" class="headerlink" title="jQuery 和 Zepto 的区别？ 各⾃的使⽤场景"></a>jQuery 和 Zepto 的区别？ 各⾃的使⽤场景</h1><ol><li>jQuery 主要⽬标是 PC 的⽹⻚中，兼容全部主流浏览器。在移动设备⽅⾯，单独推出 jQuery Mobile</li><li>Zepto 从⼀开始就定 位移动设备，相对更轻量级。它的 API 基本兼容 jQuery&#96;，但对PC浏览器兼容不理想</li></ol><h1 id="jQuery对象的特点"><a href="#jQuery对象的特点" class="headerlink" title="jQuery对象的特点"></a>jQuery对象的特点</h1><ol><li>只有 JQuery 对象才能使⽤ JQuery ⽅法</li><li>JQuery 对象是⼀个数组对象</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
          <category> Jquery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jquery </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
