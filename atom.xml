<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://pink-png.github.io</id>
    <title>死肥宅</title>
    <subtitle>肥宅快乐水</subtitle>
    <icon>https://pink-png.github.io/images/favicon.ico</icon>
    <link href="https://pink-png.github.io" />
    <author>
      <name>sanxin98</name>
    </author>
    <updated>2023-12-04T03:41:00.000Z</updated>
    <category term="编程语言" />
    <category term=" Web开发" />
    <category term=" 移动应用开发" />
    <category term=" 数据库" />
    <category term=" 前端开发" />
    <category term=" 后端开发" />
    <category term=" 框架" />
    <category term=" 数据科学与机器学习" />
    <category term=" 安全性与网络" />
    <category term=" 开源项目" />
    <category term="前端面试" />
    <category term="后端面试" />
    <entry>
        <id>https://pink-png.github.io/performance-optimization/%E5%89%8D%E7%AB%AF%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/</id>
        <title>前端调试技巧</title>
        <link rel="alternate" href="https://pink-png.github.io/performance-optimization/%E5%89%8D%E7%AB%AF%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/"/>
        <content type="html">&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;1、网络 请求重新发送xhr 
2、修改请求参数： 复制-&amp;gt;以fetch格式复制
3、复制JavaScript变量：右键复制object、将object存储为全局变量
4、$0 输出选中的第一个元素
5、截屏：Ctrl+shift+p screen
6、同时展开多级节点 选中元素，按住alt再点击7、$_ 上一个输出结果
8、Ctrl +shift +p switch切换主题
9、$$()选中所有匹配元素
10、debugger
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="前端开发" scheme="https://pink-png.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" />
        <category term="前端调试" scheme="https://pink-png.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E8%B0%83%E8%AF%95/" />
        <category term="前端调试" scheme="https://pink-png.github.io/tags/%E5%89%8D%E7%AB%AF%E8%B0%83%E8%AF%95/" />
        <updated>2023-12-04T03:41:00.000Z</updated>
    </entry>
    <entry>
        <id>https://pink-png.github.io/performance-optimization/35%E6%9D%A1%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96%E5%86%9B%E8%A7%84/</id>
        <title>35条前端优化军规</title>
        <link rel="alternate" href="https://pink-png.github.io/performance-optimization/35%E6%9D%A1%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96%E5%86%9B%E8%A7%84/"/>
        <content type="html">&lt;h1 id=&#34;减少-http-请求数&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#减少-http-请求数&#34;&gt;#&lt;/a&gt; 减少 HTTP 请求数&lt;/h1&gt;
&lt;p&gt;Web 前端 80% 的响应时间花在图片、样式、脚本等资源下载上。最直接的方式是减少页面所需资源，但并不现实。所以，减少 HTTP 请求数主要的途径是：&lt;/p&gt;
&lt;h2 id=&#34;合并-jscss-文件&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#合并-jscss-文件&#34;&gt;#&lt;/a&gt; 合并 JS/CSS 文件&lt;/h2&gt;
&lt;p&gt;服务器端（CDN）自动合并，基于 Node.js 的文件合并工具，通过把所有脚本放在一个文件中的方式来减少请求数。&lt;/p&gt;
&lt;p&gt;最好的优化是做到页面只加载一个 CSS 和一个 JS。&lt;/p&gt;
&lt;h2 id=&#34;使用-css-sprite&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#使用-css-sprite&#34;&gt;#&lt;/a&gt; 使用 CSS Sprite&lt;/h2&gt;
&lt;p&gt;将背景图片合并成一个文件，通过 background-image 和 background-position 控制显示&lt;/p&gt;
&lt;h2 id=&#34;行内图片base64-编码&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#行内图片base64-编码&#34;&gt;#&lt;/a&gt; 行内图片（Base64 编码）&lt;/h2&gt;
&lt;p&gt;使用 Data URI scheme 将图片嵌入 HTML 或者 CSS 中；或者将 CSS、JS、图片直接嵌入 HTML 中，会增加文件大小，也可能产生浏览器兼容及其他性能问题。&lt;/p&gt;
&lt;p&gt;减少页面的 HTTP 请求数是个起点，这是提升站点首次访问速度的重要指导原则。&lt;/p&gt;
&lt;h1 id=&#34;使用-cdn内容分发网络&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#使用-cdn内容分发网络&#34;&gt;#&lt;/a&gt; 使用 CDN（内容分发网络）&lt;/h1&gt;
&lt;p&gt;用户与服务器的物理距离对响应时间也有影响。把内容部署在多个地理位置分散的服务器上能让用户更快地载入页面。但具体要怎么做呢？&lt;/p&gt;
&lt;p&gt;实现内容在地理位置上分散的第一步是：不要尝试去重新设计你的 Web 应用程序来适应分布式结构。这取决于应用程序，改变结构可能包括一些让人望而生畏的任务，比如同步会话状态和跨服务器复制数据库等事务。缩短用户和内容之间距离的提议可能被推迟，或者根本不可能通过，就是因为这个难题。&lt;/p&gt;
&lt;p&gt;网站 80-90% 响应时间消耗在资源下载上，减少资源下载时间是性能优化的黄金法则。相比分布式架构的复杂和巨大投入，静态内容分发网络（CDN）可以以较低的投入，获得加载速度有效提升。&lt;/p&gt;
&lt;p&gt;内容分发网络（CDN）是一组分散在不同地理位置的 web 服务器，用来给用户更高效地发送内容。典型地，选择用来发送内容的服务器是基于网络距离的衡量标准的。例如：选跳数（hop）最少的或者响应时间最快的服务器。&lt;/p&gt;
&lt;h1 id=&#34;expires-或-cache-control-响应头&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#expires-或-cache-control-响应头&#34;&gt;#&lt;/a&gt; Expires 或 Cache-Control 响应头&lt;/h1&gt;
&lt;p&gt;这条规则有两个方面：&lt;/p&gt;
&lt;p&gt;对于静态组件：通过设置一个遥远的将来时间作为 Expires 来实现永不失效&lt;br /&gt;
多余动态组件：用合适的 Cache-Control HTTP 头来让浏览器进行条件性的请求&lt;/p&gt;
&lt;p&gt;网页设计越来越丰富，这意味着页面里有更多的脚本，图片。站点的新访客可能还是不得不提交几个 HTTP 请求，但通过使用有效期能让组件变得可缓存，这避免了在接下来的浏览过程中不必要的 HTTP 请求。有效期 HTTP 头通常被用在图片上，但它们也应该被用在所有组件上，包括脚本、样式等静态文件中。&lt;/p&gt;
&lt;p&gt;一般来讲，浏览器等客户端都会有缓存机制来减少 HTTP 请求的数目和大小，让页面能够更快加载。Web 服务器通过有效期 HTTP 响应头来告诉客户端，页面的各个组件应该被缓存多久。用一个遥远的将来时间做有效期，告诉浏览器这个响应在 2022 年 4 月 15 日前不会改变。&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;figcaption data-lang=&#34;javascript&#34;&gt;&lt;span&gt;t&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token literal-property property&#34;&gt;Expires&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;:&lt;/span&gt; Thu&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;15&lt;/span&gt; Apr &lt;span class=&#34;token number&#34;&gt;2022&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;20&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;00&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;00&lt;/span&gt; &lt;span class=&#34;token constant&#34;&gt;GMT&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;如果你用的是 Apache 服务器，用 ExpiresDefault 指令来设置相对于当前日期的有效期。下面的例子设置了从请求时间起 10 年的有效期：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;figcaption data-lang=&#34;javascript&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;ExpiresDefault &lt;span class=&#34;token string&#34;&gt;&#34;access plus 10 years&#34;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;因为 Expires 头使用一个特定的时间，它要求服务端和客户端的时钟严格同步；另外，过期日期需要经常检查，一旦过期日期到了，需要在服务器中配置提供一个新的日期。所以，HTTP1.1 引入了 Cache-Control 头来克服 Exipres 头的限制。&lt;/p&gt;
&lt;p&gt;Cache-Control 使用 max-age 指令指定组件被缓存多久，它以秒为单位定义了一个更新期限。使用带有 max-age 的 Cache-Control 可以消除 Expires 的限制，但对于不支持 HTTP1.1 的应用（在 2019 的现在很少很少了），仍希望使用 Expires 头。可以同时制定这两个响应头，如果两者同时出现时，HTTP 规范规定 max-age 指令将重写 Expires 头。&lt;/p&gt;
&lt;p&gt;当出现了 Expires 头时，直到过期时间为止一直会使用缓存的版本，浏览器不会检查任何更新，直到过了过期时间。为了确保用户能够获取组件的最新版本，需要在所有的 HTML 页面中修改组件的文件名。Yahoo 在此使用了将版本号嵌入在组件的文件名中的方法，简而言之就是通过修改文件名的方式来重置缓存。&lt;/p&gt;
&lt;h1 id=&#34;使用-gzip-压缩&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#使用-gzip-压缩&#34;&gt;#&lt;/a&gt; 使用 Gzip 压缩&lt;/h1&gt;
&lt;p&gt;压缩组件通过减少 HTTP 请求产生的响应包的大小，从而降低传输时间的方式来提高性能。从 HTTP1.1 开始，Web 客户端可以通过 HTTP 请求中的 Accept-Encoding 头来标识对压缩的支持：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;figcaption data-lang=&#34;javascript&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;Accept&lt;span class=&#34;token operator&#34;&gt;-&lt;/span&gt;Encoding&lt;span class=&#34;token operator&#34;&gt;:&lt;/span&gt; gzip&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt;deflate&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;服务器看到请求中的这个头，就会使用客户端列出的方法中的一种来压缩响应。Web 服务器通过响应中的 Content-Encoding 头来告知 Web 客户端：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;figcaption data-lang=&#34;javascript&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;Content&lt;span class=&#34;token operator&#34;&gt;-&lt;/span&gt;Encoding&lt;span class=&#34;token operator&#34;&gt;:&lt;/span&gt; gzip&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;目前许多网站通常会压缩 HTML 文档，脚本和样式表的压缩也是值得的（包括 XML 和 JSON 在内的任何文本响应理论上都值得被压缩）。但是，图片和 PDF 文件不应该被压缩，因为它们本来已经被压缩了。&lt;/p&gt;
&lt;p&gt;压缩通常能将响应的数据量减少近 70%，但是压缩通常情况下会带来服务端和客户端的 CPU 开销，要检测受益是否大于开销，需要综合考虑响应大小、带宽和客户端服务端物理距离等因素。通常需要对大于 1KB 或 2KB 的文件进行压缩。&lt;/p&gt;
&lt;p&gt;当浏览器通过代理来发送请求时，有可能出现浏览器期望接受的压缩后内容和实际接收到的不一致的情况。解决这一问题的方法是在 Web 服务器的响应中添加 Vary 头。Web 服务器可以告诉代理根据一个或多个请求头来改变缓存的响应。由于压缩的决定是基于 Accept-Encoding 请求头的，因此需要在服务器的 Vary 响应头中包含 Accept-Encoding:&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;figcaption data-lang=&#34;javascript&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token literal-property property&#34;&gt;Vary&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;:&lt;/span&gt; Accept&lt;span class=&#34;token operator&#34;&gt;-&lt;/span&gt;Encoding&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;目前大约 90% 的通过浏览器进行的网络通信都需要使用 gzip，这使得服务端和客户端的对等性变得额外重要。无论是客户端还是服务端发送错误，都会造成页面被破坏。避免错误的一种方式是采用『浏览器白名单』方式，即只为经过证实支持压缩的浏览器提供压缩内容，但是当代理缓存加进来以后，处理边缘情形浏览器将变得更加复杂。另一种方式是使用 Vary: * 或 Cache-Control: private 头来禁用代理缓存。此种方式会为所有浏览器禁用代理缓存，从而增加带宽开销。如何平衡压缩和代理支持需要在加快响应时间、减小带宽开销和边缘情形浏览器缺陷之间进行权衡：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果网站的用户很少，并且他们处于一个小圈子中，边缘情形浏览器不需要太多关注，可以压缩内容并使用 Vary: Accept-Encoding。&lt;/li&gt;
&lt;li&gt;如果更注重带宽开销，可以和前一种情形一样，压缩内容并使用 Vary: Accept-Encoding。&lt;/li&gt;
&lt;li&gt;如果网站拥有大量的、多变的用户群，能够应付较高的带宽开销，并且享有高质量的声誉，需要压缩内容并使用 Cache-Control: Private。（ Google 和 Yahoo 都使用这种方式）&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;将-css-放在页面顶部&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#将-css-放在页面顶部&#34;&gt;#&lt;/a&gt; 将 CSS 放在页面顶部&lt;/h1&gt;
&lt;p&gt;我们研究雅虎网页性能时发现把样式表移到 &amp;lt;head&amp;gt; 里会让页面更快。这是因为把样式表移到 &amp;lt;head&amp;gt; 里允许页面逐步渲染。&lt;/p&gt;
&lt;p&gt;关注性能的前端工程师希望页面被逐步渲染，这时因为，我们希望浏览器尽早渲染获取到的任何内容。这对大页面和网速慢的用户很重要。给用户视觉反馈，比如进度条的重要性已经被大量研究和记录。在我们的情况中，HTML 页面就是进度条。当浏览器逐步加载页面头部，导航条，logo 等等，这些都是给等待页面的用户的视觉反馈。这优化了整体用户体验。&lt;/p&gt;
&lt;p&gt;把样式表放在文档底部的问题是它阻止了许多浏览器的逐步渲染，包括 IE。这些浏览器阻止渲染来避免在样式更改时需要重绘页面元素。所以用户会卡在白屏。&lt;/p&gt;
&lt;p&gt;HTML&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw0L3N0cnVjdC9saW5rcy5odG1sI2gtMTIuMw==&#34;&gt;https://www.w3.org/TR/html4/struct/links.html#h-12.3&lt;/span&gt; 规范 清楚表明样式应该在 &amp;lt;head&amp;gt; 里。&lt;/p&gt;
&lt;h1 id=&#34;将-javascript-放在页面底部&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#将-javascript-放在页面底部&#34;&gt;#&lt;/a&gt; 将 JavaScript 放在页面底部&lt;/h1&gt;
&lt;p&gt;脚本会阻塞并行下载，HTTP/1.1 官方文档建议浏览器每个主机名下并行下载的组件数不要超过两个，如果图片来自多个域名，并行下载的数量就可以超过两个。如果脚本正在下载，浏览器就不开始任何其它下载任务，即使是在不同域名下的。&lt;/p&gt;
&lt;p&gt;有时候，并不容易把脚本移动到底部。举个例子，如果脚本是用 document.write 插入到页面内容中的，就没办法再往下移了。还可能存在作用域问题，在多数情况下，这些问题都是可以解决的。&lt;/p&gt;
&lt;p&gt;一个常见的建议是用推迟（deferred）脚本，有 DEFER 属性的脚本意味着不能含有 document.write，并且提示浏览器告诉他们可以继续渲染。不幸的是，Firefox 不支持 DEFER 属性。在 IE 中，脚本可能被推迟，但不尽如人意。如果脚本可以推迟，我们就可以把它放到页面底部，页面就可以更快地载入。&lt;/p&gt;
&lt;h1 id=&#34;避免使用-css-表达式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#避免使用-css-表达式&#34;&gt;#&lt;/a&gt; 避免使用 CSS 表达式&lt;/h1&gt;
&lt;p&gt;CSS 表达式是强大的（可能也是危险的）设置动态 CSS 属性的方法。IE5 开始支持，IE8 开始不赞成使用。例如，背景颜色可以设置成每小时轮换：&lt;/p&gt;
&lt;figure class=&#34;highlight css&#34;&gt;&lt;figcaption data-lang=&#34;CSS&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token property&#34;&gt;background-color&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;expression&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;new &lt;span class=&#34;token function&#34;&gt;Date&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;.&lt;span class=&#34;token function&#34;&gt;getHours&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;%2 ? &lt;span class=&#34;token string&#34;&gt;&#34;#B8D4FF&#34;&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#34;#F08A00&#34;&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;表达式的问题在于它们的评估频率高于大多数人的预期。它们不仅在页面呈现和调整大小时进行重新计算，而且在页面滚动时甚至在用户将鼠标移动到页面上时进行计算。在 CSS 表达式中添加计数器可以让我们跟踪 CSS 表达式的计算时间和频率。在页面上移动鼠标可以轻松计算超过 10,000 次。&lt;/p&gt;
&lt;h1 id=&#34;使用外部-javascript-和-css&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#使用外部-javascript-和-css&#34;&gt;#&lt;/a&gt; 使用外部 JavaScript 和 CSS&lt;/h1&gt;
&lt;p&gt;在现实环境中使用外部文件通常会产生较快的页面，因为 JavaScript 和 CSS 有机会被浏览器缓存起来。对于内联的情况，由于 HTML 文档通常不会被配置为可以进行缓存的，所以每次请求 HTML 文档都要下载 JavaScript 和 CSS。所以，如果 JavaScript 和 CSS 在外部文件中，浏览器可以缓存它们，HTML 文档的大小会被减少而不必增加 HTTP 请求数量。&lt;/p&gt;
&lt;p&gt;决定是否使用外部文件的关键在于被缓存的外部文件占请求的 HTML 文档数的比重。如果网站用户在每次会话中进行多次页面访问，同时页面重用了多个脚本和样式表，使用外部文件时很好的选择。&lt;/p&gt;
&lt;p&gt;对于大多数网站而言，难以精确度量以判断是否使用内联或外部文件，此时建议是使用外部文件的方式。对于这个问题的一个例外是网站主页，由于主页对于响应时间要求更高，因此更加倾向于内联而不是外部文件。&lt;/p&gt;
&lt;p&gt;对于内联文件而言，由于无法利用浏览器缓存，因此给人感觉依然比较低效。我们可以通过加载后下载和动态内联的方式来使得网站主页既可以获得内联的优势，同时也能缓存外部文件。&lt;/p&gt;
&lt;h1 id=&#34;减少-dns-查询&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#减少-dns-查询&#34;&gt;#&lt;/a&gt; 减少 DNS 查询&lt;/h1&gt;
&lt;p&gt;用户输入 URL 以后，浏览器首先要查询域名（&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2V4YW1wbGUuY29t&#34;&gt;example.com&lt;/span&gt;）对应服务器的 IP 地址，这个操作一般需要耗费 20-120 毫秒时间。DNS 查询完成之前，浏览器无法从服务器下载任何数据。&lt;/p&gt;
&lt;p&gt;基于性能考虑，ISP、局域网、操作系统、浏览器都会有相应的 DNS 缓存机制。&lt;/p&gt;
&lt;p&gt;IE 缓存 30 分钟，可以通过注册表中 DnsCacheTimeout 项设置；&lt;br /&gt;
Firefox 缓存 1 分钟，通过 network.dnsCacheExpiration 配置；&lt;br /&gt;
Chrome 缓存 1 分钟，通过 chrome://net-internals/#dns 配置。&lt;br /&gt;
另外需要注意的是这里有一个矛盾，减少不同的域名可减少 DNS 查找，同时也减少了页面下载资源文件的并发量。也就是说，虽然避免 DNS 查找削减了响应时间，但是减少并行下载数量却增加了响应时间。原则是把组件分散在 2~4 个域名下，控制好数量，这是同时减少 DNS 查找和允许并发下载的折中方案。&lt;/p&gt;
&lt;h1 id=&#34;压缩-javascript-和-css&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#压缩-javascript-和-css&#34;&gt;#&lt;/a&gt; 压缩 JavaScript 和 CSS&lt;/h1&gt;
&lt;p&gt;压缩具体来说就是从代码中去除不必要的字符以减少大小，从而提升加载速度。代码最小化就是去掉所有注释和不必要的空白字符（空格，换行和 tab）。&lt;/p&gt;
&lt;p&gt;在 JavaScript 中这样做能够提高响应性能，因为要下载的文件变小了。两个最常用的 JavaScript 代码压缩工具是 JSMin 和 YUI Compressor，YUI compressor 还可以压缩 CSS。&lt;/p&gt;
&lt;p&gt;混淆 是一种可选的源码优化措施，要比压缩更复杂，所以混淆过程也更容易产生 Bug。在对美国前十的网站调查中，压缩可以缩小 21%，而混淆能缩小 25%。虽然混淆的缩小程度更高，但比压缩风险更大。&lt;/p&gt;
&lt;p&gt;除了压缩外部脚本和样式，行内的和块也可以压缩。即使启用了 gzip 模块，先进行压缩也能够缩小 5% 或者更多的大小。JavaScript 和 CSS 的用处越来越多，所以压缩代码会有不错的效果。&lt;/p&gt;
&lt;p&gt;译者注：得益于 Node.js 的流行，开源社区涌现出许多高效、易用的前端优化工具，JavaScript 和 CSS 压缩类如 UglifyJS 2、csso、cssnano 等都是很成熟的工具。&lt;br /&gt;
对于内嵌的 CSS 和 JavaScript，也可以通过 htmlmin 等工具压缩。&lt;br /&gt;
这些项目都有 Gulp、Webpack 等流行构建工具的配套版本。&lt;/p&gt;
&lt;h1 id=&#34;避免-301302-重定向&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#避免-301302-重定向&#34;&gt;#&lt;/a&gt; 避免 301/302 重定向&lt;/h1&gt;
&lt;p&gt;HTTP 重定向通过 301/302 状态码实现。下面是一个 301 状态码的 HTTP 头：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; HTTP/1.1 301 Moved Permanently 
 Location: http://example.com/newuri
 Content-Type: text/html
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;浏览器会自动跳转到 Location 域指明的 URL。重定向需要的所有信息都在 HTTP 头部，而响应体一般是空的。其实额外的 HTTP 头，比如 Expires 和 Cache-Control 也表示重定向。除此之外还有别的跳转方式：refresh 元标签和 JavaScript，但如果你必须得做重定向，最好用标准的 3xx HTTP 状态码，主要是为了让返回按钮能正常使用。&lt;/p&gt;
&lt;h2 id=&#34;影响&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#影响&#34;&gt;#&lt;/a&gt; 影响&lt;/h2&gt;
&lt;p&gt;客户端收到服务器的重定向响应后，会根据响应头中 Location 的地址再次发送请求。重定向会影响用户体验，尤其是多次重定向时，用户在一段时间内看不到任何内容，只看到浏览器进度条一直在刷新。&lt;/p&gt;
&lt;h2 id=&#34;常见错误&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#常见错误&#34;&gt;#&lt;/a&gt; 常见错误&lt;/h2&gt;
&lt;p&gt;有一种常见的极其浪费资源的重定向，而且 Web 开发人员一般都意识不到这一点：URL 末尾应该添加 / 但未添加。比如，访问 &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2FzdHJvbG9neS55YWhvby5jb20vYXN0cm9sb2d5&#34;&gt;http://astrology.yahoo.com/astrology&lt;/span&gt; 将被 301 重定向到 &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2FzdHJvbG9neS55YWhvby5jb20vYXN0cm9sb2d5LyVFRiVCQyU4OCVFNiVCMyVBOCVFNiU4NCU4RiVFNiU5QyVBQiVFNSVCMCVCRSVFNyU5QSU4NA==&#34;&gt;http://astrology.yahoo.com/astrology/（注意末尾的&lt;/span&gt; /）。如果使用 Apache，可以通过 Alias 或 mod_rewrite 或 DirectorySlash 解决这个问题。&lt;/p&gt;
&lt;p&gt;另一种常见用途是从旧站点跳转到新站点，有时是跳转到同一站点的不同部分，或者针对用户的不同情况（浏览器类型，用户帐号类型等等）做一些处理。用重定向来连接两个网站是最简单的，只需要少量的额外代码。虽然在这些时候使用重定向减少了开发人员的开发复杂度，但降低了用户体验。一种替代方案是用 Alias 和 mod_rewrite，前提是两个代码都在相同的服务器上。如果是因为域名变化而使用了重定向，就可以创建一条 CNAME（创建一个指向另一个域名的 DNS 记录作为别名）结合 Alias 或者 mod_rewrite 指令。&lt;/p&gt;
&lt;h1 id=&#34;移除重复的-javascript-脚本&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#移除重复的-javascript-脚本&#34;&gt;#&lt;/a&gt; 移除重复的 JavaScript 脚本&lt;/h1&gt;
&lt;p&gt;页面含有重复的脚本文件会影响性能，这可能和你想象的不一样。在对美国前 10 大 Web 站点的评审中，发现只有 2 个站点含有重复脚本。两个主要原因增加了在单一页面中出现重复脚本的几率：团队大小和脚本数量。在这种情况下，重复脚本会创建不必要的 HTTP 请求，执行无用的 JavaScript 代码，而影响页面性能。&lt;/p&gt;
&lt;p&gt;IE 会产生不必要的 HTTP 请求，而 Firefox 不会。在 IE 中，如果一个不可缓存的外部脚本被页面引入了两次，它会在页面加载时产生两个 HTTP 请求。即使脚本是可缓存的，在用户重新加载页面时也会产生额外的 HTTP 请求。&lt;/p&gt;
&lt;p&gt;除了产生没有意义的 HTTP 请求之外，多次执行脚本也会浪费时间。因为无论脚本是否可缓存，在主流浏览器中都会执行冗余的 JavaScript 代码。&lt;/p&gt;
&lt;p&gt;避免不小心把相同脚本引入两次的一种方法就是在模板系统中实现脚本管理模块。典型的脚本引入方法就是在 HTML 页面中用 SCRIPT 标签：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;figcaption data-lang=&#34;javascript&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token operator&#34;&gt;&amp;lt;&lt;/span&gt;script type&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#34;text/javascript&#34;&lt;/span&gt; src&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#34;menu_1.0.17.js&#34;&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;&gt;&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;/&lt;/span&gt;script&lt;span class=&#34;token operator&#34;&gt;&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;升级为以下这种 PHP 动态函数 insertScript () 进行加载：&lt;/p&gt;
&lt;figure class=&#34;highlight php&#34;&gt;&lt;figcaption data-lang=&#34;PHP&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token php language-php&#34;&gt;&lt;span class=&#34;token delimiter important&#34;&gt;&amp;lt;?php&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;insertScript&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token string double-quoted-string&#34;&gt;&#34;menu.js&#34;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token delimiter important&#34;&gt;?&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;这样在 insertScript () 里执行确保加载的唯一性，或者设置好文件版本等操作。&lt;/p&gt;
&lt;h1 id=&#34;设置-etags-来控制缓存&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#设置-etags-来控制缓存&#34;&gt;#&lt;/a&gt; 设置 ETags 来控制缓存&lt;/h1&gt;
&lt;p&gt;实体标记（Entity tags，ETag）是服务器和浏览器之间判断浏览器缓存中某个文件是否匹配服务器端原文件的一种机制。实体就是资源文件，如图片，脚本，样式等等。ETag 是比验证 last-modified 日期更高效的机制。&lt;/p&gt;
&lt;p&gt;服务器这样设置组件的 ETag：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HTTP/1.1 200 OK
Last-Modified: Tue, 12 Dec 2006 03:03:59 GMT
ETag: &amp;quot;10c24bc-4ab-457e1c1f&amp;quot;
Content-Length: 12195
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之后，如果浏览器要验证文件，它用 If-None-Match 头部来传 ETag 给服务器。如果 ETag 匹配，服务器返回 304（文件未变化），就不下载内容。这样就减少了 12195 个字节的响应体。Etag 通过文件版本标识，方便服务器判断请求的内容是否有更新，如果没有就响应 304，避免重新下载：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GET /i/yahoo.gif HTTP/1.1
Host: us.yimg.com
If-Modified-Since: Tue, 12 Dec 2006 03:03:59 GMT
If-None-Match: &amp;quot;10c24bc-4ab-457e1c1f&amp;quot;
HTTP/1.1 304 Not Modified
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ETag 的问题在于，通常使用文件的某些属性来构造它，这些属性对于特定的网站服务器来说是唯一的。在集群的情况下，当浏览器从一台服务器上获取了原始文件之后又尝试向另一台服务器来验证文件时，ETag 是不匹配的。这种情况是使用服务器集群的网站经常会遇到的问题。默认情况下，Apache 和 IIS 向 ETag 中嵌入的数据都会大大降低有效性验证的成功率。&lt;/p&gt;
&lt;p&gt;Apache1.3 和 2.x 的 ETag 格式是 inode-size-timestamp。文件系统使用 inode 来存储诸如文件类型、所有者、组和访问模式等信息。尽管在多台服务器上一个给定的文件可能位于相同的目录、具有相同的文件大小、权限、时间戳等，从一台服务器到另一台服务器的 inode 仍然是不同的。&lt;/p&gt;
&lt;p&gt;IIS5.0 和 6.0 在 ETag 上有着类似的问题。IIS 上 ETag 的格式是 Filetimestamp:ChangeNumber。ChangeNumber 适用于跟踪 IIS 配置变化的计数器。对于一个网站背后的所有 IIS 服务器来说，ChangeNumber 不大可能相同。&lt;/p&gt;
&lt;p&gt;最终的结果是，对于完全相同的组件，从一台服务器到另一台，Apache 和 IIS 产生的 ETag 是不会匹配的。如果 ETag 不匹配，用户就不会按照 ETag 的设计那样接收到更小更快的 304 响应；相反，它们会收到普通的 200 响应以及组件的所有数据。&lt;/p&gt;
&lt;p&gt;如果只在一台服务器上部署网站，这通常不会产生问题；但如果使用了服务器集群，同时使用 Apache 或者 IIS 默认的 ETag 配置，用户响应将变慢，服务器负载将变高，将消耗更多的带宽，同时代理缓存的效率也会下降。即使组件具有长久的 Expires 头，一旦用户单击了 Reload 或 Refresh 按钮，依然会产生条件 GET 请求。&lt;/p&gt;
&lt;p&gt;如果组件必须通过最新修改日期之外的一些东西来进行验证，则 ETag 是一种强大的方法；如果无须自定义 ETag，则最好将其移除。 last-modified 头基于文件的时间戳进行验证，可以提供完全等价的信息，而且移除 ETag 可以减少响应和后续请求的 HTTP 头的大小。在 Apache 中，只要向 Apache 配置文件中简单地添加下面一行配置就能移除 ETag：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FileETag none
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="前端开发" scheme="https://pink-png.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" />
        <category term="前端性能优化" scheme="https://pink-png.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" />
        <category term="前端性能优化" scheme="https://pink-png.github.io/tags/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" />
        <updated>2023-12-04T03:41:00.000Z</updated>
    </entry>
    <entry>
        <id>https://pink-png.github.io/tool/git%E5%AD%A6%E4%B9%A0%E6%B8%85%E5%8D%95/</id>
        <title>git学习清单</title>
        <link rel="alternate" href="https://pink-png.github.io/tool/git%E5%AD%A6%E4%B9%A0%E6%B8%85%E5%8D%95/"/>
        <content type="html">&lt;h2 id=&#34;1-初始化本地仓库-git-init&#34;&gt;&lt;a href=&#34;#1-初始化本地仓库-git-init&#34; class=&#34;headerlink&#34; title=&#34;1.初始化本地仓库  git init &#34;&gt;&lt;/a&gt;1.初始化本地仓库  git init &lt;directory&gt;&lt;/h2&gt;&lt;h2 id=&#34;2-克隆一个远程仓库-git-clone&#34;&gt;&lt;a href=&#34;#2-克隆一个远程仓库-git-clone&#34; class=&#34;headerlink&#34; title=&#34;2.克隆一个远程仓库  git clone &#34;&gt;&lt;/a&gt;2.克隆一个远程仓库  git clone &lt;url&gt;&lt;/h2&gt;&lt;h2 id=&#34;3-添加文件到暂存区-git-add-要添加当前目录中的所有文件，请使用-代替-代码如下：-git-add&#34;&gt;&lt;a href=&#34;#3-添加文件到暂存区-git-add-要添加当前目录中的所有文件，请使用-代替-代码如下：-git-add&#34; class=&#34;headerlink&#34; title=&#34;3.添加文件到暂存区 git add 要添加当前目录中的所有文件，请使用 . 代替,代码如下： git add .&#34;&gt;&lt;/a&gt;3.添加文件到暂存区 git add &lt;file&gt;要添加当前目录中的所有文件，请使用 . 代替,代码如下： git add .&lt;/h2&gt;&lt;h2 id=&#34;4-提交更改-git-commit-m-““如果要添加对跟踪文件所做的所有更改并提交。-git-commit-a-m-““-orgit-commit-am-““&#34;&gt;&lt;a href=&#34;#4-提交更改-git-commit-m-““如果要添加对跟踪文件所做的所有更改并提交。-git-commit-a-m-““-orgit-commit-am-““&#34; class=&#34;headerlink&#34; title=&#34;4.提交更改 git commit -m ““如果要添加对跟踪文件所做的所有更改并提交。 git commit -a -m ““# orgit commit -am ““&#34;&gt;&lt;/a&gt;4.提交更改 git commit -m “&lt;message&gt;“如果要添加对跟踪文件所做的所有更改并提交。 git commit -a -m “&lt;message&gt;“# orgit commit -am “&lt;message&gt;“&lt;/h2&gt;&lt;h2 id=&#34;5-从暂存区删除一个文件-git-reset&#34;&gt;&lt;a href=&#34;#5-从暂存区删除一个文件-git-reset&#34; class=&#34;headerlink&#34; title=&#34;5.从暂存区删除一个文件 git reset &#34;&gt;&lt;/a&gt;5.从暂存区删除一个文件 git reset &lt;file&gt;&lt;/h2&gt;&lt;h2 id=&#34;6-移动或重命名文件-git-mv&#34;&gt;&lt;a href=&#34;#6-移动或重命名文件-git-mv&#34; class=&#34;headerlink&#34; title=&#34;6.移动或重命名文件 git mv  &#34;&gt;&lt;/a&gt;6.移动或重命名文件 git mv &lt;current path&gt; &lt;new path&gt;&lt;/h2&gt;&lt;h2 id=&#34;7-从存储库中删除文件-git-rm-您也可以仅使用-–cached-标志将其从暂存区中删除-git-rm-–cached&#34;&gt;&lt;a href=&#34;#7-从存储库中删除文件-git-rm-您也可以仅使用-–cached-标志将其从暂存区中删除-git-rm-–cached&#34; class=&#34;headerlink&#34; title=&#34;7.从存储库中删除文件  git rm  您也可以仅使用 –cached 标志将其从暂存区中删除	 git rm –cached &#34;&gt;&lt;/a&gt;7.从存储库中删除文件  git rm &lt;file&gt; 您也可以仅使用 –cached 标志将其从暂存区中删除	 git rm –cached &lt;file&gt;&lt;/h2&gt;&lt;h1 id=&#34;基本-Git-概念&#34;&gt;&lt;a href=&#34;#基本-Git-概念&#34; class=&#34;headerlink&#34; title=&#34;基本 Git 概念&#34;&gt;&lt;/a&gt;基本 Git 概念&lt;/h1&gt;&lt;h2 id=&#34;8-默认分支名称：main&#34;&gt;&lt;a href=&#34;#8-默认分支名称：main&#34; class=&#34;headerlink&#34; title=&#34;8.默认分支名称：main&#34;&gt;&lt;/a&gt;8.默认分支名称：main&lt;/h2&gt;&lt;h2 id=&#34;9-默认远程名称：origin&#34;&gt;&lt;a href=&#34;#9-默认远程名称：origin&#34; class=&#34;headerlink&#34; title=&#34;9.默认远程名称：origin&#34;&gt;&lt;/a&gt;9.默认远程名称：origin&lt;/h2&gt;&lt;h2 id=&#34;10-当前分支参考：HEAD&#34;&gt;&lt;a href=&#34;#10-当前分支参考：HEAD&#34; class=&#34;headerlink&#34; title=&#34;10.当前分支参考：HEAD&#34;&gt;&lt;/a&gt;10.当前分支参考：HEAD&lt;/h2&gt;&lt;h2 id=&#34;11-HEAD-的父级：HEAD-或-HEAD-1&#34;&gt;&lt;a href=&#34;#11-HEAD-的父级：HEAD-或-HEAD-1&#34; class=&#34;headerlink&#34; title=&#34;11.HEAD 的父级：HEAD^ 或 HEAD~1&#34;&gt;&lt;/a&gt;11.HEAD 的父级：HEAD^ 或 HEAD~1&lt;/h2&gt;&lt;h2 id=&#34;12-HEAD-的祖父母：HEAD-或-HEAD-2&#34;&gt;&lt;a href=&#34;#12-HEAD-的祖父母：HEAD-或-HEAD-2&#34; class=&#34;headerlink&#34; title=&#34;12.HEAD 的祖父母：HEAD^^ 或 HEAD~2&#34;&gt;&lt;/a&gt;12.HEAD 的祖父母：HEAD^^ 或 HEAD~2&lt;/h2&gt;&lt;h2 id=&#34;13-显示分支-git-branch-有用的标志：&#34;&gt;&lt;a href=&#34;#13-显示分支-git-branch-有用的标志：&#34; class=&#34;headerlink&#34; title=&#34;13.显示分支 git branch  有用的标志：&#34;&gt;&lt;/a&gt;13.显示分支 git branch  有用的标志：&lt;/h2&gt;&lt;p&gt;-a：显示所有分支（本地和远程）&lt;/p&gt;
&lt;p&gt;-r：显示远程分支&lt;/p&gt;
&lt;p&gt;-v：显示最后一次提交的分支&lt;/p&gt;
&lt;h2 id=&#34;14-创建一个分支-git-branch-你可以创建一个分支并使用-checkout-命令切换到它。git-checkout-b&#34;&gt;&lt;a href=&#34;#14-创建一个分支-git-branch-你可以创建一个分支并使用-checkout-命令切换到它。git-checkout-b&#34; class=&#34;headerlink&#34; title=&#34;14.创建一个分支 git branch   你可以创建一个分支并使用 checkout 命令切换到它。git checkout -b &#34;&gt;&lt;/a&gt;14.创建一个分支 git branch &lt;branch&gt;  你可以创建一个分支并使用 checkout 命令切换到它。git checkout -b &lt;branch&gt;&lt;/h2&gt;&lt;h2 id=&#34;15-切换到一个分支-git-checkout&#34;&gt;&lt;a href=&#34;#15-切换到一个分支-git-checkout&#34; class=&#34;headerlink&#34; title=&#34;15.切换到一个分支 git checkout &#34;&gt;&lt;/a&gt;15.切换到一个分支 git checkout &lt;branch&gt;&lt;/h2&gt;&lt;h2 id=&#34;16-删除一个分支-git-branch-d-您还可以使用-D-标志强制删除分支。-git-branch-D&#34;&gt;&lt;a href=&#34;#16-删除一个分支-git-branch-d-您还可以使用-D-标志强制删除分支。-git-branch-D&#34; class=&#34;headerlink&#34; title=&#34;16.删除一个分支 git branch -d  您还可以使用 -D 标志强制删除分支。 git branch -D &#34;&gt;&lt;/a&gt;16.删除一个分支 git branch -d &lt;branch&gt; 您还可以使用 -D 标志强制删除分支。 git branch -D &lt;branch&gt;&lt;/h2&gt;&lt;h2 id=&#34;17-合并分支-git-merge-有用的标志：&#34;&gt;&lt;a href=&#34;#17-合并分支-git-merge-有用的标志：&#34; class=&#34;headerlink&#34; title=&#34;17.合并分支 git merge  有用的标志：&#34;&gt;&lt;/a&gt;17.合并分支 git merge &lt;branch to merge into HEAD&gt; 有用的标志：&lt;/h2&gt;&lt;p&gt;–no-ff：即使合并解析为快进，也创建合并提交&lt;/p&gt;
&lt;p&gt;–squash：将指定分支中的所有提交压缩为单个提交&lt;/p&gt;
&lt;p&gt;建议不要使用 –squash 标志，因为它会将所有提交压缩为单个提交，从而导致提交历史混乱。&lt;/p&gt;
&lt;h2 id=&#34;18-变基分支-变基是将一系列提交移动或组合到新的基本提交的过程。git-rebase&#34;&gt;&lt;a href=&#34;#18-变基分支-变基是将一系列提交移动或组合到新的基本提交的过程。git-rebase&#34; class=&#34;headerlink&#34; title=&#34;18.变基分支 变基是将一系列提交移动或组合到新的基本提交的过程。git rebase &#34;&gt;&lt;/a&gt;18.变基分支 变基是将一系列提交移动或组合到新的基本提交的过程。git rebase &lt;branch to rebase from&gt;&lt;/h2&gt;&lt;h2 id=&#34;19-查看之前的提交-git-checkout&#34;&gt;&lt;a href=&#34;#19-查看之前的提交-git-checkout&#34; class=&#34;headerlink&#34; title=&#34;19.查看之前的提交 git checkout &#34;&gt;&lt;/a&gt;19.查看之前的提交 git checkout &lt;commit id&gt;&lt;/h2&gt;&lt;h2 id=&#34;20-恢复提交-git-revert&#34;&gt;&lt;a href=&#34;#20-恢复提交-git-revert&#34; class=&#34;headerlink&#34; title=&#34;20.恢复提交 git revert &#34;&gt;&lt;/a&gt;20.恢复提交 git revert &lt;commit id&gt;&lt;/h2&gt;&lt;h2 id=&#34;21-重置提交-git-reset-您还可以添加-–hard-标志来删除所有更改，但请谨慎使用。-git-reset-–hard&#34;&gt;&lt;a href=&#34;#21-重置提交-git-reset-您还可以添加-–hard-标志来删除所有更改，但请谨慎使用。-git-reset-–hard&#34; class=&#34;headerlink&#34; title=&#34;21.重置提交 git reset  您还可以添加 –hard 标志来删除所有更改，但请谨慎使用。 git reset –hard &#34;&gt;&lt;/a&gt;21.重置提交 git reset &lt;commit id&gt; 您还可以添加 –hard 标志来删除所有更改，但请谨慎使用。 git reset –hard &lt;commit id&gt;&lt;/h2&gt;&lt;h2 id=&#34;22-查看存储库的状态-git-status&#34;&gt;&lt;a href=&#34;#22-查看存储库的状态-git-status&#34; class=&#34;headerlink&#34; title=&#34;22.查看存储库的状态 git status&#34;&gt;&lt;/a&gt;22.查看存储库的状态 git status&lt;/h2&gt;&lt;h2 id=&#34;23-显示提交历史-git-log&#34;&gt;&lt;a href=&#34;#23-显示提交历史-git-log&#34; class=&#34;headerlink&#34; title=&#34;23.显示提交历史 git log&#34;&gt;&lt;/a&gt;23.显示提交历史 git log&lt;/h2&gt;&lt;h2 id=&#34;24-显示对未暂存文件的更改-git-diff-您还可以使用-–staged-标志来显示对暂存文件的更改。-git-diff-–staged&#34;&gt;&lt;a href=&#34;#24-显示对未暂存文件的更改-git-diff-您还可以使用-–staged-标志来显示对暂存文件的更改。-git-diff-–staged&#34; class=&#34;headerlink&#34; title=&#34;24.显示对未暂存文件的更改 git diff\  您还可以使用 –staged 标志来显示对暂存文件的更改。 git diff –staged&#34;&gt;&lt;/a&gt;24.显示对未暂存文件的更改 git diff\  您还可以使用 –staged 标志来显示对暂存文件的更改。 git diff –staged&lt;/h2&gt;&lt;h2 id=&#34;25-显示两次提交之间的变化-git-diff-lt-commit-id-01-gt-lt-commit-id-02-gt&#34;&gt;&lt;a href=&#34;#25-显示两次提交之间的变化-git-diff-lt-commit-id-01-gt-lt-commit-id-02-gt&#34; class=&#34;headerlink&#34; title=&#34;25.显示两次提交之间的变化 git diff &amp;lt;commit id 01&amp;gt; &amp;lt;commit id 02&amp;gt;&#34;&gt;&lt;/a&gt;25.显示两次提交之间的变化 git diff &amp;lt;commit id 01&amp;gt; &amp;lt;commit id 02&amp;gt;&lt;/h2&gt;&lt;h2 id=&#34;26-存储更改-stash-允许您在不提交更改的情况下临时存储更改。-git-stash-您还可以将消息添加到存储中。-git-stash-save-““&#34;&gt;&lt;a href=&#34;#26-存储更改-stash-允许您在不提交更改的情况下临时存储更改。-git-stash-您还可以将消息添加到存储中。-git-stash-save-““&#34; class=&#34;headerlink&#34; title=&#34;26.存储更改 stash 允许您在不提交更改的情况下临时存储更改。 git stash  您还可以将消息添加到存储中。 git stash save ““&#34;&gt;&lt;/a&gt;26.存储更改 stash 允许您在不提交更改的情况下临时存储更改。 git stash  您还可以将消息添加到存储中。 git stash save “&lt;message&gt;“&lt;/h2&gt;&lt;h2 id=&#34;27-列出存储-git-stash-list&#34;&gt;&lt;a href=&#34;#27-列出存储-git-stash-list&#34; class=&#34;headerlink&#34; title=&#34;27.列出存储 git stash list&#34;&gt;&lt;/a&gt;27.列出存储 git stash list&lt;/h2&gt;&lt;h2 id=&#34;28-申请一个藏匿处-应用存储不会将其从存储列表中删除。-git-stash-apply-如果不指定，将应用最新的-stash（适用于所有类似的-stash-命令）-您还可以使用格式-stash-应用存储（适用于所有类似的存储命令）-git-stash-apply-stash-0&#34;&gt;&lt;a href=&#34;#28-申请一个藏匿处-应用存储不会将其从存储列表中删除。-git-stash-apply-如果不指定，将应用最新的-stash（适用于所有类似的-stash-命令）-您还可以使用格式-stash-应用存储（适用于所有类似的存储命令）-git-stash-apply-stash-0&#34; class=&#34;headerlink&#34; title=&#34;28.申请一个藏匿处 应用存储不会将其从存储列表中删除。 git stash apply  如果不指定，将应用最新的 stash（适用于所有类似的 stash 命令） 您还可以使用格式 stash@{} 应用存储（适用于所有类似的存储命令） git stash apply stash@{0}&#34;&gt;&lt;/a&gt;28.申请一个藏匿处 应用存储不会将其从存储列表中删除。 git stash apply &lt;stash id&gt; 如果不指定，将应用最新的 stash（适用于所有类似的 stash 命令） 您还可以使用格式 stash@{} 应用存储（适用于所有类似的存储命令） git stash apply stash@{0}&lt;/h2&gt;&lt;h2 id=&#34;29-删除一个藏匿处-git-stash-drop&#34;&gt;&lt;a href=&#34;#29-删除一个藏匿处-git-stash-drop&#34; class=&#34;headerlink&#34; title=&#34;29.删除一个藏匿处 git stash drop &#34;&gt;&lt;/a&gt;29.删除一个藏匿处 git stash drop &lt;stash id&gt;&lt;/h2&gt;&lt;h2 id=&#34;30-删除所有藏匿处-git-stash-clear&#34;&gt;&lt;a href=&#34;#30-删除所有藏匿处-git-stash-clear&#34; class=&#34;headerlink&#34; title=&#34;30.删除所有藏匿处 git stash clear&#34;&gt;&lt;/a&gt;30.删除所有藏匿处 git stash clear&lt;/h2&gt;&lt;h2 id=&#34;31-应用和删除存储-git-stash-pop&#34;&gt;&lt;a href=&#34;#31-应用和删除存储-git-stash-pop&#34; class=&#34;headerlink&#34; title=&#34;31.应用和删除存储 git stash pop &#34;&gt;&lt;/a&gt;31.应用和删除存储 git stash pop &lt;stash id&gt;&lt;/h2&gt;&lt;h2 id=&#34;32-显示存储中的更改-git-stash-show&#34;&gt;&lt;a href=&#34;#32-显示存储中的更改-git-stash-show&#34; class=&#34;headerlink&#34; title=&#34;32.显示存储中的更改 git stash show &#34;&gt;&lt;/a&gt;32.显示存储中的更改 git stash show &lt;stash id&gt;&lt;/h2&gt;&lt;h2 id=&#34;33-添加远程仓库-git-remote-add&#34;&gt;&lt;a href=&#34;#33-添加远程仓库-git-remote-add&#34; class=&#34;headerlink&#34; title=&#34;33.添加远程仓库 git remote add  &#34;&gt;&lt;/a&gt;33.添加远程仓库 git remote add &lt;remote name&gt; &lt;url&gt;&lt;/h2&gt;&lt;h2 id=&#34;34-显示远程仓库-git-remote-添加-v-标志以显示远程存储库的-URL。-git-remote-v&#34;&gt;&lt;a href=&#34;#34-显示远程仓库-git-remote-添加-v-标志以显示远程存储库的-URL。-git-remote-v&#34; class=&#34;headerlink&#34; title=&#34;34.显示远程仓库 git remote 添加 -v 标志以显示远程存储库的 URL。 git remote -v&#34;&gt;&lt;/a&gt;34.显示远程仓库 git remote 添加 -v 标志以显示远程存储库的 URL。 git remote -v&lt;/h2&gt;&lt;h2 id=&#34;35-删除远程仓库-git-remote-remove&#34;&gt;&lt;a href=&#34;#35-删除远程仓库-git-remote-remove&#34; class=&#34;headerlink&#34; title=&#34;35.删除远程仓库 git remote remove &#34;&gt;&lt;/a&gt;35.删除远程仓库 git remote remove &lt;remote name&gt;&lt;/h2&gt;&lt;h2 id=&#34;36-重命名远程存储库-git-remote-rename&#34;&gt;&lt;a href=&#34;#36-重命名远程存储库-git-remote-rename&#34; class=&#34;headerlink&#34; title=&#34;36.重命名远程存储库 git remote rename  &#34;&gt;&lt;/a&gt;36.重命名远程存储库 git remote rename &lt;old name&gt; &lt;new name&gt;&lt;/h2&gt;&lt;h2 id=&#34;37-从远程存储库中获取更改-git-fetch&#34;&gt;&lt;a href=&#34;#37-从远程存储库中获取更改-git-fetch&#34; class=&#34;headerlink&#34; title=&#34;37.从远程存储库中获取更改 git fetch &#34;&gt;&lt;/a&gt;37.从远程存储库中获取更改 git fetch &lt;remote name&gt;&lt;/h2&gt;&lt;h2 id=&#34;38-从特定分支获取更改-git-fetch&#34;&gt;&lt;a href=&#34;#38-从特定分支获取更改-git-fetch&#34; class=&#34;headerlink&#34; title=&#34;38.从特定分支获取更改 git fetch  &#34;&gt;&lt;/a&gt;38.从特定分支获取更改 git fetch &lt;remote name&gt; &lt;branch&gt;&lt;/h2&gt;&lt;h2 id=&#34;39-从远程存储库中拉取更改-git-pull&#34;&gt;&lt;a href=&#34;#39-从远程存储库中拉取更改-git-pull&#34; class=&#34;headerlink&#34; title=&#34;39.从远程存储库中拉取更改 git pull  &#34;&gt;&lt;/a&gt;39.从远程存储库中拉取更改 git pull &lt;remote name&gt; &lt;branch&gt;&lt;/h2&gt;&lt;h2 id=&#34;40-将更改推送到远程存储库-git-push&#34;&gt;&lt;a href=&#34;#40-将更改推送到远程存储库-git-push&#34; class=&#34;headerlink&#34; title=&#34;40.将更改推送到远程存储库 git push &#34;&gt;&lt;/a&gt;40.将更改推送到远程存储库 git push &lt;remote name&gt;&lt;/h2&gt;&lt;h2 id=&#34;41-将更改推送到特定分支-git-push&#34;&gt;&lt;a href=&#34;#41-将更改推送到特定分支-git-push&#34; class=&#34;headerlink&#34; title=&#34;41.将更改推送到特定分支 git push  &#34;&gt;&lt;/a&gt;41.将更改推送到特定分支 git push &lt;remote name&gt; &lt;branch&gt;&lt;/h2&gt;</content>
        <category term="版本管理" scheme="https://pink-png.github.io/categories/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/" />
        <category term="git" scheme="https://pink-png.github.io/categories/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/git/" />
        <category term="版本管理" scheme="https://pink-png.github.io/tags/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/" />
        <updated>2023-12-01T08:43:00.000Z</updated>
    </entry>
    <entry>
        <id>https://pink-png.github.io/tool/%E4%B8%8B%E8%BD%BD%E7%B1%BB/</id>
        <title>下载</title>
        <link rel="alternate" href="https://pink-png.github.io/tool/%E4%B8%8B%E8%BD%BD%E7%B1%BB/"/>
        <content type="html">&lt;h1 id=&#34;xshell-下载地址&#34;&gt;&lt;a href=&#34;#xshell-下载地址&#34; class=&#34;headerlink&#34; title=&#34;xshell 下载地址&#34;&gt;&lt;/a&gt;xshell 下载地址&lt;/h1&gt;&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cueHNoZWxsLmNvbS96aC9mcmVlLWZvci1ob21lLXNjaG9vbC8=&#34;&gt;https://www.xshell.com/zh/free-for-home-school/&lt;/span&gt; &lt;/p&gt;
</content>
        <category term="下载" scheme="https://pink-png.github.io/categories/%E4%B8%8B%E8%BD%BD/" />
        <category term="xshell" scheme="https://pink-png.github.io/categories/%E4%B8%8B%E8%BD%BD/xshell/" />
        <category term="xshell" scheme="https://pink-png.github.io/tags/xshell/" />
        <updated>2023-12-01T08:43:00.000Z</updated>
    </entry>
    <entry>
        <id>https://pink-png.github.io/js-base/jsES6-ES13%E6%96%B0%E5%A2%9E%E7%9A%84%E5%8A%9F%E8%83%BD/</id>
        <title>ES6-ES13新增的特性</title>
        <link rel="alternate" href="https://pink-png.github.io/js-base/jsES6-ES13%E6%96%B0%E5%A2%9E%E7%9A%84%E5%8A%9F%E8%83%BD/"/>
        <content type="html">&lt;h1 id=&#34;ES6（ES2015）&#34;&gt;&lt;a href=&#34;#ES6（ES2015）&#34; class=&#34;headerlink&#34; title=&#34;ES6（ES2015）&#34;&gt;&lt;/a&gt;ES6（ES2015）&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;text&#34;&gt;块级作用域变量声明（let和const）
箭头函数
模板字面量
解构赋值
默认参数值
扩展运算符和剩余参数
类和模块化（class和import/export）
Promise 对象
迭代器和生成器（Iterator和Generator）
新的集合类型（Map、Set、WeakMap、WeakSet）
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;ES7（ES2016）&#34;&gt;&lt;a href=&#34;#ES7（ES2016）&#34; class=&#34;headerlink&#34; title=&#34;ES7（ES2016）&#34;&gt;&lt;/a&gt;ES7（ES2016）&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;text&#34;&gt;Array.prototype.includes 方法
指数操作符（**）
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;ES8-ES2017&#34;&gt;&lt;a href=&#34;#ES8-ES2017&#34; class=&#34;headerlink&#34; title=&#34;ES8 (ES2017)&#34;&gt;&lt;/a&gt;ES8 (ES2017)&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;text&#34;&gt;异步函数（async/await）
Object.values 和 Object.entries 方法
字符串填充方法（padStart和padEnd）
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;ES9-ES2018&#34;&gt;&lt;a href=&#34;#ES9-ES2018&#34; class=&#34;headerlink&#34; title=&#34;ES9 (ES2018)&#34;&gt;&lt;/a&gt;ES9 (ES2018)&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;text&#34;&gt;异步迭代器
Promise.prototype.finally 方法
Rest/Spread 属性
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;ES10-ES2019&#34;&gt;&lt;a href=&#34;#ES10-ES2019&#34; class=&#34;headerlink&#34; title=&#34;ES10 (ES2019)&#34;&gt;&lt;/a&gt;ES10 (ES2019)&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;text&#34;&gt;Array.prototype.flat 和 Array.prototype.flatMap 方法
Optional Chaining （可选链操作符 ?.）
空值合并运算符（??）
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;ES11-ES2020&#34;&gt;&lt;a href=&#34;#ES11-ES2020&#34; class=&#34;headerlink&#34; title=&#34;ES11 (ES2020)&#34;&gt;&lt;/a&gt;ES11 (ES2020)&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;text&#34;&gt;BigInt 类型
动态导入（import()）
可选的捕获绑定（Optional catch binding）
Promise.allSettled 方法
String.prototype.matchAll 方法
全局对象 globalThis
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;ES12-ES2021&#34;&gt;&lt;a href=&#34;#ES12-ES2021&#34; class=&#34;headerlink&#34; title=&#34;ES12 (ES2021)&#34;&gt;&lt;/a&gt;ES12 (ES2021)&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;text&#34;&gt;逻辑赋值运算符（||=、&amp;amp;&amp;amp;=、??=）
String.prototype.replaceAll 方法
Promise.any 方法
私有字段和方法（# 开头）
数字分隔符（Number separator）
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;ES13-ES2022&#34;&gt;&lt;a href=&#34;#ES13-ES2022&#34; class=&#34;headerlink&#34; title=&#34;ES13 (ES2022)&#34;&gt;&lt;/a&gt;ES13 (ES2022)&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;text&#34;&gt;导入.meta对象
字符串实例方法String.prototype.&amp;#123;trimLeft, trimRight&amp;#125;
异步迭代器的for-await-of支持
import()的顶级动态引入
更宽松的模板字面量转义
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="前端开发" scheme="https://pink-png.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" />
        <category term="Javascript" scheme="https://pink-png.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Javascript/" />
        <category term="Javascript" scheme="https://pink-png.github.io/tags/Javascript/" />
        <updated>2022-10-25T08:43:00.000Z</updated>
    </entry>
    <entry>
        <id>https://pink-png.github.io/js-base/js%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/</id>
        <title>javascript全局函数和全局变量</title>
        <link rel="alternate" href="https://pink-png.github.io/js-base/js%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/"/>
        <content type="html">&lt;ol&gt;
&lt;li&gt;全局变量&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Infinity 代表正的⽆穷⼤的数值。&lt;/li&gt;
&lt;li&gt;NaN 指示某个值是不是数字值。&lt;/li&gt;
&lt;li&gt;undefined 指示未定义的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;全局函数&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;decodeURI() 解码某个编码的 URI 。&lt;/li&gt;
&lt;li&gt;decodeURIComponent() 解码⼀个编码的 URI 组件。&lt;/li&gt;
&lt;li&gt;encodeURI() 把字符串编码为 URI。&lt;/li&gt;
&lt;li&gt;encodeURIComponent() 把字符串编码为 URI 组件。&lt;/li&gt;
&lt;li&gt;escape() 对字符串进⾏编码。&lt;/li&gt;
&lt;li&gt;eval() 计算 JavaScript 字符串，并把它作为脚本代码来执⾏。&lt;/li&gt;
&lt;li&gt;isFinite() 检查某个值是否为有穷⼤的数。&lt;/li&gt;
&lt;li&gt;isNaN() 检查某个值是否是数字。&lt;/li&gt;
&lt;li&gt;Number() 把对象的值转换为数字。&lt;/li&gt;
&lt;li&gt;parseFloat() 解析⼀个字符串并返回⼀个浮点数。&lt;/li&gt;
&lt;li&gt;parseInt() 解析⼀个字符串并返回⼀个整数。&lt;/li&gt;
&lt;li&gt;String() 把对象的值转换为字符串。&lt;/li&gt;
&lt;li&gt;unescape() 对由 escape() 编码的字符串进⾏解码&lt;/li&gt;
&lt;/ul&gt;
</content>
        <category term="前端开发" scheme="https://pink-png.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" />
        <category term="Javascript" scheme="https://pink-png.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Javascript/" />
        <category term="Javascript" scheme="https://pink-png.github.io/tags/Javascript/" />
        <updated>2022-10-25T08:43:00.000Z</updated>
    </entry>
    <entry>
        <id>https://pink-png.github.io/js-base/js%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F/</id>
        <title>js创建对象的多种方式</title>
        <link rel="alternate" href="https://pink-png.github.io/js-base/js%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
        <content type="html">&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;1. 对象字面量（Object Literal）：使用对象字面量可以直接创建一个简单的对象。对象字面量使用花括号 &amp;#123;&amp;#125; 包裹，并在其中定义键值对。

const person = &amp;#123;
  name: &amp;#39;John&amp;#39;,
  age: 30,
  sayHello: function() &amp;#123;
    console.log(&amp;#39;Hello!&amp;#39;);
  &amp;#125;
&amp;#125;;


优点：简洁、直观，适合创建简单的对象。
缺点：无法实现对象的复用，每次创建对象时都需要重新定义属性和方法。
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;2. 构造函数（Constructor）：通过构造函数可以创建一个对象的实例。构造函数使用 new 操作符来调用，并在内部使用 this 关键字来引用新创建的对象。
function Person(name, age) &amp;#123;
  this.name = name;
  this.age = age;
  this.sayHello = function() &amp;#123;
    console.log(&amp;#39;Hello!&amp;#39;);
  &amp;#125;;
&amp;#125;

const person = new Person(&amp;#39;John&amp;#39;, 30);

优点：可以通过 new 操作符创建对象的实例，适合创建多个相似的对象。
缺点：每个对象实例都会拥有独立的方法，占用额外的内存空间。创建大量对象时可能造成内存浪费。
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;3. 原型链继承（Prototype Chain Inheritance）：使用原型链可以实现对象的继承。可以通过给构造函数的原型对象添加属性和方法，使所有通过该构造函数创建的对象都可以共享这些属性和方法。
function Person(name, age) &amp;#123;
  this.name = name;
  this.age = age;
&amp;#125;

Person.prototype.sayHello = function() &amp;#123;
  console.log(&amp;#39;Hello!&amp;#39;);
&amp;#125;;

const person = new Person(&amp;#39;John&amp;#39;, 30);

优点：可以实现对象的属性和方法的共享，减少内存占用。适合创建多个具有相同属性和方法的对象。
缺点：所有实例共享原型对象上的属性和方法，如果对原型对象进行修改，会影响所有实例。不能传递参数给构造函数。
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;4. ES6 的类（Class）：ES6 引入了类的概念，可以使用 class 关键字来定义一个类，并通过 new 操作符创建类的实例。
class Person &amp;#123;
  constructor(name, age) &amp;#123;
    this.name = name;
    this.age = age;
  &amp;#125;
  
  sayHello() &amp;#123;
    console.log(&amp;#39;Hello!&amp;#39;);
  &amp;#125;
&amp;#125;

const person = new Person(&amp;#39;John&amp;#39;, 30);

优点：语法更加直观、易读，符合面向对象的编程习惯。支持继承、封装和多态等特性。
缺点：在底层仍然使用原型链来实现，因此也存在原型链继承的一些问题，如共享方法造成的潜在风险。
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="前端开发" scheme="https://pink-png.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" />
        <category term="Javascript" scheme="https://pink-png.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Javascript/" />
        <category term="Javascript" scheme="https://pink-png.github.io/tags/Javascript/" />
        <updated>2022-10-25T08:43:00.000Z</updated>
    </entry>
    <entry>
        <id>https://pink-png.github.io/js-base/js%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</id>
        <title>js 实现异步编程</title>
        <link rel="alternate" href="https://pink-png.github.io/js-base/js%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
        <content type="html">&lt;ol&gt;
&lt;li&gt;回调函数（Callbacks）：在异步操作完成后，通过传递一个回调函数作为参数，在异步操作结束时调用该回调函数来处理结果。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;Javascript&#34;&gt;function asyncOperation(callback) &amp;#123;
  // 模拟异步操作
  setTimeout(function() &amp;#123;
    const result = &amp;#39;Async operation completed&amp;#39;;
    callback(result);
  &amp;#125;, 1000);
&amp;#125;

asyncOperation(function(result) &amp;#123;
  console.log(result);
&amp;#125;);

优点：简单、容易理解
缺点：不利于维护，代码耦合⾼
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Promise：Promise 是一种在 ES6 中引入的异步编程模式。它代表一个异步操作最终的完成或失败，并提供了处理结果的方法。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;Javascript&#34;&gt;function asyncOperation() &amp;#123;
  return new Promise(function(resolve, reject) &amp;#123;
    // 模拟异步操作
    setTimeout(function() &amp;#123;
      const result = &amp;#39;Async operation completed&amp;#39;;
      resolve(result); // 异步操作成功
      // 或者使用 reject(new Error(&amp;#39;Async operation failed&amp;#39;)); 处理异步操作失败
    &amp;#125;, 1000);
  &amp;#125;);
&amp;#125;

asyncOperation()
  .then(function(result) &amp;#123;
    console.log(result);
  &amp;#125;)
  .catch(function(error) &amp;#123;
    console.error(error);
  &amp;#125;);

优点：可以利⽤then⽅法，进⾏链式写法；可以书写错误时的回调函数；
缺点：编写和理解，相对⽐较难
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;async&amp;#x2F;await：async&amp;#x2F;await 是在 ES2017 中引入的异步编程语法糖，基于 Promise，让异步代码看起来像同步代码一样。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;Javascript&#34;&gt;function asyncOperation() &amp;#123;
  return new Promise(function(resolve, reject) &amp;#123;
    // 模拟异步操作
    setTimeout(function() &amp;#123;
      const result = &amp;#39;Async operation completed&amp;#39;;
      resolve(result); // 异步操作成功
      // 或者使用 reject(new Error(&amp;#39;Async operation failed&amp;#39;)); 处理异步操作失败
    &amp;#125;, 1000);
  &amp;#125;);
&amp;#125;
async function processData() &amp;#123;
  try &amp;#123;
    const result = await asyncOperation();
    console.log(result);
  &amp;#125; catch (error) &amp;#123;
    console.error(error);
  &amp;#125;
&amp;#125;

processData();
优点：内置执⾏器、更好的语义、更⼴的适⽤性、返回的是Promise、结构清晰。
缺点：错误处理机制
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;事件监听（Event Listening）：事件监听是一种基于观察者模式的编程方式。通过注册事件监听器，当特定事件发生时，会触发相应的回调函数。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;Javascript&#34;&gt;// 定义一个事件触发器
const eventEmitter = new EventEmitter();

// 注册事件监听器
eventEmitter.on(&amp;#39;event&amp;#39;, function(data) &amp;#123;
  console.log(&amp;#39;Event triggered:&amp;#39;, data);
&amp;#125;);

// 触发事件
eventEmitter.emit(&amp;#39;event&amp;#39;, &amp;#39;Some data&amp;#39;);

优点：容易理解，可以绑定多个事件，每个事件可以指定多个回调函数
缺点：事件驱动型，流程不够清晰
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;发布&amp;#x2F;订阅（Publish&amp;#x2F;Subscribe）：发布&amp;#x2F;订阅也是一种基于观察者模式的编程方式，其中发布者（发布消息的对象）和订阅者（接收消息的对象）之间是松耦合的关系。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;Javascript&#34;&gt;// 创建一个发布者
const publisher = new Publisher();

// 创建一个订阅者并订阅消息
const subscriber1 = new Subscriber(&amp;#39;Subscriber 1&amp;#39;);
publisher.subscribe(subscriber1);

// 创建另一个订阅者并订阅消息
const subscriber2 = new Subscriber(&amp;#39;Subscriber 2&amp;#39;);
publisher.subscribe(subscriber2);

// 发布消息
publisher.publish(&amp;#39;Some message&amp;#39;);

类似于事件监听，但是可以通过‘消息中⼼ʼ，了解现在有多少发布者，多少订阅者
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;Generator函数&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;function* myGeneratorFunction() &amp;#123;
  try &amp;#123;
    const result = yield new Promise((resolve, reject) =&amp;gt; &amp;#123;
      setTimeout(() =&amp;gt; &amp;#123;
        resolve(&amp;#39;Async operation completed.&amp;#39;);
      &amp;#125;, 2000);
    &amp;#125;);
    console.log(result);
  &amp;#125; catch (error) &amp;#123;
    console.error(error);
  &amp;#125;
&amp;#125;

function runGenerator(generator) &amp;#123;
  const iterator = generator();

  function iterate(&amp;#123; value, done &amp;#125;) &amp;#123;
    if (done) &amp;#123;
      return;
    &amp;#125;

    if (value instanceof Promise) &amp;#123;
      value.then(
        (result) =&amp;gt; &amp;#123;
          iterate(iterator.next(result));
        &amp;#125;,
        (error) =&amp;gt; &amp;#123;
          iterate(iterator.throw(error));
        &amp;#125;
      );
    &amp;#125; else &amp;#123;
      iterate(iterator.next(value));
    &amp;#125;
  &amp;#125;

  iterate(iterator.next());
&amp;#125;

runGenerator(myGeneratorFunction);


优点：函数体内外的数据交换、错误处理机制
缺点：流程管理不⽅便
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="前端开发" scheme="https://pink-png.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" />
        <category term="Javascript" scheme="https://pink-png.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Javascript/" />
        <category term="Javascript" scheme="https://pink-png.github.io/tags/Javascript/" />
        <updated>2022-10-25T08:43:00.000Z</updated>
    </entry>
    <entry>
        <id>https://pink-png.github.io/js-base/js%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</id>
        <title>数组去重方法总结</title>
        <link rel="alternate" href="https://pink-png.github.io/js-base/js%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
        <content type="html">&lt;h1 id=&#34;借助ES6提供的Set结构-new-Set-简单好用-强烈推荐&#34;&gt;&lt;a href=&#34;#借助ES6提供的Set结构-new-Set-简单好用-强烈推荐&#34; class=&#34;headerlink&#34; title=&#34;借助ES6提供的Set结构 new Set() 简单好用 强烈推荐&#34;&gt;&lt;/a&gt;借助ES6提供的Set结构 new Set() 简单好用 强烈推荐&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;使用 Set 数据结构：将数组转换为 Set，然后再将 Set 转回数组。
 var arr = [1,9,8,8,7,7];
  function noRepeat(arr)&amp;#123;
    var newArr = [...new Set(arr)]; //利用了Set结构不能接收重复数据的特点
    return newArr
  &amp;#125;
  var arr2 = noRepeat(arr) 
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;利用-filter-indexOf-去重&#34;&gt;&lt;a href=&#34;#利用-filter-indexOf-去重&#34; class=&#34;headerlink&#34; title=&#34;利用 filter() +  indexOf() 去重&#34;&gt;&lt;/a&gt;利用 filter() +  indexOf() 去重&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。item是当前元素的值，index是当前元素的索引值。indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。利用indexOf() 查询到数组的下标，看是否等于当前的下标，相等的话就返回，否则不返回值

var arr = [&amp;#39;apple&amp;#39;,&amp;#39;apps&amp;#39;,&amp;#39;pear&amp;#39;,&amp;#39;apple&amp;#39;,&amp;#39;orange&amp;#39;,&amp;#39;apps&amp;#39;];  
  var newArr = arr.filter(function(item,index)&amp;#123;
     return arr.indexOf(item) === index;  // 因为indexOf 只能查找到第一个  
  &amp;#125;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;利用for-循环-搭配-indexOf-去重&#34;&gt;&lt;a href=&#34;#利用for-循环-搭配-indexOf-去重&#34; class=&#34;headerlink&#34; title=&#34;利用for 循环 搭配 indexOf 去重&#34;&gt;&lt;/a&gt;利用for 循环 搭配 indexOf 去重&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt; var arr = [1,9,8,8,7,7];
 function noRepeat(arr) &amp;#123;
        var newArr=[]; 
        for(var i=0;i&amp;lt;arr.length;i++) &amp;#123;
          if(newArr.indexOf(arr[i]) === -1) &amp;#123;
             newArr.push(arr[i]);
          &amp;#125;
        &amp;#125;
    return newArr
  &amp;#125;
  var arr2 = noRepeat(arr);
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;将数组的每一个元素依次与其他元素做比较，发现重复元素，删除-比较繁琐-不推荐&#34;&gt;&lt;a href=&#34;#将数组的每一个元素依次与其他元素做比较，发现重复元素，删除-比较繁琐-不推荐&#34; class=&#34;headerlink&#34; title=&#34;将数组的每一个元素依次与其他元素做比较，发现重复元素，删除 比较繁琐 不推荐&#34;&gt;&lt;/a&gt;将数组的每一个元素依次与其他元素做比较，发现重复元素，删除 比较繁琐 不推荐&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;var arr = [1,9,8,8,7,7];
 function noRepeat(arr) &amp;#123;
        for(var i = 0; i &amp;lt; arr.length-1; i++)&amp;#123;
            for(var j = i+1; j &amp;lt; arr.length; j++)&amp;#123;
                if(arr[i]===arr[j])&amp;#123;
                    arr.splice(j,1);
                    j--;
                &amp;#125;
            &amp;#125;
        &amp;#125;
        return arr;
 &amp;#125;
 var arr2 = noRepeat(arr);
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;借助新数组-通过-indexOf-方法判断当前元素在数组中的索引，如果与循环的下标相等则添加到新数组中&#34;&gt;&lt;a href=&#34;#借助新数组-通过-indexOf-方法判断当前元素在数组中的索引，如果与循环的下标相等则添加到新数组中&#34; class=&#34;headerlink&#34; title=&#34;借助新数组 通过 indexOf 方法判断当前元素在数组中的索引，如果与循环的下标相等则添加到新数组中&#34;&gt;&lt;/a&gt;借助新数组 通过 indexOf 方法判断当前元素在数组中的索引，如果与循环的下标相等则添加到新数组中&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt; var arr = [1,9,8,8,7,7];
    function noRepeat(arr) &amp;#123;
        var newArr = [];
        for (var i = 0; i &amp;lt; arr.length; i++) &amp;#123;
            if (arr.indexOf(arr[i]) == i) &amp;#123;
              newArr.push(arr[i]);
            &amp;#125;
        &amp;#125;
        return newArr;
    &amp;#125;
   var arr2 = noRepeat(arr); 
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;利用双重for循环&#34;&gt;&lt;a href=&#34;#利用双重for循环&#34; class=&#34;headerlink&#34; title=&#34;利用双重for循环&#34;&gt;&lt;/a&gt;利用双重for循环&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;var arr = [1,9,8,8,7,7];  
function noRepeat(arr)&amp;#123;
   for (var i = 0; i &amp;lt; arr.length; i++) &amp;#123;
       for (var j = 0; j &amp;lt; arr.length; j++) &amp;#123;
           if (arr[i] == arr[j] &amp;amp;&amp;amp; i != j) &amp;#123;
              arr.splice(j, 1);
            &amp;#125;
       &amp;#125;
    &amp;#125;
    return arr;
&amp;#125;
var arr2  = noRepeat(arr);
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;利用includes实现数组去重&#34;&gt;&lt;a href=&#34;#利用includes实现数组去重&#34; class=&#34;headerlink&#34; title=&#34;利用includes实现数组去重&#34;&gt;&lt;/a&gt;利用includes实现数组去重&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt; var arr = [1,9,8,8,7,7];
    function noRepeat(arr) &amp;#123;
      let newArr = [];
      for(i=0; i&amp;lt;arr.length; i++)&amp;#123;
        if(!newArr.includes(arr[i]))&amp;#123;
            newArr.push(arr[i])
        &amp;#125;
      &amp;#125;
     return newArr
   &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;利⽤-reduce-includes&#34;&gt;&lt;a href=&#34;#利⽤-reduce-includes&#34; class=&#34;headerlink&#34; title=&#34;利⽤ reduce + includes&#34;&gt;&lt;/a&gt;利⽤ reduce + includes&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;  const res = arr.reduce((prev, cur) =&amp;gt; &amp;#123;
      if(!prev.includes(cur))&amp;#123;
          prev.push(cur)
      &amp;#125;
      return prev
  &amp;#125;, [])

  优化后
 function unique(arr) &amp;#123;
    return arr.reduce((prev, cur) =&amp;gt; prev.includes(cur) ? prev : [...prev, cur])
  &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;利⽤Map数据结构去重&#34;&gt;&lt;a href=&#34;#利⽤Map数据结构去重&#34; class=&#34;headerlink&#34; title=&#34;利⽤Map数据结构去重&#34;&gt;&lt;/a&gt;利⽤Map数据结构去重&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt; function arrayNonRepeatfy(arr) &amp;#123;
    let map = new Map();
    let array = new Array(); // 数组⽤于返回结果
    for (let i = 0; i &amp;lt; arr.length; i++) &amp;#123;
        if (map.has(arr[i])) &amp;#123; // 如果有该key值
            map.set(arr[i], true);
        &amp;#125; else &amp;#123;
            map.set(arr[i], false); // 如果没有该key值
            array.push(arr[i]);
        &amp;#125;
    &amp;#125;
    return array;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;利⽤递归去重&#34;&gt;&lt;a href=&#34;#利⽤递归去重&#34; class=&#34;headerlink&#34; title=&#34;利⽤递归去重&#34;&gt;&lt;/a&gt;利⽤递归去重&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt; function unique(arr) &amp;#123;
      var array = arr;
      var len = array.length;
      array.sort(function (a, b) &amp;#123; //排序后更加⽅便去重
          return a - b;
      &amp;#125;)
      function loop(index) &amp;#123;
          if (index &amp;gt;= 1) &amp;#123;
              if (array[index] === array[index - 1]) &amp;#123;
                  array.splice(index, 1);
              &amp;#125;
              loop(index - 1); //递归loop，然后数组去重
          &amp;#125;
      &amp;#125;
      loop(len - 1);
      return array;
  &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;利⽤hasOwnProperty-filter&#34;&gt;&lt;a href=&#34;#利⽤hasOwnProperty-filter&#34; class=&#34;headerlink&#34; title=&#34;利⽤hasOwnProperty + filter&#34;&gt;&lt;/a&gt;利⽤hasOwnProperty + filter&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;function unique(arr) &amp;#123;
    var obj = &amp;#123;&amp;#125;;
    return arr.filter(function (item, index, arr) &amp;#123;
        return obj.hasOwnProperty(typeof item + item) ? false : (obj[typeof item + item] = true);
    &amp;#125;);
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;利⽤对象的属性不能相同的特点进⾏去重&#34;&gt;&lt;a href=&#34;#利⽤对象的属性不能相同的特点进⾏去重&#34; class=&#34;headerlink&#34; title=&#34;利⽤对象的属性不能相同的特点进⾏去重&#34;&gt;&lt;/a&gt;利⽤对象的属性不能相同的特点进⾏去重&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;function unique(arr) &amp;#123;
      if (!Array.isArray(arr)) &amp;#123;
          console.log(&amp;#39;type error!&amp;#39;)
          return
      &amp;#125;
      var arrry = [];
      var obj = &amp;#123;&amp;#125;;
      for (var i = 0; i &amp;lt; arr.length; i++) &amp;#123;
          if (!obj[arr[i]]) &amp;#123;
              arrry.push(arr[i])
              obj[arr[i]] = 1
          &amp;#125; else &amp;#123;
              obj[arr[i]]++
          &amp;#125;
      &amp;#125;
      return arrry;
  &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="前端开发" scheme="https://pink-png.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" />
        <category term="Javascript" scheme="https://pink-png.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Javascript/" />
        <category term="Javascript" scheme="https://pink-png.github.io/tags/Javascript/" />
        <updated>2022-10-25T08:43:00.000Z</updated>
    </entry>
    <entry>
        <id>https://pink-png.github.io/js-base/js%E6%B5%85%E8%B0%88new%20this/</id>
        <title>浅谈js中new this 关键字</title>
        <link rel="alternate" href="https://pink-png.github.io/js-base/js%E6%B5%85%E8%B0%88new%20this/"/>
        <content type="html">&lt;h1 id=&#34;new操作符具体干了什么&#34;&gt;&lt;a href=&#34;#new操作符具体干了什么&#34; class=&#34;headerlink&#34; title=&#34;new操作符具体干了什么&#34;&gt;&lt;/a&gt;new操作符具体干了什么&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;text&#34;&gt;1. 创建一个新的空对象。
2. 将新对象的原型链（[[Prototype]]）链接到构造函数的 prototype 属性上，使新对象能够访问构造函数原型中定义的属性和方法。
3. 将构造函数的作用域赋值给新对象，即将新对象的 this 绑定到构造函数上，使构造函数内部的代码能够访问和操作新对象的属性。
4. 执行构造函数内部的代码，初始化新对象的属性和方法。
5. 如果构造函数返回了一个非空对象，则返回该对象；否则，返回新创建的对象。
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;new的模拟实现&#34;&gt;&lt;a href=&#34;#new的模拟实现&#34; class=&#34;headerlink&#34; title=&#34;new的模拟实现&#34;&gt;&lt;/a&gt;new的模拟实现&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;function myNew(constructor, ...args) &amp;#123;
  // 1. 在内存中创建一个新对象
  const obj = &amp;#123;&amp;#125;;

  // 2. 将新对象的原型设置为构造函数的 prototype 属性
  Object.setPrototypeOf(obj, constructor.prototype);

  // 3. 将构造函数内部的 this 绑定到新对象
  const result = constructor.apply(obj, args);

  // 4. 执行构造函数内部的代码后，如果返回非空对象则返回该对象，否则返回新对象
  return result instanceof Object ? result : obj;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码中，myNew 函数接受构造函数和参数，模拟了 new 操作符的行为。它会创建一个新对象 obj，将该对象的原型设置为构造函数的 prototype 属性，然后将构造函数内部的 this 绑定到新对象 obj 上，最后根据构造函数的返回结果决定返回值。&lt;/p&gt;
&lt;p&gt;需要注意的是，这只是一个简化的实现，并没有考虑 new 操作符的所有细节和复杂性，如原型链继承、构造函数返回非对象值时的处理等。在实际开发中，建议优先使用原生的 new 操作符。&lt;/p&gt;
&lt;h1 id=&#34;this-对象的理解&#34;&gt;&lt;a href=&#34;#this-对象的理解&#34; class=&#34;headerlink&#34; title=&#34;this 对象的理解&#34;&gt;&lt;/a&gt;this 对象的理解&lt;/h1&gt;&lt;p&gt;&amp;#96;&amp;#96;text&lt;br&gt;在 JavaScript 中，this 是一个特殊的关键字，它指向当前执行代码的上下文对象。具体来说，this 引用的是调用函数的对象，根据函数的调用方式不同，this 会有不同的值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
```text
this 的值可以根据以下几种情况进行判断
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;1. 作为普通函数调用：当函数作为独立函数调用时，this 的值指向全局对象（在浏览器中为 window）。
function greet() &amp;#123;
  console.log(`Hello, $&amp;#123;this.name&amp;#125;`);
&amp;#125;

const obj = &amp;#123;
  name: &amp;#39;Alice&amp;#39;,
  sayHello: greet
&amp;#125;;

greet(); // 输出：Hello, undefined
obj.sayHello(); // 输出：Hello, Alice
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;2. 作为对象方法调用：当函数作为对象的方法调用时，this 的值指向调用该方法的对象。
const person = &amp;#123;
  name: &amp;#39;Alice&amp;#39;,
  sayHello() &amp;#123;
    console.log(`Hello, $&amp;#123;this.name&amp;#125;`);
  &amp;#125;
&amp;#125;;

person.sayHello(); // 输出：Hello, Alice
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;3. 作为构造函数调用：当函数被用作构造函数调用时（使用 new 关键字），this 的值指向新创建的对象。
function Person(name) &amp;#123;
  this.name = name;
  this.sayHello = function() &amp;#123;
    console.log(`Hello, $&amp;#123;this.name&amp;#125;`);
  &amp;#125;;
&amp;#125;

const john = new Person(&amp;#39;John&amp;#39;);
john.sayHello(); // 输出：Hello, John
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;4. 使用 call、apply 或 bind 方法显式指定 this 的值。
function greet(greeting) &amp;#123;
  console.log(`$&amp;#123;greeting&amp;#125;, $&amp;#123;this.name&amp;#125;`);
&amp;#125;

const person = &amp;#123;
  name: &amp;#39;Alice&amp;#39;
&amp;#125;;

greet.call(person, &amp;#39;Hi&amp;#39;); // 输出：Hi, Alice
greet.apply(person, [&amp;#39;Hi&amp;#39;]); // 输出：Hi, Alice

const boundGreet = greet.bind(person);
boundGreet(&amp;#39;Hi&amp;#39;); // 输出：Hi, Alice
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="前端开发" scheme="https://pink-png.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" />
        <category term="Javascript" scheme="https://pink-png.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Javascript/" />
        <category term="Javascript" scheme="https://pink-png.github.io/tags/Javascript/" />
        <updated>2022-10-25T08:43:00.000Z</updated>
    </entry>
    <entry>
        <id>https://pink-png.github.io/js-base/js%E6%B5%85%E8%B0%88%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%BB%A5%E5%8F%8A%E5%8F%98%E9%87%8F%E4%BB%A5%E5%8F%8A%E9%97%AD%E5%8C%85/</id>
        <title>js浅谈作用域 - 变量 - 闭包</title>
        <link rel="alternate" href="https://pink-png.github.io/js-base/js%E6%B5%85%E8%B0%88%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%BB%A5%E5%8F%8A%E5%8F%98%E9%87%8F%E4%BB%A5%E5%8F%8A%E9%97%AD%E5%8C%85/"/>
        <content type="html">&lt;h1 id=&#34;什么是作用域&#34;&gt;&lt;a href=&#34;#什么是作用域&#34; class=&#34;headerlink&#34; title=&#34;什么是作用域&#34;&gt;&lt;/a&gt;什么是作用域&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;text&#34;&gt;在 JavaScript 中，作用域是指变量的可访问范围，它控制了变量在代码中的可见性和生命周期。JavaScript 有以下几种类型的作用域和变量：
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;1. 全局作用域（Global Scope）：全局作用域是在代码中任何地方都能访问到的最外层作用域。在浏览器环境中，全局作用域通常指的是 window 对象。在全局作用域中声明的变量在整个程序中都是可访问的。 

var globalVariable = &amp;#39;I am a global variable&amp;#39;;

function foo() &amp;#123;
  console.log(globalVariable); // 输出：I am a global variable
&amp;#125;

console.log(globalVariable); // 输出：I am a global variable
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;2. 函数作用域（Function Scope）：函数作用域是在函数内部声明的变量所拥有的作用域。这意味着函数内部可以访问函数外部的变量，但函数外部无法访问函数内部的变量。

function foo() &amp;#123;
  var functionVariable = &amp;#39;I am a function variable&amp;#39;;
  console.log(functionVariable); // 输出：I am a function variable
&amp;#125;

console.log(functionVariable); // 报错：functionVariable is not defined
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;3. 块级作用域（Block Scope）：在 ES6（ECMAScript 2015）之前，JavaScript 只有全局作用域和函数作用域，没有块级作用域。块级作用域由一对花括号（&amp;#123;&amp;#125;）创建，在块级作用域内声明的变量只在该块级作用域内部可见。

function foo() &amp;#123;
  if (true) &amp;#123;
    var blockVariable = &amp;#39;I am a block variable&amp;#39;;
    let blockScopedVariable = &amp;#39;I am a block-scoped variable&amp;#39;;
    console.log(blockVariable); // 输出：I am a block variable
    console.log(blockScopedVariable); // 输出：I am a block-scoped variable
  &amp;#125;

  console.log(blockVariable); // 输出：I am a block variable
  console.log(blockScopedVariable); // 报错：blockScopedVariable is not defined
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;4. 词法作用域（Lexical Scope）：JavaScript 使用的是词法作用域，也称为静态作用域。词法作用域是在代码编写时确定的，它基于变量在代码中的位置来确定其可访问范围，而不是运行时的调用栈。

var globalVariable = &amp;#39;I am a global variable&amp;#39;;

function foo() &amp;#123;
  var functionVariable = &amp;#39;I am a function variable&amp;#39;;
  console.log(globalVariable); // 输出：I am a global variable
  console.log(functionVariable); // 输出：I am a function variable
&amp;#125;

foo();
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;text&#34;&gt;在 JavaScript 中，变量有三种声明方式：var、let 和 const。其中 var 声明的变量具有函数作用域或全局作用域，let 和 const 声明的变量具有块级作用域。

请注意，函数声明本身也遵循词法作用域，可以在函数内部定义函数，并在函数内部访问和调用。这就是 JavaScript 中的闭包机制。
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;作用域的理解&#34;&gt;&lt;a href=&#34;#作用域的理解&#34; class=&#34;headerlink&#34; title=&#34;作用域的理解&#34;&gt;&lt;/a&gt;作用域的理解&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;作⽤域链的作⽤是保证执⾏环境⾥有权访问的变量和函数是有序的，作⽤域链的变量只能向上访问，变量访问到 window 对象即被终⽌，作⽤域链向下访问变量是不被允许的&lt;/li&gt;
&lt;li&gt;简单的说，作⽤域就是变量与函数的可访问范围，即作⽤域控制着变量与函数的可⻅性和⽣命周期&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;什么是闭包？&#34;&gt;&lt;a href=&#34;#什么是闭包？&#34; class=&#34;headerlink&#34; title=&#34;什么是闭包？&#34;&gt;&lt;/a&gt;什么是闭包？&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;闭包就是能够读取其他函数内部变量的函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;闭包是指有权访问另⼀个函数作⽤域中变量的函数，创建闭包的最常⻅的⽅式就是在⼀个函数内创建另⼀个函数，通过另⼀个函数访问这个函数的局部变量,利⽤闭包可以突破作⽤链域&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;闭包的特性：&lt;br&gt;函数内再嵌套函数&lt;br&gt;内部函数可以引⽤外层的参数和变量&lt;br&gt;参数和变量不会被垃圾回收机制回收&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;闭包的理解&#34;&gt;&lt;a href=&#34;#闭包的理解&#34; class=&#34;headerlink&#34; title=&#34;闭包的理解&#34;&gt;&lt;/a&gt;闭包的理解&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;使⽤闭包主要是为了设计私有的⽅法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增⼤内存使⽤量，使⽤不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产⽣作⽤域的概念&lt;/li&gt;
&lt;li&gt;闭包 的最⼤⽤处有两个，⼀个是可以读取函数内部的变量，另⼀个就是让这些变量始终保持在内存中&lt;/li&gt;
&lt;li&gt;闭包的另⼀个⽤处，是封装对象的私有属性和私有⽅法&lt;/li&gt;
&lt;li&gt;好处：能够实现封装和缓存等；&lt;/li&gt;
&lt;li&gt;坏处：就是消耗内存、不正当使⽤会造成内存溢出的问题&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;使⽤闭包的注意点&#34;&gt;&lt;a href=&#34;#使⽤闭包的注意点&#34; class=&#34;headerlink&#34; title=&#34;使⽤闭包的注意点&#34;&gt;&lt;/a&gt;使⽤闭包的注意点&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;由于闭包会使得函数中的变量都被保存在内存中，内存消耗很⼤，所以不能滥⽤闭包，否则会造成⽹⻚的性能问题，在IE中可能导致内存泄露&lt;/li&gt;
&lt;li&gt;解决⽅法是，在退出函数之前，将不使⽤的局部变量全部删除&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;function outer() &amp;#123;
  var outerVariable = &amp;#39;I am an outer variable&amp;#39;;

  function inner() &amp;#123;
    console.log(outerVariable); // 闭包，内部函数可以访问外部函数的变量
  &amp;#125;

  return inner;
&amp;#125;

var closureFunction = outer(); 
closureFunction(); // 输出：I am an outer variable
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;什么情况下会造成内存泄漏&#34;&gt;&lt;a href=&#34;#什么情况下会造成内存泄漏&#34; class=&#34;headerlink&#34; title=&#34;什么情况下会造成内存泄漏&#34;&gt;&lt;/a&gt;什么情况下会造成内存泄漏&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;未及时释放闭包：如果闭包被保留在内存中，并且不再需要使用，但没有手动解除对闭包的引用，这将导致闭包及其所引用的变量无法被垃圾回收，从而造成内存泄漏。&lt;/li&gt;
&lt;li&gt;循环引用：如果闭包持有对其他对象的引用，而这些对象又持有对闭包的引用，形成了循环引用，那么这些对象以及闭包本身都无法被垃圾回收，导致内存泄漏。&lt;/li&gt;
&lt;li&gt;事件监听器未移除：当页面中的元素绑定了事件监听器，而这些监听器是在闭包中定义的，如果没有正确地解除对元素的引用，这会导致闭包无法释放，从而造成内存泄漏。&lt;/li&gt;
&lt;li&gt;全局变量引用：如果闭包中引用了全局变量，即使函数执行结束，闭包仍然可以访问和持有对全局变量的引用，阻止了对全局变量的释放，导致内存泄漏。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;为避免闭包导致的内存泄漏，可以采取以下措施：&#34;&gt;&lt;a href=&#34;#为避免闭包导致的内存泄漏，可以采取以下措施：&#34; class=&#34;headerlink&#34; title=&#34;为避免闭包导致的内存泄漏，可以采取以下措施：&#34;&gt;&lt;/a&gt;为避免闭包导致的内存泄漏，可以采取以下措施：&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;及时释放闭包：在不需要使用闭包时，手动解除对闭包的引用，让垃圾回收机制能够回收闭包及其引用的变量。&lt;/li&gt;
&lt;li&gt;移除事件监听器：在不再需要使用的情况下，确保移除元素上的事件监听器，以免闭包继续持有对元素的引用。&lt;/li&gt;
&lt;li&gt;避免不必要的全局变量：减少对全局作用域的依赖，限制闭包对全局变量的引用，使得相关变量能够在不需要时被回收。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;总结&#34;&gt;&lt;a href=&#34;#总结&#34; class=&#34;headerlink&#34; title=&#34;总结&#34;&gt;&lt;/a&gt;总结&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;text&#34;&gt;在上面的例子中，outer 函数返回了一个内部函数 inner，该内部函数引用了 outer 函数的变量 outerVariable。即使 outer 函数执行完毕后，inner 函数依然可以访问和操作 outerVariable 变量，这就是闭包的特性。

通过使用作用域和闭包，我们可以实现封装、数据私有化和模块化等编程概念。闭包还可以用于创建函数工厂和实现函数柯里化等高级编程技巧。
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="前端开发" scheme="https://pink-png.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" />
        <category term="Javascript" scheme="https://pink-png.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Javascript/" />
        <category term="Javascript" scheme="https://pink-png.github.io/tags/Javascript/" />
        <updated>2022-10-25T08:43:00.000Z</updated>
    </entry>
    <entry>
        <id>https://pink-png.github.io/performance-optimization/%E6%8F%90%E9%AB%98Webpack%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/</id>
        <title>webpack性能优化</title>
        <link rel="alternate" href="https://pink-png.github.io/performance-optimization/%E6%8F%90%E9%AB%98Webpack%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/"/>
        <content type="html">&lt;h1 id=&#34;如何提高Webpack构建速度&#34;&gt;&lt;a href=&#34;#如何提高Webpack构建速度&#34; class=&#34;headerlink&#34; title=&#34;如何提高Webpack构建速度&#34;&gt;&lt;/a&gt;如何提高Webpack构建速度&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;1. 代码压缩

JS 压缩
webpack 4.0默认在生产环境的时候是支持代码压缩的，即mode=production模式下。实际上webpack 4.0默认是使用terser-webpack-plugin这个压缩插件，在此之前是使用 uglifyjs-webpack-plugin，两者的区别是后者对 ES6 的压缩不是很好，同时我们可以开启 parallel参数，使用多进程压缩，加快压缩。
CSS 压缩
CSS 压缩通常是去除无用的空格等，因为很难去修改选择器、属性的名称、值等。可以使用另外一个插件：css-minimizer-webpack-plugin。
HTML 压缩
使用HtmlWebpackPlugin插件来生成 HTML 的模板时候，通过配置属性minify进行 html 优化。

module.exports = &amp;#123;
plugin:[
  new HtmlwebpackPlugin(&amp;#123;
    minify:&amp;#123;
      minifyCSS: false, // 是否压缩css
      collapseWhitespace: false, // 是否折叠空格
      removeComments: true // 是否移除注释
    &amp;#125;
  &amp;#125;)
  ]
&amp;#125;

2. 图片压缩

配置image-webpack-loader

3. Tree Shaking
Tree Shaking是一个术语，在计算机中表示消除死代码，依赖于 ES Module 的静态语法分析（不执行任何的代码，可以明确知道模块的依赖关系）。在webpack实现Tree shaking有两种方案：

usedExports：通过标记某些函数是否被使用，之后通过 Terser 来进行优化的
module.exports = &amp;#123;
    ...
    optimization:&amp;#123;
        usedExports
    &amp;#125;
  &amp;#125;
使用之后，没被用上的代码在webpack打包中会加入unused harmony export mul注释，用来告知Terser在优化时，可以删除掉这段代码。

sideEffects：跳过整个模块/文件，直接查看该文件是否有副作用

sideEffects用于告知webpack compiler哪些模块时有副作用，配置方法是在package.json中设置sideEffects属性。如果sideEffects设置为false，就是告知webpack可以安全的删除未用到的exports。如果有些文件需要保留，可以设置为数组的形式，如：

&amp;quot;sideEffecis&amp;quot;:[
    &amp;quot;./src/util/format.js&amp;quot;,
    &amp;quot;*.css&amp;quot; // 所有的css文件
]

4. 缩小打包域
排除webpack不需要解析的模块，即在使用loader的时候，在尽量少的模块中去使用。可以借助 include和exclude这两个参数，规定loader只在那些模块应用和在哪些模块不应用。

5. 减少 ES6 转为 ES5 的冗余代码
使用bable-plugin-transform-runtime插件

6. 提取公共代码
通过配置CommonsChunkPlugin插件，将多个页面的公共代码抽离成单独的文件

7. 其他
组件懒加载、路由懒加载、开启gzip、公共的第三方包上cdn、配置cache缓存Loader对文件的编译副本、配置resolve提高文件的搜索速度
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;webpack性能优化&#34;&gt;&lt;a href=&#34;#webpack性能优化&#34; class=&#34;headerlink&#34; title=&#34;webpack性能优化&#34;&gt;&lt;/a&gt;webpack性能优化&lt;/h1&gt;&lt;h2 id=&#34;开发环境性能优化&#34;&gt;&lt;a href=&#34;#开发环境性能优化&#34; class=&#34;headerlink&#34; title=&#34;开发环境性能优化&#34;&gt;&lt;/a&gt;开发环境性能优化&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;优化打包构建速度&lt;/li&gt;
&lt;li&gt;HMR&lt;/li&gt;
&lt;li&gt;优化代码调试&lt;/li&gt;
&lt;li&gt;source-map&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;生产环境性能优化&#34;&gt;&lt;a href=&#34;#生产环境性能优化&#34; class=&#34;headerlink&#34; title=&#34;生产环境性能优化&#34;&gt;&lt;/a&gt;生产环境性能优化&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;优化打包构建速度&lt;/li&gt;
&lt;li&gt;oneOf(可以按照一组优先级顺序来定义不同类型或特定条件下的模块处理方式)&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;module.exports = &amp;#123;
  // ...其他的Webpack配置
  module: &amp;#123;
    rules: [
      // ...其他规则
      &amp;#123;
        oneOf: [
          &amp;#123;
            test: /\.css$/,
            use: [&amp;#39;style-loader&amp;#39;, &amp;#39;css-loader&amp;#39;]
          &amp;#125;,
          &amp;#123;
            test: /\.less$/,
            use: [&amp;#39;style-loader&amp;#39;, &amp;#39;css-loader&amp;#39;, &amp;#39;less-loader&amp;#39;]
          &amp;#125;,
          &amp;#123;
            test: /\.js$/,
            exclude: /node_modules/,
            use: &amp;#39;babel-loader&amp;#39;
          &amp;#125;,
          // ...其他的规则
        ]
      &amp;#125;
    ]
  &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;babel缓存&lt;/li&gt;
&lt;li&gt;多进程打包&lt;/li&gt;
&lt;li&gt;externals(拒绝某些包被打包进来)&lt;/li&gt;
&lt;li&gt;dll(独立打包第三方库,减少构建时间)&lt;/li&gt;
&lt;li&gt;优化代码运行的性能&lt;/li&gt;
&lt;li&gt;缓存(hash-chunkhash-contenthash)&lt;/li&gt;
&lt;li&gt;tree shaking&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;text&#34;&gt;tree shaking：去除无用代码
  前提：1. 必须使用ES6模块化  2. 开启production环境
  作用: 减少代码体积

在package.json中配置 
  &amp;quot;sideEffects&amp;quot;: false 所有代码都没有副作用（都可以进行tree shaking）
    问题：可能会把css / @babel/polyfill （副作用）文件干掉
  &amp;quot;sideEffects&amp;quot;: [&amp;quot;*.css&amp;quot;, &amp;quot;*.less&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;10&#34;&gt;
&lt;li&gt;code split&lt;/li&gt;
&lt;li&gt;懒加载&amp;#x2F;预加载&lt;/li&gt;
&lt;li&gt;pwa(PWA 提供了一种融合了网页和原生应用优点的解决方案，能够提供离线访问、快速加载、类似原生应用的体验以及跨平台兼容性等优势)&lt;/li&gt;
&lt;/ol&gt;
</content>
        <category term="前端开发" scheme="https://pink-png.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" />
        <category term="前端性能优化" scheme="https://pink-png.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" />
        <category term="前端性能优化" scheme="https://pink-png.github.io/tags/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" />
        <updated>2022-07-25T08:43:00.000Z</updated>
    </entry>
    <entry>
        <id>https://pink-png.github.io/performance-optimization/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%A4%A7%E7%BA%B2/</id>
        <title>前端性能优化大纲</title>
        <link rel="alternate" href="https://pink-png.github.io/performance-optimization/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%A4%A7%E7%BA%B2/"/>
        <content type="html">&lt;h1 id=&#34;性能优化六大指标&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#性能优化六大指标&#34;&gt;#&lt;/a&gt; 性能优化六大指标&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;六大指标基本囊括大部分性能优化细节，可作为优化策略的补充。&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;「加载优化」：资源在加载时可做的性能优化&lt;/li&gt;
&lt;li&gt;「执行优化」：资源在执行时可做的性能优化&lt;/li&gt;
&lt;li&gt;「渲染优化」：资源在渲染时可做的性能优化&lt;/li&gt;
&lt;li&gt;「样式优化」：样式在编码时可做的性能优化&lt;/li&gt;
&lt;li&gt;「脚本优化」：脚本在编码时可做的性能优化&lt;/li&gt;
&lt;li&gt;「V8 引擎优化」：针对 V8 引擎特征可做的性能优化&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;加载优化&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#加载优化&#34;&gt;#&lt;/a&gt; 加载优化&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;优化 HTTP 请求：减少请求次数、合并与压缩静态资源、使用 CDN、http2、preload/prefetch,HTTP 缓存等&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&#34;highlight text&#34;&gt;&lt;figcaption data-lang=&#34;text&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;1.1 CDN：将资源分发到 CDN 的边缘网络节点，使用户可就近获取所需内容，大幅减小了光纤传输距离，使全球各地用户打开网站都拥有良好的网络体验。&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt; 1.2 http2：http2 的诸多特性决定了它更快的传输速度(多路复用，在浏览器可并行发送 N 条请求,首部压缩，更小的负载体积,请求优先级，更快的关键请求)。&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;目前，网站已大多上了 http2，可在控制台面板进行查看。&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;由于 http2 可并行请求，解决了 http1.1 线头阻塞的问题，以下几个性能优化点将会过时&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;资源合并。如 https://shanyue.tech/assets??index.js,interview.js,report.js&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;域名分片。&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;雪碧图(CSS Sprite)。将无数小图片合并成单个大图片。&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt; &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;10&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt; 1.3 充分利用 HTTP 缓存&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;11&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;更好的资源缓存策略，对于 CDN 来讲可减少回源次数，对于浏览器而言可减少请求发送次数。无论哪一点，对于二次网站访问都具有更好的访问体验。&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;12&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;一:缓存策略&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;13&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  1. 强缓存: 打包后带有 hash 值的资源 (如 /build/a3b4c8a8.js)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;14&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  2. 协商缓存: 打包后不带有 hash 值的资源 (如 /index.html)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;15&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;二:分包加载 (Bundle Spliting)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;16&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  1. 避免一行代码修改导致整个 bundle 的缓存失效 &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;17&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;18&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;1.4 减少 HTTP 请求及负载&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;19&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;对一个网站的资源进行压缩优化，从而达到减少 HTTP 负载的目的。&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;20&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;javascript/css/image 等常规资源（图片等...）体积优化，这是一个大话题，再以下分别讨论&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;21&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;22&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;一：image     &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;23&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    1. 小图片优化，将小图片内联为 Data URI，减小请求数量 &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;24&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    2. 选择合适的图片格式、响应式图片或按需加载图片&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;25&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    3. 在前端发展的现在，webp 普遍比 jpeg/png 更小，而 avif 又比 webp 小一个级别&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;26&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    为了无缝兼容，可选择 picture/source 进行回退处理&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;27&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&amp;lt;picture&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;28&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &amp;lt;source srcset=&#34;img/photo.avif&#34; type=&#34;image/avif&#34;&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;29&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &amp;lt;source srcset=&#34;img/photo.webp&#34; type=&#34;image/webp&#34;&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;30&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &amp;lt;img src=&#34;img/photo.jpg&#34; width=&#34;360&#34; height=&#34;240&#34;&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;31&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&amp;lt;/picture&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;32&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    4. 更合适的尺寸: 当页面仅需显示 100px/100px 大小图片时，对图片进行压缩到 100px/100px&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;33&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    5. 更合适的压缩: 可对前端图片进行适当压缩，如通过 sharp 等&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;34&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    6. 新的 API: IntersectionObserver API&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;35&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    7. 新的属性: loading=lazy &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;36&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;37&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;二：javascript&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;38&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    1. 更小的 Javascript&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;39&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;      gzip/brotli&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;40&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;      terser (minify)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;41&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;      &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;42&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    还有以下几点可以考虑考虑:&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;43&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;路由懒加载，无需加载整个应用的资源&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;44&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;Tree Shaking: 无用导出将在生产环境进行删除&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;45&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;browserlist/babel: 及时更新 browserlist，将会产生更小的垫片体积&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;46&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;再补充一个问题:&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;47&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;48&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;如何分析并优化当前项目的 Javascript 体积？如果使用 webpack 那就简单很多。&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;49&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;50&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;使用 webpack-bundle-analyze 分析打包体积&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;51&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;对一些库替换为更小体积的库，如 moment -&gt; dayjs&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;52&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;对一些库进行按需加载，如 import lodash -&gt; import lodash/get&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;53&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;对一些库使用支持 Tree Shaking，如 import lodash -&gt; import lodash-es&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;54&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;55&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;三：字体&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;56&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    1.使用字体图标和矢量图形：替代大量图片的使用&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;57&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;58&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;59&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;四：css&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;60&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  1. 把样式表放在顶部&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;61&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  2. 选择&amp;lt;link&gt;舍弃@import&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;62&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  3. 避免使用滤镜&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;63&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  4. 避免使用CSS表达式&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;64&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    用CSS表达式动态设置CSS属性，是一种强大又危险的方式。从IE5开始支持，但从IE8起就不推荐使用了。例如，可以用CSS表达式把背景颜色设置成按小时交替的：&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;65&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    background-color: expression( (new Date()).getHours()%2 ? &#34;#B8D4FF&#34; : &#34;#F08A00&#34; );&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;66&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;67&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;68&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;69&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;五：压缩工具&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;70&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;1.Terser (opens new window)是 Javascript 资源压缩混淆的神器。&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;71&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;72&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;2.swc (opens new window)是另外一个用以压缩 Javascript 的工具，它拥有与 terser 相同的 API，由于它是由 rust 所写，因此它拥有更高的性能。&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;73&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;74&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;3.html-minifier-terser (opens new window)用以压缩 HTML 的工具&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;75&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;76&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;4. gzip/brotli&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;77&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;对 JS、CSS、HTML 等文本资源均有效，但是对图片效果不大。&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;78&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;79&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;gzip 通过 LZ77 算法与 Huffman 编码来压缩文件，重复度越高的文件可压缩的空间就越大。&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;80&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;brotli 通过变种的 LZ77 算法、Huffman 编码及二阶文本建模来压缩文件，更先进的压缩算法，比 gzip 有更高的性能及压缩率&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;81&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;可在浏览器的 Content-Encoding 响应头查看该网站是否开启了压缩算法，目前知乎、掘金等已全面开启了 brotli 压缩。&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;82&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;83&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;Request Header&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;84&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;Accept-Encoding: gzip, deflate, br&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;85&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;86&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;gzip&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;87&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;Content-Encoding: gzip&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;88&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;89&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;gzip&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;90&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;Content-Encoding: br &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;91&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;92&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;93&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;5. preload/prefetch : preload/prefetch 可控制 HTTP 优先级，从而达到关键请求更快响应的目的。(延迟加载：将非关键资源延迟加载，如图片、视频、第三方插件等)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;94&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt; &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;95&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&amp;lt;link rel=&#34;prefetch&#34; href=&#34;style.css&#34; as=&#34;style&#34;&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;96&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&amp;lt;link rel=&#34;preload&#34; href=&#34;main.js&#34; as=&#34;script&#34;&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;97&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;5.1 preload 加载当前路由必需资源，优先级高。一般对于 Bundle Spliting 资源与 Code Spliting 资源做 preload&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;98&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;5.2. prefetch 优先级低，在浏览器 idle 状态时加载资源。一般用以加载其它路由资源，如当页面出现 Link，可 prefetch 当前 Link 的路由资源。（next.js 默认会对 link 做懒加载+prefetch，即当某条 Link 出现页面中，即自动 prefetch 该 Link 指向的路由资源&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;99&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;捎带说一下 dns-prefetch，可对主机地址的 DNS 进行预解析。&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;100&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;101&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&amp;lt;link rel=&#34;dns-prefetch&#34; href=&#34;//shanyue.tech&#34;&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h2 id=&#34;执行优化&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#执行优化&#34;&gt;#&lt;/a&gt; 执行优化&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;代码优化：精简 html，css，js 代码，避免重复代码&lt;/li&gt;
&lt;li&gt;异步加载：将 JavaScript 放在底部，使用 async,defer 属性&lt;/li&gt;
&lt;li&gt;代码分割和懒加载：拆分大型应用程序为小模块，按需加载模块，减少初始加载时间&lt;/li&gt;
&lt;li&gt;前端代码压缩混淆：对前端代码进行压缩和混淆，减小文件大小，提高加载速度&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;渲染优化&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#渲染优化&#34;&gt;#&lt;/a&gt; 渲染优化&lt;/h2&gt;
&lt;p&gt;**「渲染层面」** 的性能优化，无疑是如何让代码解析更好执行更快。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;「CSS 策略」：基于 CSS 规则&lt;/li&gt;
&lt;li&gt;「DOM 策略」：基于 DOM 操作&lt;/li&gt;
&lt;li&gt;「阻塞策略」：基于脚本加载&lt;/li&gt;
&lt;li&gt;「回流重绘策略」：基于回流重绘&lt;/li&gt;
&lt;li&gt;「异步更新策略」：基于异步更新&lt;/li&gt;
&lt;li&gt;「缓存策略」&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;CSS 策略&lt;/strong&gt;&lt;br /&gt;
避免出现超过三层的嵌套规则&lt;br /&gt;
避免为 ID 选择器添加多余选择器&lt;br /&gt;
避免使用标签选择器代替类选择器&lt;br /&gt;
避免使用通配选择器，只对目标节点声明规则&lt;br /&gt;
避免重复匹配重复定义，关注可继承属性&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DOM 策略&lt;/strong&gt;&lt;br /&gt;
缓存 DOM 计算属性&lt;br /&gt;
避免过多 DOM 操作&lt;br /&gt;
使用 DOMFragment 缓存批量化 DOM 操作&lt;br /&gt;
虚拟列表优化&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;阻塞策略&lt;/strong&gt;&lt;br /&gt;
脚本与 DOM / 其它脚本的依赖关系很强：对 &amp;lt;script&amp;gt; 设置 defer&lt;br /&gt;
 脚本与 DOM / 其它脚本的依赖关系不强：对 &amp;lt;script&amp;gt; 设置 async&lt;/p&gt;
&lt;p&gt;**「回流重绘策略」** 在渲染层面的性能优化里占比较重，也是最常规的性能优化之一。&lt;br /&gt;
缓存 DOM 计算属性&lt;br /&gt;
使用类合并样式，避免逐条改变样式&lt;br /&gt;
使用 display 控制 DOM 显隐，将 DOM 离线化&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;异步更新策略&lt;/strong&gt;&lt;br /&gt;
在异步任务中修改 DOM 时把其包装成微任务&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缓存策略&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;figcaption data-lang=&#34;javascript&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;在一些前端系统中，当加载页面时会发送请求，路由切换出去再切换回来时又会重新发送请求，每次请求完成后会对页面重新渲染。&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;然而这些重新请求再大多数时是没有必要的，合理地对 &lt;span class=&#34;token constant&#34;&gt;API&lt;/span&gt; 进行缓存将达到优化渲染的目的。&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token number&#34;&gt;1.&lt;/span&gt;对每一条 &lt;span class=&#34;token constant&#34;&gt;GET&lt;/span&gt; &lt;span class=&#34;token constant&#34;&gt;API&lt;/span&gt; 添加 key&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token number&#34;&gt;2.&lt;/span&gt;根据 key 控制该 &lt;span class=&#34;token constant&#34;&gt;API&lt;/span&gt; 缓存，重复发生请求时将从缓存中取得&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;Example&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token comment&#34;&gt;// 设置缓存的 Key 为 Users:10086&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;10&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token keyword&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt; isLoading&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; data &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;useQuery&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#39;users&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; userId&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;=&gt;&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;fetchUserById&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;userId&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;11&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h2 id=&#34;样式优化&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#样式优化&#34;&gt;#&lt;/a&gt; 样式优化&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;响应式设计：使用响应式布局和媒体查询适应不同设备和屏幕大小&lt;/li&gt;
&lt;li&gt;使用 CSS 预处理器：如 Less、Sass 等，提高样式编写的效率&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;脚本优化&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#脚本优化&#34;&gt;#&lt;/a&gt; 脚本优化&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;使用模块化开发：使用模块化 / 组件化的方式组织 JavaScript 代码&lt;/li&gt;
&lt;li&gt;优化 DOM 操作：减少 DOM 操作的次数，对多次操作进行批量处理&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;figcaption data-lang=&#34;javascript&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token number&#34;&gt;1.&lt;/span&gt; 批量更新：将多个 &lt;span class=&#34;token constant&#34;&gt;DOM&lt;/span&gt; 操作合并为一个操作，以减少重排和重绘的次数。例如，如果要对一个元素进行多次样式修改，可以先使用 &lt;span class=&#34;token constant&#34;&gt;CSS&lt;/span&gt; 类来添加或删除样式，最后再应用一次类，而不是每次修改都直接操作样式属性。&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token comment&#34;&gt;// 不优化的写法&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;element&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;style&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;width &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#39;100px&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;element&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;style&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;height &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#39;200px&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;element&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;style&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;backgroundColor &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#39;red&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token comment&#34;&gt;// 优化的写法&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;element&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;classList&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#39;my-class&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;10&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;element&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;classList&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;remove&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#39;my-class&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;11&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;12&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;13&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token number&#34;&gt;2.&lt;/span&gt; 使用文档片段（DocumentFragment）：将多个 &lt;span class=&#34;token constant&#34;&gt;DOM&lt;/span&gt; 节点先添加到文档片段中，然后再一次性插入文档中，这样只会触发一次重排和重绘。这在需要动态添加大量元素时特别有效。&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;14&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;15&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token comment&#34;&gt;// 不优化的写法&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;16&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;let&lt;/span&gt; i &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt; i &lt;span class=&#34;token operator&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;1000&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt; i&lt;span class=&#34;token operator&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;17&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token keyword&#34;&gt;const&lt;/span&gt; element &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; document&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;createElement&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#39;div&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;18&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  document&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;body&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;appendChild&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;element&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;19&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;20&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;21&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token comment&#34;&gt;// 优化的写法&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;22&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;const&lt;/span&gt; fragment &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; document&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;createDocumentFragment&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;23&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;let&lt;/span&gt; i &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt; i &lt;span class=&#34;token operator&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;1000&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt; i&lt;span class=&#34;token operator&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;24&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token keyword&#34;&gt;const&lt;/span&gt; element &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; document&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;createElement&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#39;div&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;25&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  fragment&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;appendChild&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;element&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;26&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;27&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;document&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;body&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;appendChild&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;fragment&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;28&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;29&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token number&#34;&gt;3.&lt;/span&gt; 缓存 &lt;span class=&#34;token constant&#34;&gt;DOM&lt;/span&gt; 查询结果：当需要多次访问同一个 &lt;span class=&#34;token constant&#34;&gt;DOM&lt;/span&gt; 元素时，将查询结果缓存在变量中，避免重复查询。&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;30&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token comment&#34;&gt;// 不优化的写法&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;31&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;let&lt;/span&gt; i &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt; i &lt;span class=&#34;token operator&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt; i&lt;span class=&#34;token operator&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;32&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  document&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;getElementById&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#39;myElement&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;innerHTML &lt;span class=&#34;token operator&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#39;new content&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;33&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;34&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;35&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token comment&#34;&gt;// 优化的写法&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;36&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;const&lt;/span&gt; element &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; document&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;getElementById&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#39;myElement&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;37&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;let&lt;/span&gt; i &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt; i &lt;span class=&#34;token operator&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt; i&lt;span class=&#34;token operator&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;38&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  element&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;innerHTML &lt;span class=&#34;token operator&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#39;new content&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;39&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;40&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;41&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token number&#34;&gt;4.&lt;/span&gt; 使用虚拟 &lt;span class=&#34;token constant&#34;&gt;DOM&lt;/span&gt;：在涉及大量数据变动和复杂视图更新的情况下，可以使用虚拟 &lt;span class=&#34;token constant&#34;&gt;DOM&lt;/span&gt; 技术，通过比对虚拟 &lt;span class=&#34;token constant&#34;&gt;DOM&lt;/span&gt; 树来最小化实际 &lt;span class=&#34;token constant&#34;&gt;DOM&lt;/span&gt; 操作的次数。&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;42&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;这些是一些常见的优化 &lt;span class=&#34;token constant&#34;&gt;DOM&lt;/span&gt; 操作的方法。请根据具体场景选择合适的方法进行优化。记住，减少 &lt;span class=&#34;token constant&#34;&gt;DOM&lt;/span&gt; 操作次数会显著提高性能和用户体验。&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h2 id=&#34;v8引擎优化&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#v8引擎优化&#34;&gt;#&lt;/a&gt; V8 引擎优化&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;避免不必要的闭包：过多的闭包会导致内存消耗增加&lt;/li&gt;
&lt;li&gt;使用高性能 API 和方法：如使用 map 而不是 for 循环等&lt;/li&gt;
&lt;li&gt;优化循环和递归：尽量减少循环和递归的层数和次数，避免性能问题&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;性能评测指标&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#性能评测指标&#34;&gt;#&lt;/a&gt; 性能评测指标&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;三大指标&lt;/strong&gt; 使用工具 lighthouse，web-vitals 等&lt;br /&gt;
 LCP: 加载性能。最大内容绘制应在 2.5s 内完成。&lt;br /&gt;
FID: 交互性能。首次输入延迟应在 100ms 内完成。&lt;br /&gt;
CLS: 页面稳定性。累积布局偏移，需手动计算，CLS 应保持在 0.1 以下。&lt;/p&gt;
&lt;h1 id=&#34;浏览器缓存优化&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#浏览器缓存优化&#34;&gt;#&lt;/a&gt; 浏览器缓存优化&lt;/h1&gt;
&lt;p&gt;为了让浏览器缓存发挥最大作用，该策略尽量遵循以下五点就能发挥浏览器缓存最大作用。&lt;/p&gt;
&lt;p&gt;「考虑拒绝一切缓存策略」：Cache-Control:no-store&lt;br /&gt;
「考虑资源是否每次向服务器请求」：Cache-Control:no-cache&lt;br /&gt;
「考虑资源是否被代理服务器缓存」：Cache-Control:public/private&lt;br /&gt;
「考虑资源过期时间」：Expires:t/Cache-Control:max-age=t,s-maxage=t&lt;br /&gt;
「考虑协商缓存」：Last-Modified/Etag&lt;br /&gt;
 缓存策略通过设置 HTTP 报文实现，在形式上分为 **「强缓存 / 强制缓存」和「协商缓存 / 对比缓存」**。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/images/xn/%E5%BC%BA%E7%BC%93%E5%AD%98.png&#34; alt=&#34;&#34; /&gt;&lt;br /&gt;
&lt;img data-src=&#34;/images/xn/%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;整个缓存策略机制很明了，先走强缓存，若命中失败才走协商缓存。若命中强缓存，直接使用强缓存；若未命中强缓存，发送请求到服务器检查是否命中协商缓存；若命中协商缓存，服务器返回 304 通知浏览器使用本地缓存，否则返回最新资源。&lt;/p&gt;
&lt;p&gt;有两种较常用的应用场景值得使用缓存策略一试，当然更多应用场景都可根据项目需求制定。&lt;/p&gt;
&lt;p&gt;「频繁变动资源」：设置 Cache-Control:no-cache，使浏览器每次都发送请求到服务器，配合 Last-Modified/ETag 验证资源是否有效&lt;br /&gt;
「不常变化资源」：设置 Cache-Control:max-age=31536000，对文件名哈希处理，当代码修改后生成新的文件名，当 HTML 文件引入文件名发生改变才会下载最新文件&lt;/p&gt;
&lt;h1 id=&#34;web-worker&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#web-worker&#34;&gt;#&lt;/a&gt; Web Worker&lt;/h1&gt;
&lt;p&gt;在纯浏览器中，如何实现高性能的实时代码编译及转换？&lt;/p&gt;
&lt;p&gt;Babel Repl(opens new window)&lt;br /&gt;
 如果纯碎使用传统的 Javascript 实现，将会耗时过多阻塞主线程，有可能导致页面卡顿。&lt;/p&gt;
&lt;p&gt;如果使用 Web Worker 交由额外的线程来做这件事，将会高效很多，基本上所有在浏览器端进行代码编译的功能都由 Web Worker 实现。&lt;/p&gt;
&lt;h1 id=&#34;wasmwebassembly&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#wasmwebassembly&#34;&gt;#&lt;/a&gt; WASM(WebAssembly)&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;JS 性能低下&lt;/li&gt;
&lt;li&gt;C++/Rust 高性能&lt;/li&gt;
&lt;li&gt;使用 C++/Rust 编写代码，然后在 Javascript 环境运行&lt;br /&gt;
试举一例:&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在纯浏览器中，如何实现高性能的图片压缩？&lt;/p&gt;
&lt;p&gt;基本上很难做到，Javascript 的性能与生态决定了实现图片压缩的艰难。&lt;/p&gt;
&lt;p&gt;而借助于 WASM 就相当于借用了其它语言的生态。&lt;/p&gt;
&lt;p&gt;1.libavif (opens new window): C 语言写的 avif 解码编码库&lt;br /&gt;
 2.libwebp (opens new window): C 语言写的 webp 解码编码库&lt;br /&gt;
 3.mozjpeg (opens new window): C 语言写的 jpeg 解码编码库&lt;br /&gt;
 4.oxipng (opens new window): Rust 语言写的 png 优化库&lt;br /&gt;
而由于 WASM，完全可以把这些其它语言的生态移植到浏览器中，从而实现一个高性能的离线式的图片压缩工具。&lt;/p&gt;
</content>
        <category term="前端开发" scheme="https://pink-png.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" />
        <category term="前端性能优化" scheme="https://pink-png.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" />
        <category term="前端性能优化" scheme="https://pink-png.github.io/tags/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" />
        <updated>2022-06-25T08:43:00.000Z</updated>
    </entry>
    <entry>
        <id>https://pink-png.github.io/performance-optimization/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BC%98%E5%8C%96%E6%80%9D%E8%80%83(uniapp)/</id>
        <title>在某某企业小程序优化思考(uniapp)</title>
        <link rel="alternate" href="https://pink-png.github.io/performance-optimization/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BC%98%E5%8C%96%E6%80%9D%E8%80%83(uniapp)/"/>
        <content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;vuex 对启动耗时的影响&lt;br /&gt;
 Vuex 是一个状态管理库，在启动阶段如果存在大量的业务逻辑，会使启动耗时增加。这是因为在启动过程中，需要初始化 Vuex 的状态和相关的模块，可能会触发一些异步操作和计算，导致启动时间延长。因此，在设计和使用 Vuex 时，需要注意避免在启动阶段执行过多的繁重操作，以减少启动耗时。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mixins 对启动耗时的影响&lt;br /&gt;
 Mixins 是一种在组件中复用代码的机制，通过将相同的逻辑和功能抽离到 Mixins 中，可以在多个组件中共享使用。在启动阶段，如果组件使用了 Mixins，会在组件实例化时执行 Mixins 中的代码逻辑，因此会增加启动耗时。如果 Mixins 中存在大量或复杂的业务逻辑，会进一步增加启动耗时。因此，使用 Mixins 时需要注意控制逻辑的复杂度，避免影响启动性能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;子组件中的请求是从 onReady 加载完再去调用请求的，所以是否组件中不要使用请求？&lt;br /&gt;
 在小程序中，子组件的请求通常是在组件的 onReady 生命周期钩子函数中进行调用。由于 onReady 是在页面的渲染准备完成后调用的，此时页面已经可见，用户可以看到页面内容。因此，在 onReady 钩子中进行请求可能会导致页面加载完成后才开始请求数据，从而延长了页面加载时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;挂载到原型上的东西，每次生成的页面都会执行这个数据，这里的影响多大？&lt;br /&gt;
 当一些数据或方法挂载到小程序的原型对象上时，每次生成的页面都可以通过原型链访问到这些数据或方法。这样做的好处是可以实现数据和方法的全局共享和复用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有没有根据包大小计算出来的 平均启动时间 / 加载耗时&lt;br /&gt;
通常情况下，并没有一个直接根据包大小计算出来的平均启动时间或加载耗时的公式或算法。因为启动时间和加载耗时受到多个因素的影响，如网络环境、设备性能、代码复杂度等。&lt;br /&gt;
包大小的增加可能会导致下载时间变长，从而影响启动时间。然而，仅仅根据包大小无法准确预测启动时间的增加，还需要考虑其他因素的综合影响。因此，对于不同的小程序和具体场景，需要进行实际测试和评估来得出准确的启动时间和加载耗时。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;计算最佳收益点&lt;/li&gt;
&lt;li&gt;其实这里想表达的是否 2M 和 1.5M 的包下载时间的差距是否几乎不计？&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;从小程序加载流程上来讲，对于首次打开小程序用户，会去下载包，包大会造成下载时间变长（在相同网络条件下）；影响启动耗时的直接因素：&lt;br /&gt;
● 平台：不同的平台下（安卓、IOS）设备性能、操作系统、框架实现、优化方案存在较大的差异，启动耗时也存在较大的差异。只有分平台比较启动耗时（包括各阶段耗时）才有意义；&lt;br /&gt;
1. 怎么做到只是针对某个机型去判断？&lt;br /&gt;
2. 是不是要去处理慢的机型呢？怎么处理是个问题&lt;br /&gt;
● 下载比例及大小：代码包下载和更新都会显著影响小程序启动耗时，在其他流程耗时稳定的情况下，下载比例升高会影响大盘启动耗时。&lt;br /&gt;
● 入口页面：不同页面启动时，根据所在分包的不同，需要下载的代码包数量和大小和代码注入量都存在差异。不同页面渲染耗时也存在差异。&lt;br /&gt;
● 机型分布：启动耗时和设备性能有较强关联，不同小程序或使用场景用户群体的差异可能导致机型分布的差异，进而影响大盘启动耗时。&lt;br /&gt;
● 网络环境：网络环境主要影响网络请求的耗时，如小程序信息获取、代码包下载等。&lt;br /&gt;
间接因素：&lt;br /&gt;
● 场景 / 访问来源：不同场景下，用户访问的页面不同，新用户比例也有差异，对启动耗时会有一定影响。此外，用户访问的目的性和自身的等待意愿也有差异，也会影响打开率。&lt;br /&gt;
1. 这里可能存在有些页面分享进来的，但是这个页面其实是不允许直接进入的，可能会造成某些问题导致的耗时&lt;br /&gt;
 2. 进入的页面不是首页，这是一种什么场景？&lt;br /&gt;
● 首次访问用户比例：用户首次访问小程序时，需要完整的进行小程序信息准备、代码包下载的流程，代码缓存也需要重新生成，启动耗时会比非首次访问高。&lt;br /&gt;
● 小程序版本更新：小程序版本更新时，用户需要更新小程序信息和代码包，代码缓存也需要重新生成，启动耗时会出现上涨。&lt;br /&gt;
1. 这个其实就是每次更新版本对启动时长的影响，特别是发布灰度的时候&lt;br /&gt;
 2. 一段时间不发新版本，启动时间会降低。这里其实说明我们登报的人，他存在多次进来看的情况（这个是肯定的）&lt;/li&gt;
&lt;/ol&gt;
</content>
        <category term="前端开发" scheme="https://pink-png.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" />
        <category term="前端性能优化" scheme="https://pink-png.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" />
        <category term="前端性能优化" scheme="https://pink-png.github.io/tags/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" />
        <updated>2022-06-25T08:43:00.000Z</updated>
    </entry>
    <entry>
        <id>https://pink-png.github.io/Web-Integration/web%E5%AE%89%E5%85%A8/</id>
        <title>web安全</title>
        <link rel="alternate" href="https://pink-png.github.io/Web-Integration/web%E5%AE%89%E5%85%A8/"/>
        <content type="html">&lt;h1 id=&#34;XSS（跨站脚本攻击）：&#34;&gt;&lt;a href=&#34;#XSS（跨站脚本攻击）：&#34; class=&#34;headerlink&#34; title=&#34;XSS（跨站脚本攻击）：&#34;&gt;&lt;/a&gt;XSS（跨站脚本攻击）：&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;text&#34;&gt;使用合适的编码和转义方式来处理输入和输出的数据。
对用户输入进行验证和过滤，避免将恶意脚本插入到页面中。
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;CSRF（跨站请求伪造）：&#34;&gt;&lt;a href=&#34;#CSRF（跨站请求伪造）：&#34; class=&#34;headerlink&#34; title=&#34;CSRF（跨站请求伪造）：&#34;&gt;&lt;/a&gt;CSRF（跨站请求伪造）：&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;text&#34;&gt;在关键操作上使用随机生成的令牌（CSRF Token），并验证该令牌的合法性。
设置合适的 SameSite Cookie 属性，限制跨站点访问。
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;点击劫持（Clickjacking）：&#34;&gt;&lt;a href=&#34;#点击劫持（Clickjacking）：&#34; class=&#34;headerlink&#34; title=&#34;点击劫持（Clickjacking）：&#34;&gt;&lt;/a&gt;点击劫持（Clickjacking）：&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;text&#34;&gt;使用 X-Frame-Options 或 Content-Security-Policy 来限制页面被嵌套到其他网站的情况。
可以使用 JavaScript 检测页面是否在 iframe 中展示，并弹出警告或拒绝加载。
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;密码安全：&#34;&gt;&lt;a href=&#34;#密码安全：&#34; class=&#34;headerlink&#34; title=&#34;密码安全：&#34;&gt;&lt;/a&gt;密码安全：&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;text&#34;&gt;采用密码哈希算法（如 bcrypt）对用户密码进行加密存储，避免明文存储。
强制要求用户设置强密码，并进行密码策略的验证（如长度、大小写字母、特殊字符等）。
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;客户端数据验证和过滤：&#34;&gt;&lt;a href=&#34;#客户端数据验证和过滤：&#34; class=&#34;headerlink&#34; title=&#34;客户端数据验证和过滤：&#34;&gt;&lt;/a&gt;客户端数据验证和过滤：&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;text&#34;&gt;不要依赖前端验证，一定要在后端进行数据验证和过滤。
对客户端输入的数据进行严格验证，避免恶意输入和攻击。
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;安全更新和依赖管理：&#34;&gt;&lt;a href=&#34;#安全更新和依赖管理：&#34; class=&#34;headerlink&#34; title=&#34;安全更新和依赖管理：&#34;&gt;&lt;/a&gt;安全更新和依赖管理：&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;text&#34;&gt;及时更新和升级前端框架、库和依赖，以获取最新的安全修复和补丁。
定期审查和监控项目的依赖项，确保没有包含已知的漏洞和安全问题。
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;HTTPS-的使用：&#34;&gt;&lt;a href=&#34;#HTTPS-的使用：&#34; class=&#34;headerlink&#34; title=&#34;HTTPS 的使用：&#34;&gt;&lt;/a&gt;HTTPS 的使用：&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;text&#34;&gt;在页面上使用 HTTPS 协议来加密数据传输，防止数据被窃取和篡改。
配置合适的 TLS/SSL 加密套件和证书，确保通信的安全性。
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;安全审计和日志记录：&#34;&gt;&lt;a href=&#34;#安全审计和日志记录：&#34; class=&#34;headerlink&#34; title=&#34;安全审计和日志记录：&#34;&gt;&lt;/a&gt;安全审计和日志记录：&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;text&#34;&gt;记录用户操作日志，追溯异常行为和安全事件。
定期进行安全审计，检查应用程序的漏洞和安全风险。
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;输入验证与过滤：&#34;&gt;&lt;a href=&#34;#输入验证与过滤：&#34; class=&#34;headerlink&#34; title=&#34;输入验证与过滤：&#34;&gt;&lt;/a&gt;输入验证与过滤：&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;text&#34;&gt;对用户输入进行验证和过滤，确保只接受预期的合法输入。
使用白名单过滤，而不是黑名单过滤，避免遗漏恶意输入。
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;安全的跨域资源共享（CORS）配置：&#34;&gt;&lt;a href=&#34;#安全的跨域资源共享（CORS）配置：&#34; class=&#34;headerlink&#34; title=&#34;安全的跨域资源共享（CORS）配置：&#34;&gt;&lt;/a&gt;安全的跨域资源共享（CORS）配置：&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;text&#34;&gt;配置合适的 CORS 头信息，限制跨域请求的访问权限。
设置合理的源和目标组合，防止未经授权的访问和信息泄露。
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;客户端存储的安全性：&#34;&gt;&lt;a href=&#34;#客户端存储的安全性：&#34; class=&#34;headerlink&#34; title=&#34;客户端存储的安全性：&#34;&gt;&lt;/a&gt;客户端存储的安全性：&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;text&#34;&gt;避免在客户端存储敏感信息，如密码、令牌等。
使用合适的存储机制，如浏览器提供的 localStorage 或 sessionStorage，加密存储敏感数据。
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;CDN-安全：&#34;&gt;&lt;a href=&#34;#CDN-安全：&#34; class=&#34;headerlink&#34; title=&#34;CDN 安全：&#34;&gt;&lt;/a&gt;CDN 安全：&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;text&#34;&gt;如果使用内容分发网络（CDN），确保从可信任的来源获取资源并验证其完整性。
配置适当的安全头部，如 Content Security Policy (CSP)。
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;防御点击劫持：&#34;&gt;&lt;a href=&#34;#防御点击劫持：&#34; class=&#34;headerlink&#34; title=&#34;防御点击劫持：&#34;&gt;&lt;/a&gt;防御点击劫持：&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;text&#34;&gt;通过在响应头中设置 X-Frame-Options 或 Content-Security-Policy，限制页面被嵌套到其他网站的情况。
对于现代浏览器，可以使用 Frame-ancestors CSP 指令来进一步控制允许嵌套页面的来源。
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;定期安全审查和漏洞扫描：&#34;&gt;&lt;a href=&#34;#定期安全审查和漏洞扫描：&#34; class=&#34;headerlink&#34; title=&#34;定期安全审查和漏洞扫描：&#34;&gt;&lt;/a&gt;定期安全审查和漏洞扫描：&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;text&#34;&gt;定期进行安全审查，检查代码中的潜在漏洞和安全隐患。
使用自动化工具进行漏洞扫描和代码静态分析，及时发现可能存在的安全问题。
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;消息传递的安全性：&#34;&gt;&lt;a href=&#34;#消息传递的安全性：&#34; class=&#34;headerlink&#34; title=&#34;消息传递的安全性：&#34;&gt;&lt;/a&gt;消息传递的安全性：&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;text&#34;&gt;对于敏感信息的传递，尽量使用加密算法加密数据。
避免将敏感信息直接传递给前端，而是在后端进行敏感信息的处理和加密。
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;防御代码注入攻击：&#34;&gt;&lt;a href=&#34;#防御代码注入攻击：&#34; class=&#34;headerlink&#34; title=&#34;防御代码注入攻击：&#34;&gt;&lt;/a&gt;防御代码注入攻击：&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;text&#34;&gt;避免在前端中执行不受信任的代码。
不要将用户输入直接拼接到代码字符串中，以防止代码注入攻击。
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;防御文件上传漏洞：&#34;&gt;&lt;a href=&#34;#防御文件上传漏洞：&#34; class=&#34;headerlink&#34; title=&#34;防御文件上传漏洞：&#34;&gt;&lt;/a&gt;防御文件上传漏洞：&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;text&#34;&gt;对用户上传的文件进行严格的验证和过滤，并使用独立的文件存储来避免安全问题。
验证文件类型、大小和内容，确保只接受合法和安全的文件。
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;安全的第三方组件和库：&#34;&gt;&lt;a href=&#34;#安全的第三方组件和库：&#34; class=&#34;headerlink&#34; title=&#34;安全的第三方组件和库：&#34;&gt;&lt;/a&gt;安全的第三方组件和库：&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;text&#34;&gt;在使用第三方组件和库时，选择经过广泛审查和更新的可信来源。
定期更新和升级第三方组件，以获取最新的安全修复和功能改进。
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;保护敏感信息：&#34;&gt;&lt;a href=&#34;#保护敏感信息：&#34; class=&#34;headerlink&#34; title=&#34;保护敏感信息：&#34;&gt;&lt;/a&gt;保护敏感信息：&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;text&#34;&gt;不要将敏感信息直接存储在前端，如密码、密钥等。
使用加密算法对敏感信息进行加密，并在后端进行处理和存储。
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="前端开发" scheme="https://pink-png.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" />
        <category term="web安全" scheme="https://pink-png.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/web%E5%AE%89%E5%85%A8/" />
        <category term="web综合问题" scheme="https://pink-png.github.io/tags/web%E7%BB%BC%E5%90%88%E9%97%AE%E9%A2%98/" />
        <updated>2021-06-25T08:43:00.000Z</updated>
    </entry>
    <entry>
        <id>https://pink-png.github.io/Web-Integration/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/</id>
        <title>浏览器渲染原理以及优化思路</title>
        <link rel="alternate" href="https://pink-png.github.io/Web-Integration/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/"/>
        <content type="html">&lt;h1 id=&#34;浏览器渲染原理&#34;&gt;&lt;a href=&#34;#浏览器渲染原理&#34; class=&#34;headerlink&#34; title=&#34;浏览器渲染原理&#34;&gt;&lt;/a&gt;浏览器渲染原理&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;text&#34;&gt;1. 渲染过程：
解析HTML：浏览器解析HTML代码，构建DOM树。
解析CSS：浏览器解析CSS样式表，构建CSSOM树。
构建渲染树：将DOM树和CSSOM树合并成渲染树，该树只包含需要显示元素的信息。
布局（Layout）：计算每个元素的大小和位置。
绘制（Paint）：根据计算好的布局信息，将每个元素绘制成屏幕上的像素。
合成（Composite）：将绘制好的元素按正确的顺序合成到最终的图像上。

2. 阻塞过程：
脚本阻塞：当浏览器遇到&amp;lt;script&amp;gt;标签或执行JavaScript代码时，会暂停HTML解析和渲染，直到脚本执行完毕。
样式加载阻塞：如果浏览器遇到外部CSS文件，会等待该文件下载和解析完毕后再继续渲染。
资源加载阻塞：当浏览器遇到资源文件如图片、字体或其他媒体时，会等待资源下载和加载完毕后再继续渲染。

3. 重绘与汇流：
重绘（Repaint）：当元素的样式改变，但不影响布局时，浏览器只需要重新绘制元素的可视部分。
汇流（Reflow）：当布局发生改变，例如改变元素的大小或位置时，浏览器需要重新计算并调整元素的布局和相关元素的位置。
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;优化&#34;&gt;&lt;a href=&#34;#优化&#34; class=&#34;headerlink&#34; title=&#34;优化&#34;&gt;&lt;/a&gt;优化&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;text&#34;&gt;1. 减少阻塞时间：
脚本加载优化：将JavaScript脚本放在页面底部，或者使用defer属性将其延迟执行，以免阻塞HTML解析和渲染过程。
样式加载优化：将CSS样式表放在&amp;lt;head&amp;gt;标签中，避免样式表的加载阻塞页面渲染。
资源加载优化：使用合适的缓存策略、减小资源文件的大小，以及使用CDN等方式来提高资源加载速度。

2. 最小化重绘与汇流：
批量修改样式：避免频繁读取和修改单个元素的样式属性，最好使用CSS类进行批量修改，这样可以减少重绘和汇流的次数。
避免强制同步布局：在修改多个元素的样式时，避免强制同步布局，即尽量将布局相关的修改集中在一起，减少不必要的重绘和汇流。

3.使用现代CSS特性：
使用CSS动画代替JavaScript动画：CSS动画借助浏览器的硬件加速，性能更高，并且不会阻塞JavaScript主线程。
使用CSS Grid 和 Flexbox 布局：这些现代的布局方式能够更有效地处理布局，减少重绘和汇流的次数。

4.图片优化：
使用适当的图片格式：根据图片特性选择合适的图片格式，例如JPEG、PNG、WebP等，以尽量减小文件大小。
图片懒加载：只在视口范围内加载可见区域的图片，延迟加载其他图片，以提高页面加载速度。

5. 代码优化：
避免频繁操作DOM：减少对DOM的修改和查询次数，可以使用文档片段（DocumentFragment）来进行批量操作。
压缩和合并代码：对CSS和JavaScript文件进行压缩和合并，减小文件体积，加快加载速度。
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="前端开发" scheme="https://pink-png.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" />
        <category term="浏览器" scheme="https://pink-png.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E6%B5%8F%E8%A7%88%E5%99%A8/" />
        <category term="web综合问题" scheme="https://pink-png.github.io/tags/web%E7%BB%BC%E5%90%88%E9%97%AE%E9%A2%98/" />
        <updated>2021-06-25T08:43:00.000Z</updated>
    </entry>
    <entry>
        <id>https://pink-png.github.io/Web-Integration/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</id>
        <title>浏览器缓存机制</title>
        <link rel="alternate" href="https://pink-png.github.io/Web-Integration/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
        <content type="html">&lt;h1 id=&#34;浏览器缓存机制&#34;&gt;&lt;a href=&#34;#浏览器缓存机制&#34; class=&#34;headerlink&#34; title=&#34;浏览器缓存机制&#34;&gt;&lt;/a&gt;浏览器缓存机制&lt;/h1&gt;&lt;p&gt;浏览器缓存机制是指浏览器在处理网页资源时，将一部分资源保存在本地存储中，以便下次请求相同资源时可以快速获取，从而提高网页加载速度和用户体验。以下是常见的浏览器缓存机制：&lt;/p&gt;
&lt;h1 id=&#34;强缓存&#34;&gt;&lt;a href=&#34;#强缓存&#34; class=&#34;headerlink&#34; title=&#34;强缓存&#34;&gt;&lt;/a&gt;强缓存&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;浏览器在第一次请求资源时，服务器通过响应头中的Cache-Control或Expires字段返回资源，并将这些信息保存在浏览器缓存中。在下一次请求相同资源时，浏览器会直接从缓存中读取，而不发起请求&lt;/li&gt;
&lt;li&gt;常用的Cache-Control值有：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;public：表示资源可以被所有用户及代理服务器缓存。&lt;/li&gt;
&lt;li&gt;private：表示资源只能被单个用户缓存，不允许代理服务器缓存。&lt;/li&gt;
&lt;li&gt;max-age：表示资源在缓存中的有效期，单位为秒。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;协商缓存&#34;&gt;&lt;a href=&#34;#协商缓存&#34; class=&#34;headerlink&#34; title=&#34;协商缓存&#34;&gt;&lt;/a&gt;协商缓存&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;在资源过期后，浏览器会发送一个带有If-Modified-Since（Last-Modified）或If-None-Match（ETag）字段的请求到服务器，询问该资源是否有更新。如果服务器返回304 Not Modified状态码，则表示资源未发生变化，浏览器会直接从缓存中读取。&lt;/li&gt;
&lt;li&gt;常用的响应头字段有：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Last-Modified：表示资源的最后修改时间。&lt;/li&gt;
&lt;li&gt;ETag：表示资源的唯一标识符。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;离线缓存&#34;&gt;&lt;a href=&#34;#离线缓存&#34; class=&#34;headerlink&#34; title=&#34;离线缓存&#34;&gt;&lt;/a&gt;离线缓存&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;HTML5提供了离线缓存机制，使用manifest文件来定义需要缓存的资源。浏览器在第一次访问网页时会下载manifest文件并根据文件中的信息缓存相应资源。在之后的访问中，即使处于离线状态，浏览器仍然能够加载并显示已缓存的页面。离线缓存可以提高网页的可访问性和性能。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;缓存位置&#34;&gt;&lt;a href=&#34;#缓存位置&#34; class=&#34;headerlink&#34; title=&#34;缓存位置&#34;&gt;&lt;/a&gt;缓存位置&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;内存缓存（Memory Cache）：&lt;br&gt;内存缓存是最快的缓存位置，将资源直接保存在浏览器内存中。&lt;br&gt;内存缓存的读取速度非常快，可以快速响应请求，适用于频繁请求和临时性资源。&lt;br&gt;但是，内存缓存的容量有限，并且在浏览器关闭时会被清空。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;硬盘缓存（Disk Cache）：&lt;br&gt;硬盘缓存将资源保存在硬盘上，相对于内存缓存来说读取速度较慢，但比重新请求资源要快得多。&lt;br&gt;硬盘缓存可以持久保存资源，并且在浏览器关闭后仍然可用。&lt;br&gt;硬盘缓存的容量相对较大，可以保存更多的资源。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;服务端缓存：&lt;br&gt;服务端缓存是指将资源保存在服务器端，由服务器返回缓存的资源给浏览器。&lt;br&gt;服务端缓存可以利用类似缓存代理、CDN等方式来提升资源获取速度，减轻服务器的压力。&lt;br&gt;服务端缓存可以根据资源的过期时间或版本号来判断是否返回缓存资源。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Service Worker 缓存：&lt;br&gt;Service Worker 是运行在浏览器后台的脚本，可以拦截网络请求并自定义响应。&lt;br&gt;Service Worker 可以将资源保存在本地缓存中，实现离线访问或快速加载。&lt;br&gt;Service Worker 缓存具有灵活性和高度可自定义的特性，适用于离线应用、推送通知等场景。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;总结&#34;&gt;&lt;a href=&#34;#总结&#34; class=&#34;headerlink&#34; title=&#34;总结&#34;&gt;&lt;/a&gt;总结&lt;/h1&gt;&lt;p&gt;通过合理设置缓存策略，可以减少对服务器的请求次数，加快网页加载速度，降低网络流量消耗。同时，如果网页内容有更新，通过修改资源的版本号或过期时间等方式来使浏览器重新请求新的资源版本。&lt;/p&gt;
</content>
        <category term="前端开发" scheme="https://pink-png.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" />
        <category term="浏览器" scheme="https://pink-png.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E6%B5%8F%E8%A7%88%E5%99%A8/" />
        <category term="web综合问题" scheme="https://pink-png.github.io/tags/web%E7%BB%BC%E5%90%88%E9%97%AE%E9%A2%98/" />
        <updated>2021-06-25T08:43:00.000Z</updated>
    </entry>
    <entry>
        <id>https://pink-png.github.io/Web-Integration/%E6%B5%8F%E8%A7%88%E5%99%A8%E9%9D%A2%E8%AF%95/</id>
        <title>web综合问题</title>
        <link rel="alternate" href="https://pink-png.github.io/Web-Integration/%E6%B5%8F%E8%A7%88%E5%99%A8%E9%9D%A2%E8%AF%95/"/>
        <content type="html">&lt;h1 id=&#34;常见的浏览器内核有哪些？&#34;&gt;&lt;a href=&#34;#常见的浏览器内核有哪些？&#34; class=&#34;headerlink&#34; title=&#34;常见的浏览器内核有哪些？&#34;&gt;&lt;/a&gt;常见的浏览器内核有哪些？&lt;/h1&gt;&lt;p&gt;主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。&lt;br&gt;渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。&lt;br&gt;JS引擎则：解析和执行javascript来实现网页的动态效果。&lt;br&gt;最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。&lt;br&gt;常见内核&lt;br&gt;Trident 内核：IE, MaxThon, TT, The World, 360, 搜狗浏览器等。[又称 MSHTML]&lt;br&gt;Gecko 内核：Netscape6 及以上版本，FF, MozillaSuite &amp;#x2F; SeaMonkey 等&lt;br&gt;Presto 内核：Opera7 及以上。 [Opera内核原为：Presto，现为：Blink;]&lt;br&gt;Webkit 内核：Safari, Chrome等。 [ Chrome的：Blink（WebKit 的分支）]&lt;/p&gt;
&lt;h1 id=&#34;网页前端性能优化的方式有哪些？&#34;&gt;&lt;a href=&#34;#网页前端性能优化的方式有哪些？&#34; class=&#34;headerlink&#34; title=&#34;网页前端性能优化的方式有哪些？&#34;&gt;&lt;/a&gt;网页前端性能优化的方式有哪些？&lt;/h1&gt;&lt;p&gt;1.压缩 css, js, 图片&lt;br&gt;2.减少 http 请求次数， 合并 css、js 、合并图片（雪碧图）&lt;br&gt;3.使用 CDN&lt;br&gt;4.减少 dom 元素数量&lt;br&gt;5.图片懒加载&lt;br&gt;6.静态资源另外用无 cookie 的域名&lt;br&gt;7.减少 dom 的访问（缓存 dom）&lt;br&gt;8.巧用事件委托&lt;br&gt;9.样式表置顶、脚本置低&lt;/p&gt;
&lt;h1 id=&#34;网页从输入网址到渲染完成经历了哪些过程？&#34;&gt;&lt;a href=&#34;#网页从输入网址到渲染完成经历了哪些过程？&#34; class=&#34;headerlink&#34; title=&#34;网页从输入网址到渲染完成经历了哪些过程？&#34;&gt;&lt;/a&gt;网页从输入网址到渲染完成经历了哪些过程？&lt;/h1&gt;&lt;p&gt;大致可以分为如下7步：&lt;/p&gt;
&lt;p&gt;输入网址；&lt;br&gt;发送到DNS服务器，并获取域名对应的web服务器对应的ip地址；&lt;br&gt;与web服务器建立TCP连接；&lt;br&gt;浏览器向web服务器发送http请求；&lt;br&gt;web服务器响应请求，并返回指定url的数据（或错误信息，或重定向的新的url地址）；&lt;br&gt;浏览器下载web服务器返回的数据及解析html源文件；&lt;br&gt;生成DOM树，解析css和js，渲染页面，直至显示完成；&lt;/p&gt;
&lt;h1 id=&#34;线程与进程的区别？&#34;&gt;&lt;a href=&#34;#线程与进程的区别？&#34; class=&#34;headerlink&#34; title=&#34;线程与进程的区别？&#34;&gt;&lt;/a&gt;线程与进程的区别？&lt;/h1&gt;&lt;p&gt;一个程序至少有一个进程,一个进程至少有一个线程.&lt;br&gt;线程的划分尺度小于进程，使得多线程程序的并发性高。&lt;br&gt;另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。&lt;br&gt;线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。&lt;br&gt;从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。&lt;/p&gt;
&lt;h1 id=&#34;HTTP常见的状态码？&#34;&gt;&lt;a href=&#34;#HTTP常见的状态码？&#34; class=&#34;headerlink&#34; title=&#34;HTTP常见的状态码？&#34;&gt;&lt;/a&gt;HTTP常见的状态码？&lt;/h1&gt;&lt;p&gt;100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息&lt;br&gt;200 OK 正常返回信息&lt;br&gt;201 Created 请求成功并且服务器创建了新的资源&lt;br&gt;202 Accepted 服务器已接受请求，但尚未处理&lt;br&gt;301 Moved Permanently 请求的网页已永久移动到新位置。&lt;br&gt;302 Found 临时性重定向。&lt;br&gt;303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。&lt;br&gt;304 Not Modified 自从上次请求后，请求的网页未修改过。&lt;br&gt;400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。&lt;br&gt;401 Unauthorized 请求未授权。&lt;br&gt;403 Forbidden 禁止访问。&lt;br&gt;404 Not Found 找不到如何与 URI 相匹配的资源。&lt;br&gt;500 Internal Server Error 最常见的服务器端错误。&lt;br&gt;503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。&lt;/p&gt;
&lt;h1 id=&#34;图片懒加载？&#34;&gt;&lt;a href=&#34;#图片懒加载？&#34; class=&#34;headerlink&#34; title=&#34;图片懒加载？&#34;&gt;&lt;/a&gt;图片懒加载？&lt;/h1&gt;&lt;p&gt;当页面滚动的时间被触发 -&amp;gt; 执行加载图片操作 -&amp;gt; 判断图片是否在可视区域内 -&amp;gt; 在，则动态将data-src的值赋予该图片&lt;/p&gt;
&lt;h1 id=&#34;移动端性能优化？&#34;&gt;&lt;a href=&#34;#移动端性能优化？&#34; class=&#34;headerlink&#34; title=&#34;移动端性能优化？&#34;&gt;&lt;/a&gt;移动端性能优化？&lt;/h1&gt;&lt;p&gt;尽量使用css3动画，开启硬件加速&lt;br&gt;适当使用touch时间代替click时间&lt;br&gt;避免使用css3渐变阴影效果&lt;br&gt;可以用transform: translateZ(0) 来开启硬件加速&lt;br&gt;不滥用float。float在渲染时计算量比较大，尽量减少使用&lt;br&gt;不滥用web字体。web字体需要下载，解析，重绘当前页面&lt;br&gt;合理使用requestAnimationFrame动画代替setTimeout&lt;br&gt;css中的属性（css3 transitions、css3 3D transforms、opacity、webGL、video）会触发GUP渲染，耗电&lt;/p&gt;
&lt;h1 id=&#34;TCP-传输的三次握手、四次挥手策略&#34;&gt;&lt;a href=&#34;#TCP-传输的三次握手、四次挥手策略&#34; class=&#34;headerlink&#34; title=&#34;TCP 传输的三次握手、四次挥手策略&#34;&gt;&lt;/a&gt;TCP 传输的三次握手、四次挥手策略&lt;/h1&gt;&lt;p&gt;三次握手：&lt;br&gt;为了准确无误地吧数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送出去后，TCP不会对传送后的情况置之不理，他一定会向对方确认是否送达，握手过程中使用TCP的标志：SYN和ACK&lt;br&gt;发送端首先发送一个带SYN的标志的数据包给对方&lt;br&gt;接收端收到后，回传一个带有SYN&amp;#x2F;ACK标志的数据包以示传达确认信息&lt;br&gt;最后，发送端再回传一个带ACK的标志的数据包，代表“握手”结束&lt;br&gt;如在握手过程中某个阶段莫明中断，TCP协议会再次以相同的顺序发送相同的数据包&lt;/p&gt;
&lt;p&gt;断开一个TCP连接需要“四次挥手”&lt;br&gt;第一次挥手：主动关闭方发送一个FIN，用来关注主动方到被动关闭方的数据传送，也即是主动关闭方告诫被动关闭方：我已经不会再给你发数据了（在FIN包之前发送的数据，如果没有收到对应的ACK确认报文，主动关闭方依然会重发这些数据）。但是，此时主动关闭方还可以接受数据&lt;br&gt;第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号收到序号 +1（与SYN相同，一个 FIN占用一个序号）&lt;br&gt;第三次挥手：被动关闭方发送一个 FIN。用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会给你发送数据了&lt;br&gt;第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手&lt;/p&gt;
&lt;h1 id=&#34;HTTP-和-HTTPS，为什么HTTPS安全？&#34;&gt;&lt;a href=&#34;#HTTP-和-HTTPS，为什么HTTPS安全？&#34; class=&#34;headerlink&#34; title=&#34;HTTP 和 HTTPS，为什么HTTPS安全？&#34;&gt;&lt;/a&gt;HTTP 和 HTTPS，为什么HTTPS安全？&lt;/h1&gt;&lt;p&gt;HTTP协议通常承载与 TCP协议之上，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的HTTPS&lt;br&gt;默认HTTP的端口号为80，HTTPS的端口号为443&lt;br&gt;因为网络请求需要中间有很多的服务器路由的转发，中间的节点都可能篡改信息，而如果使用HTTPS，密钥在你和终点站才有，https之所有说比http安全，是因为他利用ssl&amp;#x2F;tls协议传输。包含证书，流量转发，负载均衡，页面适配，浏览器适配，refer传递等，保障了传输过程的安全性&lt;/p&gt;
&lt;h1 id=&#34;axios和fetch区别对比&#34;&gt;&lt;a href=&#34;#axios和fetch区别对比&#34; class=&#34;headerlink&#34; title=&#34;axios和fetch区别对比&#34;&gt;&lt;/a&gt;axios和fetch区别对比&lt;/h1&gt;&lt;p&gt;axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，本质上也是对原生XHR的封装，只不过它是Promise的实现版本，符合最新的ES规范，它本身具有以下特征&lt;/p&gt;
&lt;p&gt;从浏览器中创建 XMLHttpRequest&lt;br&gt;支持 Promise API&lt;br&gt;客户端支持防止CSRF&lt;br&gt;提供了一些并发请求的接口（重要，方便了很多的操作）&lt;br&gt;从 node.js 创建 http 请求&lt;br&gt;拦截请求和响应&lt;br&gt;转换请求和响应数据&lt;br&gt;取消请求&lt;br&gt;自动转换JSON数据&lt;br&gt;fetch优势：&lt;/p&gt;
&lt;p&gt;语法简洁，更加语义化&lt;br&gt;基于标准 Promise 实现，支持 async&amp;#x2F;await&lt;br&gt;同构方便，使用 isomorphic-fetch&lt;br&gt;更加底层，提供的API丰富（request, response）&lt;br&gt;脱离了XHR，是ES规范里新的实现方式&lt;br&gt;fetch存在问题&lt;/p&gt;
&lt;p&gt;fetch是一个低层次的API，你可以把它考虑成原生的XHR，所以使用起来并不是那么舒服，需要进行封装。&lt;br&gt;fetch只对网络请求报错，对400，500都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。&lt;br&gt;fetch默认不会带cookie，需要添加配置项： fetch(url, {credentials: ‘include’})&lt;br&gt;fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费&lt;br&gt;fetch没有办法原生监测请求的进度，而XHR可以&lt;/p&gt;
</content>
        <category term="前端开发" scheme="https://pink-png.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" />
        <category term="浏览器" scheme="https://pink-png.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E6%B5%8F%E8%A7%88%E5%99%A8/" />
        <category term="web综合问题" scheme="https://pink-png.github.io/tags/web%E7%BB%BC%E5%90%88%E9%97%AE%E9%A2%98/" />
        <updated>2021-06-25T08:43:00.000Z</updated>
    </entry>
    <entry>
        <id>https://pink-png.github.io/front-end/Bootstrap/</id>
        <title>Bootstrap</title>
        <link rel="alternate" href="https://pink-png.github.io/front-end/Bootstrap/"/>
        <content type="html">&lt;h1 id=&#34;什么是Bootstrap？以及为什么要使⽤Bootstrap？&#34;&gt;&lt;a href=&#34;#什么是Bootstrap？以及为什么要使⽤Bootstrap？&#34; class=&#34;headerlink&#34; title=&#34;什么是Bootstrap？以及为什么要使⽤Bootstrap？&#34;&gt;&lt;/a&gt;什么是Bootstrap？以及为什么要使⽤Bootstrap？&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;Bootstrap 是⼀个⽤于快速开发 Web 应⽤程序和⽹站的前端框架。&lt;/li&gt;
&lt;li&gt;Bootstrap 是基于 HTML 、 CSS 、 JAVASCRIPT 的&lt;/li&gt;
&lt;li&gt;Bootstrap 具有移动设备优先、浏览器⽀持良好、容易上⼿、响应式设计等优点，所以Bootstrap 被⼴泛应⽤&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;使⽤Bootstrap时，要声明的⽂档类型是什么？以及为什么要这样声明？&#34;&gt;&lt;a href=&#34;#使⽤Bootstrap时，要声明的⽂档类型是什么？以及为什么要这样声明？&#34; class=&#34;headerlink&#34; title=&#34;使⽤Bootstrap时，要声明的⽂档类型是什么？以及为什么要这样声明？&#34;&gt;&lt;/a&gt;使⽤Bootstrap时，要声明的⽂档类型是什么？以及为什么要这样声明？&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;使⽤ Bootstrap 时，需要使⽤ HTML5 ⽂档类型（ Doctype ）。 &lt;!DOCTYPE html&gt;&lt;/li&gt;
&lt;li&gt;因为 Bootstrap 使⽤了⼀些 HTML5 元素和 CSS 属性，如果在 Bootstrap 创建的⽹⻚开头不使⽤ HTML5 的⽂档类型（ Doctype ），可能会⾯临⼀些浏览器显示不⼀致的问题，甚⾄可能⾯临⼀些特定情境下的不⼀致，以致于代码不能通过 W3C 标准的验证&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;什么是Bootstrap⽹格系统&#34;&gt;&lt;a href=&#34;#什么是Bootstrap⽹格系统&#34; class=&#34;headerlink&#34; title=&#34;什么是Bootstrap⽹格系统&#34;&gt;&lt;/a&gt;什么是Bootstrap⽹格系统&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;Bootstrap 包含了⼀个响应式的、移动设备优先的、不固定的⽹格系统，可以随着设备或视⼝⼤⼩的增加⽽适当地扩展到 12 列。它包含了⽤于简单的布局选项的预定义类，也包含了⽤于⽣成更多语义布局的功能强⼤的混合类&lt;/li&gt;
&lt;li&gt;响应式⽹格系统随着屏幕或视⼝（ viewport ）尺⼨的增加，系统会⾃动分为最多 12列。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;Bootstrap-⽹格系统（Grid-System）的⼯作原理&#34;&gt;&lt;a href=&#34;#Bootstrap-⽹格系统（Grid-System）的⼯作原理&#34; class=&#34;headerlink&#34; title=&#34;Bootstrap ⽹格系统（Grid System）的⼯作原理&#34;&gt;&lt;/a&gt;Bootstrap ⽹格系统（Grid System）的⼯作原理&lt;/h1&gt;&lt;p&gt;（1）⾏必须放置在 .container class 内，以便获得适当的对⻬（ alignment ）和内&lt;br&gt;边距（ padding ）。&lt;br&gt;（2）使⽤⾏来创建列的⽔平组。&lt;br&gt;（3）内容应该放置在列内，且唯有列可以是⾏的直接⼦元素。&lt;br&gt;（4）预定义的⽹格类，⽐如 .row 和 .col-xs-4 ，可⽤于快速创建⽹格布局。 LESS&lt;br&gt;混合类可⽤于更多语义布局。&lt;br&gt;（5）列通过内边距（ padding ）来创建列内容之间的间隙。该内边距是通过 .rows 上&lt;br&gt;的外边距（ margin ）取负，表示第⼀列和最后⼀列的⾏偏移。&lt;br&gt;（6）⽹格系统是通过指定您想要横跨的⼗⼆个可⽤的列来创建的。例如，要创建三个相等&lt;br&gt;的列，则使⽤三个 .col-xs-4&lt;/p&gt;
&lt;h1 id=&#34;对于各类尺⼨的设备，Bootstrap设置的class前缀分别是什么&#34;&gt;&lt;a href=&#34;#对于各类尺⼨的设备，Bootstrap设置的class前缀分别是什么&#34; class=&#34;headerlink&#34; title=&#34;对于各类尺⼨的设备，Bootstrap设置的class前缀分别是什么&#34;&gt;&lt;/a&gt;对于各类尺⼨的设备，Bootstrap设置的class前缀分别是什么&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;超⼩设备⼿机（ &amp;lt;768px ）： .col-xs-*&lt;/li&gt;
&lt;li&gt;⼩型设备平板电脑（ &amp;gt;&amp;#x3D;768px ）： .col-sm-*&lt;/li&gt;
&lt;li&gt;中型设备台式电脑（ &amp;gt;&amp;#x3D;992px ）： .col-md-*&lt;/li&gt;
&lt;li&gt;⼤型设备台式电脑（ &amp;gt;&amp;#x3D;1200px ）： .col-lg-*&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;Bootstrap-⽹格系统列与列之间的间隙宽度是多少&#34;&gt;&lt;a href=&#34;#Bootstrap-⽹格系统列与列之间的间隙宽度是多少&#34; class=&#34;headerlink&#34; title=&#34;Bootstrap ⽹格系统列与列之间的间隙宽度是多少&#34;&gt;&lt;/a&gt;Bootstrap ⽹格系统列与列之间的间隙宽度是多少&lt;/h1&gt;&lt;p&gt;间隙宽度为 30px （⼀个列的每边分别是 15px ）&lt;/p&gt;
&lt;h1 id=&#34;如果需要在⼀个标题的旁边创建副标题，可以怎样操作&#34;&gt;&lt;a href=&#34;#如果需要在⼀个标题的旁边创建副标题，可以怎样操作&#34; class=&#34;headerlink&#34; title=&#34;如果需要在⼀个标题的旁边创建副标题，可以怎样操作&#34;&gt;&lt;/a&gt;如果需要在⼀个标题的旁边创建副标题，可以怎样操作&lt;/h1&gt;&lt;p&gt;在元素两旁添加 &lt;small&gt; ，或者添加 .small 的 class&lt;/p&gt;
&lt;h1 id=&#34;⽤Bootstrap，如何设置⽂字的对⻬⽅式&#34;&gt;&lt;a href=&#34;#⽤Bootstrap，如何设置⽂字的对⻬⽅式&#34; class=&#34;headerlink&#34; title=&#34;⽤Bootstrap，如何设置⽂字的对⻬⽅式&#34;&gt;&lt;/a&gt;⽤Bootstrap，如何设置⽂字的对⻬⽅式&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;class&amp;#x3D;”text-center” 设置居中⽂本&lt;/li&gt;
&lt;li&gt;class&amp;#x3D;”text-right” 设置向右对⻬⽂本&lt;/li&gt;
&lt;li&gt;class&amp;#x3D;”text-left” 设置向左对⻬⽂本&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;Bootstrap如何设置响应式表格？&#34;&gt;&lt;a href=&#34;#Bootstrap如何设置响应式表格？&#34; class=&#34;headerlink&#34; title=&#34;Bootstrap如何设置响应式表格？&#34;&gt;&lt;/a&gt;Bootstrap如何设置响应式表格？&lt;/h1&gt;&lt;p&gt;增加 class&amp;#x3D;”table-responsive”&lt;/p&gt;
&lt;h1 id=&#34;使⽤Bootstrap创建垂直表单的基本步骤？&#34;&gt;&lt;a href=&#34;#使⽤Bootstrap创建垂直表单的基本步骤？&#34; class=&#34;headerlink&#34; title=&#34;使⽤Bootstrap创建垂直表单的基本步骤？&#34;&gt;&lt;/a&gt;使⽤Bootstrap创建垂直表单的基本步骤？&lt;/h1&gt;&lt;p&gt;（1）向⽗ &lt;form&gt; 元素添加 role&amp;#x3D;”form” ；&lt;br&gt;（2）把标签和控件放在⼀个带有 class&amp;#x3D;”form-group” 的 &lt;div&gt; 中，这是获取最佳间距&lt;br&gt;所必需的；&lt;br&gt;（3）向所有的⽂本元素 &lt;input&gt; 、 &lt;textarea&gt; 、 &lt;select&gt; 添加 class&amp;#x3D;”form-control”&lt;/p&gt;
&lt;h1 id=&#34;使⽤Bootstrap创建⽔平表单的基本步骤？&#34;&gt;&lt;a href=&#34;#使⽤Bootstrap创建⽔平表单的基本步骤？&#34; class=&#34;headerlink&#34; title=&#34;使⽤Bootstrap创建⽔平表单的基本步骤？&#34;&gt;&lt;/a&gt;使⽤Bootstrap创建⽔平表单的基本步骤？&lt;/h1&gt;&lt;p&gt;（1）向⽗ &lt;form&gt; 元素添加 class&amp;#x3D;”form-horizontal” ；&lt;br&gt;（2）把标签和控件放在⼀个带有 class&amp;#x3D;”form-group” 的 &lt;div&gt; 中；&lt;br&gt;（3）向标签添加 class&amp;#x3D;”control-label” 。&lt;/p&gt;
&lt;h1 id=&#34;使⽤Bootstrap如何创建表单控件的帮助⽂本？&#34;&gt;&lt;a href=&#34;#使⽤Bootstrap如何创建表单控件的帮助⽂本？&#34; class=&#34;headerlink&#34; title=&#34;使⽤Bootstrap如何创建表单控件的帮助⽂本？&#34;&gt;&lt;/a&gt;使⽤Bootstrap如何创建表单控件的帮助⽂本？&lt;/h1&gt;&lt;p&gt;增加 class&amp;#x3D;”help-block” 的 span 标签或 p 标签。&lt;/p&gt;
&lt;h1 id=&#34;使⽤Bootstrap激活或禁⽤按钮要如何操作？&#34;&gt;&lt;a href=&#34;#使⽤Bootstrap激活或禁⽤按钮要如何操作？&#34; class=&#34;headerlink&#34; title=&#34;使⽤Bootstrap激活或禁⽤按钮要如何操作？&#34;&gt;&lt;/a&gt;使⽤Bootstrap激活或禁⽤按钮要如何操作？&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;激活按钮：给按钮增加 .active 的 class&lt;/li&gt;
&lt;li&gt;禁⽤按钮：给按钮增加 disabled&amp;#x3D;”disabled” 的属性&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;Bootstrap有哪些关于的class？&#34;&gt;&lt;a href=&#34;#Bootstrap有哪些关于的class？&#34; class=&#34;headerlink&#34; title=&#34;Bootstrap有哪些关于的class？&#34;&gt;&lt;/a&gt;Bootstrap有哪些关于的class？&lt;/h1&gt;&lt;p&gt;（1） .img-rounded 为图⽚添加圆⻆&lt;br&gt;（2） .img-circle 将图⽚变为圆形&lt;br&gt;（3） .img-thumbnail 缩略图功能&lt;br&gt;（4） .img-responsive 图⽚响应式 (将很好地扩展到⽗元素)&lt;/p&gt;
&lt;h1 id=&#34;Bootstrap中有关元素浮动及清除浮动的class？&#34;&gt;&lt;a href=&#34;#Bootstrap中有关元素浮动及清除浮动的class？&#34; class=&#34;headerlink&#34; title=&#34;Bootstrap中有关元素浮动及清除浮动的class？&#34;&gt;&lt;/a&gt;Bootstrap中有关元素浮动及清除浮动的class？&lt;/h1&gt;&lt;p&gt;（1） class&amp;#x3D;”pull-left” 元素浮动到左边&lt;br&gt;（2） class&amp;#x3D;”pull-right” 元素浮动到右边&lt;br&gt;（3） class&amp;#x3D;”clearfix” 清除浮动&lt;/p&gt;
&lt;h1 id=&#34;除了屏幕阅读器外，其他设备上隐藏元素的class？&#34;&gt;&lt;a href=&#34;#除了屏幕阅读器外，其他设备上隐藏元素的class？&#34; class=&#34;headerlink&#34; title=&#34;除了屏幕阅读器外，其他设备上隐藏元素的class？&#34;&gt;&lt;/a&gt;除了屏幕阅读器外，其他设备上隐藏元素的class？&lt;/h1&gt;&lt;p&gt;&lt;code&gt;class=&amp;quot;sr-only&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;Bootstrap如何制作下拉菜单？&#34;&gt;&lt;a href=&#34;#Bootstrap如何制作下拉菜单？&#34; class=&#34;headerlink&#34; title=&#34;Bootstrap如何制作下拉菜单？&#34;&gt;&lt;/a&gt;Bootstrap如何制作下拉菜单？&lt;/h1&gt;&lt;p&gt;（1）将下拉菜单包裹在 class&amp;#x3D;”dropdown” 的 &lt;div&gt; 中；&lt;br&gt;（2）在触发下拉菜单的按钮中添加： class&amp;#x3D;”btn dropdown-toggle”&lt;br&gt;id&amp;#x3D;”dropdownMenu1” data-toggle&amp;#x3D;”dropdown”&lt;br&gt;（3）在包裹下拉菜单的ul中添加： class&amp;#x3D;”dropdown-menu” role&amp;#x3D;”menu” aria-labelledby&amp;#x3D;”dropdownMenu1”&lt;br&gt;（4）在下拉菜单的列表项中添加： role&amp;#x3D;”presentation” 。其中，下拉菜单的标题要添&lt;br&gt;加 class&amp;#x3D;”dropdown-header” ，选项部分要添加 tabindex&amp;#x3D;”-1” 。&lt;/p&gt;
&lt;h1 id=&#34;Bootstrap如何制作按钮组？以及⽔平按钮组和垂直按钮组的优先级？&#34;&gt;&lt;a href=&#34;#Bootstrap如何制作按钮组？以及⽔平按钮组和垂直按钮组的优先级？&#34; class=&#34;headerlink&#34; title=&#34;Bootstrap如何制作按钮组？以及⽔平按钮组和垂直按钮组的优先级？&#34;&gt;&lt;/a&gt;Bootstrap如何制作按钮组？以及⽔平按钮组和垂直按钮组的优先级？&lt;/h1&gt;&lt;p&gt;（1）⽤ class&amp;#x3D;”btn-group” 的 &lt;div&gt; 去包裹按钮组； class&amp;#x3D;”btn-group-vertical” 可设置垂直按钮组。&lt;br&gt;（2） btn-group 的优先级⾼于 btn-group-vertical 的优先级。&lt;/p&gt;
&lt;h1 id=&#34;Bootstrap如何设置按钮的下拉菜单？&#34;&gt;&lt;a href=&#34;#Bootstrap如何设置按钮的下拉菜单？&#34; class=&#34;headerlink&#34; title=&#34;Bootstrap如何设置按钮的下拉菜单？&#34;&gt;&lt;/a&gt;Bootstrap如何设置按钮的下拉菜单？&lt;/h1&gt;&lt;p&gt;在⼀个 .btn-group 中放置按钮和下拉菜单即可。&lt;/p&gt;
&lt;h1 id=&#34;Bootstrap中的输⼊框组如何制作？&#34;&gt;&lt;a href=&#34;#Bootstrap中的输⼊框组如何制作？&#34; class=&#34;headerlink&#34; title=&#34;Bootstrap中的输⼊框组如何制作？&#34;&gt;&lt;/a&gt;Bootstrap中的输⼊框组如何制作？&lt;/h1&gt;&lt;p&gt;（1）把前缀或者后缀元素放在⼀个带有 class&amp;#x3D;”input-group” 中的 &lt;div&gt; 中&lt;br&gt;（2）在该 &lt;div&gt; 内，在 class&amp;#x3D;”input-group-addon” 的 &lt;span&gt; ⾥⾯放置额外的内&lt;br&gt;容；&lt;br&gt;（3）把 &lt;span&gt; 放在 &lt;input&gt; 元素的前⾯或后⾯。&lt;/p&gt;
&lt;h1 id=&#34;Bootstrap中的导航都有哪些？&#34;&gt;&lt;a href=&#34;#Bootstrap中的导航都有哪些？&#34; class=&#34;headerlink&#34; title=&#34;Bootstrap中的导航都有哪些？&#34;&gt;&lt;/a&gt;Bootstrap中的导航都有哪些？&lt;/h1&gt;&lt;p&gt;（1）导航元素：有 class&amp;#x3D;”nav nav-tabs” 的标签⻚导航，还有 class&amp;#x3D;”nav navpills” 的胶囊式标签⻚导航；&lt;br&gt;（2）导航栏： class&amp;#x3D;”navbar navbar-default” role&amp;#x3D;”navigation” ；&lt;br&gt;（3）⾯包屑导航： class&amp;#x3D;”breadcrumb”&lt;/p&gt;
&lt;h1 id=&#34;Bootstrap中设置分⻚的class？&#34;&gt;&lt;a href=&#34;#Bootstrap中设置分⻚的class？&#34; class=&#34;headerlink&#34; title=&#34;Bootstrap中设置分⻚的class？&#34;&gt;&lt;/a&gt;Bootstrap中设置分⻚的class？&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;默认的分⻚： class&amp;#x3D;”pagination”&lt;/li&gt;
&lt;li&gt;默认的翻⻚： class&amp;#x3D;”pager”&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;Bootstrap中显示标签的class？&#34;&gt;&lt;a href=&#34;#Bootstrap中显示标签的class？&#34; class=&#34;headerlink&#34; title=&#34;Bootstrap中显示标签的class？&#34;&gt;&lt;/a&gt;Bootstrap中显示标签的class？&lt;/h1&gt;&lt;p&gt;class&amp;#x3D;”label”&lt;/p&gt;
&lt;h1 id=&#34;Bootstrap中如何制作徽章？&#34;&gt;&lt;a href=&#34;#Bootstrap中如何制作徽章？&#34; class=&#34;headerlink&#34; title=&#34;Bootstrap中如何制作徽章？&#34;&gt;&lt;/a&gt;Bootstrap中如何制作徽章？&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;css&#34;&gt;&amp;lt;span class=&amp;quot;badge&amp;quot;&amp;gt;26&amp;lt;/span&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;Bootstrap中超⼤屏幕的作⽤是什么&#34;&gt;&lt;a href=&#34;#Bootstrap中超⼤屏幕的作⽤是什么&#34; class=&#34;headerlink&#34; title=&#34;Bootstrap中超⼤屏幕的作⽤是什么&#34;&gt;&lt;/a&gt;Bootstrap中超⼤屏幕的作⽤是什么&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;text&#34;&gt;设置 class=&amp;quot;jumbotron&amp;quot; 可以制作超⼤屏幕，该组件可以增加标题的⼤⼩并
增加更多的外边距
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="前端开发" scheme="https://pink-png.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" />
        <category term="Bootstrap" scheme="https://pink-png.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Bootstrap/" />
        <category term="Bootstrap" scheme="https://pink-png.github.io/tags/Bootstrap/" />
        <updated>2021-06-25T08:43:00.000Z</updated>
    </entry>
    <entry>
        <id>https://pink-png.github.io/Web-Integration/%E8%AF%A6%E8%A7%A3%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E2%BC%8Aurl%E5%88%B0%E6%98%BE%E7%A4%BA%E2%BB%9A%E2%BE%AF/</id>
        <title>从浏览器地址栏输⼊url到显示⻚⾯的步骤</title>
        <link rel="alternate" href="https://pink-png.github.io/Web-Integration/%E8%AF%A6%E8%A7%A3%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E2%BC%8Aurl%E5%88%B0%E6%98%BE%E7%A4%BA%E2%BB%9A%E2%BE%AF/"/>
        <content type="html">&lt;ol&gt;
&lt;li&gt;在浏览器地址栏输⼊URL&lt;/li&gt;
&lt;li&gt;浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;如果资源未缓存，发起新请求&lt;/li&gt;
&lt;li&gt;如果已缓存，检验是否⾜够新鲜，⾜够新鲜直接提供给客户端，否则与服务器进⾏验证。&lt;/li&gt;
&lt;li&gt;检验新鲜通常有两个HTTP头进⾏控制 Expires 和 Cache-Control ：(  HTTP1.0提供Expires，值为⼀个绝对时间表示缓存新鲜⽇期&lt;br&gt;  HTTP1.1增加了Cache-Control: max-age&amp;#x3D;,值为以秒为单位的最⼤新鲜时间)&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;浏览器解析URL获取协议，主机，端⼝，path&lt;/li&gt;
&lt;li&gt;浏览器组装⼀个HTTP（GET）请求报⽂&lt;/li&gt;
&lt;li&gt;浏览器获取主机ip地址，过程如下：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;浏览器缓存:(浏览器会在本地进行DNS缓存，将之前解析过的域名和其对应的IP地址保存起来。当再次请求相同的域名时，浏览器会首先检查本地缓存中是否存在对应的记录)&lt;/li&gt;
&lt;li&gt;本机缓存:(如果在浏览器缓存中找不到域名的IP地址，浏览器将查找操作系统（如Windows、Mac等）的本机DNS缓存。操作系统也会对DNS查询结果进行缓存，以提高性能和减少网络请求)&lt;/li&gt;
&lt;li&gt;hosts⽂件:(如果在本机缓存中没有找到域名的IP地址，系统将查找操作系统的Hosts文件。Hosts文件是一个文本文件，可以手动配置域名和对应的IP地址映射关系)&lt;/li&gt;
&lt;li&gt;路由器缓存:(如果在Hosts文件中找不到域名的IP地址，系统将向路由器发送DNS查询请求。某些路由器会在自身进行DNS缓存，以便快速响应本地网络设备的DNS查询)&lt;/li&gt;
&lt;li&gt;ISP DNS缓存:(如果在路由器缓存中没有找到域名的IP地址，系统将向互联网服务提供商（ISP）的DNS服务器发送DNS查询请求。ISP的DNS服务器也会进行缓存，以提高DNS解析速度和网络访问效率)&lt;/li&gt;
&lt;li&gt;DNS递归查询:(如果在ISP DNS缓存中找不到域名的IP地址，ISP的DNS服务器将发起递归查询。递归查询是指DNS服务器按照一定的顺序向上级DNS服务器发出查询请求，直到找到所需的IP地址或者查询失败。在递归查询过程中，可能会经过多个DNS服务器，这可能导致负载均衡使得每次获得的IP地址可能不一样)（可能存在负载均衡导致每次IP不⼀样）&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;打开⼀个socket与⽬标IP地址，端⼝建⽴TCP链接，三次握⼿如下：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;客户端发送⼀个TCP的SYN&amp;#x3D;1，Seq&amp;#x3D;X的包到服务器端⼝&lt;/li&gt;
&lt;li&gt;服务器发回SYN&amp;#x3D;1， ACK&amp;#x3D;X+1， Seq&amp;#x3D;Y的响应包&lt;/li&gt;
&lt;li&gt;客户端发送ACK&amp;#x3D;Y+1， Seq&amp;#x3D;Z&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;TCP链接建⽴后发送HTTP请求&lt;/li&gt;
&lt;li&gt;服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使⽤HTTP Host头部判断请求的服务程序&lt;/li&gt;
&lt;li&gt;服务器检查HTTP请求头是否包含缓存验证信息如果验证缓存新鲜，返回304等对应状态码&lt;/li&gt;
&lt;li&gt;处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作&lt;/li&gt;
&lt;li&gt;服务器将响应报⽂通过TCP连接发送回浏览器&lt;/li&gt;
&lt;li&gt;浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重⽤，关闭TCP连接的四&lt;br&gt;次握⼿如下：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;主动⽅发送Fin&amp;#x3D;1， Ack&amp;#x3D;Z， Seq&amp;#x3D; X报⽂&lt;/li&gt;
&lt;li&gt;被动⽅发送ACK&amp;#x3D;X+1， Seq&amp;#x3D;Z报⽂&lt;/li&gt;
&lt;li&gt;被动⽅发送Fin&amp;#x3D;1， ACK&amp;#x3D;X， Seq&amp;#x3D;Y报⽂&lt;/li&gt;
&lt;li&gt;主动⽅发送ACK&amp;#x3D;Y， Seq&amp;#x3D;X报⽂&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;13&#34;&gt;
&lt;li&gt;浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同&lt;/li&gt;
&lt;li&gt;如果资源可缓存，进⾏缓存&lt;/li&gt;
&lt;li&gt;对响应进⾏解码（例如gzip压缩）&lt;/li&gt;
&lt;li&gt;根据资源类型决定如何处理（假设资源为HTML⽂档）&lt;/li&gt;
&lt;li&gt;解析HTML⽂档，构件DOM树，下载资源，构造CSSOM树，执⾏js脚本，这些操作没有严格的先后顺序，以下分别解释&lt;/li&gt;
&lt;li&gt;构建DOM树：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Tokenizing：根据HTML规范将字符流解析为标记&lt;/li&gt;
&lt;li&gt;Lexing：词法分析将标记转换为对象并定义属性和规则&lt;/li&gt;
&lt;li&gt;DOM construction：根据HTML标记关系将对象组成DOM树&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;19&#34;&gt;
&lt;li&gt;解析过程中遇到图⽚、样式表、js⽂件，启动下载&lt;/li&gt;
&lt;li&gt;构建CSSOM树：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Tokenizing：字符流转换为标记流&lt;/li&gt;
&lt;li&gt;Node：根据标记创建节点&lt;/li&gt;
&lt;li&gt;CSSOM：节点创建CSSOM树&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;21&#34;&gt;
&lt;li&gt;根据DOM树和CSSOM树构建渲染树 :&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;从DOM树的根节点遍历所有可⻅节点，不可⻅节点包括：1） script , meta 这样本身&lt;br&gt;不可⻅的标签。2)被css隐藏的节点，如 display: none&lt;/li&gt;
&lt;li&gt;对每⼀个可⻅节点，找到恰当的CSSOM规则并应⽤&lt;/li&gt;
&lt;li&gt;发布可视节点的内容和计算样式&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;22&#34;&gt;
&lt;li&gt;js解析如下：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;浏览器创建Document对象并解析HTML，将解析到的元素和⽂本节点添加到⽂档中，此&lt;br&gt;时document.readystate为loading&lt;/li&gt;
&lt;li&gt;HTML解析器遇到没有async和defer的script时，将他们添加到⽂档中，然后执⾏⾏内&lt;br&gt;或外部脚本。这些脚本会同步执⾏，并且在脚本下载和执⾏时解析器会暂停。这样就可&lt;br&gt;以⽤document.write()把⽂本插⼊到输⼊流中。同步脚本经常简单定义函数和注册事件&lt;br&gt;处理程序，他们可以遍历和操作script和他们之前的⽂档内容&lt;/li&gt;
&lt;li&gt;当解析器遇到设置了async属性的script时，开始下载脚本并继续解析⽂档。脚本会在它下载完成后尽快执⾏，但是解析器不会停下来等它下载。异步脚本禁使⽤document.write()，它们可以访问⾃⼰script和之前的⽂档元素&lt;/li&gt;
&lt;li&gt;当⽂档完成解析，document.readState变成interactive&lt;/li&gt;
&lt;li&gt;所有defer脚本会按照在⽂档出现的顺序执⾏，延迟脚本能访问完整⽂档树，禁⽌使⽤document.write()&lt;/li&gt;
&lt;li&gt;浏览器在Document对象上触发DOMContentLoaded事件&lt;/li&gt;
&lt;li&gt;此时⽂档完全解析完成，浏览器可能还在等待如图⽚等内容加载，等这些内容完成载⼊并且所有异步脚本完成载⼊和执⾏，document.readState变complete，window触发load事件&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;23&#34;&gt;
&lt;li&gt;显示⻚⾯（HTML解析过程中会逐步显示⻚⾯）&lt;/li&gt;
&lt;/ol&gt;
</content>
        <category term="前端开发" scheme="https://pink-png.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" />
        <category term="浏览器" scheme="https://pink-png.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E6%B5%8F%E8%A7%88%E5%99%A8/" />
        <category term="web综合问题" scheme="https://pink-png.github.io/tags/web%E7%BB%BC%E5%90%88%E9%97%AE%E9%A2%98/" />
        <updated>2021-06-25T08:43:00.000Z</updated>
    </entry>
</feed>
