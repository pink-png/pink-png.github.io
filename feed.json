{
    "version": "https://jsonfeed.org/version/1",
    "title": "死肥宅",
    "subtitle": "肥宅快乐水",
    "icon": "https://pink-png.github.io/images/favicon.ico",
    "description": "编程 & 生活",
    "home_page_url": "https://pink-png.github.io",
    "items": [
        {
            "id": "https://pink-png.github.io/performance-optimization/%E5%89%8D%E7%AB%AF%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/",
            "url": "https://pink-png.github.io/performance-optimization/%E5%89%8D%E7%AB%AF%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/",
            "title": "前端调试技巧",
            "date_published": "2023-12-04T03:41:00.000Z",
            "content_html": "<pre><code class=\"javascript\">1、网络 请求重新发送xhr \n2、修改请求参数： 复制-&gt;以fetch格式复制\n3、复制JavaScript变量：右键复制object、将object存储为全局变量\n4、$0 输出选中的第一个元素\n5、截屏：Ctrl+shift+p screen\n6、同时展开多级节点 选中元素，按住alt再点击7、$_ 上一个输出结果\n8、Ctrl +shift +p switch切换主题\n9、$$()选中所有匹配元素\n10、debugger\n</code></pre>\n",
            "tags": [
                "前端开发",
                "前端调试",
                "前端调试"
            ]
        },
        {
            "id": "https://pink-png.github.io/tool/git%E5%AD%A6%E4%B9%A0%E6%B8%85%E5%8D%95/",
            "url": "https://pink-png.github.io/tool/git%E5%AD%A6%E4%B9%A0%E6%B8%85%E5%8D%95/",
            "title": "git学习清单",
            "date_published": "2023-12-01T08:43:00.000Z",
            "content_html": "<h2 id=\"1-初始化本地仓库-git-init\"><a href=\"#1-初始化本地仓库-git-init\" class=\"headerlink\" title=\"1.初始化本地仓库  git init \"></a>1.初始化本地仓库  git init <directory></h2><h2 id=\"2-克隆一个远程仓库-git-clone\"><a href=\"#2-克隆一个远程仓库-git-clone\" class=\"headerlink\" title=\"2.克隆一个远程仓库  git clone \"></a>2.克隆一个远程仓库  git clone <url></h2><h2 id=\"3-添加文件到暂存区-git-add-要添加当前目录中的所有文件，请使用-代替-代码如下：-git-add\"><a href=\"#3-添加文件到暂存区-git-add-要添加当前目录中的所有文件，请使用-代替-代码如下：-git-add\" class=\"headerlink\" title=\"3.添加文件到暂存区 git add 要添加当前目录中的所有文件，请使用 . 代替,代码如下： git add .\"></a>3.添加文件到暂存区 git add <file>要添加当前目录中的所有文件，请使用 . 代替,代码如下： git add .</h2><h2 id=\"4-提交更改-git-commit-m-““如果要添加对跟踪文件所做的所有更改并提交。-git-commit-a-m-““-orgit-commit-am-““\"><a href=\"#4-提交更改-git-commit-m-““如果要添加对跟踪文件所做的所有更改并提交。-git-commit-a-m-““-orgit-commit-am-““\" class=\"headerlink\" title=\"4.提交更改 git commit -m ““如果要添加对跟踪文件所做的所有更改并提交。 git commit -a -m ““# orgit commit -am ““\"></a>4.提交更改 git commit -m “<message>“如果要添加对跟踪文件所做的所有更改并提交。 git commit -a -m “<message>“# orgit commit -am “<message>“</h2><h2 id=\"5-从暂存区删除一个文件-git-reset\"><a href=\"#5-从暂存区删除一个文件-git-reset\" class=\"headerlink\" title=\"5.从暂存区删除一个文件 git reset \"></a>5.从暂存区删除一个文件 git reset <file></h2><h2 id=\"6-移动或重命名文件-git-mv\"><a href=\"#6-移动或重命名文件-git-mv\" class=\"headerlink\" title=\"6.移动或重命名文件 git mv  \"></a>6.移动或重命名文件 git mv <current path> <new path></h2><h2 id=\"7-从存储库中删除文件-git-rm-您也可以仅使用-–cached-标志将其从暂存区中删除-git-rm-–cached\"><a href=\"#7-从存储库中删除文件-git-rm-您也可以仅使用-–cached-标志将其从暂存区中删除-git-rm-–cached\" class=\"headerlink\" title=\"7.从存储库中删除文件  git rm  您也可以仅使用 –cached 标志将其从暂存区中删除\t git rm –cached \"></a>7.从存储库中删除文件  git rm <file> 您也可以仅使用 –cached 标志将其从暂存区中删除\t git rm –cached <file></h2><h1 id=\"基本-Git-概念\"><a href=\"#基本-Git-概念\" class=\"headerlink\" title=\"基本 Git 概念\"></a>基本 Git 概念</h1><h2 id=\"8-默认分支名称：main\"><a href=\"#8-默认分支名称：main\" class=\"headerlink\" title=\"8.默认分支名称：main\"></a>8.默认分支名称：main</h2><h2 id=\"9-默认远程名称：origin\"><a href=\"#9-默认远程名称：origin\" class=\"headerlink\" title=\"9.默认远程名称：origin\"></a>9.默认远程名称：origin</h2><h2 id=\"10-当前分支参考：HEAD\"><a href=\"#10-当前分支参考：HEAD\" class=\"headerlink\" title=\"10.当前分支参考：HEAD\"></a>10.当前分支参考：HEAD</h2><h2 id=\"11-HEAD-的父级：HEAD-或-HEAD-1\"><a href=\"#11-HEAD-的父级：HEAD-或-HEAD-1\" class=\"headerlink\" title=\"11.HEAD 的父级：HEAD^ 或 HEAD~1\"></a>11.HEAD 的父级：HEAD^ 或 HEAD~1</h2><h2 id=\"12-HEAD-的祖父母：HEAD-或-HEAD-2\"><a href=\"#12-HEAD-的祖父母：HEAD-或-HEAD-2\" class=\"headerlink\" title=\"12.HEAD 的祖父母：HEAD^^ 或 HEAD~2\"></a>12.HEAD 的祖父母：HEAD^^ 或 HEAD~2</h2><h2 id=\"13-显示分支-git-branch-有用的标志：\"><a href=\"#13-显示分支-git-branch-有用的标志：\" class=\"headerlink\" title=\"13.显示分支 git branch  有用的标志：\"></a>13.显示分支 git branch  有用的标志：</h2><p>-a：显示所有分支（本地和远程）</p>\n<p>-r：显示远程分支</p>\n<p>-v：显示最后一次提交的分支</p>\n<h2 id=\"14-创建一个分支-git-branch-你可以创建一个分支并使用-checkout-命令切换到它。git-checkout-b\"><a href=\"#14-创建一个分支-git-branch-你可以创建一个分支并使用-checkout-命令切换到它。git-checkout-b\" class=\"headerlink\" title=\"14.创建一个分支 git branch   你可以创建一个分支并使用 checkout 命令切换到它。git checkout -b \"></a>14.创建一个分支 git branch <branch>  你可以创建一个分支并使用 checkout 命令切换到它。git checkout -b <branch></h2><h2 id=\"15-切换到一个分支-git-checkout\"><a href=\"#15-切换到一个分支-git-checkout\" class=\"headerlink\" title=\"15.切换到一个分支 git checkout \"></a>15.切换到一个分支 git checkout <branch></h2><h2 id=\"16-删除一个分支-git-branch-d-您还可以使用-D-标志强制删除分支。-git-branch-D\"><a href=\"#16-删除一个分支-git-branch-d-您还可以使用-D-标志强制删除分支。-git-branch-D\" class=\"headerlink\" title=\"16.删除一个分支 git branch -d  您还可以使用 -D 标志强制删除分支。 git branch -D \"></a>16.删除一个分支 git branch -d <branch> 您还可以使用 -D 标志强制删除分支。 git branch -D <branch></h2><h2 id=\"17-合并分支-git-merge-有用的标志：\"><a href=\"#17-合并分支-git-merge-有用的标志：\" class=\"headerlink\" title=\"17.合并分支 git merge  有用的标志：\"></a>17.合并分支 git merge <branch to merge into HEAD> 有用的标志：</h2><p>–no-ff：即使合并解析为快进，也创建合并提交</p>\n<p>–squash：将指定分支中的所有提交压缩为单个提交</p>\n<p>建议不要使用 –squash 标志，因为它会将所有提交压缩为单个提交，从而导致提交历史混乱。</p>\n<h2 id=\"18-变基分支-变基是将一系列提交移动或组合到新的基本提交的过程。git-rebase\"><a href=\"#18-变基分支-变基是将一系列提交移动或组合到新的基本提交的过程。git-rebase\" class=\"headerlink\" title=\"18.变基分支 变基是将一系列提交移动或组合到新的基本提交的过程。git rebase \"></a>18.变基分支 变基是将一系列提交移动或组合到新的基本提交的过程。git rebase <branch to rebase from></h2><h2 id=\"19-查看之前的提交-git-checkout\"><a href=\"#19-查看之前的提交-git-checkout\" class=\"headerlink\" title=\"19.查看之前的提交 git checkout \"></a>19.查看之前的提交 git checkout <commit id></h2><h2 id=\"20-恢复提交-git-revert\"><a href=\"#20-恢复提交-git-revert\" class=\"headerlink\" title=\"20.恢复提交 git revert \"></a>20.恢复提交 git revert <commit id></h2><h2 id=\"21-重置提交-git-reset-您还可以添加-–hard-标志来删除所有更改，但请谨慎使用。-git-reset-–hard\"><a href=\"#21-重置提交-git-reset-您还可以添加-–hard-标志来删除所有更改，但请谨慎使用。-git-reset-–hard\" class=\"headerlink\" title=\"21.重置提交 git reset  您还可以添加 –hard 标志来删除所有更改，但请谨慎使用。 git reset –hard \"></a>21.重置提交 git reset <commit id> 您还可以添加 –hard 标志来删除所有更改，但请谨慎使用。 git reset –hard <commit id></h2><h2 id=\"22-查看存储库的状态-git-status\"><a href=\"#22-查看存储库的状态-git-status\" class=\"headerlink\" title=\"22.查看存储库的状态 git status\"></a>22.查看存储库的状态 git status</h2><h2 id=\"23-显示提交历史-git-log\"><a href=\"#23-显示提交历史-git-log\" class=\"headerlink\" title=\"23.显示提交历史 git log\"></a>23.显示提交历史 git log</h2><h2 id=\"24-显示对未暂存文件的更改-git-diff-您还可以使用-–staged-标志来显示对暂存文件的更改。-git-diff-–staged\"><a href=\"#24-显示对未暂存文件的更改-git-diff-您还可以使用-–staged-标志来显示对暂存文件的更改。-git-diff-–staged\" class=\"headerlink\" title=\"24.显示对未暂存文件的更改 git diff\\  您还可以使用 –staged 标志来显示对暂存文件的更改。 git diff –staged\"></a>24.显示对未暂存文件的更改 git diff\\  您还可以使用 –staged 标志来显示对暂存文件的更改。 git diff –staged</h2><h2 id=\"25-显示两次提交之间的变化-git-diff-lt-commit-id-01-gt-lt-commit-id-02-gt\"><a href=\"#25-显示两次提交之间的变化-git-diff-lt-commit-id-01-gt-lt-commit-id-02-gt\" class=\"headerlink\" title=\"25.显示两次提交之间的变化 git diff &lt;commit id 01&gt; &lt;commit id 02&gt;\"></a>25.显示两次提交之间的变化 git diff &lt;commit id 01&gt; &lt;commit id 02&gt;</h2><h2 id=\"26-存储更改-stash-允许您在不提交更改的情况下临时存储更改。-git-stash-您还可以将消息添加到存储中。-git-stash-save-““\"><a href=\"#26-存储更改-stash-允许您在不提交更改的情况下临时存储更改。-git-stash-您还可以将消息添加到存储中。-git-stash-save-““\" class=\"headerlink\" title=\"26.存储更改 stash 允许您在不提交更改的情况下临时存储更改。 git stash  您还可以将消息添加到存储中。 git stash save ““\"></a>26.存储更改 stash 允许您在不提交更改的情况下临时存储更改。 git stash  您还可以将消息添加到存储中。 git stash save “<message>“</h2><h2 id=\"27-列出存储-git-stash-list\"><a href=\"#27-列出存储-git-stash-list\" class=\"headerlink\" title=\"27.列出存储 git stash list\"></a>27.列出存储 git stash list</h2><h2 id=\"28-申请一个藏匿处-应用存储不会将其从存储列表中删除。-git-stash-apply-如果不指定，将应用最新的-stash（适用于所有类似的-stash-命令）-您还可以使用格式-stash-应用存储（适用于所有类似的存储命令）-git-stash-apply-stash-0\"><a href=\"#28-申请一个藏匿处-应用存储不会将其从存储列表中删除。-git-stash-apply-如果不指定，将应用最新的-stash（适用于所有类似的-stash-命令）-您还可以使用格式-stash-应用存储（适用于所有类似的存储命令）-git-stash-apply-stash-0\" class=\"headerlink\" title=\"28.申请一个藏匿处 应用存储不会将其从存储列表中删除。 git stash apply  如果不指定，将应用最新的 stash（适用于所有类似的 stash 命令） 您还可以使用格式 stash@{} 应用存储（适用于所有类似的存储命令） git stash apply stash@{0}\"></a>28.申请一个藏匿处 应用存储不会将其从存储列表中删除。 git stash apply <stash id> 如果不指定，将应用最新的 stash（适用于所有类似的 stash 命令） 您还可以使用格式 stash@{} 应用存储（适用于所有类似的存储命令） git stash apply stash@{0}</h2><h2 id=\"29-删除一个藏匿处-git-stash-drop\"><a href=\"#29-删除一个藏匿处-git-stash-drop\" class=\"headerlink\" title=\"29.删除一个藏匿处 git stash drop \"></a>29.删除一个藏匿处 git stash drop <stash id></h2><h2 id=\"30-删除所有藏匿处-git-stash-clear\"><a href=\"#30-删除所有藏匿处-git-stash-clear\" class=\"headerlink\" title=\"30.删除所有藏匿处 git stash clear\"></a>30.删除所有藏匿处 git stash clear</h2><h2 id=\"31-应用和删除存储-git-stash-pop\"><a href=\"#31-应用和删除存储-git-stash-pop\" class=\"headerlink\" title=\"31.应用和删除存储 git stash pop \"></a>31.应用和删除存储 git stash pop <stash id></h2><h2 id=\"32-显示存储中的更改-git-stash-show\"><a href=\"#32-显示存储中的更改-git-stash-show\" class=\"headerlink\" title=\"32.显示存储中的更改 git stash show \"></a>32.显示存储中的更改 git stash show <stash id></h2><h2 id=\"33-添加远程仓库-git-remote-add\"><a href=\"#33-添加远程仓库-git-remote-add\" class=\"headerlink\" title=\"33.添加远程仓库 git remote add  \"></a>33.添加远程仓库 git remote add <remote name> <url></h2><h2 id=\"34-显示远程仓库-git-remote-添加-v-标志以显示远程存储库的-URL。-git-remote-v\"><a href=\"#34-显示远程仓库-git-remote-添加-v-标志以显示远程存储库的-URL。-git-remote-v\" class=\"headerlink\" title=\"34.显示远程仓库 git remote 添加 -v 标志以显示远程存储库的 URL。 git remote -v\"></a>34.显示远程仓库 git remote 添加 -v 标志以显示远程存储库的 URL。 git remote -v</h2><h2 id=\"35-删除远程仓库-git-remote-remove\"><a href=\"#35-删除远程仓库-git-remote-remove\" class=\"headerlink\" title=\"35.删除远程仓库 git remote remove \"></a>35.删除远程仓库 git remote remove <remote name></h2><h2 id=\"36-重命名远程存储库-git-remote-rename\"><a href=\"#36-重命名远程存储库-git-remote-rename\" class=\"headerlink\" title=\"36.重命名远程存储库 git remote rename  \"></a>36.重命名远程存储库 git remote rename <old name> <new name></h2><h2 id=\"37-从远程存储库中获取更改-git-fetch\"><a href=\"#37-从远程存储库中获取更改-git-fetch\" class=\"headerlink\" title=\"37.从远程存储库中获取更改 git fetch \"></a>37.从远程存储库中获取更改 git fetch <remote name></h2><h2 id=\"38-从特定分支获取更改-git-fetch\"><a href=\"#38-从特定分支获取更改-git-fetch\" class=\"headerlink\" title=\"38.从特定分支获取更改 git fetch  \"></a>38.从特定分支获取更改 git fetch <remote name> <branch></h2><h2 id=\"39-从远程存储库中拉取更改-git-pull\"><a href=\"#39-从远程存储库中拉取更改-git-pull\" class=\"headerlink\" title=\"39.从远程存储库中拉取更改 git pull  \"></a>39.从远程存储库中拉取更改 git pull <remote name> <branch></h2><h2 id=\"40-将更改推送到远程存储库-git-push\"><a href=\"#40-将更改推送到远程存储库-git-push\" class=\"headerlink\" title=\"40.将更改推送到远程存储库 git push \"></a>40.将更改推送到远程存储库 git push <remote name></h2><h2 id=\"41-将更改推送到特定分支-git-push\"><a href=\"#41-将更改推送到特定分支-git-push\" class=\"headerlink\" title=\"41.将更改推送到特定分支 git push  \"></a>41.将更改推送到特定分支 git push <remote name> <branch></h2>",
            "tags": [
                "版本管理",
                "git",
                "版本管理"
            ]
        },
        {
            "id": "https://pink-png.github.io/tool/%E4%B8%8B%E8%BD%BD%E7%B1%BB/",
            "url": "https://pink-png.github.io/tool/%E4%B8%8B%E8%BD%BD%E7%B1%BB/",
            "title": "下载",
            "date_published": "2023-12-01T08:43:00.000Z",
            "content_html": "<h1 id=\"xshell-下载地址\"><a href=\"#xshell-下载地址\" class=\"headerlink\" title=\"xshell 下载地址\"></a>xshell 下载地址</h1><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueHNoZWxsLmNvbS96aC9mcmVlLWZvci1ob21lLXNjaG9vbC8=\">https://www.xshell.com/zh/free-for-home-school/</span> </p>\n",
            "tags": [
                "下载",
                "xshell",
                "xshell"
            ]
        },
        {
            "id": "https://pink-png.github.io/js-base/jsES6-ES13%E6%96%B0%E5%A2%9E%E7%9A%84%E5%8A%9F%E8%83%BD/",
            "url": "https://pink-png.github.io/js-base/jsES6-ES13%E6%96%B0%E5%A2%9E%E7%9A%84%E5%8A%9F%E8%83%BD/",
            "title": "ES6-ES13新增的特性",
            "date_published": "2022-10-25T08:43:00.000Z",
            "content_html": "<h1 id=\"ES6（ES2015）\"><a href=\"#ES6（ES2015）\" class=\"headerlink\" title=\"ES6（ES2015）\"></a>ES6（ES2015）</h1><pre><code class=\"text\">块级作用域变量声明（let和const）\n箭头函数\n模板字面量\n解构赋值\n默认参数值\n扩展运算符和剩余参数\n类和模块化（class和import/export）\nPromise 对象\n迭代器和生成器（Iterator和Generator）\n新的集合类型（Map、Set、WeakMap、WeakSet）\n</code></pre>\n<h1 id=\"ES7（ES2016）\"><a href=\"#ES7（ES2016）\" class=\"headerlink\" title=\"ES7（ES2016）\"></a>ES7（ES2016）</h1><pre><code class=\"text\">Array.prototype.includes 方法\n指数操作符（**）\n</code></pre>\n<h1 id=\"ES8-ES2017\"><a href=\"#ES8-ES2017\" class=\"headerlink\" title=\"ES8 (ES2017)\"></a>ES8 (ES2017)</h1><pre><code class=\"text\">异步函数（async/await）\nObject.values 和 Object.entries 方法\n字符串填充方法（padStart和padEnd）\n</code></pre>\n<h1 id=\"ES9-ES2018\"><a href=\"#ES9-ES2018\" class=\"headerlink\" title=\"ES9 (ES2018)\"></a>ES9 (ES2018)</h1><pre><code class=\"text\">异步迭代器\nPromise.prototype.finally 方法\nRest/Spread 属性\n</code></pre>\n<h1 id=\"ES10-ES2019\"><a href=\"#ES10-ES2019\" class=\"headerlink\" title=\"ES10 (ES2019)\"></a>ES10 (ES2019)</h1><pre><code class=\"text\">Array.prototype.flat 和 Array.prototype.flatMap 方法\nOptional Chaining （可选链操作符 ?.）\n空值合并运算符（??）\n</code></pre>\n<h1 id=\"ES11-ES2020\"><a href=\"#ES11-ES2020\" class=\"headerlink\" title=\"ES11 (ES2020)\"></a>ES11 (ES2020)</h1><pre><code class=\"text\">BigInt 类型\n动态导入（import()）\n可选的捕获绑定（Optional catch binding）\nPromise.allSettled 方法\nString.prototype.matchAll 方法\n全局对象 globalThis\n</code></pre>\n<h1 id=\"ES12-ES2021\"><a href=\"#ES12-ES2021\" class=\"headerlink\" title=\"ES12 (ES2021)\"></a>ES12 (ES2021)</h1><pre><code class=\"text\">逻辑赋值运算符（||=、&amp;&amp;=、??=）\nString.prototype.replaceAll 方法\nPromise.any 方法\n私有字段和方法（# 开头）\n数字分隔符（Number separator）\n</code></pre>\n<h1 id=\"ES13-ES2022\"><a href=\"#ES13-ES2022\" class=\"headerlink\" title=\"ES13 (ES2022)\"></a>ES13 (ES2022)</h1><pre><code class=\"text\">导入.meta对象\n字符串实例方法String.prototype.&#123;trimLeft, trimRight&#125;\n异步迭代器的for-await-of支持\nimport()的顶级动态引入\n更宽松的模板字面量转义\n</code></pre>\n",
            "tags": [
                "前端开发",
                "Javascript",
                "Javascript"
            ]
        },
        {
            "id": "https://pink-png.github.io/js-base/js%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/",
            "url": "https://pink-png.github.io/js-base/js%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/",
            "title": "javascript全局函数和全局变量",
            "date_published": "2022-10-25T08:43:00.000Z",
            "content_html": "<ol>\n<li>全局变量</li>\n</ol>\n<ul>\n<li>Infinity 代表正的⽆穷⼤的数值。</li>\n<li>NaN 指示某个值是不是数字值。</li>\n<li>undefined 指示未定义的值。</li>\n</ul>\n<ol start=\"2\">\n<li>全局函数</li>\n</ol>\n<ul>\n<li>decodeURI() 解码某个编码的 URI 。</li>\n<li>decodeURIComponent() 解码⼀个编码的 URI 组件。</li>\n<li>encodeURI() 把字符串编码为 URI。</li>\n<li>encodeURIComponent() 把字符串编码为 URI 组件。</li>\n<li>escape() 对字符串进⾏编码。</li>\n<li>eval() 计算 JavaScript 字符串，并把它作为脚本代码来执⾏。</li>\n<li>isFinite() 检查某个值是否为有穷⼤的数。</li>\n<li>isNaN() 检查某个值是否是数字。</li>\n<li>Number() 把对象的值转换为数字。</li>\n<li>parseFloat() 解析⼀个字符串并返回⼀个浮点数。</li>\n<li>parseInt() 解析⼀个字符串并返回⼀个整数。</li>\n<li>String() 把对象的值转换为字符串。</li>\n<li>unescape() 对由 escape() 编码的字符串进⾏解码</li>\n</ul>\n",
            "tags": [
                "前端开发",
                "Javascript",
                "Javascript"
            ]
        },
        {
            "id": "https://pink-png.github.io/js-base/js%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F/",
            "url": "https://pink-png.github.io/js-base/js%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F/",
            "title": "js创建对象的多种方式",
            "date_published": "2022-10-25T08:43:00.000Z",
            "content_html": "<pre><code class=\"javascript\">1. 对象字面量（Object Literal）：使用对象字面量可以直接创建一个简单的对象。对象字面量使用花括号 &#123;&#125; 包裹，并在其中定义键值对。\n\nconst person = &#123;\n  name: &#39;John&#39;,\n  age: 30,\n  sayHello: function() &#123;\n    console.log(&#39;Hello!&#39;);\n  &#125;\n&#125;;\n\n\n优点：简洁、直观，适合创建简单的对象。\n缺点：无法实现对象的复用，每次创建对象时都需要重新定义属性和方法。\n</code></pre>\n<pre><code class=\"javascript\">2. 构造函数（Constructor）：通过构造函数可以创建一个对象的实例。构造函数使用 new 操作符来调用，并在内部使用 this 关键字来引用新创建的对象。\nfunction Person(name, age) &#123;\n  this.name = name;\n  this.age = age;\n  this.sayHello = function() &#123;\n    console.log(&#39;Hello!&#39;);\n  &#125;;\n&#125;\n\nconst person = new Person(&#39;John&#39;, 30);\n\n优点：可以通过 new 操作符创建对象的实例，适合创建多个相似的对象。\n缺点：每个对象实例都会拥有独立的方法，占用额外的内存空间。创建大量对象时可能造成内存浪费。\n</code></pre>\n<pre><code class=\"javascript\">3. 原型链继承（Prototype Chain Inheritance）：使用原型链可以实现对象的继承。可以通过给构造函数的原型对象添加属性和方法，使所有通过该构造函数创建的对象都可以共享这些属性和方法。\nfunction Person(name, age) &#123;\n  this.name = name;\n  this.age = age;\n&#125;\n\nPerson.prototype.sayHello = function() &#123;\n  console.log(&#39;Hello!&#39;);\n&#125;;\n\nconst person = new Person(&#39;John&#39;, 30);\n\n优点：可以实现对象的属性和方法的共享，减少内存占用。适合创建多个具有相同属性和方法的对象。\n缺点：所有实例共享原型对象上的属性和方法，如果对原型对象进行修改，会影响所有实例。不能传递参数给构造函数。\n</code></pre>\n<pre><code class=\"javascript\">4. ES6 的类（Class）：ES6 引入了类的概念，可以使用 class 关键字来定义一个类，并通过 new 操作符创建类的实例。\nclass Person &#123;\n  constructor(name, age) &#123;\n    this.name = name;\n    this.age = age;\n  &#125;\n  \n  sayHello() &#123;\n    console.log(&#39;Hello!&#39;);\n  &#125;\n&#125;\n\nconst person = new Person(&#39;John&#39;, 30);\n\n优点：语法更加直观、易读，符合面向对象的编程习惯。支持继承、封装和多态等特性。\n缺点：在底层仍然使用原型链来实现，因此也存在原型链继承的一些问题，如共享方法造成的潜在风险。\n</code></pre>\n",
            "tags": [
                "前端开发",
                "Javascript",
                "Javascript"
            ]
        },
        {
            "id": "https://pink-png.github.io/js-base/js%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/",
            "url": "https://pink-png.github.io/js-base/js%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/",
            "title": "数组去重方法总结",
            "date_published": "2022-10-25T08:43:00.000Z",
            "content_html": "<h1 id=\"借助ES6提供的Set结构-new-Set-简单好用-强烈推荐\"><a href=\"#借助ES6提供的Set结构-new-Set-简单好用-强烈推荐\" class=\"headerlink\" title=\"借助ES6提供的Set结构 new Set() 简单好用 强烈推荐\"></a>借助ES6提供的Set结构 new Set() 简单好用 强烈推荐</h1><pre><code class=\"javascript\">使用 Set 数据结构：将数组转换为 Set，然后再将 Set 转回数组。\n var arr = [1,9,8,8,7,7];\n  function noRepeat(arr)&#123;\n    var newArr = [...new Set(arr)]; //利用了Set结构不能接收重复数据的特点\n    return newArr\n  &#125;\n  var arr2 = noRepeat(arr) \n</code></pre>\n<h1 id=\"利用-filter-indexOf-去重\"><a href=\"#利用-filter-indexOf-去重\" class=\"headerlink\" title=\"利用 filter() +  indexOf() 去重\"></a>利用 filter() +  indexOf() 去重</h1><pre><code class=\"javascript\">filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。item是当前元素的值，index是当前元素的索引值。indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。利用indexOf() 查询到数组的下标，看是否等于当前的下标，相等的话就返回，否则不返回值\n\nvar arr = [&#39;apple&#39;,&#39;apps&#39;,&#39;pear&#39;,&#39;apple&#39;,&#39;orange&#39;,&#39;apps&#39;];  \n  var newArr = arr.filter(function(item,index)&#123;\n     return arr.indexOf(item) === index;  // 因为indexOf 只能查找到第一个  \n  &#125;);\n</code></pre>\n<h1 id=\"利用for-循环-搭配-indexOf-去重\"><a href=\"#利用for-循环-搭配-indexOf-去重\" class=\"headerlink\" title=\"利用for 循环 搭配 indexOf 去重\"></a>利用for 循环 搭配 indexOf 去重</h1><pre><code class=\"javascript\"> var arr = [1,9,8,8,7,7];\n function noRepeat(arr) &#123;\n        var newArr=[]; \n        for(var i=0;i&lt;arr.length;i++) &#123;\n          if(newArr.indexOf(arr[i]) === -1) &#123;\n             newArr.push(arr[i]);\n          &#125;\n        &#125;\n    return newArr\n  &#125;\n  var arr2 = noRepeat(arr);\n</code></pre>\n<h1 id=\"将数组的每一个元素依次与其他元素做比较，发现重复元素，删除-比较繁琐-不推荐\"><a href=\"#将数组的每一个元素依次与其他元素做比较，发现重复元素，删除-比较繁琐-不推荐\" class=\"headerlink\" title=\"将数组的每一个元素依次与其他元素做比较，发现重复元素，删除 比较繁琐 不推荐\"></a>将数组的每一个元素依次与其他元素做比较，发现重复元素，删除 比较繁琐 不推荐</h1><pre><code class=\"javascript\">var arr = [1,9,8,8,7,7];\n function noRepeat(arr) &#123;\n        for(var i = 0; i &lt; arr.length-1; i++)&#123;\n            for(var j = i+1; j &lt; arr.length; j++)&#123;\n                if(arr[i]===arr[j])&#123;\n                    arr.splice(j,1);\n                    j--;\n                &#125;\n            &#125;\n        &#125;\n        return arr;\n &#125;\n var arr2 = noRepeat(arr);\n</code></pre>\n<h1 id=\"借助新数组-通过-indexOf-方法判断当前元素在数组中的索引，如果与循环的下标相等则添加到新数组中\"><a href=\"#借助新数组-通过-indexOf-方法判断当前元素在数组中的索引，如果与循环的下标相等则添加到新数组中\" class=\"headerlink\" title=\"借助新数组 通过 indexOf 方法判断当前元素在数组中的索引，如果与循环的下标相等则添加到新数组中\"></a>借助新数组 通过 indexOf 方法判断当前元素在数组中的索引，如果与循环的下标相等则添加到新数组中</h1><pre><code class=\"javascript\"> var arr = [1,9,8,8,7,7];\n    function noRepeat(arr) &#123;\n        var newArr = [];\n        for (var i = 0; i &lt; arr.length; i++) &#123;\n            if (arr.indexOf(arr[i]) == i) &#123;\n              newArr.push(arr[i]);\n            &#125;\n        &#125;\n        return newArr;\n    &#125;\n   var arr2 = noRepeat(arr); \n</code></pre>\n<h1 id=\"利用双重for循环\"><a href=\"#利用双重for循环\" class=\"headerlink\" title=\"利用双重for循环\"></a>利用双重for循环</h1><pre><code class=\"javascript\">var arr = [1,9,8,8,7,7];  \nfunction noRepeat(arr)&#123;\n   for (var i = 0; i &lt; arr.length; i++) &#123;\n       for (var j = 0; j &lt; arr.length; j++) &#123;\n           if (arr[i] == arr[j] &amp;&amp; i != j) &#123;\n              arr.splice(j, 1);\n            &#125;\n       &#125;\n    &#125;\n    return arr;\n&#125;\nvar arr2  = noRepeat(arr);\n</code></pre>\n<h1 id=\"利用includes实现数组去重\"><a href=\"#利用includes实现数组去重\" class=\"headerlink\" title=\"利用includes实现数组去重\"></a>利用includes实现数组去重</h1><pre><code class=\"javascript\"> var arr = [1,9,8,8,7,7];\n    function noRepeat(arr) &#123;\n      let newArr = [];\n      for(i=0; i&lt;arr.length; i++)&#123;\n        if(!newArr.includes(arr[i]))&#123;\n            newArr.push(arr[i])\n        &#125;\n      &#125;\n     return newArr\n   &#125;\n</code></pre>\n<h1 id=\"利⽤-reduce-includes\"><a href=\"#利⽤-reduce-includes\" class=\"headerlink\" title=\"利⽤ reduce + includes\"></a>利⽤ reduce + includes</h1><pre><code class=\"javascript\">  const res = arr.reduce((prev, cur) =&gt; &#123;\n      if(!prev.includes(cur))&#123;\n          prev.push(cur)\n      &#125;\n      return prev\n  &#125;, [])\n\n  优化后\n function unique(arr) &#123;\n    return arr.reduce((prev, cur) =&gt; prev.includes(cur) ? prev : [...prev, cur])\n  &#125;\n</code></pre>\n<h1 id=\"利⽤Map数据结构去重\"><a href=\"#利⽤Map数据结构去重\" class=\"headerlink\" title=\"利⽤Map数据结构去重\"></a>利⽤Map数据结构去重</h1><pre><code class=\"javascript\"> function arrayNonRepeatfy(arr) &#123;\n    let map = new Map();\n    let array = new Array(); // 数组⽤于返回结果\n    for (let i = 0; i &lt; arr.length; i++) &#123;\n        if (map.has(arr[i])) &#123; // 如果有该key值\n            map.set(arr[i], true);\n        &#125; else &#123;\n            map.set(arr[i], false); // 如果没有该key值\n            array.push(arr[i]);\n        &#125;\n    &#125;\n    return array;\n&#125;\n</code></pre>\n<h1 id=\"利⽤递归去重\"><a href=\"#利⽤递归去重\" class=\"headerlink\" title=\"利⽤递归去重\"></a>利⽤递归去重</h1><pre><code class=\"javascript\"> function unique(arr) &#123;\n      var array = arr;\n      var len = array.length;\n      array.sort(function (a, b) &#123; //排序后更加⽅便去重\n          return a - b;\n      &#125;)\n      function loop(index) &#123;\n          if (index &gt;= 1) &#123;\n              if (array[index] === array[index - 1]) &#123;\n                  array.splice(index, 1);\n              &#125;\n              loop(index - 1); //递归loop，然后数组去重\n          &#125;\n      &#125;\n      loop(len - 1);\n      return array;\n  &#125;\n</code></pre>\n<h1 id=\"利⽤hasOwnProperty-filter\"><a href=\"#利⽤hasOwnProperty-filter\" class=\"headerlink\" title=\"利⽤hasOwnProperty + filter\"></a>利⽤hasOwnProperty + filter</h1><pre><code class=\"javascript\">function unique(arr) &#123;\n    var obj = &#123;&#125;;\n    return arr.filter(function (item, index, arr) &#123;\n        return obj.hasOwnProperty(typeof item + item) ? false : (obj[typeof item + item] = true);\n    &#125;);\n&#125;\n</code></pre>\n<h1 id=\"利⽤对象的属性不能相同的特点进⾏去重\"><a href=\"#利⽤对象的属性不能相同的特点进⾏去重\" class=\"headerlink\" title=\"利⽤对象的属性不能相同的特点进⾏去重\"></a>利⽤对象的属性不能相同的特点进⾏去重</h1><pre><code class=\"javascript\">function unique(arr) &#123;\n      if (!Array.isArray(arr)) &#123;\n          console.log(&#39;type error!&#39;)\n          return\n      &#125;\n      var arrry = [];\n      var obj = &#123;&#125;;\n      for (var i = 0; i &lt; arr.length; i++) &#123;\n          if (!obj[arr[i]]) &#123;\n              arrry.push(arr[i])\n              obj[arr[i]] = 1\n          &#125; else &#123;\n              obj[arr[i]]++\n          &#125;\n      &#125;\n      return arrry;\n  &#125;\n</code></pre>\n",
            "tags": [
                "前端开发",
                "Javascript",
                "Javascript"
            ]
        },
        {
            "id": "https://pink-png.github.io/js-base/js%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/",
            "url": "https://pink-png.github.io/js-base/js%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/",
            "title": "js 实现异步编程",
            "date_published": "2022-10-25T08:43:00.000Z",
            "content_html": "<ol>\n<li>回调函数（Callbacks）：在异步操作完成后，通过传递一个回调函数作为参数，在异步操作结束时调用该回调函数来处理结果。</li>\n</ol>\n<pre><code class=\"Javascript\">function asyncOperation(callback) &#123;\n  // 模拟异步操作\n  setTimeout(function() &#123;\n    const result = &#39;Async operation completed&#39;;\n    callback(result);\n  &#125;, 1000);\n&#125;\n\nasyncOperation(function(result) &#123;\n  console.log(result);\n&#125;);\n\n优点：简单、容易理解\n缺点：不利于维护，代码耦合⾼\n</code></pre>\n<ol start=\"2\">\n<li>Promise：Promise 是一种在 ES6 中引入的异步编程模式。它代表一个异步操作最终的完成或失败，并提供了处理结果的方法。</li>\n</ol>\n<pre><code class=\"Javascript\">function asyncOperation() &#123;\n  return new Promise(function(resolve, reject) &#123;\n    // 模拟异步操作\n    setTimeout(function() &#123;\n      const result = &#39;Async operation completed&#39;;\n      resolve(result); // 异步操作成功\n      // 或者使用 reject(new Error(&#39;Async operation failed&#39;)); 处理异步操作失败\n    &#125;, 1000);\n  &#125;);\n&#125;\n\nasyncOperation()\n  .then(function(result) &#123;\n    console.log(result);\n  &#125;)\n  .catch(function(error) &#123;\n    console.error(error);\n  &#125;);\n\n优点：可以利⽤then⽅法，进⾏链式写法；可以书写错误时的回调函数；\n缺点：编写和理解，相对⽐较难\n</code></pre>\n<ol start=\"3\">\n<li>async&#x2F;await：async&#x2F;await 是在 ES2017 中引入的异步编程语法糖，基于 Promise，让异步代码看起来像同步代码一样。</li>\n</ol>\n<pre><code class=\"Javascript\">function asyncOperation() &#123;\n  return new Promise(function(resolve, reject) &#123;\n    // 模拟异步操作\n    setTimeout(function() &#123;\n      const result = &#39;Async operation completed&#39;;\n      resolve(result); // 异步操作成功\n      // 或者使用 reject(new Error(&#39;Async operation failed&#39;)); 处理异步操作失败\n    &#125;, 1000);\n  &#125;);\n&#125;\nasync function processData() &#123;\n  try &#123;\n    const result = await asyncOperation();\n    console.log(result);\n  &#125; catch (error) &#123;\n    console.error(error);\n  &#125;\n&#125;\n\nprocessData();\n优点：内置执⾏器、更好的语义、更⼴的适⽤性、返回的是Promise、结构清晰。\n缺点：错误处理机制\n</code></pre>\n<ol start=\"4\">\n<li>事件监听（Event Listening）：事件监听是一种基于观察者模式的编程方式。通过注册事件监听器，当特定事件发生时，会触发相应的回调函数。</li>\n</ol>\n<pre><code class=\"Javascript\">// 定义一个事件触发器\nconst eventEmitter = new EventEmitter();\n\n// 注册事件监听器\neventEmitter.on(&#39;event&#39;, function(data) &#123;\n  console.log(&#39;Event triggered:&#39;, data);\n&#125;);\n\n// 触发事件\neventEmitter.emit(&#39;event&#39;, &#39;Some data&#39;);\n\n优点：容易理解，可以绑定多个事件，每个事件可以指定多个回调函数\n缺点：事件驱动型，流程不够清晰\n</code></pre>\n<ol start=\"5\">\n<li>发布&#x2F;订阅（Publish&#x2F;Subscribe）：发布&#x2F;订阅也是一种基于观察者模式的编程方式，其中发布者（发布消息的对象）和订阅者（接收消息的对象）之间是松耦合的关系。</li>\n</ol>\n<pre><code class=\"Javascript\">// 创建一个发布者\nconst publisher = new Publisher();\n\n// 创建一个订阅者并订阅消息\nconst subscriber1 = new Subscriber(&#39;Subscriber 1&#39;);\npublisher.subscribe(subscriber1);\n\n// 创建另一个订阅者并订阅消息\nconst subscriber2 = new Subscriber(&#39;Subscriber 2&#39;);\npublisher.subscribe(subscriber2);\n\n// 发布消息\npublisher.publish(&#39;Some message&#39;);\n\n类似于事件监听，但是可以通过‘消息中⼼ʼ，了解现在有多少发布者，多少订阅者\n</code></pre>\n<ol start=\"5\">\n<li>Generator函数</li>\n</ol>\n<pre><code class=\"javascript\">function* myGeneratorFunction() &#123;\n  try &#123;\n    const result = yield new Promise((resolve, reject) =&gt; &#123;\n      setTimeout(() =&gt; &#123;\n        resolve(&#39;Async operation completed.&#39;);\n      &#125;, 2000);\n    &#125;);\n    console.log(result);\n  &#125; catch (error) &#123;\n    console.error(error);\n  &#125;\n&#125;\n\nfunction runGenerator(generator) &#123;\n  const iterator = generator();\n\n  function iterate(&#123; value, done &#125;) &#123;\n    if (done) &#123;\n      return;\n    &#125;\n\n    if (value instanceof Promise) &#123;\n      value.then(\n        (result) =&gt; &#123;\n          iterate(iterator.next(result));\n        &#125;,\n        (error) =&gt; &#123;\n          iterate(iterator.throw(error));\n        &#125;\n      );\n    &#125; else &#123;\n      iterate(iterator.next(value));\n    &#125;\n  &#125;\n\n  iterate(iterator.next());\n&#125;\n\nrunGenerator(myGeneratorFunction);\n\n\n优点：函数体内外的数据交换、错误处理机制\n缺点：流程管理不⽅便\n</code></pre>\n",
            "tags": [
                "前端开发",
                "Javascript",
                "Javascript"
            ]
        },
        {
            "id": "https://pink-png.github.io/js-base/js%E6%B5%85%E8%B0%88new%20this/",
            "url": "https://pink-png.github.io/js-base/js%E6%B5%85%E8%B0%88new%20this/",
            "title": "浅谈js中new this 关键字",
            "date_published": "2022-10-25T08:43:00.000Z",
            "content_html": "<h1 id=\"new操作符具体干了什么\"><a href=\"#new操作符具体干了什么\" class=\"headerlink\" title=\"new操作符具体干了什么\"></a>new操作符具体干了什么</h1><pre><code class=\"text\">1. 创建一个新的空对象。\n2. 将新对象的原型链（[[Prototype]]）链接到构造函数的 prototype 属性上，使新对象能够访问构造函数原型中定义的属性和方法。\n3. 将构造函数的作用域赋值给新对象，即将新对象的 this 绑定到构造函数上，使构造函数内部的代码能够访问和操作新对象的属性。\n4. 执行构造函数内部的代码，初始化新对象的属性和方法。\n5. 如果构造函数返回了一个非空对象，则返回该对象；否则，返回新创建的对象。\n</code></pre>\n<h1 id=\"new的模拟实现\"><a href=\"#new的模拟实现\" class=\"headerlink\" title=\"new的模拟实现\"></a>new的模拟实现</h1><pre><code class=\"javascript\">function myNew(constructor, ...args) &#123;\n  // 1. 在内存中创建一个新对象\n  const obj = &#123;&#125;;\n\n  // 2. 将新对象的原型设置为构造函数的 prototype 属性\n  Object.setPrototypeOf(obj, constructor.prototype);\n\n  // 3. 将构造函数内部的 this 绑定到新对象\n  const result = constructor.apply(obj, args);\n\n  // 4. 执行构造函数内部的代码后，如果返回非空对象则返回该对象，否则返回新对象\n  return result instanceof Object ? result : obj;\n&#125;\n</code></pre>\n<p>上述代码中，myNew 函数接受构造函数和参数，模拟了 new 操作符的行为。它会创建一个新对象 obj，将该对象的原型设置为构造函数的 prototype 属性，然后将构造函数内部的 this 绑定到新对象 obj 上，最后根据构造函数的返回结果决定返回值。</p>\n<p>需要注意的是，这只是一个简化的实现，并没有考虑 new 操作符的所有细节和复杂性，如原型链继承、构造函数返回非对象值时的处理等。在实际开发中，建议优先使用原生的 new 操作符。</p>\n<h1 id=\"this-对象的理解\"><a href=\"#this-对象的理解\" class=\"headerlink\" title=\"this 对象的理解\"></a>this 对象的理解</h1><p>&#96;&#96;text<br>在 JavaScript 中，this 是一个特殊的关键字，它指向当前执行代码的上下文对象。具体来说，this 引用的是调用函数的对象，根据函数的调用方式不同，this 会有不同的值。</p>\n<pre><code>\n```text\nthis 的值可以根据以下几种情况进行判断\n</code></pre>\n<pre><code class=\"javascript\">1. 作为普通函数调用：当函数作为独立函数调用时，this 的值指向全局对象（在浏览器中为 window）。\nfunction greet() &#123;\n  console.log(`Hello, $&#123;this.name&#125;`);\n&#125;\n\nconst obj = &#123;\n  name: &#39;Alice&#39;,\n  sayHello: greet\n&#125;;\n\ngreet(); // 输出：Hello, undefined\nobj.sayHello(); // 输出：Hello, Alice\n</code></pre>\n<pre><code class=\"javascript\">2. 作为对象方法调用：当函数作为对象的方法调用时，this 的值指向调用该方法的对象。\nconst person = &#123;\n  name: &#39;Alice&#39;,\n  sayHello() &#123;\n    console.log(`Hello, $&#123;this.name&#125;`);\n  &#125;\n&#125;;\n\nperson.sayHello(); // 输出：Hello, Alice\n</code></pre>\n<pre><code class=\"javascript\">3. 作为构造函数调用：当函数被用作构造函数调用时（使用 new 关键字），this 的值指向新创建的对象。\nfunction Person(name) &#123;\n  this.name = name;\n  this.sayHello = function() &#123;\n    console.log(`Hello, $&#123;this.name&#125;`);\n  &#125;;\n&#125;\n\nconst john = new Person(&#39;John&#39;);\njohn.sayHello(); // 输出：Hello, John\n</code></pre>\n<pre><code class=\"javascript\">4. 使用 call、apply 或 bind 方法显式指定 this 的值。\nfunction greet(greeting) &#123;\n  console.log(`$&#123;greeting&#125;, $&#123;this.name&#125;`);\n&#125;\n\nconst person = &#123;\n  name: &#39;Alice&#39;\n&#125;;\n\ngreet.call(person, &#39;Hi&#39;); // 输出：Hi, Alice\ngreet.apply(person, [&#39;Hi&#39;]); // 输出：Hi, Alice\n\nconst boundGreet = greet.bind(person);\nboundGreet(&#39;Hi&#39;); // 输出：Hi, Alice\n</code></pre>\n",
            "tags": [
                "前端开发",
                "Javascript",
                "Javascript"
            ]
        },
        {
            "id": "https://pink-png.github.io/js-base/js%E6%B5%85%E8%B0%88%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%BB%A5%E5%8F%8A%E5%8F%98%E9%87%8F%E4%BB%A5%E5%8F%8A%E9%97%AD%E5%8C%85/",
            "url": "https://pink-png.github.io/js-base/js%E6%B5%85%E8%B0%88%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%BB%A5%E5%8F%8A%E5%8F%98%E9%87%8F%E4%BB%A5%E5%8F%8A%E9%97%AD%E5%8C%85/",
            "title": "js浅谈作用域 - 变量 - 闭包",
            "date_published": "2022-10-25T08:43:00.000Z",
            "content_html": "<h1 id=\"什么是作用域\"><a href=\"#什么是作用域\" class=\"headerlink\" title=\"什么是作用域\"></a>什么是作用域</h1><pre><code class=\"text\">在 JavaScript 中，作用域是指变量的可访问范围，它控制了变量在代码中的可见性和生命周期。JavaScript 有以下几种类型的作用域和变量：\n</code></pre>\n<pre><code class=\"javascript\">1. 全局作用域（Global Scope）：全局作用域是在代码中任何地方都能访问到的最外层作用域。在浏览器环境中，全局作用域通常指的是 window 对象。在全局作用域中声明的变量在整个程序中都是可访问的。 \n\nvar globalVariable = &#39;I am a global variable&#39;;\n\nfunction foo() &#123;\n  console.log(globalVariable); // 输出：I am a global variable\n&#125;\n\nconsole.log(globalVariable); // 输出：I am a global variable\n</code></pre>\n<pre><code class=\"javascript\">2. 函数作用域（Function Scope）：函数作用域是在函数内部声明的变量所拥有的作用域。这意味着函数内部可以访问函数外部的变量，但函数外部无法访问函数内部的变量。\n\nfunction foo() &#123;\n  var functionVariable = &#39;I am a function variable&#39;;\n  console.log(functionVariable); // 输出：I am a function variable\n&#125;\n\nconsole.log(functionVariable); // 报错：functionVariable is not defined\n</code></pre>\n<pre><code class=\"javascript\">3. 块级作用域（Block Scope）：在 ES6（ECMAScript 2015）之前，JavaScript 只有全局作用域和函数作用域，没有块级作用域。块级作用域由一对花括号（&#123;&#125;）创建，在块级作用域内声明的变量只在该块级作用域内部可见。\n\nfunction foo() &#123;\n  if (true) &#123;\n    var blockVariable = &#39;I am a block variable&#39;;\n    let blockScopedVariable = &#39;I am a block-scoped variable&#39;;\n    console.log(blockVariable); // 输出：I am a block variable\n    console.log(blockScopedVariable); // 输出：I am a block-scoped variable\n  &#125;\n\n  console.log(blockVariable); // 输出：I am a block variable\n  console.log(blockScopedVariable); // 报错：blockScopedVariable is not defined\n&#125;\n</code></pre>\n<pre><code class=\"javascript\">4. 词法作用域（Lexical Scope）：JavaScript 使用的是词法作用域，也称为静态作用域。词法作用域是在代码编写时确定的，它基于变量在代码中的位置来确定其可访问范围，而不是运行时的调用栈。\n\nvar globalVariable = &#39;I am a global variable&#39;;\n\nfunction foo() &#123;\n  var functionVariable = &#39;I am a function variable&#39;;\n  console.log(globalVariable); // 输出：I am a global variable\n  console.log(functionVariable); // 输出：I am a function variable\n&#125;\n\nfoo();\n</code></pre>\n<pre><code class=\"text\">在 JavaScript 中，变量有三种声明方式：var、let 和 const。其中 var 声明的变量具有函数作用域或全局作用域，let 和 const 声明的变量具有块级作用域。\n\n请注意，函数声明本身也遵循词法作用域，可以在函数内部定义函数，并在函数内部访问和调用。这就是 JavaScript 中的闭包机制。\n</code></pre>\n<h1 id=\"作用域的理解\"><a href=\"#作用域的理解\" class=\"headerlink\" title=\"作用域的理解\"></a>作用域的理解</h1><ol>\n<li>作⽤域链的作⽤是保证执⾏环境⾥有权访问的变量和函数是有序的，作⽤域链的变量只能向上访问，变量访问到 window 对象即被终⽌，作⽤域链向下访问变量是不被允许的</li>\n<li>简单的说，作⽤域就是变量与函数的可访问范围，即作⽤域控制着变量与函数的可⻅性和⽣命周期</li>\n</ol>\n<h1 id=\"什么是闭包？\"><a href=\"#什么是闭包？\" class=\"headerlink\" title=\"什么是闭包？\"></a>什么是闭包？</h1><ol>\n<li><p>闭包就是能够读取其他函数内部变量的函数</p>\n</li>\n<li><p>闭包是指有权访问另⼀个函数作⽤域中变量的函数，创建闭包的最常⻅的⽅式就是在⼀个函数内创建另⼀个函数，通过另⼀个函数访问这个函数的局部变量,利⽤闭包可以突破作⽤链域</p>\n</li>\n<li><p>闭包的特性：<br>函数内再嵌套函数<br>内部函数可以引⽤外层的参数和变量<br>参数和变量不会被垃圾回收机制回收</p>\n</li>\n</ol>\n<h1 id=\"闭包的理解\"><a href=\"#闭包的理解\" class=\"headerlink\" title=\"闭包的理解\"></a>闭包的理解</h1><ol>\n<li>使⽤闭包主要是为了设计私有的⽅法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增⼤内存使⽤量，使⽤不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产⽣作⽤域的概念</li>\n<li>闭包 的最⼤⽤处有两个，⼀个是可以读取函数内部的变量，另⼀个就是让这些变量始终保持在内存中</li>\n<li>闭包的另⼀个⽤处，是封装对象的私有属性和私有⽅法</li>\n<li>好处：能够实现封装和缓存等；</li>\n<li>坏处：就是消耗内存、不正当使⽤会造成内存溢出的问题</li>\n</ol>\n<h1 id=\"使⽤闭包的注意点\"><a href=\"#使⽤闭包的注意点\" class=\"headerlink\" title=\"使⽤闭包的注意点\"></a>使⽤闭包的注意点</h1><ol>\n<li>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很⼤，所以不能滥⽤闭包，否则会造成⽹⻚的性能问题，在IE中可能导致内存泄露</li>\n<li>解决⽅法是，在退出函数之前，将不使⽤的局部变量全部删除</li>\n</ol>\n<pre><code class=\"javascript\">function outer() &#123;\n  var outerVariable = &#39;I am an outer variable&#39;;\n\n  function inner() &#123;\n    console.log(outerVariable); // 闭包，内部函数可以访问外部函数的变量\n  &#125;\n\n  return inner;\n&#125;\n\nvar closureFunction = outer(); \nclosureFunction(); // 输出：I am an outer variable\n</code></pre>\n<h1 id=\"什么情况下会造成内存泄漏\"><a href=\"#什么情况下会造成内存泄漏\" class=\"headerlink\" title=\"什么情况下会造成内存泄漏\"></a>什么情况下会造成内存泄漏</h1><ol>\n<li>未及时释放闭包：如果闭包被保留在内存中，并且不再需要使用，但没有手动解除对闭包的引用，这将导致闭包及其所引用的变量无法被垃圾回收，从而造成内存泄漏。</li>\n<li>循环引用：如果闭包持有对其他对象的引用，而这些对象又持有对闭包的引用，形成了循环引用，那么这些对象以及闭包本身都无法被垃圾回收，导致内存泄漏。</li>\n<li>事件监听器未移除：当页面中的元素绑定了事件监听器，而这些监听器是在闭包中定义的，如果没有正确地解除对元素的引用，这会导致闭包无法释放，从而造成内存泄漏。</li>\n<li>全局变量引用：如果闭包中引用了全局变量，即使函数执行结束，闭包仍然可以访问和持有对全局变量的引用，阻止了对全局变量的释放，导致内存泄漏。</li>\n</ol>\n<h1 id=\"为避免闭包导致的内存泄漏，可以采取以下措施：\"><a href=\"#为避免闭包导致的内存泄漏，可以采取以下措施：\" class=\"headerlink\" title=\"为避免闭包导致的内存泄漏，可以采取以下措施：\"></a>为避免闭包导致的内存泄漏，可以采取以下措施：</h1><ol>\n<li>及时释放闭包：在不需要使用闭包时，手动解除对闭包的引用，让垃圾回收机制能够回收闭包及其引用的变量。</li>\n<li>移除事件监听器：在不再需要使用的情况下，确保移除元素上的事件监听器，以免闭包继续持有对元素的引用。</li>\n<li>避免不必要的全局变量：减少对全局作用域的依赖，限制闭包对全局变量的引用，使得相关变量能够在不需要时被回收。</li>\n</ol>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><pre><code class=\"text\">在上面的例子中，outer 函数返回了一个内部函数 inner，该内部函数引用了 outer 函数的变量 outerVariable。即使 outer 函数执行完毕后，inner 函数依然可以访问和操作 outerVariable 变量，这就是闭包的特性。\n\n通过使用作用域和闭包，我们可以实现封装、数据私有化和模块化等编程概念。闭包还可以用于创建函数工厂和实现函数柯里化等高级编程技巧。\n</code></pre>\n",
            "tags": [
                "前端开发",
                "Javascript",
                "Javascript"
            ]
        },
        {
            "id": "https://pink-png.github.io/performance-optimization/%E6%8F%90%E9%AB%98Webpack%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/",
            "url": "https://pink-png.github.io/performance-optimization/%E6%8F%90%E9%AB%98Webpack%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/",
            "title": "webpack性能优化",
            "date_published": "2022-07-25T08:43:00.000Z",
            "content_html": "<h1 id=\"如何提高Webpack构建速度\"><a href=\"#如何提高Webpack构建速度\" class=\"headerlink\" title=\"如何提高Webpack构建速度\"></a>如何提高Webpack构建速度</h1><pre><code class=\"javascript\">1. 代码压缩\n\nJS 压缩\nwebpack 4.0默认在生产环境的时候是支持代码压缩的，即mode=production模式下。实际上webpack 4.0默认是使用terser-webpack-plugin这个压缩插件，在此之前是使用 uglifyjs-webpack-plugin，两者的区别是后者对 ES6 的压缩不是很好，同时我们可以开启 parallel参数，使用多进程压缩，加快压缩。\nCSS 压缩\nCSS 压缩通常是去除无用的空格等，因为很难去修改选择器、属性的名称、值等。可以使用另外一个插件：css-minimizer-webpack-plugin。\nHTML 压缩\n使用HtmlWebpackPlugin插件来生成 HTML 的模板时候，通过配置属性minify进行 html 优化。\n\nmodule.exports = &#123;\nplugin:[\n  new HtmlwebpackPlugin(&#123;\n    minify:&#123;\n      minifyCSS: false, // 是否压缩css\n      collapseWhitespace: false, // 是否折叠空格\n      removeComments: true // 是否移除注释\n    &#125;\n  &#125;)\n  ]\n&#125;\n\n2. 图片压缩\n\n配置image-webpack-loader\n\n3. Tree Shaking\nTree Shaking是一个术语，在计算机中表示消除死代码，依赖于 ES Module 的静态语法分析（不执行任何的代码，可以明确知道模块的依赖关系）。在webpack实现Tree shaking有两种方案：\n\nusedExports：通过标记某些函数是否被使用，之后通过 Terser 来进行优化的\nmodule.exports = &#123;\n    ...\n    optimization:&#123;\n        usedExports\n    &#125;\n  &#125;\n使用之后，没被用上的代码在webpack打包中会加入unused harmony export mul注释，用来告知Terser在优化时，可以删除掉这段代码。\n\nsideEffects：跳过整个模块/文件，直接查看该文件是否有副作用\n\nsideEffects用于告知webpack compiler哪些模块时有副作用，配置方法是在package.json中设置sideEffects属性。如果sideEffects设置为false，就是告知webpack可以安全的删除未用到的exports。如果有些文件需要保留，可以设置为数组的形式，如：\n\n&quot;sideEffecis&quot;:[\n    &quot;./src/util/format.js&quot;,\n    &quot;*.css&quot; // 所有的css文件\n]\n\n4. 缩小打包域\n排除webpack不需要解析的模块，即在使用loader的时候，在尽量少的模块中去使用。可以借助 include和exclude这两个参数，规定loader只在那些模块应用和在哪些模块不应用。\n\n5. 减少 ES6 转为 ES5 的冗余代码\n使用bable-plugin-transform-runtime插件\n\n6. 提取公共代码\n通过配置CommonsChunkPlugin插件，将多个页面的公共代码抽离成单独的文件\n\n7. 其他\n组件懒加载、路由懒加载、开启gzip、公共的第三方包上cdn、配置cache缓存Loader对文件的编译副本、配置resolve提高文件的搜索速度\n</code></pre>\n<h1 id=\"webpack性能优化\"><a href=\"#webpack性能优化\" class=\"headerlink\" title=\"webpack性能优化\"></a>webpack性能优化</h1><h2 id=\"开发环境性能优化\"><a href=\"#开发环境性能优化\" class=\"headerlink\" title=\"开发环境性能优化\"></a>开发环境性能优化</h2><ol>\n<li>优化打包构建速度</li>\n<li>HMR</li>\n<li>优化代码调试</li>\n<li>source-map</li>\n</ol>\n<h2 id=\"生产环境性能优化\"><a href=\"#生产环境性能优化\" class=\"headerlink\" title=\"生产环境性能优化\"></a>生产环境性能优化</h2><ol>\n<li>优化打包构建速度</li>\n<li>oneOf(可以按照一组优先级顺序来定义不同类型或特定条件下的模块处理方式)</li>\n</ol>\n<pre><code class=\"javascript\">module.exports = &#123;\n  // ...其他的Webpack配置\n  module: &#123;\n    rules: [\n      // ...其他规则\n      &#123;\n        oneOf: [\n          &#123;\n            test: /\\.css$/,\n            use: [&#39;style-loader&#39;, &#39;css-loader&#39;]\n          &#125;,\n          &#123;\n            test: /\\.less$/,\n            use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;less-loader&#39;]\n          &#125;,\n          &#123;\n            test: /\\.js$/,\n            exclude: /node_modules/,\n            use: &#39;babel-loader&#39;\n          &#125;,\n          // ...其他的规则\n        ]\n      &#125;\n    ]\n  &#125;\n&#125;;\n</code></pre>\n<ol start=\"3\">\n<li>babel缓存</li>\n<li>多进程打包</li>\n<li>externals(拒绝某些包被打包进来)</li>\n<li>dll(独立打包第三方库,减少构建时间)</li>\n<li>优化代码运行的性能</li>\n<li>缓存(hash-chunkhash-contenthash)</li>\n<li>tree shaking</li>\n</ol>\n<pre><code class=\"text\">tree shaking：去除无用代码\n  前提：1. 必须使用ES6模块化  2. 开启production环境\n  作用: 减少代码体积\n\n在package.json中配置 \n  &quot;sideEffects&quot;: false 所有代码都没有副作用（都可以进行tree shaking）\n    问题：可能会把css / @babel/polyfill （副作用）文件干掉\n  &quot;sideEffects&quot;: [&quot;*.css&quot;, &quot;*.less&quot;]\n</code></pre>\n<ol start=\"10\">\n<li>code split</li>\n<li>懒加载&#x2F;预加载</li>\n<li>pwa(PWA 提供了一种融合了网页和原生应用优点的解决方案，能够提供离线访问、快速加载、类似原生应用的体验以及跨平台兼容性等优势)</li>\n</ol>\n",
            "tags": [
                "前端开发",
                "前端性能优化",
                "前端性能优化"
            ]
        },
        {
            "id": "https://pink-png.github.io/performance-optimization/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%A4%A7%E7%BA%B2/",
            "url": "https://pink-png.github.io/performance-optimization/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%A4%A7%E7%BA%B2/",
            "title": "前端性能优化大纲",
            "date_published": "2022-06-25T08:43:00.000Z",
            "content_html": "<h1 id=\"性能优化六大指标\"><a href=\"#性能优化六大指标\" class=\"headerlink\" title=\"性能优化六大指标\"></a>性能优化六大指标</h1><p><strong>六大指标基本囊括大部分性能优化细节，可作为优化策略的补充。</strong></p>\n<ol>\n<li>「加载优化」：资源在加载时可做的性能优化</li>\n<li>「执行优化」：资源在执行时可做的性能优化</li>\n<li>「渲染优化」：资源在渲染时可做的性能优化</li>\n<li>「样式优化」：样式在编码时可做的性能优化</li>\n<li>「脚本优化」：脚本在编码时可做的性能优化</li>\n<li>「V8引擎优化」：针对V8引擎特征可做的性能优化</li>\n</ol>\n<h2 id=\"加载优化\"><a href=\"#加载优化\" class=\"headerlink\" title=\"加载优化\"></a>加载优化</h2><ol>\n<li>优化HTTP请求：减少请求次数、合并与压缩静态资源、使用CDN等</li>\n</ol>\n<pre><code class=\"text\">1. CDN：将资源分发到 CDN 的边缘网络节点，使用户可就近获\n取所需内容，大幅减小了光纤传输距离，使全球各地用户打开网站都拥有良好的网络体验。\n\n2. http2：http2 的诸多特性决定了它更快的传输速度。\n2.1.多路复用，在浏览器可并行发送 N 条请求。\n2.2.首部压缩，更小的负载体积。\n2.3.请求优先级，更快的关键请求\n目前，网站已大多上了 http2，可在控制台面板进行查看。\n由于 http2 可并行请求，解决了 http1.1 线头阻塞的问题，以下几个性能优化点将会过时\n资源合并。如 https://shanyue.tech/assets??index.js,interview.js,report.js\n域名分片。\n雪碧图。将无数小图片合并成单个大图片。\n\n3. 充分利用 HTTP 缓存\n更好的资源缓存策略，对于 CDN 来讲可减少回源次数，对于浏览器而言可减少请求发送次数。无论哪一点，对于二次网站访问都具有更好的访问体验。\n一:缓存策略\n  1.强缓存: 打包后带有 hash 值的资源 (如 /build/a3b4c8a8.js)\n  2.协商缓存: 打包后不带有 hash 值的资源 (如 /index.html)\n二:分包加载 (Bundle Spliting)\n  1.避免一行代码修改导致整个 bundle 的缓存失效 \n\n4. 减少 HTTP 请求及负载\n对一个网站的资源进行压缩优化，从而达到减少 HTTP 负载的目的。\njs/css/image 等常规资源体积优化，这是一个大话题，再以下分别讨论\n4.1小图片优化，将小图片内联为 Data URI，减小请求数量\n4.2图片懒加载\n4.3新的 API: IntersectionObserver API\n4.4新的属性: loading=lazy \n\n5. preload/prefetch\n preload/prefetch 可控制 HTTP 优先级，从而达到关键请求更快响应的目的。\n\n&lt;link rel=&quot;prefetch&quot; href=&quot;style.css&quot; as=&quot;style&quot;&gt;\n&lt;link rel=&quot;preload&quot; href=&quot;main.js&quot; as=&quot;script&quot;&gt;\n1. preload 加载当前路由必需资源，优先级高。一般对于 Bundle Spliting 资源与 Code Spliting 资源做 preload\n2. prefetch 优先级低，在浏览器 idle 状态时加载资源。一般用以加载其它路由资源，如当页面出现 Link，可 prefetch 当前 Link 的路由资源。（next.js 默认会对 link 做懒加载+prefetch，即当某条 Link 出现页面中，即自动 prefetch 该 Link 指向的路由资源\n捎带说一下 dns-prefetch，可对主机地址的 DNS 进行预解析。\n\n&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//shanyue.tech&quot;&gt;\n</code></pre>\n<ol start=\"2\">\n<li>使用缓存：利用浏览器缓存机制，设置适当的缓存头信息</li>\n<li>图片优化：选择合适的图片格式、压缩图片文件大小、响应式图片或按需加载图片</li>\n</ol>\n<pre><code class=\"text\">在前端发展的现在，webp 普遍比 jpeg/png 更小，而 avif 又比 webp 小一个级别\n\n为了无缝兼容，可选择 picture/source 进行回退处理\n&lt;picture&gt;\n  &lt;source srcset=&quot;img/photo.avif&quot; type=&quot;image/avif&quot;&gt;\n  &lt;source srcset=&quot;img/photo.webp&quot; type=&quot;image/webp&quot;&gt;\n  &lt;img src=&quot;img/photo.jpg&quot; width=&quot;360&quot; height=&quot;240&quot;&gt;\n&lt;/picture&gt;\n\n1.更合适的尺寸: 当页面仅需显示 100px/100px 大小图片时，对图片进行压缩到 100px/100px\n2.更合适的压缩: 可对前端图片进行适当压缩，如通过 sharp 等\n</code></pre>\n<ol start=\"4\">\n<li>延迟加载：将非关键资源延迟加载，如图片、视频、第三方插件等</li>\n<li>使用字体图标和矢量图形：替代大量图片的使用</li>\n<li>更小的 Javascript</li>\n</ol>\n<pre><code class=\"text\">gzip/brotli\nterser (minify)\n还有以下几点可以考虑考虑:\n\n路由懒加载，无需加载整个应用的资源\nTree Shaking: 无用导出将在生产环境进行删除\nbrowserlist/babel: 及时更新 browserlist，将会产生更小的垫片体积\n再补充一个问题:\n\n如何分析并优化当前项目的 Javascript 体积？如果使用 webpack 那就简单很多。\n\n使用 webpack-bundle-analyze 分析打包体积\n对一些库替换为更小体积的库，如 moment -&gt; dayjs\n对一些库进行按需加载，如 import lodash -&gt; import lodash/get\n对一些库使用支持 Tree Shaking，如 import lodash -&gt; import lodash-es\n</code></pre>\n<ol start=\"7\">\n<li>压缩混淆工具</li>\n</ol>\n<pre><code class=\"text\">1.Terser (opens new window)是 Javascript 资源压缩混淆的神器。\n\n它可以根据以下策略进行压缩处理:\n\n长变量名替换短变量\n删除空格换行符\n预计算: const a = 24 * 60 * 60 * 1000 -&gt; const a = 86400000\n移除无法被执行的代码·\n移除无用的变量及函数\n可在 Terser Repl (opens new window)在线查看代码压缩效果。\n\n2.swc (opens new window)是另外一个用以压缩 Javascript 的工具，它拥有与 terser 相同的 API，由于它是由 rust 所写，因此它拥有更高的性能。\n\n3.html-minifier-terser (opens new window)用以压缩 HTML 的工具\n\n4. gzip/brotli\n对 JS、CSS、HTML 等文本资源均有效，但是对图片效果不大。\n\ngzip 通过 LZ77 算法与 Huffman 编码来压缩文件，重复度越高的文件可压缩的空间就越大。\nbrotli 通过变种的 LZ77 算法、Huffman 编码及二阶文本建模来压缩文件，更先进的压缩算法，比 gzip 有更高的性能及压缩率\n可在浏览器的 Content-Encoding 响应头查看该网站是否开启了压缩算法，目前知乎、掘金等已全面开启了 brotli 压缩。\n\nRequest Header\nAccept-Encoding: gzip, deflate, br\n\ngzip\nContent-Encoding: gzip\n\ngzip\nContent-Encoding: br \n</code></pre>\n<h2 id=\"执行优化\"><a href=\"#执行优化\" class=\"headerlink\" title=\"执行优化\"></a>执行优化</h2><ol>\n<li>代码优化：精简html，css，js代码，避免重复代码</li>\n<li>异步加载：将JavaScript放在底部，使用async,defer熟悉</li>\n<li>代码分割和懒加载：拆分大型应用程序为小模块，按需加载模块，减少初始加载时间</li>\n<li>前端代码压缩混淆：对前端代码进行压缩和混淆，减小文件大小，提高加载速度</li>\n</ol>\n<h2 id=\"渲染优化\"><a href=\"#渲染优化\" class=\"headerlink\" title=\"渲染优化\"></a>渲染优化</h2><p><strong>「渲染层面」</strong>的性能优化，无疑是如何让代码解析更好执行更快。</p>\n<ol>\n<li>「CSS策略」：基于CSS规则</li>\n<li>「DOM策略」：基于DOM操作</li>\n<li>「阻塞策略」：基于脚本加载</li>\n<li>「回流重绘策略」：基于回流重绘</li>\n<li>「异步更新策略」：基于异步更新</li>\n<li>「缓存策略」</li>\n</ol>\n<p><strong>CSS策略</strong><br>避免出现超过三层的嵌套规则<br>避免为ID选择器添加多余选择器<br>避免使用标签选择器代替类选择器<br>避免使用通配选择器，只对目标节点声明规则<br>避免重复匹配重复定义，关注可继承属性</p>\n<p><strong>DOM策略</strong><br>缓存DOM计算属性<br>避免过多DOM操作<br>使用DOMFragment缓存批量化DOM操作<br>虚拟列表优化</p>\n<p><strong>阻塞策略</strong><br>脚本与DOM&#x2F;其它脚本的依赖关系很强：对<script>设置defer<br>脚本与DOM/其它脚本的依赖关系不强：对<script>设置async</p>\n<p><strong>「回流重绘策略」</strong>在渲染层面的性能优化里占比较重，也是最常规的性能优化之一。<br>缓存DOM计算属性<br>使用类合并样式，避免逐条改变样式<br>使用display控制DOM显隐，将DOM离线化</p>\n<p><strong>异步更新策略</strong><br>在异步任务中修改DOM时把其包装成微任务</p>\n<p><strong>缓存策略</strong></p>\n<pre><code class=\"javascript\">在一些前端系统中，当加载页面时会发送请求，路由切换出去再切换回来时又会重新发送请求，每次请求完成后会对页面重新渲染。\n\n然而这些重新请求再大多数时是没有必要的，合理地对 API 进行缓存将达到优化渲染的目的。\n\n1.对每一条 GET API 添加 key\n2.根据 key 控制该 API 缓存，重复发生请求时将从缓存中取得\n\nfunction Example() &#123;\n  // 设置缓存的 Key 为 Users:10086\n  const &#123; isLoading, data &#125; = useQuery([&#39;users&#39;, userId], () =&gt; fetchUserById(userId))\n&#125;\n</code></pre>\n<h2 id=\"样式优化\"><a href=\"#样式优化\" class=\"headerlink\" title=\"样式优化\"></a>样式优化</h2><ol>\n<li>响应式设计：使用响应式布局和媒体查询适应不同设备和屏幕大小</li>\n<li>使用CSS预处理器：如Less、Sass等，提高样式编写的效率</li>\n</ol>\n<h2 id=\"脚本优化\"><a href=\"#脚本优化\" class=\"headerlink\" title=\"脚本优化\"></a>脚本优化</h2><ol>\n<li>使用模块化开发：使用模块化/组件化的方式组织JavaScript代码</li>\n<li>优化DOM操作：减少DOM操作的次数，对多次操作进行批量处理</li>\n</ol>\n<h2 id=\"V8引擎优化\"><a href=\"#V8引擎优化\" class=\"headerlink\" title=\"V8引擎优化\"></a>V8引擎优化</h2><ol>\n<li>避免不必要的闭包：过多的闭包会导致内存消耗增加</li>\n<li>使用高性能API和方法：如使用map而不是for循环等</li>\n<li>优化循环和递归：尽量减少循环和递归的层数和次数，避免性能问题</li>\n</ol>\n<h1 id=\"性能评测指标\"><a href=\"#性能评测指标\" class=\"headerlink\" title=\"性能评测指标\"></a>性能评测指标</h1><p><strong>三大指标</strong> 使用工具 lighthouse，web-vitals 等<br>LCP: 加载性能。最大内容绘制应在 2.5s 内完成。<br>FID: 交互性能。首次输入延迟应在 100ms 内完成。<br>CLS: 页面稳定性。累积布局偏移，需手动计算，CLS 应保持在 0.1 以下。</p>\n<h1 id=\"优化-DOM-操作并减少其次数\"><a href=\"#优化-DOM-操作并减少其次数\" class=\"headerlink\" title=\"优化 DOM 操作并减少其次数\"></a>优化 DOM 操作并减少其次数</h1><pre><code class=\"javascript\">1. 批量更新：将多个 DOM 操作合并为一个操作，以减少重排和重绘的次数。例如，如果要对一个元素进行多次样式修改，可以先使用 CSS 类来添加或删除样式，最后再应用一次类，而不是每次修改都直接操作样式属性。\n\n// 不优化的写法\nelement.style.width = &#39;100px&#39;;\nelement.style.height = &#39;200px&#39;;\nelement.style.backgroundColor = &#39;red&#39;;\n\n// 优化的写法\nelement.classList.add(&#39;my-class&#39;);\nelement.classList.remove(&#39;my-class&#39;);\n\n\n2. 使用文档片段（DocumentFragment）：将多个 DOM 节点先添加到文档片段中，然后再一次性插入文档中，这样只会触发一次重排和重绘。这在需要动态添加大量元素时特别有效。\n\n// 不优化的写法\nfor (let i = 0; i &lt; 1000; i++) &#123;\n  const element = document.createElement(&#39;div&#39;);\n  document.body.appendChild(element);\n&#125;\n\n// 优化的写法\nconst fragment = document.createDocumentFragment();\nfor (let i = 0; i &lt; 1000; i++) &#123;\n  const element = document.createElement(&#39;div&#39;);\n  fragment.appendChild(element);\n&#125;\ndocument.body.appendChild(fragment);\n\n3. 缓存 DOM 查询结果：当需要多次访问同一个 DOM 元素时，将查询结果缓存在变量中，避免重复查询。\n// 不优化的写法\nfor (let i = 0; i &lt; 100; i++) &#123;\n  document.getElementById(&#39;myElement&#39;).innerHTML += &#39;new content&#39;;\n&#125;\n\n// 优化的写法\nconst element = document.getElementById(&#39;myElement&#39;);\nfor (let i = 0; i &lt; 100; i++) &#123;\n  element.innerHTML += &#39;new content&#39;;\n&#125;\n\n4. 使用虚拟 DOM：在涉及大量数据变动和复杂视图更新的情况下，可以使用虚拟 DOM 技术，通过比对虚拟 DOM 树来最小化实际 DOM 操作的次数。\n这些是一些常见的优化 DOM 操作的方法。请根据具体场景选择合适的方法进行优化。记住，减少 DOM 操作次数会显著提高性能和用户体验。\n</code></pre>\n<h1 id=\"浏览器缓存优化\"><a href=\"#浏览器缓存优化\" class=\"headerlink\" title=\"浏览器缓存优化\"></a>浏览器缓存优化</h1><p>为了让浏览器缓存发挥最大作用，该策略尽量遵循以下五点就能发挥浏览器缓存最大作用。</p>\n<p>「考虑拒绝一切缓存策略」：Cache-Control:no-store<br>「考虑资源是否每次向服务器请求」：Cache-Control:no-cache<br>「考虑资源是否被代理服务器缓存」：Cache-Control:public/private<br>「考虑资源过期时间」：Expires:t/Cache-Control:max-age=t,s-maxage=t<br>「考虑协商缓存」：Last-Modified/Etag<br>缓存策略通过设置HTTP报文实现，在形式上分为<strong>「强缓存/强制缓存」和「协商缓存/对比缓存」</strong>。</p>\n<p><img data-src=\"/images/xn/%E5%BC%BA%E7%BC%93%E5%AD%98.png\"><br><img data-src=\"/images/xn/%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98.png\"></p>\n<p>整个缓存策略机制很明了，先走强缓存，若命中失败才走协商缓存。若命中强缓存，直接使用强缓存；若未命中强缓存，发送请求到服务器检查是否命中协商缓存；若命中协商缓存，服务器返回304通知浏览器使用本地缓存，否则返回最新资源。</p>\n<p>有两种较常用的应用场景值得使用缓存策略一试，当然更多应用场景都可根据项目需求制定。</p>\n<p>「频繁变动资源」：设置Cache-Control:no-cache，使浏览器每次都发送请求到服务器，配合Last-Modified/ETag验证资源是否有效<br>「不常变化资源」：设置Cache-Control:max-age=31536000，对文件名哈希处理，当代码修改后生成新的文件名，当HTML文件引入文件名发生改变才会下载最新文件</p>\n<h1 id=\"Web-Worker\"><a href=\"#Web-Worker\" class=\"headerlink\" title=\"Web Worker\"></a>Web Worker</h1><p>在纯浏览器中，如何实现高性能的实时代码编译及转换？</p>\n<p>Babel Repl(opens new window)<br>如果纯碎使用传统的 Javascript 实现，将会耗时过多阻塞主线程，有可能导致页面卡顿。</p>\n<p>如果使用 Web Worker 交由额外的线程来做这件事，将会高效很多，基本上所有在浏览器端进行代码编译的功能都由 Web Worker 实现。</p>\n<h1 id=\"WASM\"><a href=\"#WASM\" class=\"headerlink\" title=\"WASM\"></a>WASM</h1><ol>\n<li>JS 性能低下</li>\n<li>C++/Rust 高性能</li>\n<li>使用 C++/Rust 编写代码，然后在 Javascript 环境运行<br>试举一例:</li>\n</ol>\n<p>在纯浏览器中，如何实现高性能的图片压缩？</p>\n<p>基本上很难做到，Javascript 的性能与生态决定了实现图片压缩的艰难。</p>\n<p>而借助于 WASM 就相当于借用了其它语言的生态。</p>\n<p>1.libavif (opens new window): C语言写的 avif 解码编码库<br>2.libwebp (opens new window): C语言写的 webp 解码编码库<br>3.mozjpeg (opens new window): C语言写的 jpeg 解码编码库<br>4.oxipng (opens new window): Rust语言写的 png 优化库<br>而由于 WASM，完全可以把这些其它语言的生态移植到浏览器中，从而实现一个高性能的离线式的图片压缩工具。</p>\n",
            "tags": [
                "前端开发",
                "前端性能优化",
                "前端性能优化"
            ]
        },
        {
            "id": "https://pink-png.github.io/performance-optimization/%E5%9C%A8%E6%9F%90%E6%9F%90%E4%BC%81%E4%B8%9A%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BC%98%E5%8C%96%E6%80%9D%E8%80%83(uniapp)/",
            "url": "https://pink-png.github.io/performance-optimization/%E5%9C%A8%E6%9F%90%E6%9F%90%E4%BC%81%E4%B8%9A%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BC%98%E5%8C%96%E6%80%9D%E8%80%83(uniapp)/",
            "title": "在某某企业小程序优化思考(uniapp)",
            "date_published": "2022-06-25T08:43:00.000Z",
            "content_html": "<ol>\n<li><p>vuex 对启动耗时的影响<br>Vuex 是一个状态管理库，在启动阶段如果存在大量的业务逻辑，会使启动耗时增加。这是因为在启动过程中，需要初始化 Vuex 的状态和相关的模块，可能会触发一些异步操作和计算，导致启动时间延长。因此，在设计和使用 Vuex 时，需要注意避免在启动阶段执行过多的繁重操作，以减少启动耗时。</p>\n</li>\n<li><p>mixins 对启动耗时的影响<br>Mixins 是一种在组件中复用代码的机制，通过将相同的逻辑和功能抽离到 Mixins 中，可以在多个组件中共享使用。在启动阶段，如果组件使用了 Mixins，会在组件实例化时执行 Mixins 中的代码逻辑，因此会增加启动耗时。如果 Mixins 中存在大量或复杂的业务逻辑，会进一步增加启动耗时。因此，使用 Mixins 时需要注意控制逻辑的复杂度，避免影响启动性能。</p>\n</li>\n<li><p>子组件中的请求是从onReady 加载完再去调用请求的，所以是否组件中不要使用请求?<br>在小程序中，子组件的请求通常是在组件的 onReady 生命周期钩子函数中进行调用。由于 onReady 是在页面的渲染准备完成后调用的，此时页面已经可见，用户可以看到页面内容。因此，在 onReady 钩子中进行请求可能会导致页面加载完成后才开始请求数据，从而延长了页面加载时间。</p>\n</li>\n<li><p>挂载到原型上的东西 ,每次生成的页面都会执行这个数据 , 这里的影响多大?<br>当一些数据或方法挂载到小程序的原型对象上时，每次生成的页面都可以通过原型链访问到这些数据或方法。这样做的好处是可以实现数据和方法的全局共享和复用。</p>\n</li>\n<li><p>有没有根据包大小计算出来的 平均启动时间&#x2F;加载耗时<br>通常情况下，并没有一个直接根据包大小计算出来的平均启动时间或加载耗时的公式或算法。因为启动时间和加载耗时受到多个因素的影响，如网络环境、设备性能、代码复杂度等。<br>包大小的增加可能会导致下载时间变长，从而影响启动时间。然而，仅仅根据包大小无法准确预测启动时间的增加，还需要考虑其他因素的综合影响。因此，对于不同的小程序和具体场景，需要进行实际测试和评估来得出准确的启动时间和加载耗时。</p>\n</li>\n</ol>\n<ul>\n<li>计算最佳收益点</li>\n<li>其实这里想表达的是否2M 和 1.5M的包下载时间的差距是否几乎不计?</li>\n</ul>\n<ol start=\"6\">\n<li>从小程序加载流程上来讲，对于首次打开小程序用户，会去下载包，包大会造成下载时间变长（在相同网络条件下）；影响启动耗时的直接因素：<br>● 平台：不同的平台下（安卓、IOS）设备性能、操作系统、框架实现、优化方案存在较大的差异，启动耗时也存在较大的差异。只有分平台比较启动耗时（包括各阶段耗时）才有意义；<br> 1.怎么做到只是针对某个机型去判断?<br> 2.是不是要去处理慢的机型呢? 怎么处理是个问题<br>● 下载比例及大小：代码包下载和更新都会显著影响小程序启动耗时，在其他流程耗时稳定的情况下，下载比例升高会影响大盘启动耗时。<br>● 入口页面：不同页面启动时，根据所在分包的不同，需要下载的代码包数量和大小和代码注入量都存在差异。不同页面渲染耗时也存在差异。<br>● 机型分布：启动耗时和设备性能有较强关联，不同小程序或使用场景用户群体的差异可能导致机型分布的差异，进而影响大盘启动耗时。<br>● 网络环境：网络环境主要影响网络请求的耗时，如小程序信息获取、代码包下载等。<br>间接因素：<br>● 场景&#x2F;访问来源：不同场景下，用户访问的页面不同，新用户比例也有差异，对启动耗时会有一定影响。此外，用户访问的目的性和自身的等待意愿也有差异，也会影响打开率。<br> 1.这里可能存在有些页面分享进来的，但是这个页面其实是不允许直接进入的，可能会造成某些问题导致的耗时<br> 2.进入的页面不是首页，这是一种什么场景?<br>● 首次访问用户比例：用户首次访问小程序时，需要完整的进行小程序信息准备、代码包下载的流程，代码缓存也需要重新生成，启动耗时会比非首次访问高。<br>● 小程序版本更新：小程序版本更新时，用户需要更新小程序信息和代码包，代码缓存也需要重新生成，启动耗时会出现上涨。<br> 1.这个其实就是每次更新版本对启动时长的影响，特别是发布灰度的时候<br> 2.一段时间不发新版本,启动时间会降低。这里其实说明我们登报的人，他存在多次进来看的情况（这个是肯定的）</li>\n</ol>\n",
            "tags": [
                "前端开发",
                "前端性能优化",
                "前端性能优化"
            ]
        },
        {
            "id": "https://pink-png.github.io/Web-Integration/web%E5%AE%89%E5%85%A8/",
            "url": "https://pink-png.github.io/Web-Integration/web%E5%AE%89%E5%85%A8/",
            "title": "web安全",
            "date_published": "2021-06-25T08:43:00.000Z",
            "content_html": "<h1 id=\"XSS（跨站脚本攻击）：\"><a href=\"#XSS（跨站脚本攻击）：\" class=\"headerlink\" title=\"XSS（跨站脚本攻击）：\"></a>XSS（跨站脚本攻击）：</h1><pre><code class=\"text\">使用合适的编码和转义方式来处理输入和输出的数据。\n对用户输入进行验证和过滤，避免将恶意脚本插入到页面中。\n</code></pre>\n<h1 id=\"CSRF（跨站请求伪造）：\"><a href=\"#CSRF（跨站请求伪造）：\" class=\"headerlink\" title=\"CSRF（跨站请求伪造）：\"></a>CSRF（跨站请求伪造）：</h1><pre><code class=\"text\">在关键操作上使用随机生成的令牌（CSRF Token），并验证该令牌的合法性。\n设置合适的 SameSite Cookie 属性，限制跨站点访问。\n</code></pre>\n<h1 id=\"点击劫持（Clickjacking）：\"><a href=\"#点击劫持（Clickjacking）：\" class=\"headerlink\" title=\"点击劫持（Clickjacking）：\"></a>点击劫持（Clickjacking）：</h1><pre><code class=\"text\">使用 X-Frame-Options 或 Content-Security-Policy 来限制页面被嵌套到其他网站的情况。\n可以使用 JavaScript 检测页面是否在 iframe 中展示，并弹出警告或拒绝加载。\n</code></pre>\n<h1 id=\"密码安全：\"><a href=\"#密码安全：\" class=\"headerlink\" title=\"密码安全：\"></a>密码安全：</h1><pre><code class=\"text\">采用密码哈希算法（如 bcrypt）对用户密码进行加密存储，避免明文存储。\n强制要求用户设置强密码，并进行密码策略的验证（如长度、大小写字母、特殊字符等）。\n</code></pre>\n<h1 id=\"客户端数据验证和过滤：\"><a href=\"#客户端数据验证和过滤：\" class=\"headerlink\" title=\"客户端数据验证和过滤：\"></a>客户端数据验证和过滤：</h1><pre><code class=\"text\">不要依赖前端验证，一定要在后端进行数据验证和过滤。\n对客户端输入的数据进行严格验证，避免恶意输入和攻击。\n</code></pre>\n<h1 id=\"安全更新和依赖管理：\"><a href=\"#安全更新和依赖管理：\" class=\"headerlink\" title=\"安全更新和依赖管理：\"></a>安全更新和依赖管理：</h1><pre><code class=\"text\">及时更新和升级前端框架、库和依赖，以获取最新的安全修复和补丁。\n定期审查和监控项目的依赖项，确保没有包含已知的漏洞和安全问题。\n</code></pre>\n<h1 id=\"HTTPS-的使用：\"><a href=\"#HTTPS-的使用：\" class=\"headerlink\" title=\"HTTPS 的使用：\"></a>HTTPS 的使用：</h1><pre><code class=\"text\">在页面上使用 HTTPS 协议来加密数据传输，防止数据被窃取和篡改。\n配置合适的 TLS/SSL 加密套件和证书，确保通信的安全性。\n</code></pre>\n<h1 id=\"安全审计和日志记录：\"><a href=\"#安全审计和日志记录：\" class=\"headerlink\" title=\"安全审计和日志记录：\"></a>安全审计和日志记录：</h1><pre><code class=\"text\">记录用户操作日志，追溯异常行为和安全事件。\n定期进行安全审计，检查应用程序的漏洞和安全风险。\n</code></pre>\n<h1 id=\"输入验证与过滤：\"><a href=\"#输入验证与过滤：\" class=\"headerlink\" title=\"输入验证与过滤：\"></a>输入验证与过滤：</h1><pre><code class=\"text\">对用户输入进行验证和过滤，确保只接受预期的合法输入。\n使用白名单过滤，而不是黑名单过滤，避免遗漏恶意输入。\n</code></pre>\n<h1 id=\"安全的跨域资源共享（CORS）配置：\"><a href=\"#安全的跨域资源共享（CORS）配置：\" class=\"headerlink\" title=\"安全的跨域资源共享（CORS）配置：\"></a>安全的跨域资源共享（CORS）配置：</h1><pre><code class=\"text\">配置合适的 CORS 头信息，限制跨域请求的访问权限。\n设置合理的源和目标组合，防止未经授权的访问和信息泄露。\n</code></pre>\n<h1 id=\"客户端存储的安全性：\"><a href=\"#客户端存储的安全性：\" class=\"headerlink\" title=\"客户端存储的安全性：\"></a>客户端存储的安全性：</h1><pre><code class=\"text\">避免在客户端存储敏感信息，如密码、令牌等。\n使用合适的存储机制，如浏览器提供的 localStorage 或 sessionStorage，加密存储敏感数据。\n</code></pre>\n<h1 id=\"CDN-安全：\"><a href=\"#CDN-安全：\" class=\"headerlink\" title=\"CDN 安全：\"></a>CDN 安全：</h1><pre><code class=\"text\">如果使用内容分发网络（CDN），确保从可信任的来源获取资源并验证其完整性。\n配置适当的安全头部，如 Content Security Policy (CSP)。\n</code></pre>\n<h1 id=\"防御点击劫持：\"><a href=\"#防御点击劫持：\" class=\"headerlink\" title=\"防御点击劫持：\"></a>防御点击劫持：</h1><pre><code class=\"text\">通过在响应头中设置 X-Frame-Options 或 Content-Security-Policy，限制页面被嵌套到其他网站的情况。\n对于现代浏览器，可以使用 Frame-ancestors CSP 指令来进一步控制允许嵌套页面的来源。\n</code></pre>\n<h1 id=\"定期安全审查和漏洞扫描：\"><a href=\"#定期安全审查和漏洞扫描：\" class=\"headerlink\" title=\"定期安全审查和漏洞扫描：\"></a>定期安全审查和漏洞扫描：</h1><pre><code class=\"text\">定期进行安全审查，检查代码中的潜在漏洞和安全隐患。\n使用自动化工具进行漏洞扫描和代码静态分析，及时发现可能存在的安全问题。\n</code></pre>\n<h1 id=\"消息传递的安全性：\"><a href=\"#消息传递的安全性：\" class=\"headerlink\" title=\"消息传递的安全性：\"></a>消息传递的安全性：</h1><pre><code class=\"text\">对于敏感信息的传递，尽量使用加密算法加密数据。\n避免将敏感信息直接传递给前端，而是在后端进行敏感信息的处理和加密。\n</code></pre>\n<h1 id=\"防御代码注入攻击：\"><a href=\"#防御代码注入攻击：\" class=\"headerlink\" title=\"防御代码注入攻击：\"></a>防御代码注入攻击：</h1><pre><code class=\"text\">避免在前端中执行不受信任的代码。\n不要将用户输入直接拼接到代码字符串中，以防止代码注入攻击。\n</code></pre>\n<h1 id=\"防御文件上传漏洞：\"><a href=\"#防御文件上传漏洞：\" class=\"headerlink\" title=\"防御文件上传漏洞：\"></a>防御文件上传漏洞：</h1><pre><code class=\"text\">对用户上传的文件进行严格的验证和过滤，并使用独立的文件存储来避免安全问题。\n验证文件类型、大小和内容，确保只接受合法和安全的文件。\n</code></pre>\n<h1 id=\"安全的第三方组件和库：\"><a href=\"#安全的第三方组件和库：\" class=\"headerlink\" title=\"安全的第三方组件和库：\"></a>安全的第三方组件和库：</h1><pre><code class=\"text\">在使用第三方组件和库时，选择经过广泛审查和更新的可信来源。\n定期更新和升级第三方组件，以获取最新的安全修复和功能改进。\n</code></pre>\n<h1 id=\"保护敏感信息：\"><a href=\"#保护敏感信息：\" class=\"headerlink\" title=\"保护敏感信息：\"></a>保护敏感信息：</h1><pre><code class=\"text\">不要将敏感信息直接存储在前端，如密码、密钥等。\n使用加密算法对敏感信息进行加密，并在后端进行处理和存储。\n</code></pre>\n",
            "tags": [
                "前端开发",
                "web安全",
                "web综合问题"
            ]
        },
        {
            "id": "https://pink-png.github.io/Web-Integration/%E6%B5%8F%E8%A7%88%E5%99%A8%E9%9D%A2%E8%AF%95/",
            "url": "https://pink-png.github.io/Web-Integration/%E6%B5%8F%E8%A7%88%E5%99%A8%E9%9D%A2%E8%AF%95/",
            "title": "web综合问题",
            "date_published": "2021-06-25T08:43:00.000Z",
            "content_html": "<h1 id=\"常见的浏览器内核有哪些？\"><a href=\"#常见的浏览器内核有哪些？\" class=\"headerlink\" title=\"常见的浏览器内核有哪些？\"></a>常见的浏览器内核有哪些？</h1><p>主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。<br>渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。<br>JS引擎则：解析和执行javascript来实现网页的动态效果。<br>最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。<br>常见内核<br>Trident 内核：IE, MaxThon, TT, The World, 360, 搜狗浏览器等。[又称 MSHTML]<br>Gecko 内核：Netscape6 及以上版本，FF, MozillaSuite &#x2F; SeaMonkey 等<br>Presto 内核：Opera7 及以上。 [Opera内核原为：Presto，现为：Blink;]<br>Webkit 内核：Safari, Chrome等。 [ Chrome的：Blink（WebKit 的分支）]</p>\n<h1 id=\"网页前端性能优化的方式有哪些？\"><a href=\"#网页前端性能优化的方式有哪些？\" class=\"headerlink\" title=\"网页前端性能优化的方式有哪些？\"></a>网页前端性能优化的方式有哪些？</h1><p>1.压缩 css, js, 图片<br>2.减少 http 请求次数， 合并 css、js 、合并图片（雪碧图）<br>3.使用 CDN<br>4.减少 dom 元素数量<br>5.图片懒加载<br>6.静态资源另外用无 cookie 的域名<br>7.减少 dom 的访问（缓存 dom）<br>8.巧用事件委托<br>9.样式表置顶、脚本置低</p>\n<h1 id=\"网页从输入网址到渲染完成经历了哪些过程？\"><a href=\"#网页从输入网址到渲染完成经历了哪些过程？\" class=\"headerlink\" title=\"网页从输入网址到渲染完成经历了哪些过程？\"></a>网页从输入网址到渲染完成经历了哪些过程？</h1><p>大致可以分为如下7步：</p>\n<p>输入网址；<br>发送到DNS服务器，并获取域名对应的web服务器对应的ip地址；<br>与web服务器建立TCP连接；<br>浏览器向web服务器发送http请求；<br>web服务器响应请求，并返回指定url的数据（或错误信息，或重定向的新的url地址）；<br>浏览器下载web服务器返回的数据及解析html源文件；<br>生成DOM树，解析css和js，渲染页面，直至显示完成；</p>\n<h1 id=\"线程与进程的区别？\"><a href=\"#线程与进程的区别？\" class=\"headerlink\" title=\"线程与进程的区别？\"></a>线程与进程的区别？</h1><p>一个程序至少有一个进程,一个进程至少有一个线程.<br>线程的划分尺度小于进程，使得多线程程序的并发性高。<br>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。<br>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。<br>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</p>\n<h1 id=\"HTTP常见的状态码？\"><a href=\"#HTTP常见的状态码？\" class=\"headerlink\" title=\"HTTP常见的状态码？\"></a>HTTP常见的状态码？</h1><p>100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息<br>200 OK 正常返回信息<br>201 Created 请求成功并且服务器创建了新的资源<br>202 Accepted 服务器已接受请求，但尚未处理<br>301 Moved Permanently 请求的网页已永久移动到新位置。<br>302 Found 临时性重定向。<br>303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。<br>304 Not Modified 自从上次请求后，请求的网页未修改过。<br>400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。<br>401 Unauthorized 请求未授权。<br>403 Forbidden 禁止访问。<br>404 Not Found 找不到如何与 URI 相匹配的资源。<br>500 Internal Server Error 最常见的服务器端错误。<br>503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。</p>\n<h1 id=\"图片懒加载？\"><a href=\"#图片懒加载？\" class=\"headerlink\" title=\"图片懒加载？\"></a>图片懒加载？</h1><p>当页面滚动的时间被触发 -&gt; 执行加载图片操作 -&gt; 判断图片是否在可视区域内 -&gt; 在，则动态将data-src的值赋予该图片</p>\n<h1 id=\"移动端性能优化？\"><a href=\"#移动端性能优化？\" class=\"headerlink\" title=\"移动端性能优化？\"></a>移动端性能优化？</h1><p>尽量使用css3动画，开启硬件加速<br>适当使用touch时间代替click时间<br>避免使用css3渐变阴影效果<br>可以用transform: translateZ(0) 来开启硬件加速<br>不滥用float。float在渲染时计算量比较大，尽量减少使用<br>不滥用web字体。web字体需要下载，解析，重绘当前页面<br>合理使用requestAnimationFrame动画代替setTimeout<br>css中的属性（css3 transitions、css3 3D transforms、opacity、webGL、video）会触发GUP渲染，耗电</p>\n<h1 id=\"TCP-传输的三次握手、四次挥手策略\"><a href=\"#TCP-传输的三次握手、四次挥手策略\" class=\"headerlink\" title=\"TCP 传输的三次握手、四次挥手策略\"></a>TCP 传输的三次握手、四次挥手策略</h1><p>三次握手：<br>为了准确无误地吧数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送出去后，TCP不会对传送后的情况置之不理，他一定会向对方确认是否送达，握手过程中使用TCP的标志：SYN和ACK<br>发送端首先发送一个带SYN的标志的数据包给对方<br>接收端收到后，回传一个带有SYN&#x2F;ACK标志的数据包以示传达确认信息<br>最后，发送端再回传一个带ACK的标志的数据包，代表“握手”结束<br>如在握手过程中某个阶段莫明中断，TCP协议会再次以相同的顺序发送相同的数据包</p>\n<p>断开一个TCP连接需要“四次挥手”<br>第一次挥手：主动关闭方发送一个FIN，用来关注主动方到被动关闭方的数据传送，也即是主动关闭方告诫被动关闭方：我已经不会再给你发数据了（在FIN包之前发送的数据，如果没有收到对应的ACK确认报文，主动关闭方依然会重发这些数据）。但是，此时主动关闭方还可以接受数据<br>第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号收到序号 +1（与SYN相同，一个 FIN占用一个序号）<br>第三次挥手：被动关闭方发送一个 FIN。用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会给你发送数据了<br>第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手</p>\n<h1 id=\"HTTP-和-HTTPS，为什么HTTPS安全？\"><a href=\"#HTTP-和-HTTPS，为什么HTTPS安全？\" class=\"headerlink\" title=\"HTTP 和 HTTPS，为什么HTTPS安全？\"></a>HTTP 和 HTTPS，为什么HTTPS安全？</h1><p>HTTP协议通常承载与 TCP协议之上，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的HTTPS<br>默认HTTP的端口号为80，HTTPS的端口号为443<br>因为网络请求需要中间有很多的服务器路由的转发，中间的节点都可能篡改信息，而如果使用HTTPS，密钥在你和终点站才有，https之所有说比http安全，是因为他利用ssl&#x2F;tls协议传输。包含证书，流量转发，负载均衡，页面适配，浏览器适配，refer传递等，保障了传输过程的安全性</p>\n<h1 id=\"axios和fetch区别对比\"><a href=\"#axios和fetch区别对比\" class=\"headerlink\" title=\"axios和fetch区别对比\"></a>axios和fetch区别对比</h1><p>axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，本质上也是对原生XHR的封装，只不过它是Promise的实现版本，符合最新的ES规范，它本身具有以下特征</p>\n<p>从浏览器中创建 XMLHttpRequest<br>支持 Promise API<br>客户端支持防止CSRF<br>提供了一些并发请求的接口（重要，方便了很多的操作）<br>从 node.js 创建 http 请求<br>拦截请求和响应<br>转换请求和响应数据<br>取消请求<br>自动转换JSON数据<br>fetch优势：</p>\n<p>语法简洁，更加语义化<br>基于标准 Promise 实现，支持 async&#x2F;await<br>同构方便，使用 isomorphic-fetch<br>更加底层，提供的API丰富（request, response）<br>脱离了XHR，是ES规范里新的实现方式<br>fetch存在问题</p>\n<p>fetch是一个低层次的API，你可以把它考虑成原生的XHR，所以使用起来并不是那么舒服，需要进行封装。<br>fetch只对网络请求报错，对400，500都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。<br>fetch默认不会带cookie，需要添加配置项： fetch(url, {credentials: ‘include’})<br>fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费<br>fetch没有办法原生监测请求的进度，而XHR可以</p>\n",
            "tags": [
                "前端开发",
                "浏览器",
                "web综合问题"
            ]
        },
        {
            "id": "https://pink-png.github.io/Web-Integration/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/",
            "url": "https://pink-png.github.io/Web-Integration/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/",
            "title": "浏览器缓存机制",
            "date_published": "2021-06-25T08:43:00.000Z",
            "content_html": "<h1 id=\"浏览器缓存机制\"><a href=\"#浏览器缓存机制\" class=\"headerlink\" title=\"浏览器缓存机制\"></a>浏览器缓存机制</h1><p>浏览器缓存机制是指浏览器在处理网页资源时，将一部分资源保存在本地存储中，以便下次请求相同资源时可以快速获取，从而提高网页加载速度和用户体验。以下是常见的浏览器缓存机制：</p>\n<h1 id=\"强缓存\"><a href=\"#强缓存\" class=\"headerlink\" title=\"强缓存\"></a>强缓存</h1><ol>\n<li>浏览器在第一次请求资源时，服务器通过响应头中的Cache-Control或Expires字段返回资源，并将这些信息保存在浏览器缓存中。在下一次请求相同资源时，浏览器会直接从缓存中读取，而不发起请求</li>\n<li>常用的Cache-Control值有：</li>\n</ol>\n<ul>\n<li>public：表示资源可以被所有用户及代理服务器缓存。</li>\n<li>private：表示资源只能被单个用户缓存，不允许代理服务器缓存。</li>\n<li>max-age：表示资源在缓存中的有效期，单位为秒。</li>\n</ul>\n<h1 id=\"协商缓存\"><a href=\"#协商缓存\" class=\"headerlink\" title=\"协商缓存\"></a>协商缓存</h1><ol>\n<li>在资源过期后，浏览器会发送一个带有If-Modified-Since（Last-Modified）或If-None-Match（ETag）字段的请求到服务器，询问该资源是否有更新。如果服务器返回304 Not Modified状态码，则表示资源未发生变化，浏览器会直接从缓存中读取。</li>\n<li>常用的响应头字段有：</li>\n</ol>\n<ul>\n<li>Last-Modified：表示资源的最后修改时间。</li>\n<li>ETag：表示资源的唯一标识符。</li>\n</ul>\n<h1 id=\"离线缓存\"><a href=\"#离线缓存\" class=\"headerlink\" title=\"离线缓存\"></a>离线缓存</h1><ol>\n<li>HTML5提供了离线缓存机制，使用manifest文件来定义需要缓存的资源。浏览器在第一次访问网页时会下载manifest文件并根据文件中的信息缓存相应资源。在之后的访问中，即使处于离线状态，浏览器仍然能够加载并显示已缓存的页面。离线缓存可以提高网页的可访问性和性能。</li>\n</ol>\n<h1 id=\"缓存位置\"><a href=\"#缓存位置\" class=\"headerlink\" title=\"缓存位置\"></a>缓存位置</h1><ol>\n<li><p>内存缓存（Memory Cache）：<br>内存缓存是最快的缓存位置，将资源直接保存在浏览器内存中。<br>内存缓存的读取速度非常快，可以快速响应请求，适用于频繁请求和临时性资源。<br>但是，内存缓存的容量有限，并且在浏览器关闭时会被清空。</p>\n</li>\n<li><p>硬盘缓存（Disk Cache）：<br>硬盘缓存将资源保存在硬盘上，相对于内存缓存来说读取速度较慢，但比重新请求资源要快得多。<br>硬盘缓存可以持久保存资源，并且在浏览器关闭后仍然可用。<br>硬盘缓存的容量相对较大，可以保存更多的资源。</p>\n</li>\n<li><p>服务端缓存：<br>服务端缓存是指将资源保存在服务器端，由服务器返回缓存的资源给浏览器。<br>服务端缓存可以利用类似缓存代理、CDN等方式来提升资源获取速度，减轻服务器的压力。<br>服务端缓存可以根据资源的过期时间或版本号来判断是否返回缓存资源。</p>\n</li>\n<li><p>Service Worker 缓存：<br>Service Worker 是运行在浏览器后台的脚本，可以拦截网络请求并自定义响应。<br>Service Worker 可以将资源保存在本地缓存中，实现离线访问或快速加载。<br>Service Worker 缓存具有灵活性和高度可自定义的特性，适用于离线应用、推送通知等场景。</p>\n</li>\n</ol>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>通过合理设置缓存策略，可以减少对服务器的请求次数，加快网页加载速度，降低网络流量消耗。同时，如果网页内容有更新，通过修改资源的版本号或过期时间等方式来使浏览器重新请求新的资源版本。</p>\n",
            "tags": [
                "前端开发",
                "浏览器",
                "web综合问题"
            ]
        },
        {
            "id": "https://pink-png.github.io/Web-Integration/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/",
            "url": "https://pink-png.github.io/Web-Integration/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/",
            "title": "浏览器渲染原理以及优化思路",
            "date_published": "2021-06-25T08:43:00.000Z",
            "content_html": "<h1 id=\"浏览器渲染原理\"><a href=\"#浏览器渲染原理\" class=\"headerlink\" title=\"浏览器渲染原理\"></a>浏览器渲染原理</h1><pre><code class=\"text\">1. 渲染过程：\n解析HTML：浏览器解析HTML代码，构建DOM树。\n解析CSS：浏览器解析CSS样式表，构建CSSOM树。\n构建渲染树：将DOM树和CSSOM树合并成渲染树，该树只包含需要显示元素的信息。\n布局（Layout）：计算每个元素的大小和位置。\n绘制（Paint）：根据计算好的布局信息，将每个元素绘制成屏幕上的像素。\n合成（Composite）：将绘制好的元素按正确的顺序合成到最终的图像上。\n\n2. 阻塞过程：\n脚本阻塞：当浏览器遇到&lt;script&gt;标签或执行JavaScript代码时，会暂停HTML解析和渲染，直到脚本执行完毕。\n样式加载阻塞：如果浏览器遇到外部CSS文件，会等待该文件下载和解析完毕后再继续渲染。\n资源加载阻塞：当浏览器遇到资源文件如图片、字体或其他媒体时，会等待资源下载和加载完毕后再继续渲染。\n\n3. 重绘与汇流：\n重绘（Repaint）：当元素的样式改变，但不影响布局时，浏览器只需要重新绘制元素的可视部分。\n汇流（Reflow）：当布局发生改变，例如改变元素的大小或位置时，浏览器需要重新计算并调整元素的布局和相关元素的位置。\n</code></pre>\n<h1 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h1><pre><code class=\"text\">1. 减少阻塞时间：\n脚本加载优化：将JavaScript脚本放在页面底部，或者使用defer属性将其延迟执行，以免阻塞HTML解析和渲染过程。\n样式加载优化：将CSS样式表放在&lt;head&gt;标签中，避免样式表的加载阻塞页面渲染。\n资源加载优化：使用合适的缓存策略、减小资源文件的大小，以及使用CDN等方式来提高资源加载速度。\n\n2. 最小化重绘与汇流：\n批量修改样式：避免频繁读取和修改单个元素的样式属性，最好使用CSS类进行批量修改，这样可以减少重绘和汇流的次数。\n避免强制同步布局：在修改多个元素的样式时，避免强制同步布局，即尽量将布局相关的修改集中在一起，减少不必要的重绘和汇流。\n\n3.使用现代CSS特性：\n使用CSS动画代替JavaScript动画：CSS动画借助浏览器的硬件加速，性能更高，并且不会阻塞JavaScript主线程。\n使用CSS Grid 和 Flexbox 布局：这些现代的布局方式能够更有效地处理布局，减少重绘和汇流的次数。\n\n4.图片优化：\n使用适当的图片格式：根据图片特性选择合适的图片格式，例如JPEG、PNG、WebP等，以尽量减小文件大小。\n图片懒加载：只在视口范围内加载可见区域的图片，延迟加载其他图片，以提高页面加载速度。\n\n5. 代码优化：\n避免频繁操作DOM：减少对DOM的修改和查询次数，可以使用文档片段（DocumentFragment）来进行批量操作。\n压缩和合并代码：对CSS和JavaScript文件进行压缩和合并，减小文件体积，加快加载速度。\n</code></pre>\n",
            "tags": [
                "前端开发",
                "浏览器",
                "web综合问题"
            ]
        },
        {
            "id": "https://pink-png.github.io/front-end/Bootstrap/",
            "url": "https://pink-png.github.io/front-end/Bootstrap/",
            "title": "Bootstrap",
            "date_published": "2021-06-25T08:43:00.000Z",
            "content_html": "<h1 id=\"什么是Bootstrap？以及为什么要使⽤Bootstrap？\"><a href=\"#什么是Bootstrap？以及为什么要使⽤Bootstrap？\" class=\"headerlink\" title=\"什么是Bootstrap？以及为什么要使⽤Bootstrap？\"></a>什么是Bootstrap？以及为什么要使⽤Bootstrap？</h1><ol>\n<li>Bootstrap 是⼀个⽤于快速开发 Web 应⽤程序和⽹站的前端框架。</li>\n<li>Bootstrap 是基于 HTML 、 CSS 、 JAVASCRIPT 的</li>\n<li>Bootstrap 具有移动设备优先、浏览器⽀持良好、容易上⼿、响应式设计等优点，所以Bootstrap 被⼴泛应⽤</li>\n</ol>\n<h1 id=\"使⽤Bootstrap时，要声明的⽂档类型是什么？以及为什么要这样声明？\"><a href=\"#使⽤Bootstrap时，要声明的⽂档类型是什么？以及为什么要这样声明？\" class=\"headerlink\" title=\"使⽤Bootstrap时，要声明的⽂档类型是什么？以及为什么要这样声明？\"></a>使⽤Bootstrap时，要声明的⽂档类型是什么？以及为什么要这样声明？</h1><ol>\n<li>使⽤ Bootstrap 时，需要使⽤ HTML5 ⽂档类型（ Doctype ）。 <!DOCTYPE html></li>\n<li>因为 Bootstrap 使⽤了⼀些 HTML5 元素和 CSS 属性，如果在 Bootstrap 创建的⽹⻚开头不使⽤ HTML5 的⽂档类型（ Doctype ），可能会⾯临⼀些浏览器显示不⼀致的问题，甚⾄可能⾯临⼀些特定情境下的不⼀致，以致于代码不能通过 W3C 标准的验证</li>\n</ol>\n<h1 id=\"什么是Bootstrap⽹格系统\"><a href=\"#什么是Bootstrap⽹格系统\" class=\"headerlink\" title=\"什么是Bootstrap⽹格系统\"></a>什么是Bootstrap⽹格系统</h1><ol>\n<li>Bootstrap 包含了⼀个响应式的、移动设备优先的、不固定的⽹格系统，可以随着设备或视⼝⼤⼩的增加⽽适当地扩展到 12 列。它包含了⽤于简单的布局选项的预定义类，也包含了⽤于⽣成更多语义布局的功能强⼤的混合类</li>\n<li>响应式⽹格系统随着屏幕或视⼝（ viewport ）尺⼨的增加，系统会⾃动分为最多 12列。</li>\n</ol>\n<h1 id=\"Bootstrap-⽹格系统（Grid-System）的⼯作原理\"><a href=\"#Bootstrap-⽹格系统（Grid-System）的⼯作原理\" class=\"headerlink\" title=\"Bootstrap ⽹格系统（Grid System）的⼯作原理\"></a>Bootstrap ⽹格系统（Grid System）的⼯作原理</h1><p>（1）⾏必须放置在 .container class 内，以便获得适当的对⻬（ alignment ）和内<br>边距（ padding ）。<br>（2）使⽤⾏来创建列的⽔平组。<br>（3）内容应该放置在列内，且唯有列可以是⾏的直接⼦元素。<br>（4）预定义的⽹格类，⽐如 .row 和 .col-xs-4 ，可⽤于快速创建⽹格布局。 LESS<br>混合类可⽤于更多语义布局。<br>（5）列通过内边距（ padding ）来创建列内容之间的间隙。该内边距是通过 .rows 上<br>的外边距（ margin ）取负，表示第⼀列和最后⼀列的⾏偏移。<br>（6）⽹格系统是通过指定您想要横跨的⼗⼆个可⽤的列来创建的。例如，要创建三个相等<br>的列，则使⽤三个 .col-xs-4</p>\n<h1 id=\"对于各类尺⼨的设备，Bootstrap设置的class前缀分别是什么\"><a href=\"#对于各类尺⼨的设备，Bootstrap设置的class前缀分别是什么\" class=\"headerlink\" title=\"对于各类尺⼨的设备，Bootstrap设置的class前缀分别是什么\"></a>对于各类尺⼨的设备，Bootstrap设置的class前缀分别是什么</h1><ol>\n<li>超⼩设备⼿机（ &lt;768px ）： .col-xs-*</li>\n<li>⼩型设备平板电脑（ &gt;&#x3D;768px ）： .col-sm-*</li>\n<li>中型设备台式电脑（ &gt;&#x3D;992px ）： .col-md-*</li>\n<li>⼤型设备台式电脑（ &gt;&#x3D;1200px ）： .col-lg-*</li>\n</ol>\n<h1 id=\"Bootstrap-⽹格系统列与列之间的间隙宽度是多少\"><a href=\"#Bootstrap-⽹格系统列与列之间的间隙宽度是多少\" class=\"headerlink\" title=\"Bootstrap ⽹格系统列与列之间的间隙宽度是多少\"></a>Bootstrap ⽹格系统列与列之间的间隙宽度是多少</h1><p>间隙宽度为 30px （⼀个列的每边分别是 15px ）</p>\n<h1 id=\"如果需要在⼀个标题的旁边创建副标题，可以怎样操作\"><a href=\"#如果需要在⼀个标题的旁边创建副标题，可以怎样操作\" class=\"headerlink\" title=\"如果需要在⼀个标题的旁边创建副标题，可以怎样操作\"></a>如果需要在⼀个标题的旁边创建副标题，可以怎样操作</h1><p>在元素两旁添加 <small> ，或者添加 .small 的 class</p>\n<h1 id=\"⽤Bootstrap，如何设置⽂字的对⻬⽅式\"><a href=\"#⽤Bootstrap，如何设置⽂字的对⻬⽅式\" class=\"headerlink\" title=\"⽤Bootstrap，如何设置⽂字的对⻬⽅式\"></a>⽤Bootstrap，如何设置⽂字的对⻬⽅式</h1><ol>\n<li>class&#x3D;”text-center” 设置居中⽂本</li>\n<li>class&#x3D;”text-right” 设置向右对⻬⽂本</li>\n<li>class&#x3D;”text-left” 设置向左对⻬⽂本</li>\n</ol>\n<h1 id=\"Bootstrap如何设置响应式表格？\"><a href=\"#Bootstrap如何设置响应式表格？\" class=\"headerlink\" title=\"Bootstrap如何设置响应式表格？\"></a>Bootstrap如何设置响应式表格？</h1><p>增加 class&#x3D;”table-responsive”</p>\n<h1 id=\"使⽤Bootstrap创建垂直表单的基本步骤？\"><a href=\"#使⽤Bootstrap创建垂直表单的基本步骤？\" class=\"headerlink\" title=\"使⽤Bootstrap创建垂直表单的基本步骤？\"></a>使⽤Bootstrap创建垂直表单的基本步骤？</h1><p>（1）向⽗ <form> 元素添加 role&#x3D;”form” ；<br>（2）把标签和控件放在⼀个带有 class&#x3D;”form-group” 的 <div> 中，这是获取最佳间距<br>所必需的；<br>（3）向所有的⽂本元素 <input> 、 <textarea> 、 <select> 添加 class&#x3D;”form-control”</p>\n<h1 id=\"使⽤Bootstrap创建⽔平表单的基本步骤？\"><a href=\"#使⽤Bootstrap创建⽔平表单的基本步骤？\" class=\"headerlink\" title=\"使⽤Bootstrap创建⽔平表单的基本步骤？\"></a>使⽤Bootstrap创建⽔平表单的基本步骤？</h1><p>（1）向⽗ <form> 元素添加 class&#x3D;”form-horizontal” ；<br>（2）把标签和控件放在⼀个带有 class&#x3D;”form-group” 的 <div> 中；<br>（3）向标签添加 class&#x3D;”control-label” 。</p>\n<h1 id=\"使⽤Bootstrap如何创建表单控件的帮助⽂本？\"><a href=\"#使⽤Bootstrap如何创建表单控件的帮助⽂本？\" class=\"headerlink\" title=\"使⽤Bootstrap如何创建表单控件的帮助⽂本？\"></a>使⽤Bootstrap如何创建表单控件的帮助⽂本？</h1><p>增加 class&#x3D;”help-block” 的 span 标签或 p 标签。</p>\n<h1 id=\"使⽤Bootstrap激活或禁⽤按钮要如何操作？\"><a href=\"#使⽤Bootstrap激活或禁⽤按钮要如何操作？\" class=\"headerlink\" title=\"使⽤Bootstrap激活或禁⽤按钮要如何操作？\"></a>使⽤Bootstrap激活或禁⽤按钮要如何操作？</h1><ol>\n<li>激活按钮：给按钮增加 .active 的 class</li>\n<li>禁⽤按钮：给按钮增加 disabled&#x3D;”disabled” 的属性</li>\n</ol>\n<h1 id=\"Bootstrap有哪些关于的class？\"><a href=\"#Bootstrap有哪些关于的class？\" class=\"headerlink\" title=\"Bootstrap有哪些关于的class？\"></a>Bootstrap有哪些关于的class？</h1><p>（1） .img-rounded 为图⽚添加圆⻆<br>（2） .img-circle 将图⽚变为圆形<br>（3） .img-thumbnail 缩略图功能<br>（4） .img-responsive 图⽚响应式 (将很好地扩展到⽗元素)</p>\n<h1 id=\"Bootstrap中有关元素浮动及清除浮动的class？\"><a href=\"#Bootstrap中有关元素浮动及清除浮动的class？\" class=\"headerlink\" title=\"Bootstrap中有关元素浮动及清除浮动的class？\"></a>Bootstrap中有关元素浮动及清除浮动的class？</h1><p>（1） class&#x3D;”pull-left” 元素浮动到左边<br>（2） class&#x3D;”pull-right” 元素浮动到右边<br>（3） class&#x3D;”clearfix” 清除浮动</p>\n<h1 id=\"除了屏幕阅读器外，其他设备上隐藏元素的class？\"><a href=\"#除了屏幕阅读器外，其他设备上隐藏元素的class？\" class=\"headerlink\" title=\"除了屏幕阅读器外，其他设备上隐藏元素的class？\"></a>除了屏幕阅读器外，其他设备上隐藏元素的class？</h1><p><code>class=&quot;sr-only</code></p>\n<h1 id=\"Bootstrap如何制作下拉菜单？\"><a href=\"#Bootstrap如何制作下拉菜单？\" class=\"headerlink\" title=\"Bootstrap如何制作下拉菜单？\"></a>Bootstrap如何制作下拉菜单？</h1><p>（1）将下拉菜单包裹在 class&#x3D;”dropdown” 的 <div> 中；<br>（2）在触发下拉菜单的按钮中添加： class&#x3D;”btn dropdown-toggle”<br>id&#x3D;”dropdownMenu1” data-toggle&#x3D;”dropdown”<br>（3）在包裹下拉菜单的ul中添加： class&#x3D;”dropdown-menu” role&#x3D;”menu” aria-labelledby&#x3D;”dropdownMenu1”<br>（4）在下拉菜单的列表项中添加： role&#x3D;”presentation” 。其中，下拉菜单的标题要添<br>加 class&#x3D;”dropdown-header” ，选项部分要添加 tabindex&#x3D;”-1” 。</p>\n<h1 id=\"Bootstrap如何制作按钮组？以及⽔平按钮组和垂直按钮组的优先级？\"><a href=\"#Bootstrap如何制作按钮组？以及⽔平按钮组和垂直按钮组的优先级？\" class=\"headerlink\" title=\"Bootstrap如何制作按钮组？以及⽔平按钮组和垂直按钮组的优先级？\"></a>Bootstrap如何制作按钮组？以及⽔平按钮组和垂直按钮组的优先级？</h1><p>（1）⽤ class&#x3D;”btn-group” 的 <div> 去包裹按钮组； class&#x3D;”btn-group-vertical” 可设置垂直按钮组。<br>（2） btn-group 的优先级⾼于 btn-group-vertical 的优先级。</p>\n<h1 id=\"Bootstrap如何设置按钮的下拉菜单？\"><a href=\"#Bootstrap如何设置按钮的下拉菜单？\" class=\"headerlink\" title=\"Bootstrap如何设置按钮的下拉菜单？\"></a>Bootstrap如何设置按钮的下拉菜单？</h1><p>在⼀个 .btn-group 中放置按钮和下拉菜单即可。</p>\n<h1 id=\"Bootstrap中的输⼊框组如何制作？\"><a href=\"#Bootstrap中的输⼊框组如何制作？\" class=\"headerlink\" title=\"Bootstrap中的输⼊框组如何制作？\"></a>Bootstrap中的输⼊框组如何制作？</h1><p>（1）把前缀或者后缀元素放在⼀个带有 class&#x3D;”input-group” 中的 <div> 中<br>（2）在该 <div> 内，在 class&#x3D;”input-group-addon” 的 <span> ⾥⾯放置额外的内<br>容；<br>（3）把 <span> 放在 <input> 元素的前⾯或后⾯。</p>\n<h1 id=\"Bootstrap中的导航都有哪些？\"><a href=\"#Bootstrap中的导航都有哪些？\" class=\"headerlink\" title=\"Bootstrap中的导航都有哪些？\"></a>Bootstrap中的导航都有哪些？</h1><p>（1）导航元素：有 class&#x3D;”nav nav-tabs” 的标签⻚导航，还有 class&#x3D;”nav nav\u0002pills” 的胶囊式标签⻚导航；<br>（2）导航栏： class&#x3D;”navbar navbar-default” role&#x3D;”navigation” ；<br>（3）⾯包屑导航： class&#x3D;”breadcrumb”</p>\n<h1 id=\"Bootstrap中设置分⻚的class？\"><a href=\"#Bootstrap中设置分⻚的class？\" class=\"headerlink\" title=\"Bootstrap中设置分⻚的class？\"></a>Bootstrap中设置分⻚的class？</h1><ol>\n<li>默认的分⻚： class&#x3D;”pagination”</li>\n<li>默认的翻⻚： class&#x3D;”pager”</li>\n</ol>\n<h1 id=\"Bootstrap中显示标签的class？\"><a href=\"#Bootstrap中显示标签的class？\" class=\"headerlink\" title=\"Bootstrap中显示标签的class？\"></a>Bootstrap中显示标签的class？</h1><p>class&#x3D;”label”</p>\n<h1 id=\"Bootstrap中如何制作徽章？\"><a href=\"#Bootstrap中如何制作徽章？\" class=\"headerlink\" title=\"Bootstrap中如何制作徽章？\"></a>Bootstrap中如何制作徽章？</h1><pre><code class=\"css\">&lt;span class=&quot;badge&quot;&gt;26&lt;/span&gt;\n</code></pre>\n<h1 id=\"Bootstrap中超⼤屏幕的作⽤是什么\"><a href=\"#Bootstrap中超⼤屏幕的作⽤是什么\" class=\"headerlink\" title=\"Bootstrap中超⼤屏幕的作⽤是什么\"></a>Bootstrap中超⼤屏幕的作⽤是什么</h1><pre><code class=\"text\">设置 class=&quot;jumbotron&quot; 可以制作超⼤屏幕，该组件可以增加标题的⼤⼩并\n增加更多的外边距\n</code></pre>\n",
            "tags": [
                "前端开发",
                "Bootstrap",
                "Bootstrap"
            ]
        },
        {
            "id": "https://pink-png.github.io/Web-Integration/%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/",
            "url": "https://pink-png.github.io/Web-Integration/%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/",
            "title": "跨域解决方案",
            "date_published": "2021-06-25T08:43:00.000Z",
            "content_html": "<h1 id=\"什么是跨域？\"><a href=\"#什么是跨域？\" class=\"headerlink\" title=\"什么是跨域？\"></a>什么是跨域？</h1><pre><code class=\"text\">在前端领域中，跨域是指浏览器允许向服务器发送跨域请求，从而克服Ajax只能**同源**使用的限制。\n\n什么是同源策略？\n\n**同源策略**是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指&quot;协议+域名+端口&quot;三者相同，即便两个不同的域名指向同一个ip地址，也非同源\n\n同源策略限制以下几种行为：\n\n- Cookie、LocalStorage 和 IndexDB 无法读取\n- DOM和JS对象无法获得\n- AJAX 请求不能发送\n\n举例说明：⽐如⼀个⿊客程序，他利⽤ Iframe 把真正的银⾏登录⻚⾯嵌到他的⻚⾯上，\n当你使⽤真实的⽤户名，密码登录时，他的⻚⾯就可以通过 Javascript 读取到你的表单\n中 input 中的内容，这样⽤户名，密码就轻松到⼿了。\n</code></pre>\n<h1 id=\"JSONP跨域\"><a href=\"#JSONP跨域\" class=\"headerlink\" title=\"JSONP跨域\"></a>JSONP跨域</h1><p><strong>jsonp</strong>的原理就是利用<code>&lt;script&gt;</code>标签没有跨域限制，通过<code>&lt;script&gt;</code>标签src属性，发送带有callback参数的GET请求，服务端将接口返回数据拼凑到callback函数中，返回给浏览器，浏览器解析执行，从而前端拿到callback函数返回的数据。</p>\n<p>1）原生JS实现：</p>\n<pre><code class=\"text\">&lt;script&gt;\n    var script = document.createElement(&#39;script&#39;);\n    script.type = &#39;text/javascript&#39;;\n\n    // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数\n    script.src = &#39;http://www.domain2.com:8080/login?user=admin&amp;callback=handleCallback&#39;;\n    document.head.appendChild(script);\n\n    // 回调执行函数\n    function handleCallback(res) &#123;\n        alert(JSON.stringify(res));\n    &#125;\n &lt;/script&gt;\n</code></pre>\n<p>服务端返回如下（返回时即执行全局函数）：</p>\n<pre><code class=\"text\">handleCallback(&#123;&quot;success&quot;: true, &quot;user&quot;: &quot;admin&quot;&#125;)\n</code></pre>\n<p>2）jquery Ajax实现：</p>\n<pre><code class=\"text\">$.ajax(&#123;\n    url: &#39;http://www.domain2.com:8080/login&#39;,\n    type: &#39;get&#39;,\n    dataType: &#39;jsonp&#39;,  // 请求方式为jsonp\n    jsonpCallback: &quot;handleCallback&quot;,  // 自定义回调函数名\n    data: &#123;&#125;\n&#125;);\n</code></pre>\n<p>3）Vue axios实现：</p>\n<pre><code class=\"text\">this.$http = axios;\nthis.$http.jsonp(&#39;http://www.domain2.com:8080/login&#39;, &#123;\n    params: &#123;&#125;,\n    jsonp: &#39;handleCallback&#39;\n&#125;).then((res) =&gt; &#123;\n    console.log(res); \n&#125;)\n</code></pre>\n<p>后端node.js代码：</p>\n<pre><code class=\"text\">var querystring = require(&#39;querystring&#39;);\nvar http = require(&#39;http&#39;);\nvar server = http.createServer();\n\nserver.on(&#39;request&#39;, function(req, res) &#123;\n    var params = querystring.parse(req.url.split(&#39;?&#39;)[1]);\n    var fn = params.callback;\n\n    // jsonp返回设置\n    res.writeHead(200, &#123; &#39;Content-Type&#39;: &#39;text/javascript&#39; &#125;);\n    res.write(fn + &#39;(&#39; + JSON.stringify(params) + &#39;)&#39;);\n\n    res.end();\n&#125;);\n\nserver.listen(&#39;8080&#39;);\nconsole.log(&#39;Server is running at port 8080...&#39;);\n</code></pre>\n<p>jsonp的缺点：只能发送get一种请求。</p>\n<h1 id=\"跨域资源共享（CORS）（后端配置跨域）\"><a href=\"#跨域资源共享（CORS）（后端配置跨域）\" class=\"headerlink\" title=\"跨域资源共享（CORS）（后端配置跨域）\"></a>跨域资源共享（CORS）（后端配置跨域）</h1><p><strong>CORS</strong>是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。<br>它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。<br>CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。</p>\n<p>浏览器将CORS跨域请求分为简单请求和非简单请求。</p>\n<p>只要同时满足一下两个条件，就属于简单请求</p>\n<p>(1)使用下列方法之一：</p>\n<ul>\n<li>head</li>\n<li>get</li>\n<li>post</li>\n</ul>\n<p>(2)请求的Heder是</p>\n<ul>\n<li>Accept</li>\n<li>Accept-Language</li>\n<li>Content-Language</li>\n<li>Content-Type: 只限于三个值：application&#x2F;x-www-form-urlencoded、multipart&#x2F;form-data、text&#x2F;plain</li>\n</ul>\n<p>不同时满足上面的两个条件，就属于非简单请求。浏览器对这两种的处理，是不一样的。</p>\n<p>简单请求</p>\n<p>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。</p>\n<pre><code class=\"text\">GET /cors HTTP/1.1\nOrigin: http://api.bob.com\nHost: api.alice.com\nAccept-Language: en-US\nConnection: keep-alive\nUser-Agent: Mozilla/5.0...\n</code></pre>\n<p>上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</p>\n<p>CORS请求设置的响应头字段，都以 Access-Control-开头:</p>\n<p><strong>1）Access-Control-Allow-Origin</strong>：必选</p>\n<p>它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。</p>\n<p><strong>2）Access-Control-Allow-Credentials</strong>：可选</p>\n<p>它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。</p>\n<p><strong>3）Access-Control-Expose-Headers</strong>：可选</p>\n<p>CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。</p>\n<p>非简单请求</p>\n<p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application&#x2F;json。非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。</p>\n<p>预检请求</p>\n<p>预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。请求头信息里面，关键字段是Origin，表示请求来自哪个源。除了Origin字段，”预检”请求的头信息包括两个特殊字段。</p>\n<pre><code class=\"text\">OPTIONS /cors HTTP/1.1\nOrigin: http://api.bob.com\nAccess-Control-Request-Method: PUT\nAccess-Control-Request-Headers: X-Custom-Header\nHost: api.alice.com\nAccept-Language: en-US\nConnection: keep-alive\nUser-Agent: Mozilla/5.0..\n</code></pre>\n<p><strong>1）Access-Control-Request-Method</strong>：必选</p>\n<p>用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。</p>\n<p><strong>2）Access-Control-Request-Headers</strong>：可选</p>\n<p>该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。</p>\n<p>预检请求的回应</p>\n<p>服务器收到”预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。</p>\n<p>HTTP回应中，除了关键的是Access-Control-Allow-Origin字段，其他CORS相关字段如下：</p>\n<p><strong>1）Access-Control-Allow-Methods</strong>：必选</p>\n<p>它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。</p>\n<p><strong>2）Access-Control-Allow-Headers</strong></p>\n<p>如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。</p>\n<p><strong>3）Access-Control-Allow-Credentials</strong>：可选</p>\n<p>该字段与简单请求时的含义相同。</p>\n<p><strong>4）Access-Control-Max-Age</strong>：可选</p>\n<p>用来指定本次预检请求的有效期，单位为秒。</p>\n<p>CORS跨域示例</p>\n<p><strong>1）前端设置</strong>：</p>\n<ul>\n<li>原生ajax：</li>\n</ul>\n<pre><code class=\"text\">var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容\n\n// 前端设置是否带cookie\nxhr.withCredentials = true;\n\nxhr.open(&#39;post&#39;, &#39;http://www.domain2.com:8080/login&#39;, true);\nxhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application/x-www-form-urlencoded&#39;);\nxhr.send(&#39;user=admin&#39;);\n\nxhr.onreadystatechange = function() &#123;\n    if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123;\n        alert(xhr.responseText);\n    &#125;\n&#125;;\n</code></pre>\n<ul>\n<li>jquery ajax：</li>\n</ul>\n<pre><code class=\"text\">$.ajax(&#123;\n    ...\n   xhrFields: &#123;\n       withCredentials: true    // 前端设置是否带cookie\n   &#125;,\n   crossDomain: true,   // 会让请求头中包含跨域的额外信息，但不会含cookie\n    ...\n&#125;);\n</code></pre>\n<p><strong>2）服务端设置</strong>：</p>\n<ul>\n<li>nodejs代码</li>\n</ul>\n<pre><code class=\"text\">var http = require(&#39;http&#39;);\nvar server = http.createServer();\nvar qs = require(&#39;querystring&#39;);\n\nserver.on(&#39;request&#39;, function(req, res) &#123;\n    var postData = &#39;&#39;;\n\n    // 数据块接收中\n    req.addListener(&#39;data&#39;, function(chunk) &#123;\n        postData += chunk;\n    &#125;);\n\n    // 数据接收完毕\n    req.addListener(&#39;end&#39;, function() &#123;\n        postData = qs.parse(postData);\n\n        // 跨域后台设置\n        res.writeHead(200, &#123;\n            &#39;Access-Control-Allow-Credentials&#39;: &#39;true&#39;,     // 后端允许发送Cookie\n            &#39;Access-Control-Allow-Origin&#39;: &#39;http://www.domain1.com&#39;,    // 允许访问的域（协议+域名+端口）\n            /* \n             * 此处设置的cookie还是domain2的而非domain1，因为后端也不能跨域写cookie(nginx反向代理可以实现)，\n             * 但只要domain2中写入一次cookie认证，后面的跨域接口都能从domain2中获取cookie，从而实现所有的接口都能跨域访问\n             */\n            &#39;Set-Cookie&#39;: &#39;l=a123456;Path=/;Domain=www.domain2.com;HttpOnly&#39;  // HttpOnly的作用是让js无法读取cookie\n        &#125;);\n\n        res.write(JSON.stringify(postData));\n        res.end();\n    &#125;);\n&#125;);\n\nserver.listen(&#39;8080&#39;);\nconsole.log(&#39;Server is running at port 8080...&#39;);\n</code></pre>\n<h1 id=\"nginx代理跨域\"><a href=\"#nginx代理跨域\" class=\"headerlink\" title=\"nginx代理跨域\"></a>nginx代理跨域</h1><p>nginx代理跨域，实质和CORS跨域原理一样，通过配置文件设置请求响应头Access-Control-Allow-Origin…等字段。</p>\n<p>1）nginx配置解决iconfont跨域</p>\n<p>浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。</p>\n<pre><code class=\"text\">location / &#123;\n  add_header Access-Control-Allow-Origin *;\n&#125;\n</code></pre>\n<p>2）nginx反向代理接口跨域</p>\n<p>跨域问题：同源策略仅是针对浏览器的安全策略。服务器端调用HTTP接口只是使用HTTP协议，不需要同源策略，也就不存在跨域问题。</p>\n<p>实现思路：通过Nginx配置一个代理服务器域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域访问。</p>\n<p>nginx具体配置：</p>\n<pre><code class=\"text\">#proxy服务器\nserver &#123;\n    listen       81;\n    server_name  www.domain1.com;\n\n    location / &#123;\n        proxy_pass   http://www.domain2.com:8080;  #反向代理\n        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名\n        index  index.html index.htm;\n\n        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用\n        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*\n        add_header Access-Control-Allow-Credentials true;\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"nodejs中间件代理跨域\"><a href=\"#nodejs中间件代理跨域\" class=\"headerlink\" title=\"nodejs中间件代理跨域\"></a>nodejs中间件代理跨域</h1><p>node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。</p>\n<p><strong>1）非vue框架的跨域</strong></p>\n<p>使用node + express + http-proxy-middleware搭建一个proxy服务器。</p>\n<ul>\n<li>前端代码：</li>\n</ul>\n<pre><code class=\"text\">var xhr = new XMLHttpRequest();\n\n// 前端开关：浏览器是否读写cookie\nxhr.withCredentials = true;\n\n// 访问http-proxy-middleware代理服务器\nxhr.open(&#39;get&#39;, &#39;http://www.domain1.com:3000/login?user=admin&#39;, true);\nxhr.send();\n</code></pre>\n<ul>\n<li>中间件服务器代码：</li>\n</ul>\n<pre><code class=\"text\">var express = require(&#39;express&#39;);\nvar proxy = require(&#39;http-proxy-middleware&#39;);\nvar app = express();\n\napp.use(&#39;/&#39;, proxy(&#123;\n    // 代理跨域目标接口\n    target: &#39;http://www.domain2.com:8080&#39;,\n    changeOrigin: true,\n\n    // 修改响应头信息，实现跨域并允许带cookie\n    onProxyRes: function(proxyRes, req, res) &#123;\n        res.header(&#39;Access-Control-Allow-Origin&#39;, &#39;http://www.domain1.com&#39;);\n        res.header(&#39;Access-Control-Allow-Credentials&#39;, &#39;true&#39;);\n    &#125;,\n\n    // 修改响应信息中的cookie域名\n    cookieDomainRewrite: &#39;www.domain1.com&#39;  // 可以为false，表示不修改\n&#125;));\n\napp.listen(3000);\nconsole.log(&#39;Proxy server is listen at port 3000...&#39;);\n</code></pre>\n<p><strong>2）vue框架的跨域</strong></p>\n<p>node + vue + webpack + webpack-dev-server搭建的项目，跨域请求接口，直接修改webpack.config.js配置。开发环境下，vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域。</p>\n<p>webpack.config.js部分配置：</p>\n<pre><code class=\"text\">module.exports = &#123;\n    entry: &#123;&#125;,\n    module: &#123;&#125;,\n    ...\n    devServer: &#123;\n        historyApiFallback: true,\n        proxy: [&#123;\n            context: &#39;/login&#39;,\n            target: &#39;http://www.domain2.com:8080&#39;,  // 代理跨域目标接口\n            changeOrigin: true,\n            secure: false,  // 当代理某些https服务报错时用\n            cookieDomainRewrite: &#39;www.domain1.com&#39;  // 可以为false，表示不修改\n        &#125;],\n        noInfo: true\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"document-domain-iframe跨域\"><a href=\"#document-domain-iframe跨域\" class=\"headerlink\" title=\"document.domain + iframe跨域\"></a>document.domain + iframe跨域</h1><p>此方案仅限主域相同，子域不同的跨域应用场景。实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。</p>\n<p>1）父窗口：(<span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHA6Ly93d3cuZG9tYWluLmNvbS9hLmh0bWw=\">http://www.domain.com/a.html</span>)</p>\n<pre><code class=\"text\">&lt;iframe id=&quot;iframe&quot; src=&quot;http://child.domain.com/b.html&quot;&gt;&lt;/iframe&gt;\n&lt;script&gt;\n    document.domain = &#39;domain.com&#39;;\n    var user = &#39;admin&#39;;\n&lt;/script&gt;\n</code></pre>\n<p>1）子窗口：(<span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHA6Ly9jaGlsZC5kb21haW4uY29tL2EuaHRtbA==\">http://child.domain.com/a.html</span>)</p>\n<pre><code class=\"text\">&lt;script&gt;\n    document.domain = &#39;domain.com&#39;;\n    // 获取父窗口中变量\n    console.log(&#39;get js data from parent ---&gt; &#39; + window.parent.user);\n&lt;/script&gt;\n</code></pre>\n<h1 id=\"location-hash-iframe跨域\"><a href=\"#location-hash-iframe跨域\" class=\"headerlink\" title=\"location.hash + iframe跨域\"></a>location.hash + iframe跨域</h1><p>实现原理： a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。</p>\n<p>具体实现：A域：a.html -&gt; B域：b.html -&gt; A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。</p>\n<p>1）a.html：(<span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHA6Ly93d3cuZG9tYWluMS5jb20vYS5odG1s\">http://www.domain1.com/a.html</span>)</p>\n<pre><code class=\"text\">&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain2.com/b.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;\n&lt;script&gt;\n    var iframe = document.getElementById(&#39;iframe&#39;);\n\n    // 向b.html传hash值\n    setTimeout(function() &#123;\n        iframe.src = iframe.src + &#39;#user=admin&#39;;\n    &#125;, 1000);\n    \n    // 开放给同域c.html的回调方法\n    function onCallback(res) &#123;\n        alert(&#39;data from c.html ---&gt; &#39; + res);\n    &#125;\n&lt;/script&gt;\n</code></pre>\n<p>2）b.html：(<span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHA6Ly93d3cuZG9tYWluMi5jb20vYi5odG1s\">http://www.domain2.com/b.html</span>)</p>\n<pre><code class=\"text\">&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain1.com/c.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;\n&lt;script&gt;\n    var iframe = document.getElementById(&#39;iframe&#39;);\n\n    // 监听a.html传来的hash值，再传给c.html\n    window.onhashchange = function () &#123;\n        iframe.src = iframe.src + location.hash;\n    &#125;;\n&lt;/script&gt;\n</code></pre>\n<p>3）c.html：(<span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHA6Ly93d3cuZG9tYWluMS5jb20vYy5odG1s\">http://www.domain1.com/c.html</span>)</p>\n<pre><code class=\"text\">&lt;script&gt;\n    // 监听b.html传来的hash值\n    window.onhashchange = function () &#123;\n        // 再通过操作同域a.html的js回调，将结果传回\n        window.parent.parent.onCallback(&#39;hello: &#39; + location.hash.replace(&#39;#user=&#39;, &#39;&#39;));\n    &#125;;\n&lt;/script&gt;\n</code></pre>\n<h1 id=\"window-name-iframe跨域\"><a href=\"#window-name-iframe跨域\" class=\"headerlink\" title=\"window.name + iframe跨域\"></a>window.name + iframe跨域</h1><p>window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。</p>\n<p>1）a.html：(<span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHA6Ly93d3cuZG9tYWluMS5jb20vYS5odG1s\">http://www.domain1.com/a.html</span>)</p>\n<pre><code class=\"text\">var proxy = function(url, callback) &#123;\n    var state = 0;\n    var iframe = document.createElement(&#39;iframe&#39;);\n\n    // 加载跨域页面\n    iframe.src = url;\n\n    // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name\n    iframe.onload = function() &#123;\n        if (state === 1) &#123;\n            // 第2次onload(同域proxy页)成功后，读取同域window.name中数据\n            callback(iframe.contentWindow.name);\n            destoryFrame();\n\n        &#125; else if (state === 0) &#123;\n            // 第1次onload(跨域页)成功后，切换到同域代理页面\n            iframe.contentWindow.location = &#39;http://www.domain1.com/proxy.html&#39;;\n            state = 1;\n        &#125;\n    &#125;;\n\n    document.body.appendChild(iframe);\n\n    // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）\n    function destoryFrame() &#123;\n        iframe.contentWindow.document.write(&#39;&#39;);\n        iframe.contentWindow.close();\n        document.body.removeChild(iframe);\n    &#125;\n&#125;;\n\n// 请求跨域b页面数据\nproxy(&#39;http://www.domain2.com/b.html&#39;, function(data)&#123;\n    alert(data);\n&#125;);\n</code></pre>\n<p>2）proxy.html：(<span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHA6Ly93d3cuZG9tYWluMS5jb20vcHJveHkuaHRtbA==\">http://www.domain1.com/proxy.html</span>)</p>\n<p>中间代理页，与a.html同域，内容为空即可。</p>\n<p>3）b.html：(<span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHA6Ly93d3cuZG9tYWluMi5jb20vYi5odG1s\">http://www.domain2.com/b.html</span>)</p>\n<pre><code class=\"text\">&lt;script&gt;\n    window.name = &#39;This is domain2 data!&#39;;\n&lt;/script&gt;\n</code></pre>\n<p>通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p>\n<h1 id=\"postMessage跨域\"><a href=\"#postMessage跨域\" class=\"headerlink\" title=\"postMessage跨域\"></a>postMessage跨域</h1><p>postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：</p>\n<ul>\n<li>页面和其打开的新窗口的数据传递</li>\n<li>多窗口之间消息传递</li>\n<li>页面与嵌套的iframe消息传递</li>\n<li>上面三个场景的跨域数据传递</li>\n</ul>\n<p>用法：postMessage(data,origin)方法接受两个参数：</p>\n<ul>\n<li><strong>data</strong>： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。</li>\n<li><strong>origin</strong>： 协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”&#x2F;“。</li>\n</ul>\n<p>1）a.html：(<span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHA6Ly93d3cuZG9tYWluMS5jb20vYS5odG1s\">http://www.domain1.com/a.html</span>)</p>\n<pre><code class=\"text\">&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain2.com/b.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;\n&lt;script&gt;       \n    var iframe = document.getElementById(&#39;iframe&#39;);\n    iframe.onload = function() &#123;\n        var data = &#123;\n            name: &#39;aym&#39;\n        &#125;;\n        // 向domain2传送跨域数据\n        iframe.contentWindow.postMessage(JSON.stringify(data), &#39;http://www.domain2.com&#39;);\n    &#125;;\n\n    // 接受domain2返回数据\n    window.addEventListener(&#39;message&#39;, function(e) &#123;\n        alert(&#39;data from domain2 ---&gt; &#39; + e.data);\n    &#125;, false);\n&lt;/script&gt;\n</code></pre>\n<p>2）b.html：(<span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHA6Ly93d3cuZG9tYWluMi5jb20vYi5odG1s\">http://www.domain2.com/b.html</span>)</p>\n<pre><code class=\"text\">&lt;script&gt;\n    // 接收domain1的数据\n    window.addEventListener(&#39;message&#39;, function(e) &#123;\n        alert(&#39;data from domain1 ---&gt; &#39; + e.data);\n\n        var data = JSON.parse(e.data);\n        if (data) &#123;\n            data.number = 16;\n\n            // 处理后再发回domain1\n            window.parent.postMessage(JSON.stringify(data), &#39;http://www.domain1.com&#39;);\n        &#125;\n    &#125;, false);\n&lt;/script&gt;\n</code></pre>\n<h1 id=\"WebSocket协议跨域\"><a href=\"#WebSocket协议跨域\" class=\"headerlink\" title=\"WebSocket协议跨域\"></a>WebSocket协议跨域</h1><p>WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。<br>原生WebSocket API使用起来不太方便，我们使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHA6Ly9Tb2NrZXQuaW8=\">http://Socket.io</span>，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。</p>\n<p>1）前端代码：</p>\n<pre><code class=\"text\">&lt;div&gt;user input：&lt;input type=&quot;text&quot;&gt;&lt;/div&gt;\n&lt;script src=&quot;https://cdn.bootcss.com/socket.io/2.2.0/socket.io.js&quot;&gt;&lt;/script&gt;\n&lt;script&gt;\nvar socket = io(&#39;http://www.domain2.com:8080&#39;);\n\n// 连接成功处理\nsocket.on(&#39;connect&#39;, function() &#123;\n    // 监听服务端消息\n    socket.on(&#39;message&#39;, function(msg) &#123;\n        console.log(&#39;data from server: ---&gt; &#39; + msg); \n    &#125;);\n\n    // 监听服务端关闭\n    socket.on(&#39;disconnect&#39;, function() &#123; \n        console.log(&#39;Server socket has closed.&#39;); \n    &#125;);\n&#125;);\n\ndocument.getElementsByTagName(&#39;input&#39;)[0].onblur = function() &#123;\n    socket.send(this.value);\n&#125;;\n&lt;/script&gt;\n</code></pre>\n<p>2）Nodejs socket后台：</p>\n<pre><code class=\"text\">var http = require(&#39;http&#39;);\nvar socket = require(&#39;socket.io&#39;);\n\n// 启http服务\nvar server = http.createServer(function(req, res) &#123;\n    res.writeHead(200, &#123;\n        &#39;Content-type&#39;: &#39;text/html&#39;\n    &#125;);\n    res.end();\n&#125;);\n\nserver.listen(&#39;8080&#39;);\nconsole.log(&#39;Server is running at port 8080...&#39;);\n\n// 监听socket连接\nsocket.listen(server).on(&#39;connection&#39;, function(client) &#123;\n    // 接收信息\n    client.on(&#39;message&#39;, function(msg) &#123;\n        client.send(&#39;hello：&#39; + msg);\n        console.log(&#39;data from client: ---&gt; &#39; + msg);\n    &#125;);\n\n    // 断开处理\n    client.on(&#39;disconnect&#39;, function() &#123;\n        console.log(&#39;Client socket has closed.&#39;); \n    &#125;);\n&#125;);\n</code></pre>\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><pre><code class=\"text\">以上就是9种常见的跨域解决方案，jsonp（只支持get请求，支持老的IE浏览器）适合加载不同域名的js、css，img等静态资源；CORS（支持所有类型的HTTP请求，但浏览器IE10以下不支持）适合做ajax各种跨域请求；Nginx代理跨域和nodejs中间件跨域原理都相似，都是搭建一个服务器，直接在服务器端请求HTTP接口，这适合前后端分离的前端项目调后端接口。document.domain+iframe适合主域名相同，子域名不同的跨域请求。postMessage、websocket都是HTML5新特性，兼容性不是很好，只适用于主流浏览器和IE10+\n</code></pre>\n",
            "tags": [
                "前端开发",
                "跨域",
                "web综合问题"
            ]
        },
        {
            "id": "https://pink-png.github.io/front-end/PM2%20+%20linux/",
            "url": "https://pink-png.github.io/front-end/PM2%20+%20linux/",
            "title": "PM2",
            "date_published": "2021-06-25T08:43:00.000Z",
            "content_html": "<h1 id=\"什么是pm2\"><a href=\"#什么是pm2\" class=\"headerlink\" title=\"什么是pm2\"></a>什么是pm2</h1><p>pm2 是一个带有负载均衡功能的Node应用的进程管理器.<br>当你要把你的独立代码利用全部的服务器上的所有CPU，并保证进程永远都活着，0秒的重载， PM2是完美的。它非常适合IaaS结构，但不要把它用于PaaS方案（随后将开发Paas的解决方案）</p>\n<h1 id=\"主要特性\"><a href=\"#主要特性\" class=\"headerlink\" title=\"主要特性\"></a>主要特性</h1><p>内建负载均衡（使用Node cluster 集群模块）<br>后台运行<br>0秒停机重载，我理解大概意思是维护升级的时候不需要停机.<br>具有Ubuntu和CentOS 的启动脚本<br>停止不稳定的进程（避免无限循环）<br>控制台检测<br>提供 HTTP API<br>远程控制和实时的接口API ( Nodejs 模块,允许和PM2进程管理器交互 )<br>测试过Nodejs v0.11 v0.10 v0.8版本，兼容CoffeeScript,基于Linux 和MacOS.</p>\n<h1 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h1><p>npm install -g pm2</p>\n<h1 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h1><p>pm2 start app.js -i 4 #后台运行pm2，启动4个app.js<br>                      # 也可以把’max’ 参数传递给 start<br>                      # 正确的进程数目依赖于Cpu的核心数目<br>pm2 start app.js –name my-api # 命名进程<br>pm2 list               # 显示所有进程状态<br>pm2 monit              # 监视所有进程<br>pm2 logs               # 显示所有进程日志<br>pm2 stop all           # 停止所有进程<br>pm2 restart all        # 重启所有进程<br>pm2 reload all         # 0秒停机重载进程 (用于 NETWORKED 进程)<br>pm2 stop 0             # 停止指定的进程<br>pm2 restart 0          # 重启指定的进程<br>pm2 startup            # 产生 init 脚本 保持进程活着<br>pm2 web                # 运行健壮的 computer API endpoint (<span class=\"exturl\" data-url=\"aHR0cDovL2xvY2FsaG9zdDo5NjE1Lw==\">http://localhost:9615</span>)<br>pm2 delete 0           # 杀死指定的进程<br>pm2 delete all         # 杀死全部进程</p>\n<h2 id=\"运行进程的不同方式：\"><a href=\"#运行进程的不同方式：\" class=\"headerlink\" title=\"运行进程的不同方式：\"></a>运行进程的不同方式：</h2><p>pm2 start app.js -i max  # 根据有效CPU数目启动最大进程数目<br>pm2 start app.js -i 3      # 启动3个进程<br>pm2 start app.js -x        #用fork模式启动 app.js 而不是使用 cluster<br>pm2 start app.js -x – -a 23   # 用fork模式启动 app.js 并且传递参数 (-a 23)<br>pm2 start app.js –name serverone  # 启动一个进程并把它命名为 serverone<br>pm2 stop serverone       # 停止 serverone 进程<br>pm2 start app.json        # 启动进程, 在 app.json里设置选项<br>pm2 start app.js -i max – -a 23        #在–之后给 app.js 传递参数<br>pm2 start app.js -i max -e err.log -o out.log  # 启动 并 生成一个配置文件</p>\n<h2 id=\"你也可以执行用其他语言编写的app-fork-模式\"><a href=\"#你也可以执行用其他语言编写的app-fork-模式\" class=\"headerlink\" title=\"你也可以执行用其他语言编写的app  ( fork 模式):\"></a>你也可以执行用其他语言编写的app  ( fork 模式):</h2><p>pm2 start my-bash-script.sh    -x –interpreter bash<br>pm2 start my-python-script.py -x –interpreter python</p>\n<p>0秒停机重载:<br>这项功能允许你重新载入代码而不用失去请求连接。<br>注意：<br>仅能用于web应用<br>运行于Node 0.11.x版本<br>运行于 cluster 模式（默认模式）<br>pm2 reload all<br>CoffeeScript:<br>pm2 start my_app.coffee  #这就是全部<br>PM2准备好为产品级服务了吗？<br>只需在你的服务器上测试<br>git clone <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL1VuaXRlY2gvcG0yLmdpdA==\">https://github.com/Unitech/pm2.git</span><br>cd pm2<br>npm install  # 或者 npm install –dev ，如果devDependencies 没有安装<br>npm test<br>pm2 list<br>列出由pm2管理的所有进程信息，还会显示一个进程会被启动多少次，因为没处理的异常。</p>\n<p>pm2 monit<br>监视每个node进程的CPU和内存的使用情况。</p>\n",
            "tags": [
                "前端开发",
                "PM2",
                "PM2"
            ]
        }
    ]
}