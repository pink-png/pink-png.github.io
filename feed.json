{
    "version": "https://jsonfeed.org/version/1",
    "title": "死肥宅",
    "subtitle": "肥宅快乐水",
    "icon": "http://yoursite.com/images/favicon.ico",
    "description": "双马尾の罪",
    "home_page_url": "http://yoursite.com",
    "items": [
        {
            "id": "http://yoursite.com/front-end/Jquery/",
            "url": "http://yoursite.com/front-end/Jquery/",
            "title": "Jquery基础",
            "date_published": "2021-06-25T08:43:00.000Z",
            "content_html": "",
            "tags": [
                "前端开发",
                "Jquery",
                "Jquery"
            ]
        },
        {
            "id": "http://yoursite.com/front-end/JavaScript%E8%BF%90%E7%94%A8/",
            "url": "http://yoursite.com/front-end/JavaScript%E8%BF%90%E7%94%A8/",
            "title": "js运用",
            "date_published": "2021-06-25T08:43:00.000Z",
            "content_html": "<h1 id=\"一：什么是JavaScript\"><a href=\"#一：什么是JavaScript\" class=\"headerlink\" title=\"一：什么是JavaScript\"></a>一：什么是JavaScript</h1><h2 id=\"1-发展历史\"><a href=\"#1-发展历史\" class=\"headerlink\" title=\"1.发展历史\"></a>1.发展历史</h2><pre><code class=\"javascript\">1995年 JavaScript 1.0 问世 它的主要用途是代替 Perl 等服务器端语言处理输入验证\n1997年 javascript 1.1 作为提案被提交给欧洲计算机制造商协会（Ecma）TC39 委员会他们花了数月时间打造出 ECMA-262\n1998年 国际标准化组织（ISO）和国际电工委员会（IEC）也将 ECMAScript 采纳为标准  自此以后，各家浏览器均以 ECMAScript 作为自己 JavaScript 实现的依据，虽然具体实现各有不同。\n</code></pre>\n<h2 id=\"2-javascript的构成\"><a href=\"#2-javascript的构成\" class=\"headerlink\" title=\"2.javascript的构成\"></a>2.javascript的构成</h2><pre><code class=\"javascript\">1.核心（ECMAScript）    \n2.文档对象模型（DOM）\n3.浏览器对象模型（BOM）\n</code></pre>\n<h1 id=\"一：数据类型以及相应的操作\"><a href=\"#一：数据类型以及相应的操作\" class=\"headerlink\" title=\"一：数据类型以及相应的操作\"></a>一：数据类型以及相应的操作</h1><h5 id=\"2：关于Array处理数据的方法总结\"><a href=\"#2：关于Array处理数据的方法总结\" class=\"headerlink\" title=\"2：关于Array处理数据的方法总结\"></a>2：关于Array处理数据的方法总结</h5><pre><code class=\"javascript\">//敲重点1：创建数组的方式有2种，一种是构造函数的方式 一个是字面量的方式，最好使用字面量的方式\n//因为不管Array或者String本身也是构造函数\n        Array = String;\n        let aa = new Array(1,2,3,4,5);\n        console.log(aa);  //string\n\n        let bb = [1,2,3,4];\n        console.log(bb); //[1,2,3,4]\n\n----------------------------------------------------------\n\n//敲重点2：ECMAScript的数组每个槽位可以存储任意类型的数据，而且ECMAScript数组也是动态大小的，会随着数据的添加自动增长\n        let arr = [1,&#39;1&#39;,[1,2,3,4],&#123;obj1:11,obj2:[1,2,3,4]&#125;];\n\n------------------------------------------------------------\n        \n//敲重点3：数组排列位置\n//使用for循环打乱位数组置\n        var Arr = [4, 1, 67, 12, 45, 121, 3];\n        function randArr(arr) &#123;\n            for (var i = 0; i &lt; arr.length; i++) &#123;\n                var iRand = parseInt(arr.length * Math.random());\n                var temp = arr[i];\n                arr[i] = arr[iRand];\n                arr[iRand] = temp;\n            &#125;\n            return arr;\n        &#125;\n\n//使用sort方法错误打乱位数组置\n        arr.sort(function () &#123;\n            return (0.5 - Math.random());\n        &#125;);\n\n\n//reverse()方法是倒序交换位置 会改变原来的数组\n        let newarr = arr.reverse()\n          console.log(newarr === arr)  //true\n\n\n//利用sort()对数组对象某个值进行升序排序\n        let arr = [&#123; &#39;a&#39;: 1, &#39;b&#39;: 2 &#125;, &#123; &#39;a&#39;: 466, &#39;b&#39;: 2 &#125;, &#123; &#39;a&#39;: 623, &#39;b&#39;: 2 &#125;, &#123; &#39;a&#39;: 7, &#39;b&#39;: 2 &#125;, &#123; &#39;a&#39;: 67, &#39;b&#39;: 2 &#125;]\n\n        function creatCompare(propertyName) &#123; //根据哪个属性值排序\n            return function (obj1, obj2) &#123;\n                //对象两两比较\n                let value1 = obj1[propertyName];\n                let value2 = obj2[propertyName];\n                if (value1 &lt; value2) &#123;\n                    return -1\n                &#125; else if (value1 &gt; value2) &#123;\n                    return 1\n                &#125; else &#123;\n                    return 0\n                &#125;\n            &#125;\n        &#125;\n\n        let newarr = arr.sort(creatCompare(&#39;a&#39;))\n        console.log(newarr)\n---------------------------------------------------------------\n\n//敲重点4：数组的转换方法\n//数组转成字符串\n        let color = [&#39;green&#39;,&#39;red&#39;,&#39;pink&#39;]\n        console.log(color.join())  // green,red,pink\n        console.log(color.join(&#39;,&#39;)) // green,red,pink\n        console.log(color.join(&#39;|&#39;))  // green|red|pink\n\n//以下这种方法只能转成以逗号分隔的字符串\n        let colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; \n        alert(colors.toString()); // red,blue,green\n        alert(colors.valueOf()); // red,blue,green\n        alert(colors); // red,blue,green\t\t\n//扩展：字符串转数组\n        console.log(color.join(&#39;|&#39;).split(&#39;|&#39;)) //[&#39;green&#39;,&#39;red&#39;,&#39;pink&#39;]\n\n----------------------------------------------------------------\n\n//敲重点5：栈方法\n        let arr = [1,2,3,4];\n        arr.push(5); //向数组末尾添加5\n        let poparr = arr.pop();   //取得数组末尾的值，并且删除\n        console.log(arr);  //[1,2,3,4]\n\n----------------------------------------------------------------\n\n//敲重点6：队列方法\n           let arr = [1,2,3,4];\n           let shiftarr = arr.shift(); //删除数组第一项并取得\n           arr.unshift(1); //向数组第一项添加\n           console.log(arr); // [1,2,3,4]\n\n------------------------------------------------------------\n\n//敲重点7：数组相关的操作方法\n        let arr = [1,2,3,4,5]\n        \n//拼接2个数组  返回一个新的数组,不改变原来的数组\n        let zenarr = arr.concat(6,7,8)\n        console.log(zenarr) // [1, 2, 3, 4, 5, 6, 7, 8]\n        \n//concat方法不传参数对数组进行第一层的深拷贝\n        let arr = [1,2,3];\n        let newarr = arr.concat()\n        \n\n//数组截取    遵循左包，右不包\n        console.log(arr.slice(1))  //[2,3,4]\n        console.log(arr.slice(2))   //[3,4]\n        console.log(arr.slice(2,4)) //[3,4] \n\n//slice方法不传参数对数组进行第一层深拷贝\n        let arr = [1,2,3,4]\n        let slicearr = arr.slice()\n        console.log(slicearr) //返回跟原来一样的新数组   [1,2,3,4]\n\n------------------------------------------------------------\n\n\n//敲重点8：数组增删改\n    \n        let arr = [1,2,3,4]\n\n//删除    \n        arr.splice(1,1) //传入2个参数，第一个数数组开始位置，第二个是删除的数量\n        console.log(arr)   //[1,3,4] \n\n//插入\n        arr.splice(1,0,2) //传入3个参数  第一个参数是开始位置，第二个是要删除的数量，要插入的元素   \n        console.log(arr) //[1,2,3,4]\n\n//替换\n        arr.splice(3,0,4,5,6)  //方法同插入  ，在序列为3的位置后面，删除0个，添加 4，5，6\n        console.log(arr) //[1, 2, 3, 4, 5, 6, 4]\n\n--------------------------------------------------------------\n\n//敲重点9：搜索和位置方法\n        \n//indexOf从索为0开始搜索   \n//lastIndexOf从最后一项开始搜索\n        let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];\n        alert(numbers.indexOf(4)); // 3\n        alert(numbers.lastIndexOf(4)); // 5\n        alert(numbers.includes(4)); // true\n        alert(numbers.indexOf(4, 4)); // 5\n        alert(numbers.lastIndexOf(4, 4)); // 3\n        alert(numbers.includes(4, 7)); // false\n        let person = &#123; name: &quot;Nicholas&quot; &#125;;\n        let people = [&#123; name: &quot;Nicholas&quot; &#125;];\n        let morePeople = [person];\n        alert(people.indexOf(person)); // -1\n        alert(morePeople.indexOf(person)); // 0\n        alert(people.includes(person)); // false\n        alert(morePeople.includes(person)); // true\n\n\n//使用includes()方法判断数组里有无某数据  \n          function test(fruit) &#123;\n            const redFruits = [&#39;apple&#39;, &#39;strawberry&#39;, &#39;cherry&#39;, &#39;cranberries&#39;];\n            if (redFruits.includes(fruit)) &#123;\n                console.log(&#39;存在&#39;);\n            &#125;else&#123;\n                console.log(&#39;不存在&#39;)\n            &#125;\n        &#125;\n\n--------------------------------------------------------------\n\n//敲重点10：断言函数的运用\n//找到匹配项后，这两个方法都不再继续搜索。 \n//可以说是查询判断里性能最好的方法\n        const people = [\n            &#123;\n                name: &quot;Matt&quot;,\n                age: 27\n            &#125;,\n            &#123;\n                name: &quot;Nicholas&quot;,\n                age: 29\n            &#125;\n        ];\n        alert(people.find((element, index, array) =&gt; element.age &lt; 28));\n        // &#123;name: &quot;Matt&quot;, age: 27&#125;\n        alert(people.findIndex((element, index, array) =&gt; element.age &lt; 28));\n        // 0\n\n\n//其实也可以当做循环使用\n        const evens = [2, 4, 6];\n\n        evens.find((element, index, array) =&gt; &#123;\n            console.log(element);\n            console.log(index); \n            console.log(array);\n            return element === 4;\n        &#125;);\n// 2\n// 0\n// [2, 4, 6]\n// 4\n// 1\n// [2, 4, 6]\n\n--------------------------------------------------------------\n\n//敲重点11：迭代方法\nevery()：对数组每一项都运行传入的函数，如果对每一项函数都返回 true，则这个方法返回 true。\nfilter()：对数组每一项都运行传入的函数，函数返回 true 的项会组成数组之后返回。\nforEach()：对数组每一项都运行传入的函数，没有返回值。\nmap()：对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组。\nsome()：对数组每一项都运行传入的函数，如果有一项函数返回 true，则这个方法返回 true。\n这些方法都不改变调用它们的数组。\n\n//map方法每次要主动定义返回项\n            let newobjarr =  objarr.map((item)=&gt;&#123;\n                item.a += 1;\n                item.b += 1;\n                return &#123;a:item.a,b:item.b&#125;\n\n            &#125;)     \n            console.log(newobjarr)\n\n//敲重点12：归并方法\nreduce()\n        \n\n        //每一项都加1\n        let arr = [1,1,2,3,4,5]\n        const res = arr.reduce(function(prev,cur)&#123;\n            return [...prev,cur + 1]\n        &#125;,[])\n\n\n\n\n        //数组求和\n        const text = [&#123;\n            id: 1,\n            sex: 0\n        &#125;, &#123;\n            id: 2,\n            sex: 1\n        &#125;, &#123;\n            id: 3,\n            sex: 1\n        &#125;]\n\n        const res = text.reduce(function (prev, cur, index, array) &#123;\n            return prev + cur.id\n        &#125;, 0)\n\n\n        // 计算数组每个元素出现的次数\n        const arr = [1, 1, 2, 3, 4]\n        const rescount = arr.reduce(function (prev, cur, index, array) &#123;\n            if (cur in prev) &#123;\n                prev[cur]++\n            &#125; else &#123;\n                prev[cur] = 1\n            &#125;\n            return prev\n        &#125;, &#123;&#125;)\n        \n        //取出最大值\n         const res = arr.reduce(function(prev,cur)&#123;\n           return prev &lt;= cur ? prev = cur : prev = prev\n        &#125;,0)\n\n\n        //数组去重\n        const res = arr.reduce(function(prev,cur)&#123;\n            return !prev.includes(cur) ? [...prev,cur] : prev\n        &#125;,[])\n\n\n        // 将二维数组转化为一维\n        const arrer = [[0, 1], [2, 3], [4, 5]]\n        const arrerres = arrer.reduce(function (prev, cur) &#123;\n            return prev.concat(cur)\n        &#125;, [])\n\n\n        // 将多维数组转化为一维\n        let arr = [[0, 1], [2, 3], [4, [5, 6, 7]]]\n        const newArr = function (arr) &#123;\n            return arr.reduce((pre, cur) =&gt; pre.concat(Array.isArray(cur) ? newArr(cur) : cur), [])\n        &#125;\n\nreduceRight()\n\n\n\n\n//12.某些方法调用用会修改自身的数组?\n  push\n  pop\n  shift\n  unshift\n  splice\n  sort\n  reverse\n</code></pre>\n<h5 id=\"3：关于String包装类型处理数据的总结\"><a href=\"#3：关于String包装类型处理数据的总结\" class=\"headerlink\" title=\"3：关于String包装类型处理数据的总结\"></a>3：关于String包装类型处理数据的总结</h5><pre><code class=\"javascript\">\n        let mseesage = new String(&#39;hello&#39;)\n        console.log(mseesage.length)  //返回字符串的长度  5\n        console.log(mseesage.charAt(0))  //返回某个索引值  h\n        console.log(mseesage.charCodeAt(0))  //字符编码  h的字符编码是108\n\n3.1\n// 字符串拼接  不改变原来的字符串， 返回一个新的字符串\n        let o = &#39;hello&#39;\n        let result = stringvalue.concat(&#39;world&#39;) //可以接受多个参数，用逗号分开\n\n        console.log(result)  //  hello world\n        console.log(stringvalue) //hello  \n\n// 采用 加号 +  实现快速拼接\n        let a = &#39;hello&#39;\n        let b = a + &#39;world&#39;\n        console.log(a)  // hello\n        console.log(b) //hello world \n\n3.2\n//字符串提取\n        let stringvalue = &#39;hello world&#39;\n        console.log(stringValue.slice(3)); // &quot;lo world&quot;\n        console.log(stringValue.substring(3)); // &quot;lo world&quot;\n        console.log(stringValue.substr(3)); // &quot;lo world&quot;\n        console.log(stringValue.slice(3, 7)); // &quot;lo w&quot;\n        console.log(stringValue.substring(3, 7)); // &quot;lo w&quot;\n        console.log(stringValue.substr(3, 7)); // &quot;lo worl&quot; \n\n//clice 单个参数是 左不包后面全要 (]        2个参数是 左不包，后包  (]\n//substring 单个参数是 左不包后面全要 (]         2个参数是 左包，后包   []\n//substr 单个参数是 左包后面全要  []           2个参数是 左包，第二个参数是截取个数  []\n\n3.3\n//字符串位置方法\n        let stringvalue = &#39;hello world&#39;\n        console.log(stringvalue.indexOf(&quot;o&quot;)) // 4\n        console.log(stringvalue.lastIndexOf(&quot;o&quot;)) // 7 \n//indexOd和lastIndexOf的区别就是前者是从前面开始寻找，后者是从后面开始寻找\n\n//传入第二个参数的时候，\n        console.log(stringValue.indexOf(&quot;o&quot;, 6)); // 7\n        console.log(stringValue.lastIndexOf(&quot;o&quot;, 6)); // 4 \n//第二个参数代表从哪个序列开始寻找\n\n\n//寻找某段字符串里的某个字符，并全部记录它的序列位置\n        let stringValue = &quot;Lorem ipsum dolor sit amet, consectetur adipisicing elit&quot;;\n        let positions = new Array();\n        let pos = stringValue.indexOf(&quot;e&quot;); \n\n        while(pos &gt; -1)&#123; \n            positions.push(pos)\n            pos = stringValue.indexOf(&#39;e&#39;, pos + 1)\n        &#125;\n        console.log(positions)  // [3,24,32,35,52]\n\n3.4\n//查看字符串里是否包含某个 字符串 或者字符\n//有三种方法可以判断  \n        let message = &quot;foobarbaz&quot;;\n        console.log(message.startsWith(&quot;foo&quot;)); // true\n        console.log(message.startsWith(&quot;bar&quot;)); // false\n        console.log(message.endsWith(&quot;baz&quot;)); // true\n        console.log(message.endsWith(&quot;bar&quot;)); // false\n        console.log(message.includes(&quot;bar&quot;)); // true\n        console.log(message.includes(&quot;qux&quot;)); // false \n\n//startsWith()检查开始于索引 0 的匹配项 \n//endsWith()检查开始于索引(string.length - substring.length)的匹配项\n//includes()检查整个字符串\n\n//基本就是使用includes就完事了\n\n3.5\n//trim() 删除2边空格    原字符串不受到影响 返回一个新的字符串\n        let stringValue = &quot; hello world &quot;;\n        let trimmedStringValue = stringValue.trim();\n        console.log(stringValue); // &quot; hello world &quot;\n        console.log(trimmedStringValue); // &quot;hello world&quot; \n\n//扩展：\n//trimLeft()和 trimRight()方法分别用于从字符串开始和末尾清理空格符。\n\n\n3.6\n//repeat()  复制多次字符串 原字符串不受影响  返回一个新的字符串\n        let stringvalue = &#39;ha&#39;\n        console.log(stringvalue.repeat(12).concat(&#39; yyyy&#39;)) \n// hahahahahahahahahahahaha yyyy\n\n\n3.7\n //padStart()和 padEnd()方法会复制字符串，如果小于指定长度，则在相应一边填充字符，直至\n//满足长度条件。这两个方法的第一个参数是长度，第二个参数是可选的填充字符串，默认为空格\n\n\n3.8\n// 字符串迭代与解构简单的运用，原理参考js高程\n        let arr = []\n        let str = &#39;asddd&#39;\n        arr = [...str]\n        console.log(arr)  //[&quot;a&quot;, &quot;s&quot;, &quot;d&quot;, &quot;d&quot;, &quot;d&quot;]\n\n3.9\n        //字符串大小转换\n        let stringValue = &quot;hello world&quot;;\n        console.log(stringValue.toLocaleUpperCase()); // &quot;HELLO WORLD&quot;\n        console.log(stringValue.toUpperCase()); // &quot;HELLO WORLD&quot;\n        console.log(stringValue.toLocaleLowerCase()); // &quot;hello world&quot;\n        console.log(stringValue.toLowerCase()); // &quot;hello world&quot; \n/*原来就有的是 toUpperCase 和 toLowerCase ，但是在很多地区，地区特定的方法与通用的方法是一样的。但在少数语言中（如土耳其语），Unicode 大小写转换需应用特殊规则，要使用地区特定的方法才能实现正确转换。*/\n\n//推荐使用 toLocaleUpperCase 和 toLocaleLowerCase\n\n//记忆方法是一个是Up是向上 就是放大\n\n3.10\n//字符串替换  简单用法   \n        let text = &quot;cat, bat, sat, fat&quot;;\n        let result = text.replace(&quot;at&quot;, &quot;ond&quot;);\n        console.log(result); // &quot;cond, bat, sat, fat&quot;  \n            //配合正则表达式的高级用法\n        result = text.replace(/a t/g, &quot;ond&quot;);\n        console.log(result); // &quot;cond, bond, sond, fond&quot; \n\n3.11\n//计算输入的字符个数\n         getByteLen(val) &#123;\n              var len = 0\n              for (var i = 0; i &lt; val.length; i++) &#123;\n                var a = val.charAt(i)\n                if (a.match(/[^\\x00-\\xff]/gi) != null) &#123;\n                  len += 2\n                &#125; else &#123;\n                  len += 1\n                &#125;\n              &#125;\n              return len\n            &#125;\n\n3.12\n        \n//实现方法为将字符串按某个字符切割成若干个字符串，并以数组形式返回\n        var s = &quot;abc,abcd,aaa&quot;;\n        ss = s.split(&quot;,&quot;);// 在每个逗号(,)处进行分解  [&quot;abc&quot;, &quot;abcd&quot;, &quot;aaa&quot;]\n        var s1 = &quot;helloworld&quot;;\n        ss1 = s1.split(&#39;&#39;);  //[&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;, &quot;w&quot;, &quot;o&quot;, &quot;r&quot;, &quot;l&quot;, &quot;d&quot;]\n</code></pre>\n<h5 id=\"4：关于Number包装类型的处理\"><a href=\"#4：关于Number包装类型的处理\" class=\"headerlink\" title=\"4：关于Number包装类型的处理\"></a>4：关于Number包装类型的处理</h5><pre><code class=\"javascript\">    \n        let num1 = new Number(10.4545)\n        let num2 = new Number(10)\n        console.log(num1.toFixed(2)) //10.45  //表示返回2位小数,采用4舍5入\n        console.log(num2.toFixed(2)) //10.00 \n</code></pre>\n<h5 id=\"5：关于Date时间处理\"><a href=\"#5：关于Date时间处理\" class=\"headerlink\" title=\"5：关于Date时间处理\"></a>5：关于Date时间处理</h5><pre><code class=\"javascript\">// 创建时间类\n        let time = new Date()   \n        console.log(time)  // Sat Nov 14 2020 15:51:41 GMT+0800 (中国标准时间)\n        console.log(Date.parse(new Date())) //使用Date.parse这个方法可以将其转化成 13位的时间戳\n    \n\n// 填入时间戳，得出天/时/分\n        function DateDifference(faultDate, completeTime) &#123;\n          // let d1 = new Date(faultDate);\n          // let d2 = new Date(completeTime);\n          var stime = new Date(faultDate).getTime();\n          var etime = new Date(completeTime).getTime();\n          var usedTime = etime - stime;  //两个时间戳相差的毫秒数\n          var days = Math.floor(usedTime / (24 * 3600 * 1000));\n          //计算出小时数\n          var leave1 = usedTime % (24 * 3600 * 1000);    //计算天数后剩余的毫秒数\n          var hours = Math.floor(leave1 / (3600 * 1000));\n          //计算相差分钟数\n          var leave2 = leave1 % (3600 * 1000);        //计算小时数后剩余的毫秒数\n          var minutes = Math.floor(leave2 / (60 * 1000));\n          var time = days + &quot;天&quot; + hours + &quot;时&quot; + minutes + &quot;分&quot;;\n          //   var time = days;\n          return time;\n        &#125;\n// 使用方法\n        console.log( DateDifference(1597800343,1697900343) )\n\n\n//时间戳转时间格式\n        getdate() &#123;\n           var now = new Date(),\n           y = now.getFullYear(),\n           m = now.getMonth() + 1,\n           d = now.getDate()\n           return y + &#39;-&#39; + (m &lt; 10 ? &#39;0&#39; + m : m) + &#39;-&#39; + (d &lt; 10 ? &#39;0&#39; + d : d) + &#39; &#39; +                             now.toTimeString().substr(0, 8)\n         &#125;\n\n</code></pre>\n<h5 id=\"6：关于Math内置对象的处理\"><a href=\"#6：关于Math内置对象的处理\" class=\"headerlink\" title=\"6：关于Math内置对象的处理\"></a>6：关于Math内置对象的处理</h5><pre><code class=\"javascript\">\n2.1：\n//Math对象属性  例如 Math.E  (自然对数的基数 e 的值)\n\n2.2：\t\n//最大最小值\n         let max = Math.max(3, 6, 5, 7)\n         let min = Math.min(3, 4, 1, 5)\n\n         console.log(max)  //7\n         console.log(min)  //1 \n\n//可以传入数组\n        let values = [1, 2, 3, 4, 5, 6, 7, 8];\n        let maxarr = Math.max(...values); \n        console.log(maxarr)\n\n2.3：\n        //舍入方法\n        console.log(Math.ceil(25.9)); // 26\n        console.log(Math.ceil(25.5)); // 26\n        console.log(Math.ceil(25.1)); // 26\n        console.log(Math.round(25.9)); // 26\n        console.log(Math.round(25.5)); // 26\n        console.log(Math.round(25.1)); // 25\n        console.log(Math.fround(0.4)); // 0.4000000059604645\n        console.log(Math.fround(0.5)); // 0.5\n        console.log(Math.fround(25.9)); // 25.899999618530273\n        console.log(Math.floor(25.9)); // 25\n        console.log(Math.floor(25.5)); // 25\n        console.log(Math.floor(25.1)); // 25 \n\n//Math.ceil()方法始终向上舍入为最接近的整数\n//Math.floor()方法始终向下舍入为最接近的整数\n//Math.round()方法执行四舍五入\n//Math.fround()方法返回数值最接近的单精度（32 位）浮点值表示\n\n\n2.4\n// 随机数\n         let round = Math.random()  \n//返回一个 0-1 范围内的随机数（0.9356889462950324），其中包含0但是不包含1\n\n2.4.1\n//返回一个 [a,b]中的随机数\n        let bb = Math.round(Math.random()*b + a)\n</code></pre>\n<h5 id=\"7：数据类型检测\"><a href=\"#7：数据类型检测\" class=\"headerlink\" title=\"7：数据类型检测\"></a>7：数据类型检测</h5><pre><code class=\"javascript\">(1)typeof  (2)instanceof  (3)constructor  (4)Object.prototype.toString.call()\n\n1：在`JavaScript`里使用`typeof`判断数据类型，只能区分**基本类型**，即：`number`、`string`、`undefined`、`boolean`、`object`。\n\n2：对于`null`、`array`、`function`、`object`来说，使用`typeof`都会统一返回`object`字符串。\n\n3：要想区分对象、数组、函数、单纯使用`typeof`是不行的。在JS中，可以通过`Object.prototype.toString.call()`方法，判断某个对象之属于哪种内置类型。分为`null`、`string`、`boolean`、`number`、`undefined`、`array`、`function`、`object`、`date`、`math`。\n\n4：constructor 本来是用于标识对象类型的。\n\n5：一般认为 instanceof 操作符是确定对象类型 更可靠的方式。\n\n\n    let obj = &#123;&#125;\n    let num1 = 1\n    console.log(typeof obj)   //object\n    console.log(obj instanceof Object)  //true\n    console.log(obj.constructor) //ƒ Object() &#123; [native code] &#125;\n    console.log( Object.prototype.toString.call(1)) // [object Number]\n    console.log(Object.prototype.toString.call(obj)) // [object Object]\n</code></pre>\n<h5 id=\"8：深浅拷贝\"><a href=\"#8：深浅拷贝\" class=\"headerlink\" title=\"8：深浅拷贝\"></a>8：深浅拷贝</h5><p>1：深浅拷贝的区别</p>\n<p>首先要知道一点的就是，JavaScript的数据类型的分为基本数据类型和引用类型，</p>\n<p>对于基本数据类型的拷贝，并没有深浅拷贝的区别，我们所说的深浅拷贝都是对于<strong>引用数据类型</strong>而言的</p>\n<p><strong>浅拷贝的概念</strong></p>\n<p>浅拷贝的意思就是只复制引用，而未复制真正的值。</p>\n<pre><code class=\"javascript\">       // 定义一个数组\n       let arr = [1,2,3,4,5]\n       // 定义一个对象\n       let obj = &#123;a:&#39;a&#39;,b:&#39;b&#39;,c:[1,2,3,4,5],d:&#123;dd:&#39;dd&#39;&#125;&#125;\n    \n       //赋值这个数组给另一个变量\n       let clonearr = arr\n       //赋值这个数组给另一个对象\n       let cloneobj = obj \n\n        // 打印一下拷贝的数据，嗯，是个原本来的一样的\n       console.log(clonearr) // [1,2,3,4,5]\n       console.log(cloneobj) // &#123;a:&#39;a&#39;,b:&#39;b&#39;,c:Array[3],d:&#123;dd:&#39;dd&#39;&#125;&#125;\n    \n        // 这个时候操作来了，我们给这个克隆的数组添加数据 克隆的对象也修改数据\n        clonearr.push(6)\n        cloneobj.a = &#123;aa:&#39;aa&#39;&#125;\n\n        //打印2个数组   发现arr是和修改过的clonearr是一样的\n        console.log(arr)  // [1,2,3,4,5,6]\n        console.log(clonearr) // [1,2,3,4,5,6]\n\n        //打印2个对象   发现obj是和修改过的cloneobj是一样的\n        console.log(obj); // &#123;a:&#123;aa:&#39;aa&#39;&#125;,b:&#39;b&#39;,c:Array[3],d:&#123;dd:&#39;dd&#39;&#125;&#125;\n        console.log(cloneobj); // &#123;a:&#123;aa:&#39;aa&#39;&#125;,b:&#39;b&#39;,c:Array[3],d:&#123;dd:&#39;dd&#39;&#125;&#125;\n \n</code></pre>\n<h6 id=\"1：深拷贝有哪些方式？\"><a href=\"#1：深拷贝有哪些方式？\" class=\"headerlink\" title=\"1：深拷贝有哪些方式？\"></a>1：深拷贝有哪些方式？</h6><pre><code class=\"javascript\">深拷贝就是对目标的完全拷贝，不像浅拷贝那样只是复制了一层引用，就连值也都复制了。\n\n只要进行了深拷贝，它们老死不相往来，谁也不会影响谁。\n\n目前实现深拷贝的方法不多，主要是两种：\n\n1. 利用 `JSON` 对象中的 `parse` 和 `stringify`\n2. 利用递归来实现每一层都重新创建对象并赋值\n\n`JSON.stringify` 是将一个 `JavaScript` 值转成一个 `JSON` 字符串。\n\n`JSON.parse` 是将一个 `JSON` 字符串转成一个 `JavaScript` 值或对象。\n</code></pre>\n<p><strong>使用JSON.stringify(obj)的缺点</strong></p>\n<pre><code class=\"javascript\">   确实是深拷贝，也很方便。但是，这个方法只能适用于一些简单的情况。比如下面这样的一个对象就不适用：   \nconst obj = &#123;\n          name:&#39;gsq&#39;,\n          hello:function()&#123;\n              console.log(&#39;gsq&#39;);\n          &#125;\n      &#125;\n\n      const cloneobj = JSON.parse(JSON.stringify(obj))\n\n      console.log(obj) // &#123;name: &quot;gsq&quot;, hello: ƒ&#125;\n      console.log(cloneobj) //  &#123;name: &quot;gsq&quot;&#125;\n</code></pre>\n<p><strong>注意</strong>：使用 JSON.parse(JSON.stringify(obj)) 进行深拷贝 对   <code>undefined</code>、<code>function</code>、<code>symbol</code> 会在转换过程中被忽略。。。</p>\n<p><strong>递归的方法</strong></p>\n<p>递归的思想就很简单了，就是对每一层的数据都实现一次 <code>创建对象-&gt;对象赋值</code> 的操作，简单粗暴上代码：</p>\n<p><strong>这种方式就不存在<code>undefined</code>、<code>function</code>、<code>symbol</code> 被忽略了</strong></p>\n<pre><code class=\"javascript\">function deepClone(source)&#123;\n  const targetObj = source.constructor === Array ? [] : &#123;&#125;; // 判断复制的目标是数组还是对象\n  for(let keys in source)&#123; // 遍历目标\n    if(source.hasOwnProperty(keys))&#123;\n      if(source[keys] &amp;&amp; typeof source[keys] === &#39;object&#39;)&#123; // 如果值是对象，就递归一下\n        targetObj[keys] = source[keys].constructor === Array ? [] : &#123;&#125;;\n        targetObj[keys] = deepClone(source[keys]);\n      &#125;else&#123; // 如果不是，就直接赋值\n        targetObj[keys] = source[keys];\n      &#125;\n    &#125; \n  &#125;\n  return targetObj;\n&#125;\n</code></pre>\n<h6 id=\"2：浅拷贝有哪些方式\"><a href=\"#2：浅拷贝有哪些方式\" class=\"headerlink\" title=\"2：浅拷贝有哪些方式\"></a>2：浅拷贝有哪些方式</h6><p>1：concat</p>\n<pre><code class=\"javascript\">        const arr = [1,2,3,4,5];\n        const clonearr = arr.concat();\nconsole.log(arr === clonearr)  // false\n</code></pre>\n<p>2：slice</p>\n<pre><code class=\"javascript\">    let arr1 = [1,2,3,4]\n    let arr2 = arr1.slice()\nconsole.log(arr1 === arr2) //false\n</code></pre>\n<p>3：es6之  <code>Object.assign()</code></p>\n<pre><code class=\"javascript\">    let obj = &#123;&#39;a&#39; : 1, &#39;b&#39; : 2&#125;\n    let cloneobj = Object.assign(&#123;&#125;,obj)\nconsole.log(obj === cloneobj) //false    \n</code></pre>\n<p>4：es6扩展运算符 …</p>\n<pre><code class=\"javascript\">        let arr = [1,2,3,4]\n        let clonearr = [...arr]\nconsole.log(arr === clonearr) //false\n</code></pre>\n<p>5：es6 from方法</p>\n<pre><code class=\"javascript\">        const a1 = [1, 2, 3, 4];\n        const a2 = Array.from(a1); \nconsole.log(a1 === a2) //false\n</code></pre>\n<p>6：使用map方法</p>\n<pre><code class=\"javascript\">        const arr = [1,2,3,4]\n        let clonearr = arr.map(item =&gt; item)\nconsole.log(arr === clonearr)\n</code></pre>\n<p>7：自定义函数浅拷贝</p>\n<pre><code class=\"javascript\">function shallowClone(source) &#123;\n  const targetObj = source.constructor === Array ? [] : &#123;&#125;; // 判断复制的目标是数组还是对象\n  for (let keys in source) &#123; // 遍历目标\n    if (source.hasOwnProperty(keys)) &#123;\n      targetObj[keys] = source[keys];\n    &#125;\n  &#125;\n  return targetObj;\n&#125;\n</code></pre>\n<p><strong>总结</strong>：</p>\n<ol>\n<li>赋值运算符 <code>=</code> 实现的是浅拷贝，只拷贝对象的引用值；</li>\n<li>JavaScript 中数组和对象自带的拷贝方法都是“首层深拷贝”；</li>\n<li><code>JSON.stringify</code> 实现的是深拷贝，但是对目标对象有要求，转化的值不能是<code>function</code>，<code>undefined</code>，<code>symbol</code> ；</li>\n<li>若想真正意义上的深拷贝，请递归。</li>\n</ol>\n<h1 id=\"二：作用域以及变量\"><a href=\"#二：作用域以及变量\" class=\"headerlink\" title=\"二：作用域以及变量\"></a>二：作用域以及变量</h1><h5 id=\"2：变量声明提升\"><a href=\"#2：变量声明提升\" class=\"headerlink\" title=\"2：变量声明提升\"></a>2：变量声明提升</h5><p><strong>只有var会存在变量提升</strong></p>\n<pre><code class=\"javascript\">       var a = 1;\n       var b = 2;\n       var c = 4;\n       a = b = c ;  //相当于  a = c    b = c\n       console.log(a) //4\n       console.log(b) //4\n       console.log(c) //4\n       console.log(a = b = c) //4\n</code></pre>\n<pre><code class=\"javascript\">        var foo = 1;\n        function bar() &#123;\n            if (!foo) &#123;\n                var foo = 10;\n            &#125;\n            alert(foo);\n        &#125;\n         bar();   //输出什么?\n\n解析过程：\n        //1:首先会预解析 ：注意函数比变量优先级高\n        function bar()&#123;\n            var foo;   //这里此时foo没有被赋值 是undefined\n            if(!foo) &#123; //!undefined == true\n                var foo; \n                foo = 10\n            &#125;  //到这里后foo被赋值为10\n            alert(foo)\n        &#125;\n        var foo;\n        foo = 1;\n        bar()  // 10\n</code></pre>\n<pre><code class=\"javascript\">        var num = 123;\n        function f1(num) &#123;\n            console.log(num); \n        &#125;\n        function f2() &#123;\n            var num = 456;\n            f1(num);\n        &#125;\n        f2();\n\n解析过程：\n        //1:首先会预解析 ：注意函数比变量优先级高\n        function f1(num)&#123;\n            console.log(num)\n        &#125;\n        function f2()&#123;  //执行f2函数\n            var num; //声明num\n            num = 456; //赋值456\n            f1(num) //执行f1函数 。传入num的值456 ，打印456\n        &#125;\n\n        var num;\n        num = 123;\n        f2()\n</code></pre>\n<pre><code class=\"javascript\">        function fn()&#123;\n           var a = 1, b = 1, c = 1;\n         &#125;\n         fn();\n         console.log(c); \n         console.log(b);\n         console.log(a); \n\n解析过程：\n        //  1:预解析\n        function fn()&#123;\n            var a,b,c;\n            a = 1, b = 1, c = 1;\n        &#125;\n        // 执行fn函数  因为作用域链是从里往外查询\n        // 分别输出cba 直接在c这一行报错\n        // 原因:\n        //js是解释型语言，执行一行解释一行，发现报错就停止执行\n        //因为作用域链是从里往外查询 此时输出cba的环境已经是最大的windows环境了\n</code></pre>\n<pre><code class=\"javascript\">        function fn1()&#123;\n           var a = b = c = 1;\n         &#125;\n         fn1();\n         console.log(c); \n         console.log(b); \n         console.log(a); \n\n解析过程：\n         //1:预解析\n         function fn1()&#123;\n             var a = 1;\n             b = 1;  \n             c = 1; \n         &#125;  //对于局部函数变量里面没有声明var的变量  都是全局变量\n         console.log(c);  //1 \n         console.log(b);  //1\n         console.log(a);  // Uncaught ReferenceError: a is not defined\n</code></pre>\n<pre><code class=\"javascript\">        var a = 1;\n        function fn()&#123;\n            var a = 2;\n            function fnSon(a)&#123;\n                a = 3;\n                console.log(a); \n            &#125;\n            fnSon();\n            console.log(a);  \n        &#125;\n        console.log(a);  \n        fn();\n        console.log(a); \n\n解析过程：\n        //预解析\n        function fn()&#123;\n            function fnSon(a)&#123;\n                a = 3; //a没有定义var是全局变量\n                console.log(a) //直接得到当前作用域的值 3\n            &#125;\n            var a; //跟fnSon函数同一作用预的变量a\n            a = 2; //a赋值2\n            fnSon(); //此时fnSon并未传入参数a ,直接执行fnSon \n            console.log(a) //得到当前作用域的值 2\n        &#125;\n        var a;\n        a = 1;\n        console.log(a) //直接得到全局变量 1\n        fn(); //执行fn函数 \n        console.log(a)  //\n</code></pre>\n<pre><code class=\"javascript\">        var a ;\n        function a()&#123;\n            console.log(&#39;呵呵&#39;)\n            function a()&#123;\n                a = 4;\n                console.log(&#39;哈哈&#39;)\n            &#125;\n            a();\n            console.log(a);\n        &#125;\n        a();\n        console.log(a);\n\n解析过程:\n        //预解析\n        function a()&#123;\n            console.log(&#39;呵呵&#39;) //注意啦:  打印不存在变量提升\n            function a()&#123;\n                a = 4; //全局变量a\n                console.log(&#39;哈哈&#39;)  //哈哈\n            &#125;\n            a() \n            console.log(a) // 取得当前同级作用域的 4 \n        &#125;\n        var a;\n        a()\n        console.log(a) //函数a //此时函数a取代了 a 函数\n</code></pre>\n<pre><code class=\"javascript\">        var value = &#39;hello&#39;;\n        function show() &#123;\n            alert(value);\n            if (!value) &#123;\n                var value = &#39;function&#39;;\n            &#125;\n            alert(value);\n        &#125;\n        show() \n\n\n解析过程：\n        // 预解析\n        var value;\n        value = &#39;hello&#39;\n        function show() &#123;\n            var value;  //undefined\n            alert(value) \n            if(!value)&#123;  //!undnefined  = true\n                value = &#39;function&#39; \n            &#125;\n            alert(value)       \n        &#125;\n        show()  //此处调用函数依次弹出 &quot;undefined&quot;, &quot;function&quot;\n</code></pre>\n<h5 id=\"3：作用域链\"><a href=\"#3：作用域链\" class=\"headerlink\" title=\"3：作用域链\"></a>3：作用域链</h5><p>作用域分为<strong>全局作用域</strong>和<strong>函数作用域</strong></p>\n<table>\n<thead>\n<tr>\n<th>作用域</th>\n<th>意义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>函数作用域</td>\n<td>在固定的代码片段才能被访问</td>\n</tr>\n<tr>\n<td>全局作用域</td>\n<td>代码在程序的任何地方都能被访问，window 对象的内置属性都拥有全局作用域。</td>\n</tr>\n</tbody></table>\n<pre><code class=\"javascript\">        var a = 10, b = 20;  //全局作用域\n        function fn() &#123;\n            var a = 100, c = 300; //fn作用域\n            console.log(a);\n            function bar() &#123;  \n                var a = 1000, d = 4000  //bar作用域\n                console.log(a);\n            &#125;\n        &#125;\n        bar()\n\n作用域特点：\n作用域有上下级关系，上下级关系的确定就看函数是在哪个作用域下创建的。如上，fn作用域下创建了bar函数，那么“fn作用域”就是“bar作用域”的上级。   \n\n作用域用处：\n作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。\n\n变量取值：\n到创建 这个变量 的函数的作用域中取值\n</code></pre>\n<p>作用域链</p>\n<pre><code class=\"javascript\">        var x = 10;\n\n        function fn() &#123;\n            console.log(x);\n        &#125;\n\n        function show(f) &#123;\n            var x = 20;\n            (function () &#123;\n                f();    // 10\n            &#125;)()\n        &#125;\n\n        show(fn);\n1：一般情况下，变量取值到 创建 这个变量 的函数的作用域中取值。\n    \n2：但是如果在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链。\n</code></pre>\n<h5 id=\"4：闭包（closure）\"><a href=\"#4：闭包（closure）\" class=\"headerlink\" title=\"4：闭包（closure）\"></a>4：闭包（closure）</h5><table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>特点</td>\n<td>1：外部访问函数内部变成可能（我们知道作用域链，是只能里面一层一层访问到外面，但是，外部不能访问内部）2：局部变量常驻在内存中  3：可以避免使用全局变量，防止全局变量污染  4：缺点是会造成内存泄漏（有一块内存空间长期被占用，而不被释放）</td>\n</tr>\n<tr>\n<td>概念</td>\n<td><strong>闭包函数：</strong>声明在一个函数中的函数，叫做闭包函数。<strong>闭包：</strong>内部函数总是可以访问其所在的外部函数中声明的参数和变量，即使在其外部函数被返回（寿命终结）了之后。</td>\n</tr>\n</tbody></table>\n<p>闭包的创建</p>\n<pre><code class=\"javascript\">example 1\n        function funA() &#123;\n            var a = 10;  // funA的活动对象之中;\n            return function () &#123;   //匿名函数的活动对象;\n                alert(a);\n            &#125;\n        &#125;\n        var b = funA();\n        b();  //10\n</code></pre>\n<pre><code class=\"javascript\">example 2\n        function outerFn() &#123;\n            var i = 0;\n            function innerFn() &#123;\n                i++;\n                console.log(i);\n            &#125;\n            return innerFn;\n        &#125;\n        var inner = outerFn();  //每次外部函数执行的时候,都会开辟一块内存空间,外部函数的地址不同，都会重新创建一个新的地址\n        inner();\n        inner();\n        inner();\n        var inner2 = outerFn();\n        inner2();\n        inner2();\n        inner2();   //1 2 3 1 2 3\n</code></pre>\n<pre><code class=\"javascript\">example 3\n        var i = 0;\n        function outerFn() &#123;\n            function innnerFn() &#123;\n                i++;\n                console.log(i);\n            &#125;\n            return innnerFn;\n        &#125;\n        var inner1 = outerFn();\n        var inner2 = outerFn();\n        inner1();\n        inner2();      //同一个地址变量每调用一次  i+1 \n        inner1();\n        inner2();     //1 2 3 4\n</code></pre>\n<pre><code class=\"javascript\">example 4\n        function fn() &#123;\n            var a = 3;\n            return function () &#123;\n                return ++a;\n            &#125;\n        &#125;\n        alert(fn()());  //4   \n        alert(fn()());  //4 \n    //并没有创建地址变量去保存\n</code></pre>\n<pre><code class=\"javascript\">example 5\n        function outerFn() &#123;\n            var i = 0;\n            function innnerFn() &#123;\n                i++;\n                console.log(i);\n            &#125;\n            return innnerFn;\n        &#125;\n        var inner1 = outerFn();\n        var inner2 = outerFn();\n        inner1();\n        inner2();\n        inner1();\n        inner2();    //1 1 2 2\n</code></pre>\n<pre><code class=\"javascript\">example 6\n        (function () &#123;   //自调用函数\n            var m = 0;\n            function getM() &#123; return m; &#125; \n            function seta(val) &#123; m = val; &#125; \n            window.g = getM;  //window是最高级的对象  添加windows下一个g的一个键值  值为 getM\n            window.f = seta; \n        &#125;)();\n        f(100);\n        console.info(g());   //100  闭包找到的是同一地址中父级函数中对应变量最终的值\n</code></pre>\n<pre><code class=\"javascript\">example 7\n        function a() &#123;\n            var i = 0;\n            function b() &#123; alert(++i); &#125;\n            return b;\n        &#125;\n        var c = a();   //函数的赋值是引用类型的\n        c();      //1 \n        c();      //2\n</code></pre>\n<pre><code class=\"javascript\">example 8\n        function f() &#123;\n            var count = 0;\n            return function () &#123;\n                count++;\n                console.info(count);\n            &#125;\n        &#125;\n        var t1 = f();\n        t1();     //1 \n        t1();     //2 \n        t1();     //3 \n</code></pre>\n<pre><code class=\"javascript\">example 9\n        var add = function (x) &#123;\n            var sum = 1;\n            var tmp = function (x) &#123;\n                sum = sum + x;\n                return tmp;\n            &#125;\n            tmp.toString = function () &#123;\n                return sum;\n            &#125;\n            return tmp;\n        &#125;\n        alert(add(1)(2)(3));     //6\n</code></pre>\n<pre><code class=\"javascript\">example 10\n        var lis = document.getElementsByTagName(&quot;li&quot;);\n        for (var i = 0; i &lt; lis.length; i++) &#123;\n            (function (i) &#123;\n                lis[i].onclick = function () &#123;\n                    console.log(i);\n                &#125;;\n            &#125;)(i);       //事件处理函数中闭包的写法\n        &#125;\n</code></pre>\n<pre><code class=\"javascript\">example 11\n        function m1() &#123;\n            var x = 1;\n            return function () &#123;\n                console.log(++x);\n            &#125;\n        &#125;\n\n        m1()();   //2\n        m1()();   //2\n        m1()();   //2\n\n        var m2 = m1();\n        m2();   //2\n        m2();   //3\n        m2();   //4\n   //一个是有变量地址的，一个是没有的 ，有的才会保存\n</code></pre>\n<pre><code class=\"javascript\">example 12\n        var fn = (function () &#123;\n            var i = 10;\n            function fn() &#123;\n                console.log(++i);\n            &#125;\n            return fn;\n        &#125;)()\n        fn();   //11\n        fn();   //12\n</code></pre>\n<pre><code class=\"javascript\">example 13\n        function love1() &#123;\n            var num = 223;\n            var me1 = function () &#123;\n                console.log(num);\n            &#125;\n            num++;\n            return me1;\n        &#125;\n        var loveme1 = love1();\n        loveme1();   //输出224\n预解析：\n        function love1() &#123;\n            var num;\n            var me1;\n            me1 = function()&#123;\n                console.log(num)\n            &#125;\n            num = 233\n            num ++;\n            return me1;\n        &#125;\n        var loveme1 = love1();\n        loveme1();   //输出224\n</code></pre>\n<pre><code class=\"javascript\">example 14\n        function fun(n, o) &#123;\n            console.log(o);\n            return &#123;\n                fun: function (m) &#123;\n                    return fun(m, n);\n                &#125;\n            &#125;;\n        &#125;\n        var a = fun(0);  //undefined\n        a.fun(1);  //0  \n        a.fun(2);  //0  \n        a.fun(3);  //0  \n        var b = fun(0).fun(1).fun(2).fun(3);   //undefined  0  1  2\n        var c = fun(0).fun(1);\n        c.fun(2);\n        c.fun(3);  //undefined  0  1  1\n</code></pre>\n<pre><code class=\"javascript\">example 15\n        function fn() &#123;\n            var arr = [];\n            for (var i = 0; i &lt; 5; i++) &#123;\n                arr[i] = function () &#123;\n                    return i;\n                &#125;\n            &#125;\n            return arr;\n        &#125;\n        var list = fn();\n        for (var i = 0, len = list.length; i &lt; len; i++) &#123;\n            console.log(list[i]());\n        &#125;  //5 5 5 5 5\n</code></pre>\n<pre><code class=\"javascript\">example 16\n        function fn() &#123;\n            var arr = [];\n            for (var i = 0; i &lt; 5; i++) &#123;\n                arr[i] = (function (i) &#123;\n                    return function () &#123;\n                        return i;\n                    &#125;;\n                &#125;)(i);\n            &#125;\n            return arr;\n        &#125;\n        var list = fn();\n        for (var i = 0, len = list.length; i &lt; len; i++) &#123;\n            console.log(list[i]());\n        &#125;  //0 1 2 3 4\n</code></pre>\n<h1 id=\"三：JavaScript创建对象\"><a href=\"#三：JavaScript创建对象\" class=\"headerlink\" title=\"三：JavaScript创建对象\"></a>三：JavaScript创建对象</h1><h5 id=\"1：js创建对象的几种方式的优缺点\"><a href=\"#1：js创建对象的几种方式的优缺点\" class=\"headerlink\" title=\"1：js创建对象的几种方式的优缺点\"></a>1：js创建对象的几种方式的优缺点</h5><pre><code class=\"javascript\">1:工厂模式\n        function createPerson(name, age, job) &#123;\n            let o = new Object();\n            o.name = name;\n            o.age = age;\n            o.job = job;\n            o.sayName = function () &#123;\n                console.log(this.name);\n            &#125;;\n            return o;\n        &#125;\n        let person1 = createPerson(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);\n        let person2 = createPerson(&quot;Greg&quot;, 27, &quot;Doctor&quot;);\n        console.log(person1.isPrototypeOf == person2.isPrototypeOf); //true\n\n//敲重点一：\n这里，函数 createPerson()接收 3 个参数，根据这几个参数构建了一个包含 Person 信息的对象。\n可以用不同的参数多次调用这个函数，每次都会返回包含 3 个属性和 1 个方法的对象。这种工厂模式虽\n然可以解决创建多个类似对象的问题，但没有解决对象标识问题（即新创建的对象是什么类型）。\n</code></pre>\n<pre><code class=\"javascript\">2:构造函数模式\n        function Person(name, age, job) &#123;\n            this.name = name;\n            this.age = age;\n            this.job = job;\n            this.sayName = function () &#123;\n                console.log(this.name);\n            &#125;;\n        &#125;\n        let person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);\n        let person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);\n        person1.sayName(); // Nicholas\n        person2.sayName(); // Greg \n        console.log(person1.isPrototypeOf == person2.isPrototypeOf) //true\n        console.log(person1.sayName == person2.sayName);  //false    \n\n//敲重点一：\n实际上，Person()内部的代码跟 createPerson()基本是一样的，只是有如下区别。\n1: 没有显式地创建对象没有 return\n2: 属性和方法直接赋值给了 this\n3: 没有 return\n\n//敲重点二：\n构造函数名称的首字母都是要大写的，非构造函数则以小写字母开头。\n有助于在 ECMAScript 中区分构造函数和普通函数。毕竟 ECMAScript 的构造函数就是能创建对象的函数。\n\n//敲重点三：\n要创建 Person 的实例，应使用 new 操作符。以这种方式调用构造函数会执行如下操作。\n1: 在内存中创建一个新对象。\n2: 这个新对象内部的[[Prototype]]特性被赋值为构造函数的 prototype 属性。\n3: 构造函数内部的 this 被赋值为这个新对象（即 this 指向新对象）。\n4: 执行构造函数内部的代码（给新对象添加属性）。\n5: 如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。\n\n//敲重点四：\nperson1 和 person2 分别保存着 Person 的不同实例。这两个对象都有一个 constructor 属性指向 Person，\nconsole.log(person1.constructor == Person); // true\nconsole.log(person2.constructor == Person); // true \nconstructor 本来是用于标识对象类型的。不过，一般认为 instanceof 操作符是确定对象类型\n更可靠的方式。前面例子中的每个对象都是 Object 的实例，同时也是 Person 的实例，如下面调用\ninstanceof 操作符的结果所示：\nconsole.log(person1 instanceof Object); // true\nconsole.log(person1 instanceof Person); // true\nconsole.log(person2 instanceof Object); // true\nconsole.log(person2 instanceof Person); // true \n定义自定义构造函数可以确保实例被标识为特定类型，相比于工厂模式，这是一个很大的好处。在\n这个例子中，person1 和 person2 之所以也被认为是 Object 的实例，是因为所有自定义对象都继承自 Object\n\n//敲重点五：\n构造函数不一定要写成函数声明的形式。赋值给变量的函数表达式也可以表示构造函数：\n        let Person = function (name, age, job) &#123;\n            this.name = name;\n            this.age = age;\n            this.job = job;\n            this.sayName = function () &#123;\n                console.log(this.name);\n            &#125;;\n        &#125;\nlet person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);\nlet person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);\nperson1.sayName(); // Nicholas\nperson2.sayName(); // Greg\nconsole.log(person1 instanceof Object); // true\nconsole.log(person1 instanceof Person); // true\nconsole.log(person2 instanceof Object); // true\nconsole.log(person2 instanceof Person); // true \n\n//敲重点六：\n在实例化时，如果不想传参数，那么构造函数后面的括号可加可不加。只要有 new 操作符，就可以调用相应的构造函数：\n        function Person() &#123;\n            this.name = &quot;Jake&quot;;\n            this.sayName = function () &#123;\n                console.log(this.name);\n            &#125;;\n        &#125;\n        let person1 = new Person();\n        let person2 = new Person;\n\n        person1.sayName(); // Jake\n        person2.sayName(); // Jake\n        console.log(person1 instanceof Object); // true\n        console.log(person1 instanceof Person); // true\n        console.log(person2 instanceof Object); // true\n        console.log(person2 instanceof Person); // true\n\n//敲重点七： 构造函数也是函数\n构造函数与普通函数唯一的区别就是调用方式不同。除此之外，构造函数也是函数。并没有把某个\n函数定义为构造函数的特殊语法。任何函数只要使用 new 操作符调用就是构造函数，而不使用 new 操\n作符调用的函数就是普通函数。比如，前面的例子中定义的 Person()可以像下面这样调用：\n\n为啥都是大写，因为这样可以区别于普通的函数，一目了然的就知道这是构造函数\n\n\n//敲重点八：构造函数的问题（优化构造函数）\n构造函数虽然有用，但也不是没有问题。构造函数的主要问题在于，其定义的方法会在每个实例上\n都创建一遍。因此对前面的例子而言，person1 和 person2 都有名为 sayName()的方法，但这两个方\n法不是同一个 Function 实例。我们知道，ECMAScript 中的函数是对象，因此每次定义函数时，都会\n初始化一个对象\n\n逻辑上讲，这个构造函数实际上是这样的：\n function Person(name, age, job) &#123;\n            this.name = name;\n            this.age = age;\n            this.job = job;\n            this.sayName = new Function(&quot;console.log(this.name)&quot;); // 逻辑等价\n        &#125;\n这样理解这个构造函数可以更清楚地知道，每个 Person 实例都会有自己的 Function 实例用于显\n示 name 属性。当然了，以这种方式创建函数会带来不同的作用域链和标识符解析。但创建新 Function\n实例的机制是一样的。因此不同实例上的函数虽然同名却不相等，如下所示：\nconsole.log(person1.sayName == person2.sayName); // false \n\n怎么优化呢?\n    函数定义转移到构造函数外部\n        function Person(name, age, job) &#123;\n            this.name = name;\n            this.age = age;\n            this.job = job;\n            this.sayName = sayName;\n        &#125;\n        function sayName() &#123;\n            console.log(this.name);\n        &#125;\n        let person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);\n        let person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);\n        person1.sayName(); // Nicholas\n        person2.sayName(); // Greg \n    \n在这里，sayName()被定义在了构造函数外部。在构造函数内部，sayName 属性等于全局 sayName()函数。因为这一次 sayName 属性中包含的只是一个指向外部函数的指针，所以 person1 和 person2共享了定义在全局作用域上的 sayName()函数。这样虽然解决了相同逻辑的函数重复定义的问题，但全局作用域也因此被搞乱了，因为那个函数实际上只能在一个对象上调用。如果这个对象需要多个方法，那么就要在全局作用域中定义多个函数。这会导致自定义类型引用的代码不能很好地聚集一起。这个新问题可以通过原型模式来解决。\n</code></pre>\n<h5 id=\"2：原型模式创建对象（重点部分单独分离出来）\"><a href=\"#2：原型模式创建对象（重点部分单独分离出来）\" class=\"headerlink\" title=\"2：原型模式创建对象（重点部分单独分离出来）\"></a>2：原型模式创建对象（重点部分单独分离出来）</h5><pre><code class=\"javascript\">//敲重点一：为啥出现原型模式创建对象?\n这样虽然解决了相同逻辑的函数重复定义的问题，但全局作用域也因此被搞乱了，因为那个函数实际上只能在一个对象上调用。如果这个对象需要多个方法，那么就要在全局作用域中定义多个函数。这会导致自定义类型引用的代码不能很好地聚集一起。这个新问题可以通过原型模式来解决。\n\n        function Person() &#123; &#125;\n        //也可以使用函数表达式的方式创建对象\n        //  let Person = function() &#123;&#125;; \n    \n        Person.prototype.name = &quot;Nicholas&quot;;\n        Person.prototype.age = 29;\n        Person.prototype.job = &quot;Software Engineer&quot;;\n        Person.prototype.sayName = function () &#123;\n            console.log(this.name);\n        &#125;;\n        let person1 = new Person();\n        person1.sayName(); // &quot;Nicholas&quot;\n        let person2 = new Person();\n        person2.sayName(); // &quot;Nicholas&quot;\n        console.log(person1.sayName == person2.sayName); // true\n这里，所有属性和 sayName()方法都直接添加到了 Person 的 prototype 属性上，构造函数体中什么也没有。但这样定义之后，调用构造函数创建的新对象仍然拥有相应的属性和方法。与构造函数模式不同，使用这种原型模式定义的属性和方法是由所有实例共享的。因此 person1 和 person2 访问的都是相同的属性和相同的 sayName()函数。要理解这个过程，就必须理解 ECMAScript 中原型的本质。 \n\n\n\n//敲重点二：理解原型\n无论何时，只要创建一个函数，就会按照特定的规则为这个函数创建一个 prototype 属性（指向原型对象）。默认情况下，所有原型对象自动获得一个名为 constructor 的属性，指回与之关联的构造函数。对前面的例子而言，Person.prototype.constructor 指向 Person。然后，因构造函数而异，可能会给原型对象添加其他属性和方法。\n\n在自定义构造函数时，原型对象默认只会获得 constructor 属性，其他的所有方法都继承自Object。每次调用构造函数创建一个新实例，这个实例的内部[[Prototype]]指针就会被赋值为构造函数的原型对象。脚本中没有访问这个[[Prototype]]特性的标准方式，但 Firefox、Safari 和 Chrome会在每个对象上暴露__proto__属性，通过这个属性可以访问对象的原型。在其他实现中，这个特性完全被隐藏了。关键在于理解这一点：实例与构造函数原型之间有直接的联系，但实例与构造函数之间没有。\n\n1:构造函数可以是函数表达式, 也可以是函数声明\n2:声明之后，构造函数就有了一个 与之关联的原型对象\n3:如前所述，构造函数有一个 prototype 属性 引用其原型对象，而这个原型对象也有一个 constructor 属性，引用这个构造函数 换句话说，两者循环引用\n4: 正常的原型链都会终止于 Object 的原型对象,Object 原型的原型是 null\n5:构造函数、原型对象和实例是 3 个完全不同的对象\n6:实例通过__proto__链接到原型对象 它实际上指向隐藏特性[[Prototype]] 构造函数通过 prototype 属性链接到原型对象 实例与构造函数没有直接联系，与原型对象有直接联系\n7: 同一个构造函数创建的两个实例 共享同一个原型对象：\n\n\n//敲重点三：相关API\n1：\n使用 isPrototypeOf()方法确定两个对象之间的这种关系\n本质上，isPrototypeOf()会在传入参数的[[Prototype]]指向调用它的对象时返回 true\n//说白了就是判断当前的实例对象是不是指向当前的原型\nconsole.log(Person.prototype.isPrototypeOf(person1)); // true\nconsole.log(Person.prototype.isPrototypeOf(person2)); // true \n\n2：\nECMAScript的Object 类型有一个方法叫 Object.getPrototypeOf()，返回参数的内部特性[[Prototype]]的值 \n//说白了，就是获取当前实例的原型对象\nconsole.log(Object.getPrototypeOf(person1) == Person.prototype); // true\nconsole.log(Object.getPrototypeOf(person1).name); // &quot;Nicholas&quot;\n\n3:\nObject 类型还有一个 setPrototypeOf()方法，可以向实例的私有特性[[Prototype]]写入一\n个新值。这样就可以重写一个对象的原型继承关系\n        let biped = &#123;\n            numLegs: 2\n        &#125;;\n        let person = &#123;\n            name: &#39;Matt&#39;\n        &#125;;\n        Object.setPrototypeOf(person, biped);\n        console.log(person.name); // Matt\n        console.log(person.numLegs); // 2\n        console.log(Object.getPrototypeOf(person) === biped); // true\n//但是不建议这样做，会严重影响性能\n\n4:\n为避免使用 Object.setPrototypeOf()可能造成的性能下降，可以通过 Object.create()来创建一个新对象，同时为其指定原型\n        let biped = &#123;\n            numLegs: 2\n        &#125;;\n        let person = Object.create(biped);\n        person.name = &#39;Matt&#39;;\n        console.log(person.name); // Matt\n        console.log(person.numLegs); // 2\n        console.log(Object.getPrototypeOf(person) === biped); // true\n\n\n//敲重点四：原型层级\n说白了就是 构造函数创造出来的实例 访问属性或者方法 会先从构造函数里面寻找，如果找不到会到原型里面找\n</code></pre>\n<h1 id=\"四：JavaScript继承\"><a href=\"#四：JavaScript继承\" class=\"headerlink\" title=\"四：JavaScript继承\"></a>四：JavaScript继承</h1><h5 id=\"1：原型链\"><a href=\"#1：原型链\" class=\"headerlink\" title=\"1：原型链\"></a>1：原型链</h5><pre><code class=\"javascript\">//敲重点一： 什么是原型链\n原型链是ECMAScript的主要继承方式\n\n其基本思想就是通过原型继承多个引用\n类型的属性和方法。重温一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型有一个属性指回构造函数，而实例有一个内部指针指向原型。如果原型是另一个类型的实例呢？那就意味着这个原型本身有一个内部指针指向另一个原型，相应地另一个原型也有一个指针指向另一个构造函数。这样就在实例和原型之间构造了一条原型链。这就是原型链的基本构想。\n</code></pre>\n<h5 id=\"1：js如何实现继承-ES6类的原理\"><a href=\"#1：js如何实现继承-ES6类的原理\" class=\"headerlink\" title=\"1：js如何实现继承(ES6类的原理)\"></a>1：js如何实现继承(ES6类的原理)</h5><pre><code class=\"javascript\">原型链继承\n\n盗用构造函数继承\n\n组合继承\n\n原型式继承\n\n寄生式继承\n\n寄生组合继承\n</code></pre>\n<h5 id=\"2：ES6类\"><a href=\"#2：ES6类\" class=\"headerlink\" title=\"2：ES6类\"></a>2：ES6类</h5><pre><code class=\"javascript\">//敲重点一： 为什么出现类的概念\n因为通过原型链和构造函数虽然能是实现继承，各种继承策略都有自己的问题，也有相应的妥协 但是代码也显得非常冗长和混乱。   \n\n为解决这些问题，ECMAScript 6 新引入的 class 关键字具有正式定义类的能力。类（class）是ECMAScript 中新的基础性语法糖结构。虽然 ECMAScript 6 类表面上看起来可以支持正式的面向对象编程，但实际上它背后使用的仍然是原型和构造函数的概念\n\n//敲重点二： 怎么定义一个类\nclass Person &#123;&#125;  //类声明\n或者\nconst Animal = class &#123;&#125;;  //类表达式\n\n与函数表达式类似，类表达式在它们被求值前也不能引用。\n与函数定义不同的是，虽然函数声明可以提升，但类定义不能\n\n//敲重点三：类可以由哪些构成\n构造函数方法、实例方法、获取函数、设置函数和静态类方法\n1.构造函数方法 constructor ，每当创建实例的时候都会执行\n2.实例方法  就是定义在原型上的方法，是每个实例都共享的\n3.静态方法  直接用类点静态方法调用，（注意，实例是不能调用的）\n静态方法很适合返回实例工厂\n        class Person &#123;\n            constructor(age) &#123;\n                this.age_ = age;\n            &#125;\n            sayAge() &#123;\n                console.log(this.age_);\n            &#125;\n            static create() &#123;\n                // 使用随机年龄创建并返回一个 Person 实例\n                return new Person(Math.floor(Math.random() * 100));\n            &#125;\n        &#125;\n        console.log(Person.create()); // Person &#123; age_: ... &#125;\n\n//敲重点四：继承\nES6 类支持单继承。使用 extends 关键字，就可以继承任何拥有[[Construct]]和原型的对象。很大程度上，这意味着不仅可以继承一个类，也可以继承普通的构造函数（保持向后兼容）\n</code></pre>\n<h1 id=\"五：new，this\"><a href=\"#五：new，this\" class=\"headerlink\" title=\"五：new，this\"></a>五：new，this</h1><h5 id=\"1：new操作符具体干了什么\"><a href=\"#1：new操作符具体干了什么\" class=\"headerlink\" title=\"1：new操作符具体干了什么\"></a>1：new操作符具体干了什么</h5><pre><code class=\"javascript\">1：在内存中创建一个新对象\n2：这个对象内部的[[Prototype]]特性被赋值为构造函数的protopype属性\n3：构造函数的内部的this被赋值为这个新对象（即this指向新对象）\n4：执行构造函数内部的代码（给新对象添加属性）\n5：如果构造函数返回非空对象，则返回该对象；否则返回刚创建的新对象\n</code></pre>\n<h5 id=\"2：new的模拟实现\"><a href=\"#2：new的模拟实现\" class=\"headerlink\" title=\"2：new的模拟实现\"></a>2：new的模拟实现</h5><h5 id=\"3：this对象的理解\"><a href=\"#3：this对象的理解\" class=\"headerlink\" title=\"3：this对象的理解\"></a>3：this对象的理解</h5><h1 id=\"六：call-x2F-apply-x2F-bind\"><a href=\"#六：call-x2F-apply-x2F-bind\" class=\"headerlink\" title=\"六：call&#x2F;apply&#x2F;bind\"></a>六：call&#x2F;apply&#x2F;bind</h1><h5 id=\"1：call-x2F-apply-x2F-bind\"><a href=\"#1：call-x2F-apply-x2F-bind\" class=\"headerlink\" title=\"1：call&#x2F;apply&#x2F;bind\"></a>1：call&#x2F;apply&#x2F;bind</h5><h5 id=\"2：call和apply的模拟实现\"><a href=\"#2：call和apply的模拟实现\" class=\"headerlink\" title=\"2：call和apply的模拟实现\"></a>2：call和apply的模拟实现</h5><h5 id=\"3：bind的模拟实现\"><a href=\"#3：bind的模拟实现\" class=\"headerlink\" title=\"3：bind的模拟实现\"></a>3：bind的模拟实现</h5><h1 id=\"七：事件\"><a href=\"#七：事件\" class=\"headerlink\" title=\"七：事件\"></a>七：事件</h1><h5 id=\"1：事件流\"><a href=\"#1：事件流\" class=\"headerlink\" title=\"1：事件流\"></a>1：事件流</h5><h5 id=\"2：事件的三个阶段\"><a href=\"#2：事件的三个阶段\" class=\"headerlink\" title=\"2：事件的三个阶段\"></a>2：事件的三个阶段</h5><h5 id=\"3：事件的代理有何委托\"><a href=\"#3：事件的代理有何委托\" class=\"headerlink\" title=\"3：事件的代理有何委托\"></a>3：事件的代理有何委托</h5><h5 id=\"4：如何派发事件\"><a href=\"#4：如何派发事件\" class=\"headerlink\" title=\"4：如何派发事件\"></a>4：如何派发事件</h5><h1 id=\"八：event-loop\"><a href=\"#八：event-loop\" class=\"headerlink\" title=\"八：event loop\"></a>八：event loop</h1><h5 id=\"1：进程和线程\"><a href=\"#1：进程和线程\" class=\"headerlink\" title=\"1：进程和线程\"></a>1：进程和线程</h5><h5 id=\"2：执行栈\"><a href=\"#2：执行栈\" class=\"headerlink\" title=\"2：执行栈\"></a>2：执行栈</h5><h5 id=\"3：为什么js是单线程，而不是多线程\"><a href=\"#3：为什么js是单线程，而不是多线程\" class=\"headerlink\" title=\"3：为什么js是单线程，而不是多线程\"></a>3：为什么js是单线程，而不是多线程</h5><h5 id=\"4：宏任务-x2F-微任务\"><a href=\"#4：宏任务-x2F-微任务\" class=\"headerlink\" title=\"4：宏任务&#x2F;微任务\"></a>4：宏任务&#x2F;微任务</h5><h5 id=\"5-浏览器与Node事件（有何区别）\"><a href=\"#5-浏览器与Node事件（有何区别）\" class=\"headerlink\" title=\"5:浏览器与Node事件（有何区别）\"></a>5:浏览器与Node事件（有何区别）</h5><h1 id=\"十：浏览器缓存机制\"><a href=\"#十：浏览器缓存机制\" class=\"headerlink\" title=\"十：浏览器缓存机制\"></a>十：浏览器缓存机制</h1><h5 id=\"1：缓存位置\"><a href=\"#1：缓存位置\" class=\"headerlink\" title=\"1：缓存位置\"></a>1：缓存位置</h5><pre><code class=\"javascript\">## webStorage\n\n1. 存储内容大小一般支持5MB左右（不同浏览器可能还不一样）\n\n2. 浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制。\n\n3. 相关API：\n\n   1. ```xxxxxStorage.setItem(&#39;key&#39;, &#39;value&#39;);```\n                      该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值。\n\n   2. ```xxxxxStorage.getItem(&#39;person&#39;);```\n\n      ​\t\t该方法接受一个键名作为参数，返回键名对应的值。\n\n   3. ```xxxxxStorage.removeItem(&#39;key&#39;);```\n\n      ​\t\t该方法接受一个键名作为参数，并把该键名从存储中删除。\n\n   4. ``` xxxxxStorage.clear()```\n\n      ​\t\t该方法会清空存储中的所有数据。\n\n4. 备注：\n\n   1. SessionStorage存储的内容会随着浏览器窗口关闭而消失。\n   2. LocalStorage存储的内容，需要手动清除才会消失。\n   3. ```xxxxxStorage.getItem(xxx)```如果xxx对应的value获取不到，那么getItem的返回值是null。\n   4. ```JSON.parse(null)```的结果依然是null。\n</code></pre>\n<h5 id=\"2：缓存策略（强缓存，协商缓存）\"><a href=\"#2：缓存策略（强缓存，协商缓存）\" class=\"headerlink\" title=\"2：缓存策略（强缓存，协商缓存）\"></a>2：缓存策略（强缓存，协商缓存）</h5><h1 id=\"十一：浏览器渲染原理\"><a href=\"#十一：浏览器渲染原理\" class=\"headerlink\" title=\"十一：浏览器渲染原理\"></a>十一：浏览器渲染原理</h1><h5 id=\"1：渲染过程\"><a href=\"#1：渲染过程\" class=\"headerlink\" title=\"1：渲染过程\"></a>1：渲染过程</h5><h5 id=\"2：阻塞过程\"><a href=\"#2：阻塞过程\" class=\"headerlink\" title=\"2：阻塞过程\"></a>2：阻塞过程</h5><h5 id=\"3：重绘和汇流（重排）\"><a href=\"#3：重绘和汇流（重排）\" class=\"headerlink\" title=\"3：重绘和汇流（重排）\"></a>3：重绘和汇流（重排）</h5><h1 id=\"十二：进阶知识\"><a href=\"#十二：进阶知识\" class=\"headerlink\" title=\"十二：进阶知识\"></a>十二：进阶知识</h1><h5 id=\"1：函数式编程\"><a href=\"#1：函数式编程\" class=\"headerlink\" title=\"1：函数式编程\"></a>1：函数式编程</h5><h5 id=\"2：HTML5-Web-Worker\"><a href=\"#2：HTML5-Web-Worker\" class=\"headerlink\" title=\"2：HTML5 Web Worker\"></a>2：HTML5 Web Worker</h5><h5 id=\"3：Service-Worker\"><a href=\"#3：Service-Worker\" class=\"headerlink\" title=\"3：Service Worker\"></a>3：Service Worker</h5><h1 id=\"十三：ECMAScript\"><a href=\"#十三：ECMAScript\" class=\"headerlink\" title=\"十三：ECMAScript\"></a>十三：ECMAScript</h1><h2 id=\"一：es5基础-es5是从ECMAScript从第一版到现在比较完善的一版\"><a href=\"#一：es5基础-es5是从ECMAScript从第一版到现在比较完善的一版\" class=\"headerlink\" title=\"一：es5基础(es5是从ECMAScript从第一版到现在比较完善的一版)\"></a>一：es5基础(es5是从ECMAScript从第一版到现在比较完善的一版)</h2><h3 id=\"1：变量-var\"><a href=\"#1：变量-var\" class=\"headerlink\" title=\"1：变量 var\"></a>1：变量 var</h3><pre><code class=\"javascript\">1.var声明的作用域\n    //该变量将在函数退出时被销毁\n    function test() &#123; \n         var message = &quot;hi&quot;; // 局部变量\n    &#125; \n    test(); \n    console.log(message); // 出错！\n    \n    //去掉之前的 var 操作符之后，message 就变成了全局变量\n    function test() &#123; \n         message = &quot;hi&quot;; // 全局变量\n    &#125; \n    test(); \n    console.log(message); // &quot;hi&quot;\n\n\n2.逗号分隔符定义多个变量\n    var name = &#39;hi&#39;,\n        age = 18,\n        height = 1.8\n    \n3.var声明提升\n    function foo() &#123; \n         console.log(age); \n         var age = 26; \n    &#125; \n    foo(); // undefined \n\n上面的代码等价于\n    function foo() &#123; \n         var age; \n         console.log(age); \n         age = 26; \n    &#125; \n    foo(); // undefined\n\n</code></pre>\n<h3 id=\"2：JavaScript-ES5-数据类型\"><a href=\"#2：JavaScript-ES5-数据类型\" class=\"headerlink\" title=\"2：JavaScript(ES5)数据类型\"></a>2：JavaScript(ES5)数据类型</h3><pre><code class=\"javascript\">数据类型：`Undefined`、`Null`、`Boolean`、`String`、`Number`、`Symbol （ES6新出的）`、`Object`\n引用类型：Object可以细分为：`基本引用类型`,`集合引用类型`\n基本引用类型：`Date`,`RegExp`,`原始包装类型(Boolean,Number,String)`,`单例内置对象(Global,Math)`\n集合引用类型：`Object`,`Array`,`定型数组`,`Map`,`WeakMap`,`Set`,`WeakSet`\n</code></pre>\n<h3 id=\"3：数据类型的检测\"><a href=\"#3：数据类型的检测\" class=\"headerlink\" title=\"3：数据类型的检测\"></a>3：数据类型的检测</h3><pre><code class=\"javascript\">`为什么要有数据类型的检测?`\n只有 7 种数据类型似乎不足以表示全部数据。但 ECMAScript 的数据类型很灵活，一种数据类型可以当作多种数据类型来使用\n\n\n`有哪些检测方法?`\n(1)typeof\n(2)instanceof(主要用于判断是那种对象类型)\n(3)constructor  \n(4)Object.prototype.toString.call()\n\n1：在`JavaScript`里使用`typeof`判断数据类型，即：`number`、`string`、`undefined`、`boolean`。\n\n2：对于`null`、`array`、`function`、`object`来说，使用`typeof`都会统一返回`object`字符串。\n\n3：要想区分对象、数组、函数、单纯使用`typeof`是不行的。在JS中，可以通过`Object.prototype.toString.call()`方法，判断某个对象之属于哪种内置类型。分为`null`、`string`、`boolean`、`number`、`undefined`、`array`、`function`、`object`、`date`、`math`。\n\n4：constructor 本来是用于标识对象类型的。\n\n5：一般认为 instanceof 操作符是确定对象类型 更可靠的方式。\n\n\n    let obj = &#123;&#125;\n    let num1 = 1\n    console.log(typeof obj)   //object\n    console.log(obj instanceof Object)  //true\n    console.log(obj.constructor) //ƒ Object() &#123; [native code] &#125;\n    console.log( Object.prototype.toString.call(1)) // [object Number]\n    console.log(Object.prototype.toString.call(obj)) // [object Object]\n</code></pre>\n<h2 id=\"二：es6新增的特性\"><a href=\"#二：es6新增的特性\" class=\"headerlink\" title=\"二：es6新增的特性\"></a>二：es6新增的特性</h2><h3 id=\"1：变量-let\"><a href=\"#1：变量-let\" class=\"headerlink\" title=\"1：变量 let\"></a>1：变量 let</h3><pre><code class=\"javascript\">1.只能在块作用域里面生效\n    if (true) &#123; \n         var name = &#39;Matt&#39;; \n         console.log(name); // Matt \n    &#125; \n    console.log(name); // Matt\n\n    if (true) &#123; \n         let age = 26; \n         console.log(age); // 26 \n    &#125; \n    console.log(age); // ReferenceError: age 没有定义\n\n2.不能重复定义同一个变量\n    var name; \n    var name; \n\n    let age; \n    let age; // SyntaxError；标识符 age 已经声明过了\n\n3.暂时性死区\n    // name 会被提升\n    console.log(name); // undefined \n    var name = &#39;Matt&#39;; \n\n    // age 不会被提升\n    console.log(age); // ReferenceError：age 没有定义\n    let age = 26; \n\n4.全局声明\n    // 与 var 关键字不同，使用 let 在全局作用域中声明的变量不会成为 window 对象的属性\n\n    var name = &#39;Matt&#39;; \n    console.log(window.name); // &#39;Matt&#39; \n\n    let age = 26; \n    console.log(window.age); // undefined\n    \n5.for 循环中的 let声明\n    // 在 let出现之前，for 循环定义的迭代变量会渗透到循环体外部：\n        for (var i = 0; i &lt; 5; ++i) &#123; \n             // 循环逻辑 \n        &#125; \n    console.log(i); // 5\n    \n    // 改成使用 let之后，这个问题就消失了，因为迭代变量的作用域仅限于 for 循环块内部：\n        for (let i = 0; i &lt; 5; ++i) &#123; \n             // 循环逻辑\n        &#125; \n    console.log(i); // ReferenceError: i 没有定义\n</code></pre>\n<h3 id=\"2：变量-const\"><a href=\"#2：变量-const\" class=\"headerlink\" title=\"2：变量 const\"></a>2：变量 const</h3><pre><code class=\"javascript\">1.声明变量时必须同时初始化变量，如果是常量且不能修改,如果是对象则可以修改\n2.不允许重复声明\n3.声明的作用域也是块\n4.不能用 const 来声明迭代变量（因为迭代变量会自增）\n</code></pre>\n<h3 id=\"3：解构赋值\"><a href=\"#3：解构赋值\" class=\"headerlink\" title=\"3：解构赋值\"></a>3：解构赋值</h3><pre><code class=\"javascript\">1.分为数组解构和对象解构，项目中从接口获取的数据可以解构为自己需要的数据，也常用于交换变量值\n2.这里面引入了rest参数，用来获取函数的多余参数，这样就不需要使用arguments对象。\n</code></pre>\n<h3 id=\"4：模板字符串-主要是针对变量\"><a href=\"#4：模板字符串-主要是针对变量\" class=\"headerlink\" title=\"4：模板字符串(主要是针对变量)\"></a>4：模板字符串(主要是针对变量)</h3><pre><code class=\"javascript\">&#123;\n    let name = &#39;list&#39;;\n    let info = &#39;hello world&#39;;\n    let m = `i am $&#123;name&#125;,$&#123;info&#125;`;\n&#125;\n</code></pre>\n<h3 id=\"5：数组新增的方法\"><a href=\"#5：数组新增的方法\" class=\"headerlink\" title=\"5：数组新增的方法\"></a>5：数组新增的方法</h3><pre><code class=\"javascript\">1.Array.from()：遍历数组元素，用于将类数组结构转换为数组实例\n2.Array.of()：用于将一组参数转换为数组实例\n3.Array.fill()：替换元素\n4.Array.keys()：返回一个数组，返回的是数组的下标\n5.Array.values()：返回一个数组，返回的是数组中的值\n6.Array.entries()：返回下标和值\n7.Array.copyWithin(起始位置,从第几个数据读取,截止位置)\n8.Array.find()：找出第一个符合条件的数组成员\n9.Array.findIndex()：找出第一个符合条件的数组成员的下标\n</code></pre>\n<h3 id=\"6：字符串新增的方法\"><a href=\"#6：字符串新增的方法\" class=\"headerlink\" title=\"6：字符串新增的方法\"></a>6：字符串新增的方法</h3><pre><code class=\"javascript\">1.String.includes(value)：是否包含value值，是的话返回true\n</code></pre>\n<h3 id=\"7：函数新增的方法\"><a href=\"#7：函数新增的方法\" class=\"headerlink\" title=\"7：函数新增的方法\"></a>7：函数新增的方法</h3><pre><code class=\"javascript\">1.扩展运算符：…[1,2,3] //1,2,3 把数组拆分成了三个值\n2.箭头函数：\n箭头函数是普通函数的简写，可以更优雅的定义一个函数，和普通函数相比，有以下几点差异：\n（1）函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。\n（2）不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。\n（3）不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。\n（4）不可以使用 new 命令，因为：\n没有自己的 this，无法调用 call，apply。\n没有 prototype 属性 ，而 new 命令在执行时需要将构造函数的 prototype 赋值给新的对象的 proto\n</code></pre>\n<h3 id=\"8：对象新增的方法\"><a href=\"#8：对象新增的方法\" class=\"headerlink\" title=\"8：对象新增的方法\"></a>8：对象新增的方法</h3><pre><code class=\"javascript\">1.Object.is(value1,value2)：判断两个参数是否相等\n2.Object.assign(value1,value2)：浅拷贝，拷贝出来的结果是 [value1,value2]（value1和value2都是对象）\n3.扩展运算符：&#123;a,b,…c&#125;=&#123;a:’a’,b:’b’,c:’c’,d:’d’&#125;→c=&#123;c:’c’,d:’d’&#125;\n4.for…in循环遍历对象自身的和继承的可枚举属性\n5.Object.keys(obj)：返回一个数组，返回的是数组成员的下标\n6.Object.getOwnPropertySymbols(obj)：返回的是Symbol定义的值\n7.Object.ownKeys(obj)：可以拿到所有的值，包括Symbol定义的和非Symbol定义的\n</code></pre>\n<h3 id=\"9：Symbol用法\"><a href=\"#9：Symbol用法\" class=\"headerlink\" title=\"9：Symbol用法\"></a>9：Symbol用法</h3><pre><code class=\"javascript\">1.这是ES6新增的数据类型，表示独一无二的值\n\n&#123;\nlet a1 = Symbol.for(‘a1’)\n//后面再对a1赋值也是无效的，a1的值依旧是’a1’\n&#125;\n</code></pre>\n<h3 id=\"10：Set-Map数据结构\"><a href=\"#10：Set-Map数据结构\" class=\"headerlink\" title=\"10：Set-Map数据结构\"></a>10：Set-Map数据结构</h3><pre><code class=\"javascript\">1.Set本身是一个构造函数，类似于数组，但是里面的值都是唯一的，没有重复的值，所以可以用Set去重\n\n&#123;\n    let array = [1,1,2,2,6,5];\n    let set = new Set(array);\n    console.log(set);  //[1,2,6,5]\n&#125;\n&#123;\n    //接下里介绍几个方法\n    let arr = [&#39;add&#39;,&#39;delete&#39;,&#39;clear&#39;,&#39;has&#39;];\n    let list = new Set(arr);\n    list.has(&#39;add&#39;) //判断是否有该值\n    list.delete(&#39;add&#39;);\t//、删除该值\n    list.clear(); //清空\n&#125;\n\n\n2.Map数据结构类似于对象，也是键值对的集合，但是键的范围不局限与字符\n&#123;\n    let map = new Map();\n    let arr = [&#39;123&#39;];\n    map.set(arr,456);\n    map.get(arr);  //456\n&#125;\n\n</code></pre>\n<h3 id=\"11：Proxy\"><a href=\"#11：Proxy\" class=\"headerlink\" title=\"11：Proxy\"></a>11：Proxy</h3><pre><code class=\"javascript\">1.Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。\n\n2.Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，\n因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，\n用在这里表示由它来“代理”某些操作，可以译为“代理器”。\n\nvar proxy = new Proxy(target, handler);\n\n优点：通过代理，条件与对象本身隔绝，后续代码维护、健壮都很强\n</code></pre>\n<h3 id=\"12：Class的基本用法\"><a href=\"#12：Class的基本用法\" class=\"headerlink\" title=\"12：Class的基本用法\"></a>12：Class的基本用法</h3><pre><code class=\"javascript\">1.class其实是对function的简化 class的声明\n\n//基本定义和生成实例\nclass Parent&#123;\n    constructor(name)&#123;\n        this.name = name;\n    &#125;\n&#125;\nlet parent = new Parent(&#39;xiaomao&#39;)\n//继承\nclass Child extends Parent&#123;\n    //子类怎么去覆盖父类,this一定要放在super后面\n    constructor(name = &#39;child&#39;)&#123;\n        super(name);   //若super()，则所有参数都是父类的\n        this.type = &#39;child&#39;;   //子类增加的属性\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"13：Promise\"><a href=\"#13：Promise\" class=\"headerlink\" title=\"13：Promise\"></a>13：Promise</h3><pre><code class=\"javascript\">promise实际上解决jquery的ajax回调地域(解决层层嵌套),只是异步编程的一种解决方案\nnew promise(function(resolve,reject) &#123;\n        resolve(&#39;...&#39;)\n    &#125; ).then(function(value) &#123;\n        console.log(value)\n    &#125;).catch(function(error)&#123;\n    console.log(error)\n&#125;)\n</code></pre>\n<h5 id=\"1：什么是promise\"><a href=\"#1：什么是promise\" class=\"headerlink\" title=\"1：什么是promise\"></a>1：什么是promise</h5><p>Promise 是异步编程的一种解决方案： 从语法上讲，promise是一个对象，从它可以获取异步操作的消息；从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。 promise有三种状态：**pending(等待态)，fulfiled(成功态)，rejected(失败态)**；状态一旦改变，就不会再变。创造promise实例后，它会立即执行</p>\n<h5 id=\"2：promise用来解决什么问题\"><a href=\"#2：promise用来解决什么问题\" class=\"headerlink\" title=\"2：promise用来解决什么问题\"></a>2：promise用来解决什么问题</h5><pre><code class=\"javascript\">// 当参数a大于10且参数fn2是一个方法时 执行fn2\n     function fn1(a, fn2)&#123;\n        if(a &gt; 10 &amp;&amp; fn2 instanceof Function)&#123;\n            fn2()\n        &#125;\n     &#125;\n\n     fn1(12, ()=&gt;&#123;\n         console.log(&#39;this is callback&#39;)\n     &#125;)\n一般来说我们会碰到的回调嵌套都不会很多，一般就一到两级，但是某些情况下，回调嵌套很多时，代码就会非常繁琐，会给我们的编程带来很多的麻烦，这种情况俗称——回调地狱。\n\n主要用来解决：\n1：回调地狱，代码难以维护，常常第一个的函数输出的是第二个函数的输入的这种现象\n2：promise可以支持多个并发的请求，获取并发请求中的请求\n3：promise可以解决异步问题，本身不能说promise是异步的\n</code></pre>\n<h5 id=\"3：promise的基础用法\"><a href=\"#3：promise的基础用法\" class=\"headerlink\" title=\"3：promise的基础用法\"></a>3：promise的基础用法</h5><pre><code class=\"javascript\">1： Promise是一个构造函数，自己身上有all、reject、resolve这几个眼熟的方法，原型上有then、catch等同样很眼熟的方法。\n\n      let p = new Promise((resolve, reject) =&gt; &#123;\n          //执行异步操作\n          setTimeout(() =&gt; &#123;\n              console.log(&#39;执行完成&#39;)\n              resolve(&#39;我是成功！！&#39;)\n          &#125;, 2000);\n      &#125;)\n上段代码会直接执行 2秒后输出 &#39;执行完成&#39;\n\nPromise的构造函数接收一个参数：函数，并且这个函数需要传入两个参数：\nresolve：异步操作执行成功后的回调函数\nreject：异步操作执行失败后的回调函数\n\n2：then 链式操作的用法  \n从表面上看，Promise只是能够简化层层回调的写法，而实质上，Promise的精髓是“状态”，用维护状态、传递状态的方式来使得回调函数能够及时调用，它比传递callback函数要简单、灵活的多。所以使用Promise的正确场景是这样的：\n      p.then((data) =&gt; &#123;\n          console.log(data)\n      &#125;)\n\n3：reject的用法 \n把Promise的状态置为rejected，这样我们在then中就能捕捉到，然后执行“失败”情况的回调。看下面的代码。\n      let p = new Promise((resolve, reject) =&gt; &#123;\n          //执行异步操作\n          setTimeout(() =&gt; &#123;\n              let num = Math.ceil(Math.random()*10) //生成1 - 10的随机数\n               if(num &lt;= 5)&#123;\n                   resolve(num)\n               &#125;else&#123;\n                   reject(&#39;数字是大于5的&#39;)\n               &#125;\n          &#125;, 1000);\n      &#125;)\n\n      p.then((data) =&gt; &#123;\n          console.log(&#39;resolve&#39;,data)\n      &#125;,(err) =&gt; &#123;\n          console.log(&#39;rejeced&#39;,err)\n      &#125;)\n产生以一个随机数，如果大于5就会使用reject  错误(err)输出&#39;数字是大于5&#39;\n\n4：catch的用法 (前面的代码有错误可以报出来，不要promise是无法执行下来的)\n我们知道Promise对象除了then方法，还有一个catch方法，它是做什么用的呢？其实它和then的第二个参数一样，用来指定reject的回调。用法是这样：\n      let p = new Promise((resolve, reject) =&gt; &#123;\n          //执行异步操作\n          setTimeout(() =&gt; &#123;\n              let num = Math.ceil(Math.random()*10) //生成1 - 10的随机数\n               if(num &lt;= 5)&#123;\n                   resolve(num)\n               &#125;else&#123;\n                   reject(&#39;数字是大于5的&#39;)\n               &#125;\n          &#125;, 1000);\n      &#125;)\n\n      p.then((data) =&gt; &#123;\n          console.log(&#39;resolve&#39;,data)  // 假设随机数是 3  那么输出 resolve 为 3\n          console.log(aaaa)  //aaaa是没有被定义的\n      &#125;,(err) =&gt; &#123;\n          console.log(&#39;rejeced&#39;,err)\n      &#125;).catch((err) =&gt; &#123;\n          console.log(&#39;rejeced&#39;,err)  //  这里报错 ： rejeced ReferenceError: aaaa is not defined\n      &#125;)\n在resolve的回调中，我们console.log(somedata);而aaaa这个变量是没有被定义的。如果我们不用Promise，代码运行到这里就直接在控制台报错了，不往下运行了。\n</code></pre>\n<h5 id=\"4：all的用法\"><a href=\"#4：all的用法\" class=\"headerlink\" title=\"4：all的用法\"></a>4：all的用法</h5><pre><code class=\"javascript\">1:\nall的用法：谁跑的慢，以谁为准执行回调。all接收一个数组参数，里面的值最终都算返回Promise对象\n\n2:\nPromise的all方法提供了并行执行异步操作的能力，并且在所有异步操作执行完后才执行回调。看下面的例子：\n\n        let promise1 = new Promise((resolve, reject) =&gt; &#123;\n            setTimeout(() =&gt; &#123;\n                var num = Math.ceil(Math.random() * 10); //生成1-10的随机数\n                if (num &lt;= 5) &#123;\n                    resolve(num);\n                &#125;\n                else &#123;\n                    reject(&#39;数字太大了1&#39;);\n                &#125;\n            &#125;)\n        &#125;)\n        let promise2 = new Promise((resolve, reject) =&gt; &#123;\n            setTimeout(() =&gt; &#123;\n                var num = Math.ceil(Math.random() * 10); //生成1-10的随机数\n                if (num &lt;= 5) &#123;\n                    resolve(num);\n                &#125;\n                else &#123;\n                    reject(&#39;数字太大了2&#39;);\n                &#125;\n            &#125;)\n        &#125;)\n        let promise3 = new Promise((resolve, reject) =&gt; &#123;\n            setTimeout(() =&gt; &#123;\n                var num = Math.ceil(Math.random() * 10); //生成1-10的随机数\n                if (num &lt;= 5) &#123;\n                    resolve(num);\n                &#125;\n                else &#123;\n                    reject(&#39;数字太大了3&#39;);\n                &#125;\n            &#125;)\n        &#125;)\n\n        let p = Promise.all([promise1, promise2, promise3])\n\n        p.then(function (res) &#123;\n            //三个都成功则成功 res返回 [p1,p2,p3] 结果的数组\n            console.log(res)\n        &#125;, function (err) &#123;\n            //只要有失败，则失败  err 返回在哪个promise失败的回调\n            console.log(err)\n        &#125;)\n\n有了all，你就可以并行执行多个异步操作，并且在一个回调中处理所有的返回数据，是不是很酷？有一个场景是很适合用这个的，一些游戏类的素材比较多的应用，打开网页时，预先加载需要用到的各种资源如图片、flash以及各种静态文件。所有的都加载完后，我们再进行页面的初始化。\n</code></pre>\n<h5 id=\"5：race的用法\"><a href=\"#5：race的用法\" class=\"headerlink\" title=\"5：race的用法\"></a>5：race的用法</h5><pre><code class=\"javascript\">1:race的用法：谁跑的快，以谁为准执行回调\n\n2：race的使用场景：比如我们可以用race给某个异步请求设置超时时间，并且在超时后执行相应的操作，代码如下\n\n        //请求某个图片资源\n        function requestImg() &#123;\n            var p = new Promise((resolve, reject) =&gt; &#123;\n                var img = new Image();\n                img.onload = function () &#123;\n                    resolve(img);\n                &#125;\n                img.src = &#39;图片的路径&#39;;\n            &#125;);\n            return p;\n        &#125;\n        //延时函数，用于给请求计时\n        function timeout() &#123;\n            var p = new Promise((resolve, reject) =&gt; &#123;\n                setTimeout(() =&gt; &#123;\n                    reject(&#39;图片请求超时&#39;);\n                &#125;, 5000);\n            &#125;);\n            return p;\n        &#125;\n        Promise.race([requestImg(), timeout()]).then((data) =&gt; &#123;\n            console.log(data);\n        &#125;).catch((err) =&gt; &#123;\n            console.log(err);\n        &#125;);\n\nrequestImg函数会异步请求一张图片，我把地址写为&quot;图片的路径&quot;，所以肯定是无法成功请求到的。timeout函数是一个延时5秒的异步操作。我们把这两个返回Promise对象的函数放进race，于是他俩就会赛跑，如果5秒之内图片请求成功了，那么遍进入then方法，执行正常的流程。如果5秒钟图片还未成功返回，那么timeout就跑赢了，则进入catch，报出“图片请求超时”的信息。\n</code></pre>\n<h5 id=\"6：手写一个promise\"><a href=\"#6：手写一个promise\" class=\"headerlink\" title=\"6：手写一个promise\"></a>6：手写一个promise</h5><h5 id=\"7：promise面试题\"><a href=\"#7：promise面试题\" class=\"headerlink\" title=\"7：promise面试题\"></a>7：promise面试题</h5><pre><code class=\"javascript\">1.\nconst promise = new Promise((resolve, reject) =&gt; &#123;\n  console.log(1)\n  resolve()\n  console.log(2)\n&#125;)\npromise.then(() =&gt; &#123;\n  console.log(3)\n&#125;)\nconsole.log(4)\n\n\n输出:  1 2 4 3\n解释:  Promise构造函数是同步执行的,promsie.then 中的函数是异步执行的 \n</code></pre>\n<pre><code class=\"javascript\">2.\nconst promise1 = new Promise((resolve, reject) =&gt; &#123;\n  setTimeout(() =&gt; &#123;\n    resolve(&#39;success&#39;)\n  &#125;, 1000)\n&#125;)\nconst promise2 = promise1.then(() =&gt; &#123;\n  throw new Error(&#39;error!!!&#39;)\n&#125;)\n\nconsole.log(&#39;promise1&#39;, promise1)\nconsole.log(&#39;promise2&#39;, promise2)\n\nsetTimeout(() =&gt; &#123;\n  console.log(&#39;promise1&#39;, promise1)\n  console.log(&#39;promise2&#39;, promise2)\n&#125;, 2000)\n\n输出:\npromise1 Promise &#123; &lt;pending&gt; &#125;\npromise2 Promise &#123; &lt;pending&gt; &#125;\n(node:50928) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): Error: error!!!\n(node:50928) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.\npromise1 Promise &#123; &#39;success&#39; &#125;\npromise2 Promise &#123;\n  &lt;rejected&gt; Error: error!!!\n    at promise.then (...)\n    at &lt;anonymous&gt; &#125;\n\n解释：promise 有 3 种状态：pending、fulfilled 或 rejected。状态改变只能是 pending-&gt;fulfilled 或者 pending-&gt;rejected，状态一旦改变则不能再变。上面 promise2 并不是 promise1，而是返回的一个新的 Promise 实例。\n\n</code></pre>\n<pre><code class=\"javascript\">3.\nconst promise = new Promise((resolve, reject) =&gt; &#123;\n  resolve(&#39;success1&#39;)\n  reject(&#39;error&#39;)\n  resolve(&#39;success2&#39;)\n&#125;)\n\npromise\n  .then((res) =&gt; &#123;\n    console.log(&#39;then: &#39;, res)\n  &#125;)\n  .catch((err) =&gt; &#123;\n    console.log(&#39;catch: &#39;, err)\n  &#125;)\n\n输出: success1\n解释：构造函数中的 resolve 或 reject 只有第一次执行有效，多次调用没有任何作用，呼应代码二结论：promise 状态一旦改变则不能再变。\n</code></pre>\n<pre><code class=\"javascript\">4.\nPromise.resolve(1)\n  .then((res) =&gt; &#123;\n    console.log(res)\n    return 2\n  &#125;)\n  .catch((err) =&gt; &#123;\n    return 3\n  &#125;)\n  .then((res) =&gt; &#123;\n    console.log(res)\n  &#125;)\n\n输出:  1,2\n\n解释：promise 可以链式调用。提起链式调用我们通常会想到通过 return this 实现，不过 Promise 并不是这样实现的。promise 每次调用 .then 或者 .catch 都会返回一个新的 promise，从而实现了链式调用。\n</code></pre>\n<pre><code class=\"javascript\">5.\nconst promise = new Promise((resolve, reject) =&gt; &#123;\n  setTimeout(() =&gt; &#123;\n    console.log(&#39;once&#39;)\n    resolve(&#39;success&#39;)\n  &#125;, 1000)\n&#125;)\n\nconst start = Date.now()\npromise.then((res) =&gt; &#123;\n  console.log(res, Date.now() - start)\n&#125;)\npromise.then((res) =&gt; &#123;\n  console.log(res, Date.now() - start)\n&#125;)\n\n输出:\nonce\nsuccess 1005\nsuccess 1007\n\n解释：promise 的 .then 或者 .catch 可以被调用多次，但这里 Promise 构造函数只执行一次。或者说 promise 内部状态一经改变，并且有了一个值，那么后续每次调用 .then 或者 .catch 都会直接拿到该值\n</code></pre>\n<pre><code class=\"javascript\">6.\nPromise.resolve()\n  .then(() =&gt; &#123;\n    return new Error(&#39;error!!!&#39;)\n  &#125;)\n  .then((res) =&gt; &#123;\n    console.log(&#39;then: &#39;, res)\n  &#125;)\n  .catch((err) =&gt; &#123;\n    console.log(&#39;catch: &#39;, err)\n  &#125;)\n\n输出:\nthen: Error: error!!!\n    at Promise.resolve.then (...)\n    at ...\n                             \n解释：.then 或者 .catch 中 return 一个 error 对象并不会抛出错误，所以不会被后续的 .catch 捕获，需要改成其中一种：                                                       \n</code></pre>\n<pre><code class=\"javascript\">7.\nconst promise = Promise.resolve()\n  .then(() =&gt; &#123;\n    return promise\n  &#125;)\npromise.catch(console.error)\n\n输出:\nTypeError: Chaining cycle detected for promise #&lt;Promise&gt;\n    at &lt;anonymous&gt;\n    at process._tickCallback (internal/process/next_tick.js:188:7)\n    at Function.Module.runMain (module.js:667:11)\n    at startup (bootstrap_node.js:187:16)\n    at bootstrap_node.js:607:3\n\n解释：.then 或 .catch 返回的值不能是 promise 本身，否则会造成死循环。类似于：\nprocess.nextTick(function tick () &#123;\n  console.log(&#39;tick&#39;)\n  process.nextTick(tick)\n&#125;)\n</code></pre>\n<pre><code class=\"javascript\">8.\nPromise.resolve(1)\n  .then(2)\n  .then(Promise.resolve(3))\n  .then(console.log)\n\n输出: 1\n\n解释：.then 或者 .catch 的参数期望是函数，传入非函数则会发生值穿透。\n</code></pre>\n<pre><code class=\"javascript\">9.\nPromise.resolve()\n  .then(function success (res) &#123;\n    throw new Error(&#39;error&#39;)\n  &#125;, function fail1 (e) &#123;\n    console.error(&#39;fail1: &#39;, e)\n  &#125;)\n  .catch(function fail2 (e) &#123;\n    console.error(&#39;fail2: &#39;, e)\n  &#125;)\n\n输出:\nfail2: Error: error\n    at success (...)\n    at ...\n                \n解释：.then 可以接收两个参数，第一个是处理成功的函数，第二个是处理错误的函数。.catch 是 .then 第二个参数的简便写法，但是它们用法上有一点需要注意：.then 的第二个处理错误的函数捕获不了第一个处理成功的函数抛出的错误，而后续的 .catch 可以捕获之前的错误。当然以下代码也可以：            \n</code></pre>\n<pre><code class=\"javascript\">10.\nprocess.nextTick(() =&gt; &#123;\n  console.log(&#39;nextTick&#39;)\n&#125;)\nPromise.resolve()\n  .then(() =&gt; &#123;\n    console.log(&#39;then&#39;)\n  &#125;)\nsetImmediate(() =&gt; &#123;\n  console.log(&#39;setImmediate&#39;)\n&#125;)\nconsole.log(&#39;end&#39;)\n\n输出:\nend\nnextTick\nthen\nsetImmediate\n\n解释：process.nextTick 和 promise.then 都属于 microtask，而 setImmediate 属于 macrotask，在事件循环的 check 阶段执行。事件循环的每个阶段（macrotask）之间都会执行 microtask，事件循环的开始会先执行一次 microtask。\n</code></pre>\n<h3 id=\"14：Iterator和for…of循环\"><a href=\"#14：Iterator和for…of循环\" class=\"headerlink\" title=\"14：Iterator和for…of循环\"></a>14：Iterator和for…of循环</h3><pre><code class=\"javascript\">遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。\n\nIterator 的作用有三个：\n一是为各种数据结构，提供一个统一的、简便的访问接口；\n二是使得数据结构的成员能够按某种次序排列；\n三是 ES6 创造了一种新的遍历命令for…of循环，Iterator 接口主要供for…of消费\n</code></pre>\n<h3 id=\"15：Generator\"><a href=\"#15：Generator\" class=\"headerlink\" title=\"15：Generator\"></a>15：Generator</h3><pre><code class=\"javascript\">Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。\n\nGenerator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。\n\n执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。\n返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。\n\n形式上，Generator 函数是一个普通函数，但是有两个特征。\n一是，function关键字与函数名之间有一个星号；\n二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”\n\nfunction* helloWorldGenerator() &#123;\n  yield &#39;hello&#39;;\n  yield &#39;world&#39;;\n  return &#39;ending&#39;;\n&#125;\nvar hw = helloWorldGenerator();\n\n上面代码定义了一个 Generator 函数helloWorldGenerator，它内部有两个yield表达式（hello和world），即该函数有三个状态：hello，world 和 return 语句（结束执行）。\n\n然后，Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。\n不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，\n也就是前面介绍的遍历器对象（Iterator Object）。\n</code></pre>\n<h3 id=\"16：Module体系\"><a href=\"#16：Module体系\" class=\"headerlink\" title=\"16：Module体系\"></a>16：Module体系</h3><pre><code class=\"javascript\">\n模块功能主要由两个命令构成：\nexport和import。\nexport命令用于规定模块的对外接口，\nimport命令用于输入其他模块提供的功能。\nexport default&#123;&#125;\n为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到export default命令，为模块指定默认输出。\n\nimport animal from &#39;./content&#39;\nexport default &#39;a cat&#39;\n\n\nimport &#123;say.type&#125; from &#39;./content&#39;\nimport * as content from &#39;./content&#39;\n</code></pre>\n<h2 id=\"三：es7新增的特性\"><a href=\"#三：es7新增的特性\" class=\"headerlink\" title=\"三：es7新增的特性\"></a>三：es7新增的特性</h2><h3 id=\"1-数组新增的方法\"><a href=\"#1-数组新增的方法\" class=\"headerlink\" title=\"1:数组新增的方法\"></a>1:数组新增的方法</h3><pre><code class=\"javascript\">1.Array.includes(value)：是否包含value值，是的话返回true\n</code></pre>\n<h1 id=\"十四：防抖和节流\"><a href=\"#十四：防抖和节流\" class=\"headerlink\" title=\"十四：防抖和节流\"></a>十四：防抖和节流</h1><pre><code class=\"javascript\">防抖的定义:任务频繁触发的情况下，只有触发的间隔超过指定间隔，任务才执行。\n\n案例:方式用户多次点击按钮，监听滚动条滚动,操纵一个小人让他有跳跃的动作，你狂点鼠标，小人狂跳，这就是最直观的抖动现象。\n\n代码实现:\n        function debounce(fn, delay) &#123;\n            let timer;\n            return function () &#123;\n                let args = arguments;\n                if (timer) &#123;\n                    clearTimeout(timer);\n                &#125;\n                timer = setTimeout(() =&gt; &#123;\n                    fn.call(this, args);\n                &#125;, delay)\n            &#125;\n        &#125;\n</code></pre>\n<pre><code class=\"javascript\">节流的定义:指定时间间隔只执行一次，执行频率不受操作频率影响，但会把所有的都执行完。\n\n案例:节流就像排队，比如我们在车站候车，当听到检票进站的通知，不论你有多紧急，跑得多快，还是得跟着排队，一个个地过闸机口，你的通过速度不可能比闸机口开关的速度更快了。\n\n代码实现:\n        function throttle(fn, delay) &#123;\n            let flag = true;\n            return function () &#123;\n                if (flag) &#123;\n                    flag = false;\n                &#125;\n                timer = setTimeout(() =&gt; &#123;\n                    fn();\n                    flag = true;\n                &#125;, delay)\n            &#125;\n        &#125;\n</code></pre>\n",
            "tags": [
                "前端开发",
                "Javascript",
                "Javascript"
            ]
        },
        {
            "id": "http://yoursite.com/front-end/Typescript/",
            "url": "http://yoursite.com/front-end/Typescript/",
            "title": "Typescript基础",
            "date_published": "2021-06-25T08:43:00.000Z",
            "content_html": "",
            "tags": [
                "前端开发",
                "Typescript",
                "Typescript"
            ]
        },
        {
            "id": "http://yoursite.com/front-end/React/",
            "url": "http://yoursite.com/front-end/React/",
            "title": "React基础",
            "date_published": "2021-06-25T08:43:00.000Z",
            "content_html": "<h1 id=\"一：React-基础\"><a href=\"#一：React-基础\" class=\"headerlink\" title=\"一：React 基础\"></a>一：React 基础</h1><h2 id=\"1-jsx\"><a href=\"#1-jsx\" class=\"headerlink\" title=\"1.jsx\"></a>1.jsx</h2><h2 id=\"2-虚拟dom\"><a href=\"#2-虚拟dom\" class=\"headerlink\" title=\"2.虚拟dom\"></a>2.虚拟dom</h2><h1 id=\"二：组件化\"><a href=\"#二：组件化\" class=\"headerlink\" title=\"二：组件化\"></a>二：组件化</h1><h2 id=\"1-context\"><a href=\"#1-context\" class=\"headerlink\" title=\"1.context\"></a>1.context</h2><h2 id=\"2-ant-design\"><a href=\"#2-ant-design\" class=\"headerlink\" title=\"2.ant-design\"></a>2.ant-design</h2><h2 id=\"3-高阶组件\"><a href=\"#3-高阶组件\" class=\"headerlink\" title=\"3.高阶组件\"></a>3.高阶组件</h2><h1 id=\"三：react全家桶\"><a href=\"#三：react全家桶\" class=\"headerlink\" title=\"三：react全家桶\"></a>三：react全家桶</h1><h2 id=\"1-redux\"><a href=\"#1-redux\" class=\"headerlink\" title=\"1.redux\"></a>1.redux</h2><h2 id=\"2-react-router\"><a href=\"#2-react-router\" class=\"headerlink\" title=\"2.react-router\"></a>2.react-router</h2><h2 id=\"3-umi\"><a href=\"#3-umi\" class=\"headerlink\" title=\"3.umi\"></a>3.umi</h2><h2 id=\"4-dva\"><a href=\"#4-dva\" class=\"headerlink\" title=\"4.dva\"></a>4.dva</h2><h1 id=\"四：react源码\"><a href=\"#四：react源码\" class=\"headerlink\" title=\"四：react源码\"></a>四：react源码</h1><h2 id=\"1-虚拟dom构建\"><a href=\"#1-虚拟dom构建\" class=\"headerlink\" title=\"1.虚拟dom构建\"></a>1.虚拟dom构建</h2><h2 id=\"2-createElement\"><a href=\"#2-createElement\" class=\"headerlink\" title=\"2.createElement\"></a>2.createElement</h2><h2 id=\"3-Component\"><a href=\"#3-Component\" class=\"headerlink\" title=\"3.Component\"></a>3.Component</h2><h2 id=\"4-rander\"><a href=\"#4-rander\" class=\"headerlink\" title=\"4.rander\"></a>4.rander</h2><h1 id=\"五：react性能优化\"><a href=\"#五：react性能优化\" class=\"headerlink\" title=\"五：react性能优化\"></a>五：react性能优化</h1><h1 id=\"六：服务端渲染SSR\"><a href=\"#六：服务端渲染SSR\" class=\"headerlink\" title=\"六：服务端渲染SSR\"></a>六：服务端渲染SSR</h1><h2 id=\"1-next-js\"><a href=\"#1-next-js\" class=\"headerlink\" title=\"1.next.js\"></a>1.next.js</h2>",
            "tags": [
                "前端开发",
                "React",
                "React"
            ]
        },
        {
            "id": "http://yoursite.com/front-end/css%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AF%87/",
            "url": "http://yoursite.com/front-end/css%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AF%87/",
            "title": "css性能优化篇",
            "date_published": "2021-06-25T08:43:00.000Z",
            "content_html": "<h1 id=\"加载性能\"><a href=\"#加载性能\" class=\"headerlink\" title=\"加载性能\"></a>加载性能</h1><pre><code class=\"text\">（1）合并和压缩 CSS 文件以减少文件大小。\n（2）css单一样式：当需要下边距和左边距的时候，很多时候选择:margin:top 0 bottom 0;但margin-bottom:bottom;margin-left:left;执行的效率更高。\n（3）减少使用@import,而建议使用link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。\n（4）延迟或异步加载 CSS 文件，特别是对于首屏渲染来说。\n（5）使用 CDN（内容分发网络）来加速 CSS 文件的加载。\n（6）利用浏览器缓存机制，设置适当的缓存头信息。\n</code></pre>\n<h1 id=\"选择器性能\"><a href=\"#选择器性能\" class=\"headerlink\" title=\"选择器性能\"></a>选择器性能</h1><pre><code class=\"text\">（1）关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）。CSS选择符是从右到左进行匹配的。当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素等等；\n（2）如果规则拥有ID选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）。\n（3）避免使用通配规则，如*&#123;&#125;计算次数惊人！只对需要用到的元素进行选择。\n（4）尽量少的去对标签进行选择，而是用class。\n（5）尽量少的去使用后代选择器，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素。\n（6）了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则。\n</code></pre>\n<h1 id=\"渲染性能\"><a href=\"#渲染性能\" class=\"headerlink\" title=\"渲染性能\"></a>渲染性能</h1><pre><code class=\"text\">（1）慎重使用高性能属性：浮动、定位。\n（2）最小化重绘和重排操作，尽量在一次渲染中完成所有样式的修改。\n（3）去除空规则：｛｝。空规则的产生原因一般来说是为了预留样式。去除这些空规则无疑能减少css文档体积。\n（4）属性值为0时，不加单位。\n（5）属性值为浮动小数0.**，可以省略小数点之前的0。\n（6）标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。\n（7）不使用@import前缀，它会影响css的加载速度。\n（8）选择器优化嵌套，尽量避免层级过深。\n（9）css雪碧图，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清楚，再使用。\n（10）正确使用display的属性，由于display的作用，某些样式组合会无效，徒增样式体积的同时也影响解析性能。\n（11）不滥用web字体。对于中文网站来说WebFonts可能很陌生，国外却很流行。web fonts通常体积庞大，而且一些浏览器在下载web fonts时会阻塞页面渲染损伤性能。\n（12）使用硬件加速特性（如 transform 和 opacity）来提高动画的性能。\n</code></pre>\n<h1 id=\"可维护性、健壮性\"><a href=\"#可维护性、健壮性\" class=\"headerlink\" title=\"可维护性、健壮性\"></a>可维护性、健壮性</h1><pre><code class=\"text\">（1）将具有相同属性的样式抽离出来，整合并通过class在页面中进行使用，提高css的可维护性。\n（2）样式与内容分离：将css代码定义到外部css中。\n（3）使用模块化的 CSS 结构，将样式分成独立的模块或组件。\n（4）使用注释和良好的命名规范，使样式易于理解和维护。\n（5）遵循代码风格指南和最佳实践，减少冗余和不必要的样式。\n（6）使用 CSS 预处理器（如 Sass 或 Less）来提高样式代码的可维护性和重用性。\n</code></pre>\n",
            "tags": [
                "前端开发",
                "css",
                "css"
            ]
        },
        {
            "id": "http://yoursite.com/front-end/html+css%E9%9D%A2%E8%AF%95/",
            "url": "http://yoursite.com/front-end/html+css%E9%9D%A2%E8%AF%95/",
            "title": "css面试",
            "date_published": "2021-06-25T08:43:00.000Z",
            "content_html": "<h1 id=\"BFC\"><a href=\"#BFC\" class=\"headerlink\" title=\"BFC\"></a>BFC</h1><pre><code class=\"text\">BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于普通流，即：元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。\n可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。\n只要元素满足下面任一条件即可触发 BFC 特性\n\nbody 根元素\n浮动元素：float 除 none 以外的值\n绝对定位元素：position (absolute、fixed)\ndisplay 为 inline-block、table-cells、flex\noverflow 除了 visible 以外的值 (hidden、auto、scroll)\n</code></pre>\n<h1 id=\"多种方式实现同心圆\"><a href=\"#多种方式实现同心圆\" class=\"headerlink\" title=\"多种方式实现同心圆\"></a>多种方式实现同心圆</h1><pre><code class=\"text\">1.  2个view 相对定位 + 绝对定位\n2.  2个view  flex布局\n3.  1个view  使用伪元素\n</code></pre>\n<h1 id=\"介绍一下-CSS-的盒子模型？\"><a href=\"#介绍一下-CSS-的盒子模型？\" class=\"headerlink\" title=\"介绍一下 CSS 的盒子模型？\"></a>介绍一下 CSS 的盒子模型？</h1><pre><code class=\"text\">有两种， IE 盒子模型、W3C 盒子模型；\n盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；\n区 别： IE 的 content 部分把 border 和 padding 计算了进去;\n</code></pre>\n<h1 id=\"css-选择器优先级？\"><a href=\"#css-选择器优先级？\" class=\"headerlink\" title=\"css 选择器优先级？\"></a>css 选择器优先级？</h1><pre><code class=\"text\">!important &gt; 行内样式（比重1000）&gt; ID 选择器（比重100） &gt; 类选择器（比重10） &gt; 标签（比重1） &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性\n</code></pre>\n<h1 id=\"垂直居中几种方式？\"><a href=\"#垂直居中几种方式？\" class=\"headerlink\" title=\"垂直居中几种方式？\"></a>垂直居中几种方式？</h1><pre><code class=\"text\">1.单行文本: line-height = height\n2.图片: vertical-align: middle;\n3.absolute 定位: top: 50%;left: 50%;transform: translate(-50%, -50%);\n4.flex:display:flex;justify-content: center;  align-items: center\n</code></pre>\n<h1 id=\"简明说一下-CSS-link-与-import-的区别和用法？\"><a href=\"#简明说一下-CSS-link-与-import-的区别和用法？\" class=\"headerlink\" title=\"简明说一下 CSS link 与 @import 的区别和用法？\"></a>简明说一下 CSS link 与 @import 的区别和用法？</h1><pre><code class=\"text\">link 是 XHTML 标签，除了加载CSS外，还可以定义 RSS 等其他事务；@import 属于 CSS 范畴，只能加载 CSS。\nlink 引用 CSS 时，在页面载入时同时加载；@import 需要页面网页完全载入以后加载。\nlink 是 XHTML 标签，无兼容问题；@import 是在 CSS2.1 提出的，低版本的浏览器不支持。\nlink 支持使用 Javascript 控制 DOM 去改变样式；而@import不支持。\n</code></pre>\n<h1 id=\"rgba和opacity的透明效果有什么不同？\"><a href=\"#rgba和opacity的透明效果有什么不同？\" class=\"headerlink\" title=\"rgba和opacity的透明效果有什么不同？\"></a>rgba和opacity的透明效果有什么不同？</h1><pre><code class=\"text\">opacity 会继承父元素的 opacity 属性，而 RGBA 设置的元素的后代元素不会继承不透明属性。\n</code></pre>\n<h1 id=\"display-none和visibility-hidden的区别？\"><a href=\"#display-none和visibility-hidden的区别？\" class=\"headerlink\" title=\"display:none和visibility:hidden的区别？\"></a>display:none和visibility:hidden的区别？</h1><pre><code class=\"text\">display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。\nvisibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。\n</code></pre>\n<h1 id=\"position的值，-relative和absolute分别是相对于谁进行定位的？\"><a href=\"#position的值，-relative和absolute分别是相对于谁进行定位的？\" class=\"headerlink\" title=\"position的值， relative和absolute分别是相对于谁进行定位的？\"></a>position的值， relative和absolute分别是相对于谁进行定位的？</h1><pre><code class=\"text\">relative:相对定位，相对于自己本身在正常文档流中的位置进行定位。\nabsolute:生成绝对定位，相对于最近一级定位不为static的父元素进行定位。\nfixed: （老版本IE不支持）生成绝对定位，相对于浏览器窗口或者frame进行定位。\nstatic:默认值，没有定位，元素出现在正常的文档流中。\nsticky:生成粘性定位的元素，容器的位置根据正常文档流计算得出。\n</code></pre>\n<h1 id=\"画一条0-5px的直线？\"><a href=\"#画一条0-5px的直线？\" class=\"headerlink\" title=\"画一条0.5px的直线？\"></a>画一条0.5px的直线？</h1><pre><code class=\"text\">考查的是css3的transform\n\nheight: 1px;\ntransform: scale(0.5);\n</code></pre>\n<h1 id=\"calc-support-media各自的含义及用法？\"><a href=\"#calc-support-media各自的含义及用法？\" class=\"headerlink\" title=\"calc, support, media各自的含义及用法？\"></a>calc, support, media各自的含义及用法？</h1><pre><code class=\"text\">@support 主要是用于检测浏览器是否支持CSS的某个属性，其实就是条件判断，如果支持某个属性，你可以写一套样式，如果不支持某个属性，你也可以提供另外一套样式作为替补。\ncalc() 函数用于动态计算长度值。 calc()函数支持 “+”, “-”, “*”, “/” 运算；\n@media 查询，你可以针对不同的媒体类型定义不同的样式。\n</code></pre>\n<h1 id=\"1rem、1em、1vh、1px各自代表的含义？\"><a href=\"#1rem、1em、1vh、1px各自代表的含义？\" class=\"headerlink\" title=\"1rem、1em、1vh、1px各自代表的含义？\"></a>1rem、1em、1vh、1px各自代表的含义？</h1><pre><code class=\"text\">\n1.rem\nrem是全部的长度都相对于根元素元素。通常做法是给html元素设置一个字体大小，然后其他元素的长度单位就为rem。\n    \n2. em\n子元素字体大小的em是相对于父元素字体大小\n元素的width/height/padding/margin用em的话是相对于该元素的font-size\nvw/vh\n全称是 Viewport Width 和 Viewport Height，视窗的宽度和高度，相当于 屏幕宽度和高度的 1%，不过，处理宽度的时候%单位更合适，处理高度的 话 vh 单位更好。\n    \n3. px\npx像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的。\n一般电脑的分辨率有&#123;19201024&#125;等不同的分辨率\n19201024 前者是屏幕宽度总共有1920个像素,后者则是高度为1024个像素\n</code></pre>\n<h1 id=\"css画一个三角形？\"><a href=\"#css画一个三角形？\" class=\"headerlink\" title=\"css画一个三角形？\"></a>css画一个三角形？</h1><pre><code class=\"css\">.a &#123;\n    width: 0;\n    height: 0;\n    border-width: 100px;\n    border-style: solid;\n    border-color: transparent #0099CC transparent transparent;\n    transform: rotate(90deg); /*顺时针旋转90°*/\n&#125;\n&lt;div class=&quot;a&quot;&gt;&lt;/div&gt;\n</code></pre>\n<h1 id=\"HTML5里面都新增了那些新特性？\"><a href=\"#HTML5里面都新增了那些新特性？\" class=\"headerlink\" title=\"HTML5里面都新增了那些新特性？\"></a>HTML5里面都新增了那些新特性？</h1><pre><code class=\"text\">1. HTML5新的语义标签\n\narticle 独立的内容。\naside 侧边栏。\nheader 头部。\nnav 导航。\nsection 文档中的节。\nfooter 页脚。\n\n2. 画布(Canvas) API\n3. 地理(Geolocation) API\n4. 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；\n5. sessionStorage 的数据在浏览器关闭后自动删除\n6. 新的技术webworker, websocket, Geolocation\n7. 拖拽释放(Drag and drop) API\n8. 音频、视频API(audio,video)\n9. 表单控件，calendar、date、time、email、url、searc\n</code></pre>\n<h1 id=\"CSS3-里面都新增了那些新特性？\"><a href=\"#CSS3-里面都新增了那些新特性？\" class=\"headerlink\" title=\"CSS3 里面都新增了那些新特性？\"></a>CSS3 里面都新增了那些新特性？</h1><pre><code class=\"text\">\n1. 发展历史：CSS于1996年发布，而CSS3是CSS的第三个主要版本，于2001年开始提出，但其功能逐渐得到实现并得以广泛支持直到近年来。\n\n2. 模块化：CSS3采用了模块化的方式来组织样式属性。每个模块专注于特定的功能，例如布局、动画、字体等。这使得开发人员可以根据需要选择特定的模块进行应用，而不需要引入整个CSS3规范。\n\n3. 新增功能：CSS3引入了许多新特性和功能，如圆角边框、阴影、渐变、过渡、动画、媒体查询、弹性盒子布局、网格布局等。这些功能扩展了网页设计师的能力，使其能够创建更丰富、更交互性的用户界面。\n\n4. 浏览器兼容性：传统的CSS规范在不同浏览器上的兼容性并不一致，需要使用特定的浏览器前缀进行适配。然而，CSS3的很多功能已经得到了主流浏览器的广泛支持，因此在一定程度上减少了兼容性的问题。\n</code></pre>\n",
            "tags": [
                "前端开发",
                "css",
                "css"
            ]
        },
        {
            "id": "http://yoursite.com/front-end/nodejs/",
            "url": "http://yoursite.com/front-end/nodejs/",
            "title": "Nodejs基础",
            "date_published": "2021-06-25T08:43:00.000Z",
            "content_html": "<h1 id=\"一：nodejs-基础\"><a href=\"#一：nodejs-基础\" class=\"headerlink\" title=\"一：nodejs 基础\"></a>一：nodejs 基础</h1><h2 id=\"1-异步\"><a href=\"#1-异步\" class=\"headerlink\" title=\"1.异步\"></a>1.异步</h2><h2 id=\"2-io\"><a href=\"#2-io\" class=\"headerlink\" title=\"2.io\"></a>2.io</h2><h2 id=\"3-fs\"><a href=\"#3-fs\" class=\"headerlink\" title=\"3.fs\"></a>3.fs</h2><h1 id=\"二：nodeweb开发\"><a href=\"#二：nodeweb开发\" class=\"headerlink\" title=\"二：nodeweb开发\"></a>二：nodeweb开发</h1><h2 id=\"1-koa2\"><a href=\"#1-koa2\" class=\"headerlink\" title=\"1.koa2\"></a>1.koa2</h2><h2 id=\"2-router\"><a href=\"#2-router\" class=\"headerlink\" title=\"2.router\"></a>2.router</h2><h2 id=\"3-eggjs\"><a href=\"#3-eggjs\" class=\"headerlink\" title=\"3.eggjs\"></a>3.eggjs</h2><h1 id=\"三：鉴权\"><a href=\"#三：鉴权\" class=\"headerlink\" title=\"三：鉴权\"></a>三：鉴权</h1><h2 id=\"1-cookie\"><a href=\"#1-cookie\" class=\"headerlink\" title=\"1.cookie\"></a>1.cookie</h2><h2 id=\"2-jwt\"><a href=\"#2-jwt\" class=\"headerlink\" title=\"2.jwt\"></a>2.jwt</h2><h2 id=\"3-oauth\"><a href=\"#3-oauth\" class=\"headerlink\" title=\"3.oauth\"></a>3.oauth</h2><h1 id=\"四：数据库\"><a href=\"#四：数据库\" class=\"headerlink\" title=\"四：数据库\"></a>四：数据库</h1><h2 id=\"1-mysql\"><a href=\"#1-mysql\" class=\"headerlink\" title=\"1.mysql\"></a>1.mysql</h2><h2 id=\"2-redis\"><a href=\"#2-redis\" class=\"headerlink\" title=\"2.redis\"></a>2.redis</h2><h2 id=\"3-mongodb\"><a href=\"#3-mongodb\" class=\"headerlink\" title=\"3.mongodb\"></a>3.mongodb</h2><h1 id=\"五：中间件\"><a href=\"#五：中间件\" class=\"headerlink\" title=\"五：中间件\"></a>五：中间件</h1><h1 id=\"六：部署发布\"><a href=\"#六：部署发布\" class=\"headerlink\" title=\"六：部署发布\"></a>六：部署发布</h1><h2 id=\"1-PM2\"><a href=\"#1-PM2\" class=\"headerlink\" title=\"1.PM2\"></a>1.PM2</h2><h2 id=\"2-nginx\"><a href=\"#2-nginx\" class=\"headerlink\" title=\"2.nginx\"></a>2.nginx</h2><h2 id=\"3-docker\"><a href=\"#3-docker\" class=\"headerlink\" title=\"3.docker\"></a>3.docker</h2>",
            "tags": [
                "前端开发",
                "Nodejs",
                "Nodejs"
            ]
        },
        {
            "id": "http://yoursite.com/front-end/javascript%E9%9D%A2%E8%AF%95/",
            "url": "http://yoursite.com/front-end/javascript%E9%9D%A2%E8%AF%95/",
            "title": "js面试",
            "date_published": "2021-06-25T08:43:00.000Z",
            "content_html": "<h2 id=\"1-JS-数据类型\"><a href=\"#1-JS-数据类型\" class=\"headerlink\" title=\"1. JS 数据类型 ?\"></a>1. JS 数据类型 ?</h2><pre><code class=\"javascript\">1.数字（Number）：表示数值，包括整数和浮点数。例如：42, 3.14。\n\n2.字符串（String）：表示文本数据，用于存储和操作字符序列。字符串可以使用单引号或双引号括起来。例如：&#39;Hello&#39;, &quot;World&quot;。\n\n3.布尔值（Boolean）：表示逻辑值，只有两个取值：true 和 false。布尔值常用于条件判断和逻辑运算。\n\n4.空值（Null）：表示空值或不存在的对象。当变量被赋值为 null 时，表示该变量没有任何值。\n\n5.未定义（Undefined）：表示变量声明了但未赋值。如果一个变量没有初始化，它的值就是 undefined。\n\n6.符号（Symbol）：ES6 引入的新数据类型，表示独一无二的值。符号通常用作对象属性的键。\n\n除了这些基本数据类型，JavaScript 还提供了一种复杂类型：\n\n7.对象（Object）：表示复合值，可包含多个键值对。键是字符串或符号，值可以是任意类型。对象是 JavaScript 中最常见的数据类型之一，例如数组、函数等都是对象。\n</code></pre>\n<h2 id=\"2-判断一个值是什么类型有哪些方法？\"><a href=\"#2-判断一个值是什么类型有哪些方法？\" class=\"headerlink\" title=\"2. 判断一个值是什么类型有哪些方法？\"></a>2. 判断一个值是什么类型有哪些方法？</h2><pre><code class=\"javascript\">typeof 操作符：typeof 操作符用于检查一个值的类型。它返回一个表示该值类型的字符串。常见的返回值包括 &quot;number&quot;、&quot;string&quot;、&quot;boolean&quot;、&quot;object&quot;、&quot;function&quot;、&quot;undefined&quot;、&quot;symbol&quot;。例如：\njavascript\ntypeof 42; // &quot;number&quot;\ntypeof &quot;Hello&quot;; // &quot;string&quot;\ntypeof true; // &quot;boolean&quot;\ntypeof undefined; // &quot;undefined&quot;\ntypeof null; // &quot;object&quot;（注意这是一个历史遗留问题）\ntypeof Symbol(&quot;symbol&quot;); // &quot;symbol&quot;\ntypeof &#123;&#125;; // &quot;object&quot;\ntypeof []; // &quot;object&quot;\ntypeof function() &#123;&#125;; // &quot;function&quot;\n\n\n\ninstanceof 操作符：instanceof 操作符用于检查一个对象是否属于某个构造函数的实例。它返回一个布尔值。例如：\njavascript\nvar arr = [];\narr instanceof Array; // true\narr instanceof Object; // true，因为 Array 是 Object 的派生类\n\nvar date = new Date();\ndate instanceof Date; // true\ndate instanceof Object; // true，因为 Date 是 Object 的派生类\n\n\nconstructor 属性：constructor 属性是对象的内置属性，指向创建该对象的构造函数。可以通过比较对象的 constructor 属性与预期构造函数来判断对象的类型。例如：\njavascript\nvar num = 42;\nnum.constructor === Number; // true\n\nvar str = &quot;Hello&quot;;\nstr.constructor === String; // true\n\nvar bool = true;\nbool.constructor === Boolean; // true\n\n\n\nObject.prototype.toString：Object 的原型对象上具有 toString 方法，可以通过调用该方法来获取一个值的类型字符串。例如：\njavascript\nvar obj = &#123;&#125;;\nObject.prototype.toString.call(obj); // &quot;[object Object]&quot;\n\nvar arr = [];\nObject.prototype.toString.call(arr); // &quot;[object Array]&quot;\n\nvar date = new Date();\nObject.prototype.toString.call(date); // &quot;[object Date]&quot;\n</code></pre>\n<h2 id=\"3-null-和-undefined-的区别？\"><a href=\"#3-null-和-undefined-的区别？\" class=\"headerlink\" title=\"3. null 和 undefined 的区别？\"></a>3. null 和 undefined 的区别？</h2><pre><code class=\"javascript\">undefined 通常表示缺少预期的值或变量尚未初始化。它是一个全局对象的属性，也可以通过声明变量但不进行赋值来获得该值。\n\nnull 表示明确地指定一个变量为空值，一般用于表示对象或变量没有有效的值。它是一个关键字，不是全局对象的属性。\n</code></pre>\n<h2 id=\"4-怎么判断一个变量arr的话是否为数组（此题用-typeof-不行）？\"><a href=\"#4-怎么判断一个变量arr的话是否为数组（此题用-typeof-不行）？\" class=\"headerlink\" title=\"4. 怎么判断一个变量arr的话是否为数组（此题用 typeof 不行）？\"></a>4. 怎么判断一个变量arr的话是否为数组（此题用 typeof 不行）？</h2><pre><code class=\"javascript\">如果你不想使用 typeof 来判断一个变量是否为数组，可以使用 Array.isArray() 方法。这个方法会检查给定的值是否为一个数组，并返回一个布尔值。\n\n以下是一个示例：\n\njavascript\nvar arr = [1, 2, 3];\nconsole.log(Array.isArray(arr)); // 输出 true\n\nvar obj = &#123;&#125;;\nconsole.log(Array.isArray(obj)); // 输出 false\n在上述示例中，Array.isArray() 方法被用来检查变量 arr 是否为数组。如果 arr 是一个数组，则返回 true；否则，返回 false。\n\n如果需要兼容老版本的浏览器，可以使用以下代码来实现类似的功能：\n\njavascript\nfunction isArray(arr) &#123;\n  return Object.prototype.toString.call(arr) === &#39;[object Array]&#39;;\n&#125;\n\nvar arr = [1, 2, 3];\nconsole.log(isArray(arr)); // 输出 true\n\nvar obj = &#123;&#125;;\nconsole.log(isArray(obj)); // 输出 false\n</code></pre>\n<h2 id=\"5-“-x3D-x3D-x3D-”、“-x3D-x3D-”的区别？\"><a href=\"#5-“-x3D-x3D-x3D-”、“-x3D-x3D-”的区别？\" class=\"headerlink\" title=\"5. “ &#x3D;&#x3D;&#x3D;”、“ &#x3D;&#x3D;”的区别？\"></a>5. “ &#x3D;&#x3D;&#x3D;”、“ &#x3D;&#x3D;”的区别？</h2><pre><code class=\"javascript\">==，当且仅当两个运算数相等时，它返回 true，即不检查数据类型\n===，只有在无需类型转换运算数就相等的情况下，才返回 true，需要检查数据类型\n</code></pre>\n<h2 id=\"6-“eval是做什么的？\"><a href=\"#6-“eval是做什么的？\" class=\"headerlink\" title=\"6. “eval是做什么的？\"></a>6. “eval是做什么的？</h2><pre><code class=\"javascript\">它的功能是把对应的字符串解析成 JS 代码并运行；\n应该避免使用 eval，不安全，非常耗性能（2次，一次解析成 js 语句，一次执行）。\n</code></pre>\n<h2 id=\"7-箭头函数有哪些特点？\"><a href=\"#7-箭头函数有哪些特点？\" class=\"headerlink\" title=\"7. 箭头函数有哪些特点？\"></a>7. 箭头函数有哪些特点？</h2><pre><code class=\"javascript\">不需要function关键字来创建函数\n省略return关键字\n改变this指向\n</code></pre>\n<h2 id=\"8-var、let、const-区别？\"><a href=\"#8-var、let、const-区别？\" class=\"headerlink\" title=\"8. var、let、const 区别？\"></a>8. var、let、const 区别？</h2><pre><code class=\"javascript\">var具有函数作用域，变量提升，并且可以重复声明。\nlet和const具有块级作用域，没有变量提升，而且不允许重复声明（在同一个作用域内）。\nlet声明的变量可重新赋值，而const声明的变量是常量，不可重新赋值。\n</code></pre>\n<h2 id=\"9-new操作符具体干了什么呢？\"><a href=\"#9-new操作符具体干了什么呢？\" class=\"headerlink\" title=\"9. new操作符具体干了什么呢？\"></a>9. new操作符具体干了什么呢？</h2><pre><code class=\"javascript\">1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。\n2、属性和方法被加入到 this 引用的对象中。\n3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。\n</code></pre>\n<h2 id=\"10-JSON-的了解？\"><a href=\"#10-JSON-的了解？\" class=\"headerlink\" title=\"10. JSON 的了解？\"></a>10. JSON 的了解？</h2><pre><code class=\"javascript\">JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。\n它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小\n</code></pre>\n<h2 id=\"11-document-write-和-innerHTML-的区别？\"><a href=\"#11-document-write-和-innerHTML-的区别？\" class=\"headerlink\" title=\"11. document.write 和 innerHTML 的区别？\"></a>11. document.write 和 innerHTML 的区别？</h2><pre><code class=\"javascript\">document.write 只能重绘整个页面\ninnerHTML 可以重绘页面的一部分\n</code></pre>\n<h2 id=\"12-ajax过程？\"><a href=\"#12-ajax过程？\" class=\"headerlink\" title=\"12. ajax过程？\"></a>12. ajax过程？</h2><pre><code class=\"javascript\">(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象.\n(2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.\n(3)设置响应HTTP请求状态变化的函数.\n(4)发送HTTP请求.\n(5)获取异步调用返回的数据.\n(6)使用JavaScript和DOM实现局部刷新.\n</code></pre>\n<h2 id=\"13-请解释一下-JavaScript-的同源策略？\"><a href=\"#13-请解释一下-JavaScript-的同源策略？\" class=\"headerlink\" title=\"13. 请解释一下 JavaScript 的同源策略？\"></a>13. 请解释一下 JavaScript 的同源策略？</h2><pre><code class=\"javascript\">概念:同源策略是客户端脚本（尤其是Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。\n这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。\n指一段脚本只能读取来自同一来源的窗口和文档的属性。\n</code></pre>\n<h2 id=\"14-介绍一下闭包和闭包常用场景？\"><a href=\"#14-介绍一下闭包和闭包常用场景？\" class=\"headerlink\" title=\"14. 介绍一下闭包和闭包常用场景？\"></a>14. 介绍一下闭包和闭包常用场景？</h2><pre><code class=\"javascript\">闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包常见方式，就是在一个函数的内部创建另一个函数\n使用闭包主要为了设计私有的方法和变量，闭包的优点是可以避免变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念。\n闭包有三个特性：\n函数嵌套函数\n函数内部可以引用外部的参数和变量\n参数和变量不会被垃圾回收机制回收\n应用场景，设置私有变量的方法\n不适用场景：返回闭包的函数是个非常大的函数\n闭包的缺点就是常驻内存，会增大内存使用量，使用不当会造成内存泄漏\n</code></pre>\n<h2 id=\"15-javascript的内存-垃圾-回收机制？\"><a href=\"#15-javascript的内存-垃圾-回收机制？\" class=\"headerlink\" title=\"15. javascript的内存(垃圾)回收机制？\"></a>15. javascript的内存(垃圾)回收机制？</h2><pre><code class=\"javascript\">垃圾回收器会每隔一段时间找出那些不再使用的内存，然后为其释放内存\n一般使用标记清除方法(mark and sweep), 当变量进入环境标记为进入环境，离开环境标记为离开环境\n垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了\n还有引用计数方法(reference counting), 在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间。\n在IE中虽然JavaScript对象通过标记清除的方式进行垃圾回收，但BOM与DOM对象却是通过引用计数回收垃圾的， 也就是说只要涉及BOM及DOM就会出现循环引用问题。\n</code></pre>\n<h2 id=\"16-JavaScript原型，原型链-有什么特点？\"><a href=\"#16-JavaScript原型，原型链-有什么特点？\" class=\"headerlink\" title=\"16. JavaScript原型，原型链 ? 有什么特点？\"></a>16. JavaScript原型，原型链 ? 有什么特点？</h2><pre><code class=\"javascript\">\n</code></pre>\n<h2 id=\"17-事件队列（宏任务微任务）\"><a href=\"#17-事件队列（宏任务微任务）\" class=\"headerlink\" title=\"17. 事件队列（宏任务微任务）\"></a>17. 事件队列（宏任务微任务）</h2><pre><code class=\"微任务和宏任务的本质区别。\">可以分为微任务（micro task）队列和宏任务（macro task）队列。\n\n微任务一般比宏任务先执行，并且微任务队列只有一个，宏任务队列可能有多个。另外我们常见的点击和键盘等事件也属于宏任务。\n\n下面我们看一下常见宏任务和常见微任务。\n\n常见宏任务：\nsetTimeout()\nsetInterval()\nsetImmediate()\n常见微任务：\n\npromise.then()、promise.catch()\nnew MutaionObserver()\nprocess.nextTick()\n\n\n微任务和宏任务的本质区别。\n\n宏任务特征：有明确的异步任务需要执行和回调；需要其他异步线程支持。\n微任务特征：没有明确的异步任务需要执行，只有回调；不需要其他异步线程支持。\n</code></pre>\n<h2 id=\"19-async-x2F-await\"><a href=\"#19-async-x2F-await\" class=\"headerlink\" title=\"19. async&#x2F;await\"></a>19. async&#x2F;await</h2><pre><code class=\"javascript\">async 是一个通过异步执行并隐式返回 Promise 作为结果的函数。是Generator函数的语法糖，并对Generator函数进行了改进。\n改进：\n\n内置执行器，无需手动执行 next() 方法。\n更好的语义\n更广的适用性：co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。\n返回值是 Promise，比 Generator 函数返回的 Iterator 对象方便，可以直接使用 then() 方法进行调用。\nasync 隐式返回 Promise 作为结果的函数，那么可以简单理解为，await后面的函数执行完毕时，await会产生一个微任务(Promise.then是微任务)。\n</code></pre>\n<h2 id=\"20-JavaScript-是单线程的，浏览器是多进程的\"><a href=\"#20-JavaScript-是单线程的，浏览器是多进程的\" class=\"headerlink\" title=\"20. JavaScript 是单线程的，浏览器是多进程的\"></a>20. JavaScript 是单线程的，浏览器是多进程的</h2><pre><code class=\"javascript\">每打开一个新网页就会创建一个渲染进程\n渲染进程是多线程的\n负责页面渲染的 GUI 渲染线程\n负责JavaScript的执行的 JavaScript 引擎线程，\n负责浏览器事件循环的事件触发线程，注意这不归 JavaScript 引擎线程管\n负责定时器的定时触发器线程，setTimeout 中低于 4ms 的时间间隔算为4ms\n负责XMLHttpRequest的异步 http 请求线程\nGUI 渲染线程与 JavaScript 引擎线程是互斥的\n单线程JavaScript是因为避免 DOM 渲染的冲突，web worker 支持多线程，但是 web worker 不能访问 window 对象，document 对象等。\n</code></pre>\n",
            "tags": [
                "前端开发",
                "Javascript",
                "Javascript"
            ]
        },
        {
            "id": "http://yoursite.com/front-end/uniapp/",
            "url": "http://yoursite.com/front-end/uniapp/",
            "title": "uniapp基础原理",
            "date_published": "2021-06-25T08:43:00.000Z",
            "content_html": "",
            "tags": [
                "前端开发",
                "uniapp",
                "uniapp"
            ]
        },
        {
            "id": "http://yoursite.com/front-end/vue%E5%B8%B8%E7%94%A8%E5%9F%BA%E7%A1%80/",
            "url": "http://yoursite.com/front-end/vue%E5%B8%B8%E7%94%A8%E5%9F%BA%E7%A1%80/",
            "title": "vue常用基础",
            "date_published": "2021-06-25T08:43:00.000Z",
            "content_html": "<p>vue系列基础到原理.</p>\n<h1 id=\"一：Vue基础\"><a href=\"#一：Vue基础\" class=\"headerlink\" title=\"一：Vue基础\"></a>一：Vue基础</h1><h2 id=\"1：vue生命周期和生命周期钩子函数？\"><a href=\"#1：vue生命周期和生命周期钩子函数？\" class=\"headerlink\" title=\"1：vue生命周期和生命周期钩子函数？\"></a>1：vue生命周期和生命周期钩子函数？</h2><p><strong>beforecreated</strong>：在实例初始化之后，el 和 data 并未初始化（这个时期，this变量还不能使用，在data下的数据，和methods下的方法，watcher中的事件都不能获得到；）<br><strong>created</strong>:完成了 data 数据的初始化，el没有（这个时候可以操作vue实例中的数据和各种方法，但是还不能对”dom”节点进行操作；）<br><strong>beforeMount</strong>：完成了 el 和 data 初始化这里的el是虚拟的dom；<br><strong>mounted</strong> ：完成挂载，在这发起后端请求，拿回数据，配合路由钩子做一些事情（挂载完毕，这时dom节点被渲染到文档内，一些需要dom的操作在此时才能正常进行），定义定时器<br><strong>beforeUpdate</strong>：<strong>数据是新的，但是页面是旧的</strong><br><strong>update</strong>：数据和页面保持同步了，</p>\n<p><strong>activited</strong>：keep-alive 专属，组件被激活时调用</p>\n<p><strong>activited</strong>：keep-alive 专属，组件被销毁时调用</p>\n<p><strong>beforeDestory</strong>： 你确认删除定时器吗？<br><strong>destoryed</strong> ：当前组件已被删除，(其实就是页面的退出)</p>\n<p><strong>A、什么是vue生命周期？</strong><br>Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。<br><strong>B、vue生命周期的作用是什么？</strong><br>它的生命周期有多个事件钩子,让我们在控制整个Vue实例的过程时更容易形成好的逻辑。<br><strong>C、vue生命周期总共有几个阶段？</strong><br>它可以总共分为8个阶段：创建前&#x2F;后, 载入前&#x2F;后,更新前&#x2F;后,销毁前&#x2F;销毁后<br><strong>D、第一次页面加载会触发哪几个钩子？</strong><br>第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子<br><strong>E、DOM 渲染在 哪个周期中就已经完成？</strong><br>DOM 渲染在 mounted 中就已经完成了。<br><strong>F、简单描述每个周期具体适合哪些场景？</strong></p>\n<pre><code class=\"javascript\">1.beforecreate:可以在加个loading事件，在加载实例是触发\n2.created:初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用\n3.mounted:异步请求，启动定时器，绑定自定义事件，订阅消息\n4.updated:如果对数据统一处理\n5.beforeDestroy:清除定时器，解绑自定义事件，取消订阅,一般不再这里在操作数据，即使操作了，页面也不会更新了\n</code></pre>\n<h2 id=\"2：v-show与v-if的区别\"><a href=\"#2：v-show与v-if的区别\" class=\"headerlink\" title=\"2：v-show与v-if的区别\"></a>2：v-show与v-if的区别</h2><p>v-show是css切换，v-if是完整的销毁和重新创建<br>使用频繁切换时用v-show,运行时较少改变时用v-if<br>V-if&#x3D;’false’v-if是条件渲染，当false的时候不会渲染<br>使用v-if的时候，如果值为false，那么页面将不会有这个html标签生成<br>v-show则是不管值是为true还是false，html元素都会存在，只是css中的display显示或隐藏<br>v-show 仅仅控制元素的显示方式，将 display 属性在 block 和 none 来回切换；而v-if会控制这个 DOM 节点的存在与否。当我们需要经常切换某个元素的显示&#x2F;隐藏时，使用v-show会更加节省性能上的开销；当只需要一次显示或隐藏时，使用v-if更加合理。</p>\n<h2 id=\"3：开发中常用的指令有哪些\"><a href=\"#3：开发中常用的指令有哪些\" class=\"headerlink\" title=\"3：开发中常用的指令有哪些?\"></a>3：开发中常用的指令有哪些?</h2><p>v-model:一般用在表达输入，很轻松的实现表单控件和数据的双向绑定</p>\n<pre><code class=\"javascript\">v-html：更新元素的innerHTML\n\n&lt;p v-html=&quot;msg&quot;&gt;&lt;/p&gt;\n\nvar vm = new Vue(&#123;\n            el : &quot;#app&quot;,\n            data : &#123;\n                msg : &quot;&lt;h1&gt;这是一个h1元素内容&lt;/h1&gt;&quot;\n            &#125;\n        &#125;);\n</code></pre>\n<p>v-show与v-if：条件渲染，注意二者区别<br>v-on:click:可以简写为@click,@绑定一个事件。如果事件触发了，就可以指定事件的处理函数<br>v-for：基于源数据多次渲染元素或模板<br>v-bind:当表达式的值改变时，将其产生的连带影响，响应式地作用于DOM语法<br>v-bind:title&#x3D;”msg”简写：    :title&#x3D;”msg”</p>\n<pre><code class=\"javascript\">v-clock解决页面闪烁问题\n\n如果网速慢，而该标签内容是变量没有请求响应回来的时候，页面上先不显示该标签（vue给该标签加了css样式），当响应回来的时候改标签默认将css样式去除。此指令可以解决使用插值表达式页面闪烁问题\n\n将该指令加在html标签中时，可以在该文件中加style属性为display：none，例子如下：\n\n&lt;div class=&quot;#app&quot; v-cloak&gt;\n    &lt;p&gt;&#123;&#123;name&#125;&#125;&lt;/p&gt;\n&lt;/div&gt;\n\n[v-cloak] &#123;\n    display: none;\n&#125;\n</code></pre>\n<h2 id=\"4：绑定class的数组用法\"><a href=\"#4：绑定class的数组用法\" class=\"headerlink\" title=\"4：绑定class的数组用法\"></a>4：绑定class的数组用法</h2><pre><code class=\"javascript\">1.对象方法v-bind:class=&quot;&#123;&#39;orange&#39;:isRipe, &#39;green&#39;:isNotRipe&#125;”\n\n:class=&quot;tindex == index ? &#39;aaa&#39;:&#39;bbb&#39;&quot;\n\n2.数组方法v-bind:class=&quot;[class1,class2]&quot;\n\n\n3.行内v-bind:style=&quot;&#123;color:color,fontSize:fontSize+&#39;px&#39;&#125;”\n</code></pre>\n<h2 id=\"5：计算属性和methods\"><a href=\"#5：计算属性和methods\" class=\"headerlink\" title=\"5：计算属性和methods\"></a>5：计算属性和methods</h2><pre><code class=\"javascript\">computed:&#123;\n    fullName:&#123;\n        //get有什么作用? 当有人读取实例(data)上的数据时候,get就会被调用，返回值可以是data上的值\n        //get什么时候调用? 1.初次读取时，2.所依赖的数据发生变化的时候\n        get()&#123;  //fullName被读取时调用\n            return this.firstName\n        &#125;,\n        //set什么时候调用? 当fullName被修改时\n        set(value)&#123;\t//fullName被修改时调用 \n                //非必须写\n            console.log(&#39;修改fullName后的值&#39;,value)\t\n        &#125;\n    &#125;\n    //简写方式\n    fullNamejianxie()&#123;\n        return this.firstName  + &#39;jianxie&#39;\n    &#125;\n&#125;\n\n1.定义:要用的属性存在，要通过已有的属性计算而来\n2.计算属性的底层借助Object.defineProperty()方法提供gettter/setter\n3.get函数什么时候调用?\n     (1).初次读取时\n     (2).所依赖的数据发生变化的时\n4.优势:与methods实现相比，内部有缓存机制(复用),效率更高,调试方便\n5.备注:\n     (1).计算属性最终会出现在vm(实例)上，直接读取即可\n     (2).如果计算属性被修改，那必须写set去响应数据，且set中要引起计算时依赖的数据发送变化\n</code></pre>\n<h2 id=\"6：computed-计算属性-和watch-监听-的对比\"><a href=\"#6：computed-计算属性-和watch-监听-的对比\" class=\"headerlink\" title=\"6：computed(计算属性)和watch(监听)的对比\"></a>6：computed(计算属性)和watch(监听)的对比</h2><p><strong>computed</strong></p>\n<pre><code class=\"javascript\">\ncomputed是计算属性，也就是计算值，它更多用于计算值的场景\ncomputed具有缓存性，computed的值在getter执行后是会缓存的，只有在它依赖的属性值改变之后，下一次获取computed的值时重新调用对应的getter来计算\ncomputed适用于计算比较消耗性能的计算场景\n</code></pre>\n<p><strong>watch</strong></p>\n<pre><code class=\"javascript\">&lt;template&gt;\n    &lt;div class=&quot;container&quot;&gt;\n        &lt;!-- 1.监听实例上的基础数据类型 --&gt;\n        &lt;button @click=&quot;isHot = !isHot&quot;&gt;&#123;&#123;isHot&#125;&#125;&lt;/button&gt;\n\n        &lt;hr&gt;\n\n        &lt;!-- 2.监听引用类型的数据 --&gt;\n        &lt;button @click=&quot;obj.age++&quot;&gt;&#123;&#123;obj.age&#125;&#125;&lt;/button&gt;\n        \n        &lt;hr&gt;\n\n        &lt;!-- 3.修改对象类型的数据变成字符串 --&gt;\n        &lt;button @click=&quot;obj = &#39;变成其他数据类型了&#39;&quot;&gt;&#123;&#123;obj&#125;&#125;&lt;/button&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\n    export default &#123;\n        name: &#39;index&#39;,\n        data() &#123;\n            return &#123;\n                isHot : true,\n                obj :&#123;\n                    name: &#39;js&#39;,\n                    age : 18\n                &#125;   \n            &#125;\n        &#125;,\n        watch:&#123;\n            isHot:&#123;\n                immediate : true, //初始化的时候，让handler调用一下\n                handler(newValue,oldValue)&#123; //handle什么时候调用? isHot发送变化时候\n                    console.log(&#39;isHot被修改了&#39;,newValue,oldValue)\n                &#125;\n            &#125;,\n            // &#39;obj.age&#39; :&#123; \n            //      handler(newValue,oldValue)&#123; \n            //         console.log(&#39;age被修改了&#39;,newValue,oldValue)\n            //     &#125;\n            //      //监视多级结构中某个属性的变化(不建议这么写，如果有很多个值呢？)\n            // &#125;,\n            // obj:&#123;\n            //     //这么写即使是age的值发送改变，也不会有任何操作。\n            //     //因为此时监视的是 obj下的整个对象,除非对象变成其他类型的数据才会触发\n            //     handler(newValue,oldValue)&#123; \n            //         console.log(&#39;obj被修改了&#39;,newValue,oldValue)\n            //     &#125;\n            // &#125;,\n            obj:&#123;\n                //深度监视 \n                //不管是obj的数据类型变了，还是里面的值变了\n                deep : true,\n                handler(newValue,oldValue)&#123;\n                      console.log(&#39;obj被修改了&#39;,newValue,oldValue)\n                &#125;\n            &#125;,\n            // 简写方式 =&gt;\n            // 什么时候的时候才能简写?   只需要用到handler的时候\n            isHot(newValue,oldValue)&#123;\n                console.log(&#39;isHot被修改了&#39;,newValue,oldValue)  \n            &#125;\n        &#125;\n    &#125;\n&lt;/script&gt;\n&lt;style lang=&quot;less&quot;&gt;\n        .container&#123;\n            width: 100VW;\n            height: 100VH;\n        &#125;\n&lt;/style&gt;\n\n\n1.watch可以监听异步任务,计算属性无法开启异步任务\n&lt;template&gt;\n  &lt;div class=&quot;container&quot;&gt;\n    &lt;button @click=&quot;obj = &#39;变成其他数据类型了&#39;&quot;&gt;&#123;&#123; obj &#125;&#125;&lt;/button&gt;\n    &lt;div&gt;\n      &#123;&#123; ahhh &#125;&#125;\n    &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nexport default &#123;\n  name: &quot;index&quot;,\n  data() &#123;\n    return &#123;\n      ahhh: 1,\n      obj: &#123;\n        name: &quot;js&quot;,\n        age: 18,\n      &#125;,\n    &#125;;\n  &#125;,\n  watch: &#123;\n    obj: &#123;\n      deep: true,\n      handler(newValue, oldValue) &#123;\n        console.log(&quot;obj被修改了&quot;, newValue, oldValue);\n        setTimeout(() =&gt; &#123;  \n            //这里注意要用箭头函数(this会一层一层往外找)，不能使用普通函数（this执行windows）\n            //开启异步任务\n          console.log(&quot;this&quot;, this);\n          this.ahhh += 1;\n        &#125;, 1000);\n      &#125;,\n    &#125;,\n  &#125;,\n&#125;;\n&lt;/script&gt;\n&lt;style lang=&quot;less&quot;&gt;\n.container &#123;\n  width: 100vw;\n  height: 100vh;\n&#125;\n&lt;/style&gt;\n</code></pre>\n<h2 id=\"7：vue组件的scoped属性的作用\"><a href=\"#7：vue组件的scoped属性的作用\" class=\"headerlink\" title=\"7：vue组件的scoped属性的作用\"></a>7：vue组件的scoped属性的作用</h2><p>在style标签上添加scoped属性，以表示它的样式作用于当下的模块，很好的实现了样式私有化的目的；<br>但是也得慎用：样式不易（可）修改，而很多时候，我们是需要对公共组件的样式做微调的；</p>\n<p><strong>解决办法：</strong></p>\n<pre><code class=\"javascript\">①：使用混合型的css样式：（混合使用全局跟本地的样式） &lt;style&gt; /* 全局样式 */ &lt;/style&gt;&lt;style scoped&gt; /* 本地样式 */ &lt;/style&gt;\n②：深度作用选择器（&gt;&gt;&gt;）如果你希望 scoped 样式中的一个选择器能够作用得“更深”，例如影响子组件，你可以使用 &gt;&gt;&gt; 操作符：\n&lt;style scoped&gt;\n    .a &gt;&gt;&gt; .b &#123; /* ... */ &#125; &lt;/style&gt;\n</code></pre>\n<h2 id=\"8：vue常用修饰符\"><a href=\"#8：vue常用修饰符\" class=\"headerlink\" title=\"8：vue常用修饰符\"></a>8：vue常用修饰符</h2><p><strong>修饰符分为：一般修饰符，事件修身符，按键、系统</strong></p>\n<p><strong>①一般修饰符</strong><br>.lazy：v-model 在每次 input 事件触发后将输入框的值与数据进行同步 。你可以添加 lazy 修饰符，从而转变为使用 change 事件进行同步</p>\n<pre><code class=\"javascript\">&lt;input v-model.lazy=&quot;msg&quot; &gt; \n</code></pre>\n<p><strong>.number</strong></p>\n<pre><code class=\"javascript\">&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt;\n</code></pre>\n<p><strong>.trim</strong></p>\n<pre><code class=\"javascript\">1.如果要自动过滤用户输入的首尾空白字符 &lt;input v-model.trim=&#39;trim&#39;&gt;\n</code></pre>\n<p><strong>② 事件修饰符</strong></p>\n<pre><code class=\"javascript\">1. 阻止单击事件继续传播 \n&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;  \n\n2.提交事件不再重载页面\n&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt; \n\n3.添加事件监听器时使用事件捕获模式(即元素自身触发的事件先在此处处理，然后才交由内部元素进行处理)\n&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;   \n\n4.只当在 event.target 是当前元素自身时触发处理函数(即事件不是从内部元素触发的)\n&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt; \n\n5.点击事件将只会触发一次 \n&lt;a v-on:click.once=&quot;doThis&quot;&gt;&lt;/a&gt;  \n\n6.vue组件添加事件\n&lt;Tabber @click.native=&quot;doThis&quot;&gt;&lt;/Tabbar&gt; \n\n7.修饰符可以串联\n&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt; \n</code></pre>\n<p><strong>③按键修饰符</strong></p>\n<p>全部的按键别名:</p>\n<pre><code class=\"js\">.enter\n.tab\n.delete (捕获“删除”和“退格”键)\n.esc\n.space\n.up\n.down\n.left\n.right\n.ctrl\n.alt\n.shift\n.meta\n</code></pre>\n<pre><code class=\"js\">&lt;input v-on:keyup.enter=&quot;submit&quot;&gt; 或者 &lt;input @keyup.enter=&quot;submit&quot;&gt;\n</code></pre>\n<p><strong>④系统修饰键 （可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器）</strong></p>\n<pre><code class=\"js\">.ctrl\n.alt\n.shift\n.meta\n</code></pre>\n<pre><code class=\"js\">&lt;input @keyup.alt.67=&quot;clear&quot;&gt; 或者 &lt;div @click.ctrl=&quot;doSomething&quot;&gt;Do something&lt;/div&gt;&lt;!-- Ctrl + Click --&gt;\n</code></pre>\n<h2 id=\"9：v-on可以监听多个事件处理吗？（可以的）\"><a href=\"#9：v-on可以监听多个事件处理吗？（可以的）\" class=\"headerlink\" title=\"9：v-on可以监听多个事件处理吗？（可以的）\"></a>9：v-on可以监听多个事件处理吗？（可以的）</h2><p>一个元素绑定多个事件的两种写法，一个事件绑定多个函数的两种写法，修饰符的使用。</p>\n<pre><code class=\"js\">&lt;a style=&quot;cursor:default&quot; v-on=&#39;&#123;click:DoSomething,mouseleave:MouseLeave&#125;&#39;&gt;doSomething&lt;/a&gt;\n</code></pre>\n<p>在method方法里面分别写两个事件；</p>\n<pre><code class=\"js\">&lt;button @click=&quot;a(),b()&quot;&gt;点我ab&lt;/button&gt;\n</code></pre>\n<h2 id=\"10：vue事件中使用event对象\"><a href=\"#10：vue事件中使用event对象\" class=\"headerlink\" title=\"10：vue事件中使用event对象\"></a>10：vue事件中使用event对象</h2><pre><code class=\"js\">&lt;template&gt;\n    //不加括号的的时候，直接拿到event对象\n&lt;button @click=&quot;btn&quot;&gt;点击&lt;/button&gt;  \n&lt;/template&gt;\n\nbtn(value)&#123;\n    console.log(&#39;value&#39;,value)\t\n&#125;\n\n\n\n//现在的需求是点击事件直接传值过来，但是也要event对象\n&lt;template&gt;\n    //加了括号\n&lt;button @click=&quot;btn($event,1,2)&quot;&gt;点击&lt;/button&gt;  \n&lt;/template&gt;\n\nbtn(value,...a)&#123;\n    console.log(&#39;value&#39;,value)\n    console.log(&#39;a&#39;,a)  // [1,2]\n&#125;\n</code></pre>\n<h2 id=\"11：nextTick\"><a href=\"#11：nextTick\" class=\"headerlink\" title=\"11：nextTick\"></a>11：nextTick</h2><ol>\n<li>语法：<code>this.$nextTick(回调函数)</code></li>\n<li>作用：在下一次 DOM 更新结束后执行其指定的回调。</li>\n<li>什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行。</li>\n</ol>\n<pre><code class=\"js\">**比如你想让一个dom元素显示**，然后下一步去获取这个元素的offsetWidth，最后你获取到的会是0。\nopenSubmenu() &#123;\n    this.show = true //获取不到宽度\n    this.$nextTick(() =&gt; \n      //这里才可以 let w = this.$refs.submenu.offsetWidth;\n   &#125;)\n&#125;\n</code></pre>\n<h2 id=\"13：Vue组件间传递数据的方式\"><a href=\"#13：Vue组件间传递数据的方式\" class=\"headerlink\" title=\"13：Vue组件间传递数据的方式\"></a>13：Vue组件间传递数据的方式</h2><h3 id=\"1-props配置项-父传子-or-子传父\"><a href=\"#1-props配置项-父传子-or-子传父\" class=\"headerlink\" title=\"1.props配置项(父传子 or 子传父)\"></a>1.props配置项(父传子 or 子传父)</h3><ol>\n<li><p>功能：让组件接收外部传过来的数据</p>\n</li>\n<li><p>传递数据：<code>&lt;Demo name=&quot;xxx&quot;/&gt;</code></p>\n</li>\n<li><p>接收数据：</p>\n<ol>\n<li><p>第一种方式（只接收）：<code>props:[&#39;name&#39;] </code></p>\n</li>\n<li><p>第二种方式（限制类型）：<code>props:&#123;name:String&#125;</code></p>\n</li>\n<li><p>第三种方式（限制类型、限制必要性、指定默认值）：</p>\n<pre><code class=\"js\">props:&#123;\n    name:&#123;\n    type:String, //类型\n    required:true, //必要性\n    default:&#39;老王&#39; //默认值\n    &#125;\n&#125;\n</code></pre>\n</li>\n</ol>\n<blockquote>\n<p>备注：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据。</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"2-组件的自定义事件-子传父\"><a href=\"#2-组件的自定义事件-子传父\" class=\"headerlink\" title=\"2.组件的自定义事件(子传父)\"></a>2.组件的自定义事件(子传父)</h3><ol>\n<li><p>一种组件间通信的方式，适用于：<strong style=\"color:red\">子组件 &#x3D;&#x3D;&#x3D;&gt; 父组件</strong></p>\n</li>\n<li><p>使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（<span style=\"color:red\">事件的回调在A中</span>）。</p>\n</li>\n<li><p>绑定自定义事件：</p>\n<ol>\n<li><p>第一种方式，在父组件中：<code>&lt;Demo @dataarr=&quot;test&quot;/&gt;</code>  或 <code>&lt;Demo v-on:dataarr=&quot;test&quot;/&gt;</code></p>\n</li>\n<li><p>第二种方式，在父组件中：</p>\n<pre><code class=\"js\">&lt;Demo ref=&quot;demo&quot;/&gt;\n......\nmounted()&#123;\n   this.$refs.xxx.$on(&#39;dataarr&#39;,this.test)\n&#125;\n</code></pre>\n</li>\n<li><p>若想让自定义事件只能触发一次，可以使用<code>once</code>修饰符，或<code>$once</code>方法。</p>\n</li>\n</ol>\n</li>\n<li><p>触发自定义事件：<code>this.$emit(&#39;dataarr&#39;,数据)</code>\t\t</p>\n</li>\n<li><p>解绑自定义事件<code>this.$off(&#39;dataarr&#39;)</code></p>\n</li>\n<li><p>组件上也可以绑定原生DOM事件，需要使用<code>native</code>修饰符。</p>\n</li>\n<li><p>注意：通过<code>this.$refs.xxx.$on(&#39;dataarr&#39;,回调)</code>绑定自定义事件时，回调<span style=\"color:red\">要么配置在methods中</span>，<span style=\"color:red\">要么用箭头函数</span>，否则this指向会出问题！</p>\n</li>\n</ol>\n<h3 id=\"3-全局事件总线（GlobalEventBus）\"><a href=\"#3-全局事件总线（GlobalEventBus）\" class=\"headerlink\" title=\"3.全局事件总线（GlobalEventBus）\"></a>3.全局事件总线（GlobalEventBus）</h3><ol>\n<li><p>一种组件间通信的方式，适用于<span style=\"color:red\">任意组件间通信</span>。</p>\n</li>\n<li><p>安装全局事件总线：</p>\n<pre><code class=\"js\">new Vue(&#123;\n    ......\n    beforeCreate() &#123;\n        Vue.prototype.$bus = this //安装全局事件总线，$bus就是当前应用的vm\n    &#125;,\n    ......\n&#125;) \n</code></pre>\n</li>\n<li><p>使用事件总线：</p>\n<ol>\n<li><p>接收数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的<span style=\"color:red\">回调留在A组件自身。</span></p>\n<pre><code class=\"js\">methods()&#123;\n  demo(data)&#123;......&#125;\n&#125;\n......\nmounted() &#123;\n  this.$bus.$on(&#39;xxxx&#39;,this.demo)\n&#125;\n</code></pre>\n</li>\n<li><p>提供数据：<code>this.$bus.$emit(&#39;xxxx&#39;,数据)</code></p>\n</li>\n</ol>\n</li>\n<li><p>最好在beforeDestroy钩子中，用$off去解绑<span style=\"color:red\">当前组件所用到的</span>事件。</p>\n</li>\n</ol>\n<h3 id=\"4-消息订阅与发布（pubsub）\"><a href=\"#4-消息订阅与发布（pubsub）\" class=\"headerlink\" title=\"4.消息订阅与发布（pubsub）\"></a>4.消息订阅与发布（pubsub）</h3><ol>\n<li><p>一种组件间通信的方式，适用于<span style=\"color:red\">任意组件间通信</span>。</p>\n</li>\n<li><p>使用步骤：</p>\n<ol>\n<li><p>安装pubsub：<code>npm i pubsub-js</code></p>\n</li>\n<li><p>引入: <code>import pubsub from &#39;pubsub-js&#39;</code></p>\n</li>\n<li><p>接收数据：A组件想接收数据，则在A组件中订阅消息，订阅的<span style=\"color:red\">回调留在A组件自身。</span></p>\n<pre><code class=\"js\">methods()&#123;\n  demo(data)&#123;......&#125;\n&#125;\n......\nmounted() &#123;\n  this.pid = pubsub.subscribe(&#39;xxx&#39;,this.demo) //订阅消息\n&#125;\n</code></pre>\n</li>\n<li><p>提供数据：<code>pubsub.publish(&#39;xxx&#39;,数据)</code></p>\n</li>\n<li><p>最好在beforeDestroy钩子中，用<code>PubSub.unsubscribe(pid)</code>去<span style=\"color:red\">取消订阅。</span></p>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"5：prvide-amp-inject\"><a href=\"#5：prvide-amp-inject\" class=\"headerlink\" title=\"5：prvide &amp; inject\"></a>5：prvide &amp; inject</h3><h3 id=\"6：整合\"><a href=\"#6：整合\" class=\"headerlink\" title=\"6：整合\"></a>6：整合</h3><pre><code class=\"javascript\">Vue 组件间通信只要指以下 3 类通信：父子组件通信、隔代组件通信、兄弟组件通信，下面我们分别介绍每种通信方式且会说明此种方法可适用于哪类组件间通信。\n（1）props / $emit 适用 父子组件通信\n\n这种方法是 Vue 组件的基础，相信大部分同学耳闻能详，所以此处就不举例展开介绍。\n（2）ref 与 $parent / $children适用 父子组件通信\n\nref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例\n$parent / $children：访问父 / 子实例\n（3）EventBus （$emit / $on）适用于 父子、隔代、兄弟组件通信\n\n这种方法通过一个空的 Vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件。\n（4）$attrs/$listeners适用于 隔代组件通信\n\n$attrs：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 v-bind=&quot;$attrs&quot; 传入内部组件。通常配合 inheritAttrs 选项一起使用。\n$listeners：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=&quot;$listeners&quot; 传入内部组件\n（5）provide / inject适用于 隔代组件通信\n\n祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。\n（6）Vuex适用于 父子、隔代、兄弟组件通信\n\nVuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。\nVuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。\n改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。\n</code></pre>\n<pre><code class=\"javascript\">\n\n//父组件需要拿到子组件的数据和实例\n父组件调用子组件的方法 :this.$refs.yeluosen.childMethod()\n\n//子组件拿到父组件的实例 (可以处理父组件分数据和调用父组件的方法)\n this.$parent\n</code></pre>\n<h2 id=\"14：vue更新响应式的缺陷和-set的使用\"><a href=\"#14：vue更新响应式的缺陷和-set的使用\" class=\"headerlink\" title=\"14：vue更新响应式的缺陷和$set的使用\"></a>14：vue更新响应式的缺陷和$set的使用</h2><pre><code class=\"javascript\">&lt;template&gt;\n  &lt;div class=&quot;container&quot;&gt;\n    &lt;ul&gt;\n      &lt;li v-for=&quot;(item, index) in person&quot; :key=&quot;index&quot;&gt;\n        &#123;&#123; item &#125;&#125;\n      &lt;/li&gt;\n    &lt;/ul&gt;\n    &lt;button @click=&quot;addsex&quot;&gt;手动点击给对象添加属性&lt;/button&gt;\n\n    &lt;hr /&gt;\n\n    &lt;ul&gt;\n      &lt;li v-for=&quot;(item, index) in hobby&quot; :key=&quot;index&quot;&gt;\n        &#123;&#123; item &#125;&#125;\n      &lt;/li&gt;\n    &lt;/ul&gt;\n    &lt;button @click=&quot;addhobby&quot;&gt;手动点击给数组修改属性&lt;/button&gt;\n\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nexport default &#123;\n  name: &quot;index&quot;,\n  data() &#123;\n    return &#123;\n      person: &#123;\n        name: &quot;jack&quot;,\n        age: 18,\n      &#125;,\n      hobby: [&quot;抽烟&quot;, &quot;喝酒&quot;, &quot;烫头&quot;],\n      persons: [\n        &#123; name: &quot;gsq&quot;, age: 18 ,status : false &#125;,\n        &#123; name: &quot;gsq02&quot;, age: 19,status : false &#125;,\n        &#123; name: &quot;gsq03&quot;, age: 20,status : false &#125;,\n      ],\n    &#125;;\n  &#125;,\n  methods: &#123;\n    addsex() &#123;\n      // 对象不能这么添加\n      // this.person.sex = &#39;男&#39;\n\n      //正确写法\n      this.$set(this.person, &quot;sex&quot;, &quot;男&quot;)\n    &#125;,\n    addhobby()&#123;\n      // 必须使用响应式的数组方法可以更新/或者使用this.$set\n      // 哪些数组是相应式的？\n      // push,pop,shift,unshift,splice,sort,reverse\n        // this.hobby.splice(0,1,&#39;哈哈&#39;)\n\n      // 或者使用\n      this.$set(this.hobby,0,&#39;哈哈&#39;)  \n    &#125;\n  &#125;,\n&#125;;\n&lt;/script&gt;\n&lt;style lang=&quot;less&quot;&gt;\n.container &#123;\n  width: 100vw;\n  height: 100vh;\n&#125;\n&lt;/style&gt;\n\n\nVue监视数据的原理：\n1. vue会监视data中所有层次的数据。\n\n2. 如何监测对象中的数据？\n通过setter实现监视，且要在new Vue时就传入要监测的数据。\n    (1).对象中后追加的属性，Vue默认不做响应式处理\n    (2).如需给后添加的属性做响应式，请使用如下API：\n        Vue.set(target，propertyName/index，value) 或 \n        vm.$set(target，propertyName/index，value)\n\n3. 如何监测数组中的数据？\n通过包裹数组更新元素的方法实现，本质就是做了两件事：\n    (1).调用原生对应的方法对数组进行更新。\n    (2).重新解析模板，进而更新页面。\n\n4.在Vue修改数组中的某个元素一定要用如下方法：\n    1.使用这些API:push()、pop()、shift()、unshift()、splice()、sort()、reverse()\n    2.Vue.set() 或 vm.$set()\n\n特别注意：Vue.set() 和 vm.$set() 不能给vm 或 vm的根数据对象 添加属性！！！\n</code></pre>\n<h2 id=\"15：Vue获取dom元素节点并操作元素的样式\"><a href=\"#15：Vue获取dom元素节点并操作元素的样式\" class=\"headerlink\" title=\"15：Vue获取dom元素节点并操作元素的样式\"></a>15：Vue获取dom元素节点并操作元素的样式</h2><pre><code class=\"javascript\">$refs 获取的是组件对象\n$el 获取的是dom节点\n\n1.获取到元素节点(这里通过this.$refs获取元素节点)\nthis.$refs.xxxxx.$el\n2.操作元素的样式\nthis.$refs.num1Underline.$el.style.transform = &#39;scaleX(1)&#39;\n\n这种方法需要注意的是$el 用于获取vue挂载的实例的dom对象，如果不添加$el则获取不到style的属性值，会打印 TypeError: Cannot read property &#39;style&#39; of undefined 错误，这个错误大家一定都很熟悉，是类型错误，没有访问到dom元素\n</code></pre>\n<h2 id=\"16：forceUpdate\"><a href=\"#16：forceUpdate\" class=\"headerlink\" title=\"16：forceUpdate\"></a>16：forceUpdate</h2><pre><code class=\"javascript\">//数据更新后，组件没更新。使用这个方法强制刷新组件\nthis.$forceUpdate();\n</code></pre>\n<h2 id=\"17：mixin-混入\"><a href=\"#17：mixin-混入\" class=\"headerlink\" title=\"17：mixin(混入)\"></a>17：mixin(混入)</h2><pre><code class=\"javascript\">1. 功能：可以把多个组件共用的配置提取成一个混入对象\n\n2. 使用方式：\n\n   第一步定义混合：\n</code></pre>\n<p>   {<br>       data(){….},<br>       methods:{….}<br>       ….<br>   }</p>\n<pre><code>\n第二步使用混入：\n\n​\t全局混入：```Vue.mixin(xxx)```\n​\t局部混入：```mixins:[&#39;xxx&#39;]\t```\n</code></pre>\n<h2 id=\"18：插件\"><a href=\"#18：插件\" class=\"headerlink\" title=\"18：插件\"></a>18：插件</h2><pre><code class=\"javascript\">1. 功能：用于增强Vue\n\n2. 本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据。\n\n3. 定义插件：\n   对象.install = function (Vue, options) &#123;\n       // 1. 添加全局过滤器\n       Vue.filter(....)\n   \n       // 2. 添加全局指令\n       Vue.directive(....)\n   \n       // 3. 配置全局混入(合)\n       Vue.mixin(....)\n   \n       // 4. 添加实例方法\n       Vue.prototype.$myMethod = function () &#123;...&#125;\n       Vue.prototype.$myProperty = xxxx\n   &#125;\n\n4. 使用插件：Vue.use()\n</code></pre>\n<h2 id=\"19：插槽\"><a href=\"#19：插槽\" class=\"headerlink\" title=\"19：插槽\"></a>19：插槽</h2><ol>\n<li><p>作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 <strong style=\"color:red\">父组件 &#x3D;&#x3D;&#x3D;&gt; 子组件</strong> 。</p>\n</li>\n<li><p>分类：默认插槽、具名插槽、作用域插槽</p>\n</li>\n<li><p>使用方式：</p>\n<ol>\n<li><p>默认插槽：</p>\n<pre><code class=\"vue\">父组件中：\n        &lt;Category&gt;\n           &lt;div&gt;html结构1&lt;/div&gt;\n        &lt;/Category&gt;\n子组件中：\n        &lt;template&gt;\n            &lt;div&gt;\n               &lt;!-- 定义插槽 --&gt;\n               &lt;slot&gt;插槽默认内容...&lt;/slot&gt;\n            &lt;/div&gt;\n        &lt;/template&gt;\n</code></pre>\n</li>\n<li><p>具名插槽：</p>\n<pre><code class=\"vue\">父组件中：\n        &lt;Category&gt;\n            &lt;template slot=&quot;center&quot;&gt;\n              &lt;div&gt;html结构1&lt;/div&gt;\n            &lt;/template&gt;\n\n            &lt;template v-slot:footer&gt;\n               &lt;div&gt;html结构2&lt;/div&gt;\n            &lt;/template&gt;\n        &lt;/Category&gt;\n子组件中：\n        &lt;template&gt;\n            &lt;div&gt;\n               &lt;!-- 定义插槽 --&gt;\n               &lt;slot name=&quot;center&quot;&gt;插槽默认内容...&lt;/slot&gt;\n               &lt;slot name=&quot;footer&quot;&gt;插槽默认内容...&lt;/slot&gt;\n            &lt;/div&gt;\n        &lt;/template&gt;\n</code></pre>\n</li>\n<li><p>作用域插槽：</p>\n<ol>\n<li><p>理解：<span style=\"color:red\">数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。</span>（games数据在Category组件中，但使用数据所遍历出来的结构由App组件决定）</p>\n</li>\n<li><p>具体编码：</p>\n<pre><code class=\"vue\">父组件中：\n        &lt;Category&gt;\n            &lt;template scope=&quot;scopeData&quot;&gt;\n                &lt;!-- 生成的是ul列表 --&gt;\n                &lt;ul&gt;\n                    &lt;li v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/li&gt;\n                &lt;/ul&gt;\n            &lt;/template&gt;\n        &lt;/Category&gt;\n\n        &lt;Category&gt;\n            &lt;template slot-scope=&quot;scopeData&quot;&gt;\n                &lt;!-- 生成的是h4标题 --&gt;\n                &lt;h4 v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/h4&gt;\n            &lt;/template&gt;\n        &lt;/Category&gt;\n子组件中：\n        &lt;template&gt;\n            &lt;div&gt;\n                &lt;slot :games=&quot;games&quot;&gt;&lt;/slot&gt;\n            &lt;/div&gt;\n        &lt;/template&gt;\n        \n        &lt;script&gt;\n            export default &#123;\n                name:&#39;Category&#39;,\n                props:[&#39;title&#39;],\n                //数据在子组件自身\n                data() &#123;\n                    return &#123;\n                        games:[&#39;红色警戒&#39;,&#39;穿越火线&#39;,&#39;劲舞团&#39;,&#39;超级玛丽&#39;]\n                    &#125;\n                &#125;,\n            &#125;\n        &lt;/script&gt;\n</code></pre>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"20-vue-生命周期执行顺序-父子组件\"><a href=\"#20-vue-生命周期执行顺序-父子组件\" class=\"headerlink\" title=\"20: vue 生命周期执行顺序(父子组件)\"></a>20: vue 生命周期执行顺序(父子组件)</h2><pre><code class=\"javascript\">1.加载渲染过程：\n父beforecreate -&gt; 父created -&gt; 父beforemount -&gt; 父mounted -&gt; 子created -&gt; 子beforemount\n-&gt;  子mounted -&gt; 父mounted\n\n2.子组件更新过程：\n父beforeUpdate -&gt; 子beforeUpdate -&gt; 子updated -&gt; 父updated\n\n3.父组件更新过程：\n父beforeUpdate -&gt; 父updated\n\n4.销毁过程：\n父beforedestroy -&gt; 子beforedestroy -&gt; 子destroy  -&gt; 父destroy \n\n\n\n页面第一次加在会触发beforecreate，created，beforemount，mounted。\n\n 拓展:如果有缓存keep-alive。那么还会触发actived钩子，退出时触发deactived。后续再进入只会触发actived钩子了。所以说频繁触发的函数放在active里面，执行一次的放在mounted里面。\n\n父子组件生命周期的触发顺序是:参考洋葱模型。\n\n先是父组件的生命周期beforecreate，created，beforemount，子组件beforecreate，created，beforemount，子组件的mounted，父组件的mounted。因为要再父组件渲染前把子组件的数据渲染到父组件里面，所以在父组件dom挂载前mounted渲染前，先加载子组件的生命周期。\n\n</code></pre>\n<h2 id=\"21-谈谈你对-keep-alive-的了解？\"><a href=\"#21-谈谈你对-keep-alive-的了解？\" class=\"headerlink\" title=\"21. 谈谈你对 keep-alive 的了解？\"></a>21. 谈谈你对 keep-alive 的了解？</h2><pre><code class=\"javascript\">keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性：\n\n一般结合路由和动态组件一起使用，用于缓存组件；\n提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；\n对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。\n</code></pre>\n<h1 id=\"二：Vue-Router\"><a href=\"#二：Vue-Router\" class=\"headerlink\" title=\"二：Vue-Router\"></a>二：Vue-Router</h1><h2 id=\"1-基本使用\"><a href=\"#1-基本使用\" class=\"headerlink\" title=\"1.基本使用\"></a>1.基本使用</h2><ol>\n<li><p>安装vue-router，命令：<code>npm i vue-router</code></p>\n</li>\n<li><p>应用插件：<code>Vue.use(VueRouter)</code></p>\n</li>\n<li><p>编写router配置项:</p>\n<pre><code class=\"js\">//引入VueRouter\nimport VueRouter from &#39;vue-router&#39;\n//引入Luyou 组件\nimport About from &#39;../components/About&#39;\nimport Home from &#39;../components/Home&#39;\n\n//创建router实例对象，去管理一组一组的路由规则\nconst router = new VueRouter(&#123;\n    routes:[\n        &#123;\n            path:&#39;/about&#39;,\n            component:About\n        &#125;,\n        &#123;\n            path:&#39;/home&#39;,\n            component:Home\n        &#125;\n    ]\n&#125;)\n\n//暴露router\nexport default router\n</code></pre>\n</li>\n<li><p>实现切换（active-class可配置高亮样式）</p>\n<pre><code class=\"vue\">&lt;router-link active-class=&quot;active&quot; to=&quot;/about&quot;&gt;About&lt;/router-link&gt;\n</code></pre>\n</li>\n<li><p>指定展示位置</p>\n<pre><code class=\"vue\">&lt;router-view&gt;&lt;/router-view&gt;\n</code></pre>\n</li>\n</ol>\n<h2 id=\"2-几个注意点\"><a href=\"#2-几个注意点\" class=\"headerlink\" title=\"2.几个注意点\"></a>2.几个注意点</h2><ol>\n<li>路由组件通常存放在<code>pages</code>文件夹，一般组件通常存放在<code>components</code>文件夹。</li>\n<li>通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。</li>\n<li>每个组件都有自己的<code>$route</code>属性，里面存储着自己的路由信息。</li>\n<li>整个应用只有一个router，可以通过组件的<code>$router</code>属性获取到。</li>\n</ol>\n<h2 id=\"3-多级路由（多级路由）\"><a href=\"#3-多级路由（多级路由）\" class=\"headerlink\" title=\"3.多级路由（多级路由）\"></a>3.多级路由（多级路由）</h2><ol>\n<li><p>配置路由规则，使用children配置项：</p>\n<pre><code class=\"js\">routes:[\n    &#123;\n        path:&#39;/about&#39;,\n        component:About,\n    &#125;,\n    &#123;\n        path:&#39;/home&#39;,\n        component:Home,\n        children:[ //通过children配置子级路由\n            &#123;\n                path:&#39;news&#39;, //此处一定不要写：/news\n                component:News\n            &#125;,\n            &#123;\n                path:&#39;message&#39;,//此处一定不要写：/message\n                component:Message\n            &#125;\n        ]\n    &#125;\n]\n</code></pre>\n</li>\n<li><p>跳转（要写完整路径）：</p>\n<pre><code class=\"vue\">&lt;router-link to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt;\n</code></pre>\n</li>\n</ol>\n<h2 id=\"4-路由的query参数\"><a href=\"#4-路由的query参数\" class=\"headerlink\" title=\"4.路由的query参数\"></a>4.路由的query参数</h2><ol>\n<li><p>传递参数</p>\n<pre><code class=\"vue\">&lt;!-- 跳转并携带query参数，to的字符串写法 --&gt;\n&lt;router-link :to=&quot;/home/message/detail?id=666&amp;title=你好&quot;&gt;跳转&lt;/router-link&gt;\n                \n&lt;!-- 跳转并携带query参数，to的对象写法 --&gt;\n&lt;router-link \n    :to=&quot;&#123;\n        path:&#39;/home/message/detail&#39;,\n        query:&#123;\n           id:666,\n            title:&#39;你好&#39;\n        &#125;\n    &#125;&quot;\n&gt;跳转&lt;/router-link&gt;\n</code></pre>\n</li>\n<li><p>接收参数：</p>\n<pre><code class=\"js\">$route.query.id\n$route.query.title\n</code></pre>\n</li>\n</ol>\n<h2 id=\"5-命名路由\"><a href=\"#5-命名路由\" class=\"headerlink\" title=\"5.命名路由\"></a>5.命名路由</h2><ol>\n<li><p>作用：可以简化路由的跳转。</p>\n</li>\n<li><p>如何使用</p>\n<ol>\n<li><p>给路由命名：</p>\n<pre><code class=\"js\">&#123;\n    path:&#39;/demo&#39;,\n    component:Demo,\n    children:[\n        &#123;\n            path:&#39;test&#39;,\n            component:Test,\n            children:[\n                &#123;\n                    name:&#39;hello&#39; //给路由命名\n                    path:&#39;welcome&#39;,\n                    component:Hello,\n                &#125;\n            ]\n        &#125;\n    ]\n&#125;\n</code></pre>\n</li>\n<li><p>简化跳转：</p>\n<pre><code class=\"vue\">&lt;!--简化前，需要写完整的路径 --&gt;\n&lt;router-link to=&quot;/demo/test/welcome&quot;&gt;跳转&lt;/router-link&gt;\n\n&lt;!--简化后，直接通过名字跳转 --&gt;\n&lt;router-link :to=&quot;&#123;name:&#39;hello&#39;&#125;&quot;&gt;跳转&lt;/router-link&gt;\n\n&lt;!--简化写法配合传递参数 --&gt;\n&lt;router-link \n    :to=&quot;&#123;\n        name:&#39;hello&#39;,\n        query:&#123;\n           id:666,\n            title:&#39;你好&#39;\n        &#125;\n    &#125;&quot;\n&gt;跳转&lt;/router-link&gt;\n</code></pre>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"6-路由的params参数\"><a href=\"#6-路由的params参数\" class=\"headerlink\" title=\"6.路由的params参数\"></a>6.路由的params参数</h2><ol>\n<li><p>配置路由，声明接收params参数</p>\n<pre><code class=\"js\">&#123;\n    path:&#39;/home&#39;,\n    component:Home,\n    children:[\n        &#123;\n            path:&#39;news&#39;,\n            component:News\n        &#125;,\n        &#123;\n            component:Message,\n            children:[\n                &#123;\n                    name:&#39;xiangqing&#39;,\n                    path:&#39;detail/:id/:title&#39;, //使用占位符声明接收params参数\n                    component:Detail\n                &#125;\n            ]\n        &#125;\n    ]\n&#125;\n</code></pre>\n</li>\n<li><p>传递参数</p>\n<pre><code class=\"vue\">&lt;!-- 跳转并携带params参数，to的字符串写法 --&gt;\n&lt;router-link :to=&quot;/home/message/detail/666/你好&quot;&gt;跳转&lt;/router-link&gt;\n                \n&lt;!-- 跳转并携带params参数，to的对象写法 --&gt;\n&lt;router-link \n    :to=&quot;&#123;\n        name:&#39;xiangqing&#39;,\n        params:&#123;\n           id:666,\n            title:&#39;你好&#39;\n        &#125;\n    &#125;&quot;\n&gt;跳转&lt;/router-link&gt;\n</code></pre>\n<blockquote>\n<p>特别注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置！</p>\n</blockquote>\n</li>\n<li><p>接收参数：</p>\n<pre><code class=\"js\">$route.params.id\n$route.params.title\n</code></pre>\n</li>\n</ol>\n<h2 id=\"7-路由的props配置\"><a href=\"#7-路由的props配置\" class=\"headerlink\" title=\"7.路由的props配置\"></a>7.路由的props配置</h2><p>​\t作用：让路由组件更方便的收到参数</p>\n<pre><code class=\"js\">&#123;\n    name:&#39;xiangqing&#39;,\n    path:&#39;detail/:id&#39;,\n    component:Detail,\n\n    //第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件\n    // props:&#123;a:900&#125;\n\n    //第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件\n    // props:true\n    \n    //第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件\n    props(route)&#123;\n        return &#123;\n            id:route.query.id,\n            title:route.query.title\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"8-lt-router-link-gt-的replace属性\"><a href=\"#8-lt-router-link-gt-的replace属性\" class=\"headerlink\" title=\"8.&lt;router-link&gt;的replace属性\"></a>8.<code>&lt;router-link&gt;</code>的replace属性</h2><ol>\n<li>作用：控制路由跳转时操作浏览器历史记录的模式</li>\n<li>浏览器的历史记录有两种写入方式：分别为<code>push</code>和<code>replace</code>，<code>push</code>是追加历史记录，<code>replace</code>是替换当前记录。路由跳转时候默认为<code>push</code></li>\n<li>如何开启<code>replace</code>模式：<code>&lt;router-link replace .......&gt;News&lt;/router-link&gt;</code></li>\n</ol>\n<h2 id=\"9-编程式路由导航\"><a href=\"#9-编程式路由导航\" class=\"headerlink\" title=\"9.编程式路由导航\"></a>9.编程式路由导航</h2><ol>\n<li><p>作用：不借助<code>&lt;router-link&gt; </code>实现路由跳转，让路由跳转更加灵活</p>\n</li>\n<li><p>具体编码：</p>\n<pre><code class=\"js\">//$router的两个API\nthis.$router.push(&#123;\n    name:&#39;xiangqing&#39;,\n        params:&#123;\n            id:xxx,\n            title:xxx\n        &#125;\n&#125;)\n\nthis.$router.replace(&#123;\n    name:&#39;xiangqing&#39;,\n        params:&#123;\n            id:xxx,\n            title:xxx\n        &#125;\n&#125;)\nthis.$router.forward() //前进\nthis.$router.back() //后退\nthis.$router.go() //可前进也可后退\n</code></pre>\n</li>\n</ol>\n<h2 id=\"10-缓存路由组件\"><a href=\"#10-缓存路由组件\" class=\"headerlink\" title=\"10.缓存路由组件\"></a>10.缓存路由组件</h2><ol>\n<li><p>作用：让不展示的路由组件保持挂载，不被销毁。</p>\n</li>\n<li><p>具体编码：</p>\n<pre><code class=\"vue\">&lt;keep-alive include=&quot;News&quot;&gt; \n    &lt;router-view&gt;&lt;/router-view&gt;\n&lt;/keep-alive&gt;\n</code></pre>\n</li>\n</ol>\n<h2 id=\"11-两个新的生命周期钩子\"><a href=\"#11-两个新的生命周期钩子\" class=\"headerlink\" title=\"11.两个新的生命周期钩子\"></a>11.两个新的生命周期钩子</h2><ol>\n<li><p>作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态。</p>\n</li>\n<li><p>具体名字：</p>\n<ol>\n<li><code>activated</code>路由组件被激活时触发。</li>\n<li><code>deactivated</code>路由组件失活时触发。</li>\n</ol>\n<p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。</p>\n<pre><code class=\"javascript\">&lt;keep-alive&gt;\n  &lt;component&gt;\n    &lt;!-- 该组件将被缓存！ --&gt;\n  &lt;/component&gt;\n&lt;/keep-alive&gt;\n如果只想 router-view 里面某个组件被缓存\n\n\nexport default [\n  &#123;\n    path: &#39;/&#39;,\n    name: &#39;home&#39;,\n    component: Home,\n    meta: &#123;\n      keepAlive: true // 需要被缓存\n    &#125;\n  &#125;, &#123;\n    path: &#39;/:id&#39;,\n    name: &#39;edit&#39;,\n    component: Edit,\n    meta: &#123;\n      keepAlive: false // 不需要被缓存\n    &#125;\n  &#125;\n]\n&lt;keep-alive&gt;\n    &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;\n        &lt;!-- 这里是会被缓存的视图组件，比如 Home！ --&gt;\n    &lt;/router-view&gt;\n&lt;/keep-alive&gt;\n \n&lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;\n    &lt;!-- 这里是不被缓存的视图组件，比如 Edit！ --&gt;\n&lt;/router-view&gt;\n</code></pre>\n</li>\n</ol>\n<h2 id=\"12-路由守卫\"><a href=\"#12-路由守卫\" class=\"headerlink\" title=\"12.路由守卫\"></a>12.路由守卫</h2><ol>\n<li><p>作用：对路由进行权限控制</p>\n</li>\n<li><p>分类：全局守卫、独享守卫、组件内守卫</p>\n</li>\n<li><p>全局守卫:</p>\n<pre><code class=\"js\">//全局前置守卫：初始化时执行、每次路由切换前执行\nrouter.beforeEach((to,from,next)=&gt;&#123;\n    console.log(&#39;beforeEach&#39;,to,from)\n    if(to.meta.isAuth)&#123; //判断当前路由是否需要进行权限控制\n        if(localStorage.getItem(&#39;school&#39;) === &#39;atguigu&#39;)&#123; //权限控制的具体规则\n            next() //放行\n        &#125;else&#123;\n            alert(&#39;暂无权限查看&#39;)\n            // next(&#123;name:&#39;guanyu&#39;&#125;)\n        &#125;\n    &#125;else&#123;\n        next() //放行\n    &#125;\n&#125;)\n\n//全局后置守卫：初始化时执行、每次路由切换后执行\nrouter.afterEach((to,from)=&gt;&#123;\n    console.log(&#39;afterEach&#39;,to,from)\n    if(to.meta.title)&#123; \n        document.title = to.meta.title //修改网页的title\n    &#125;else&#123;\n        document.title = &#39;vue_test&#39;\n    &#125;\n&#125;)\n</code></pre>\n</li>\n<li><p>独享守卫:</p>\n<pre><code class=\"js\">beforeEnter(to,from,next)&#123;\n    console.log(&#39;beforeEnter&#39;,to,from)\n    if(to.meta.isAuth)&#123; //判断当前路由是否需要进行权限控制\n        if(localStorage.getItem(&#39;school&#39;) === &#39;atguigu&#39;)&#123;\n            next()\n        &#125;else&#123;\n            alert(&#39;暂无权限查看&#39;)\n            // next(&#123;name:&#39;guanyu&#39;&#125;)\n        &#125;\n    &#125;else&#123;\n        next()\n    &#125;\n&#125;\n</code></pre>\n</li>\n<li><p>组件内守卫：</p>\n<pre><code class=\"js\">//进入守卫：通过路由规则，进入该组件时被调用\nbeforeRouteEnter (to, from, next) &#123;\n&#125;,\n//离开守卫：通过路由规则，离开该组件时被调用\nbeforeRouteLeave (to, from, next) &#123;\n&#125;\n</code></pre>\n</li>\n</ol>\n<h2 id=\"13-vue-router实现路由懒加载（-动态加载路由-）\"><a href=\"#13-vue-router实现路由懒加载（-动态加载路由-）\" class=\"headerlink\" title=\"13.vue-router实现路由懒加载（ 动态加载路由 ）\"></a>13.vue-router实现路由懒加载（ 动态加载路由 ）</h2><pre><code class=\"javascript\">import Vue from &#39;vue&#39;\nimport VueRouter from &#39;vue-router&#39;\n\nVue.use(VueRouter)\n\nconst routes = [\n  &#123;\n    path: &#39;/&#39;,\n    name: &#39;Home&#39;,\n    component: () =&gt; import( &#39;../views/Home.vue&#39;)   //使用import的方式导入组件\n  &#125;,\n  &#123;\n    path: &#39;/about&#39;,\n    name: &#39;About&#39;,\n    component: () =&gt; import( &#39;../views/About.vue&#39;)\n  &#125;\n]\n\nconst router = new VueRouter(&#123;\n  mode: &#39;history&#39;,\n  base: process.env.BASE_URL,\n  routes\n&#125;)\n\nexport default router\n</code></pre>\n<h2 id=\"14-vue-router如何响应-路由参数-的变化？\"><a href=\"#14-vue-router如何响应-路由参数-的变化？\" class=\"headerlink\" title=\"14.vue-router如何响应 路由参数 的变化？\"></a>14.vue-router如何响应 路由参数 的变化？</h2><p><strong>原来的组件实例会被复用。这也意味着组件的生命周期钩子不会再被调用。你可以简单地 watch (监测变化) $route 对象：</strong></p>\n<pre><code class=\"js\">const User = &#123;\n  template: &#39;...&#39;,\n  watch: &#123;\n    &#39;$route&#39; (to, from) &#123;\n      // 对路由变化作出响应...\n    &#125;\n  &#125;\n&#125;\n</code></pre>\n<h2 id=\"15-route和-router的区别是什么\"><a href=\"#15-route和-router的区别是什么\" class=\"headerlink\" title=\"15.$route和$router的区别是什么\"></a>15.$route和$router的区别是什么</h2><pre><code class=\"javascript\">$route为当前router跳转当前路由组件里可获取name、path、query、params等\n\n$router为VueRouter实例，想要导航到不同URL，则使用$router.push方法\n</code></pre>\n<h2 id=\"16-hash和history的区别\"><a href=\"#16-hash和history的区别\" class=\"headerlink\" title=\"16.hash和history的区别\"></a>16.hash和history的区别</h2><ol>\n<li><p>对于一个url来说，什么是hash值？—— #及其后面的内容就是hash值。</p>\n</li>\n<li><p>hash值不会包含在 HTTP 请求中，即：hash值不会带给服务器。</p>\n</li>\n<li><p>hash模式：</p>\n<ol>\n<li>地址中永远带着#号，不美观 。</li>\n<li>若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。</li>\n<li>兼容性较好。</li>\n</ol>\n</li>\n<li><p>history模式：</p>\n<ol>\n<li>地址干净，美观 。</li>\n<li>兼容性和hash模式相比略差。</li>\n<li>应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"17-路由鉴权\"><a href=\"#17-路由鉴权\" class=\"headerlink\" title=\"17.路由鉴权\"></a>17.路由鉴权</h2><h2 id=\"18-vue-router-路由模式有几种？\"><a href=\"#18-vue-router-路由模式有几种？\" class=\"headerlink\" title=\"18.vue-router 路由模式有几种？\"></a>18.vue-router 路由模式有几种？</h2><pre><code class=\"javascript\">vue-router 有 3 种路由模式：hash、history、abstract，对应的源码如下所示：\n\nswitch (mode) &#123;\n  case &#39;history&#39;:\n    this.history = new HTML5History(this, options.base)\n    break\n  case &#39;hash&#39;:\n    this.history = new HashHistory(this, options.base, this.fallback)\n    break\n  case &#39;abstract&#39;:\n    this.history = new AbstractHistory(this, options.base)\n    break\n  default:\n    if (process.env.NODE_ENV !== &#39;production&#39;) &#123;\n      assert(false, `invalid mode: $&#123;mode&#125;`)\n    &#125;\n&#125;\n\n其中，3 种路由模式的说明如下：\n\nhash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器；\nhistory : 依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式；\nabstract : 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.\n</code></pre>\n<h2 id=\"19-能说下-vue-router-中常用的-hash-和-history-路由模式实现原理吗？\"><a href=\"#19-能说下-vue-router-中常用的-hash-和-history-路由模式实现原理吗？\" class=\"headerlink\" title=\"19. 能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？\"></a>19. 能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？</h2><pre><code class=\"javascript\">（1）hash 模式的实现原理\n早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 ‘#search’：\nhttps://www.word.com#search\nhash 路由模式的实现主要是基于下面几个特性：\n\nURL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送；\nhash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换；\n可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用 JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值；\n我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。\n\n\n（2）history 模式的实现原理\nHTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。\n唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示：\nwindow.history.pushState(null, null, path);\nwindow.history.replaceState(null, null, path);\nhistory 路由模式的实现主要基于存在下面几个特性：\n\npushState 和 repalceState 两个 API 来操作实现 URL 的变化 ；\n我们可以使用 popstate 事件来监听 url 的变化，从而对页面进行跳转（渲染）；\nhistory.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。\n</code></pre>\n<h1 id=\"三：Vuex\"><a href=\"#三：Vuex\" class=\"headerlink\" title=\"三：Vuex\"></a>三：Vuex</h1><h2 id=\"1-概念\"><a href=\"#1-概念\" class=\"headerlink\" title=\"1.概念\"></a>1.概念</h2><p>​\t\t在Vue中实现集中式状态（数据）管理的一个Vue插件，对vue应用中多个组件的共享状态进行集中式的管理（读&#x2F;写），也是一种组件间通信的方式，且适用于任意组件间通信。</p>\n<h2 id=\"2-何时使用？\"><a href=\"#2-何时使用？\" class=\"headerlink\" title=\"2.何时使用？\"></a>2.何时使用？</h2><p>​\t\t多个组件需要共享数据时，音乐播放、登录状态、加入购物车</p>\n<h2 id=\"3-搭建vuex环境\"><a href=\"#3-搭建vuex环境\" class=\"headerlink\" title=\"3.搭建vuex环境\"></a>3.搭建vuex环境</h2><ol>\n<li><p>创建文件：<code>src/store/index.js</code></p>\n<pre><code class=\"js\">//引入Vue核心库\nimport Vue from &#39;vue&#39;\n//引入Vuex\nimport Vuex from &#39;vuex&#39;\n//应用Vuex插件\nVue.use(Vuex)\n\n//准备actions对象——响应组件中用户的动作\nconst actions = &#123;&#125;\n//准备mutations对象——修改state中的数据\nconst mutations = &#123;&#125;\n//准备state对象——保存具体的数据\nconst state = &#123;&#125;\n\n//创建并暴露store\nexport default new Vuex.Store(&#123;\n    actions,\n    mutations,\n    state\n&#125;)\n</code></pre>\n</li>\n<li><p>在<code>main.js</code>中创建vm时传入<code>store</code>配置项</p>\n<pre><code class=\"js\">......\n//引入store\nimport store from &#39;./store&#39;\n......\n\n//创建vm\nnew Vue(&#123;\n    el:&#39;#app&#39;,\n    render: h =&gt; h(App),\n    store\n&#125;)\n</code></pre>\n</li>\n</ol>\n<h2 id=\"4-基本使用\"><a href=\"#4-基本使用\" class=\"headerlink\" title=\"4.基本使用\"></a>4.基本使用</h2><ol>\n<li><p>初始化数据、配置<code>actions</code>、配置<code>mutations</code>，操作文件<code>store.js</code></p>\n<pre><code class=\"js\">//引入Vue核心库\nimport Vue from &#39;vue&#39;\n//引入Vuex\nimport Vuex from &#39;vuex&#39;\n//引用Vuex\nVue.use(Vuex)\n\nconst actions = &#123;\n    //响应组件中加的动作\n    jia(context,value)&#123;\n        // console.log(&#39;actions中的jia被调用了&#39;,miniStore,value)\n        context.commit(&#39;JIA&#39;,value)\n    &#125;,\n&#125;\n\nconst mutations = &#123;\n    //执行加\n    JIA(state,value)&#123;\n        // console.log(&#39;mutations中的JIA被调用了&#39;,state,value)\n        state.sum += value\n    &#125;\n&#125;\n\n//初始化数据\nconst state = &#123;\n   sum:0\n&#125;\n\n//创建并暴露store\nexport default new Vuex.Store(&#123;\n    actions,\n    mutations,\n    state,\n&#125;)\n</code></pre>\n</li>\n<li><p>组件中读取vuex中的数据：<code>$store.state.sum</code></p>\n</li>\n<li><p>组件中修改vuex中的数据：<code>$store.dispatch(&#39;action中的方法名&#39;,数据)</code> 或 <code>$store.commit(&#39;mutations中的方法名&#39;,数据)</code></p>\n<blockquote>\n<p> 备注：若没有网络请求或其他业务逻辑，组件中也可以越过actions，即不写<code>dispatch</code>，直接编写<code>commit</code></p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"5-getters的使用\"><a href=\"#5-getters的使用\" class=\"headerlink\" title=\"5.getters的使用\"></a>5.getters的使用</h2><ol>\n<li><p>概念：当state中的数据需要经过加工后再使用时，可以使用getters加工。</p>\n</li>\n<li><p>在<code>store.js</code>中追加<code>getters</code>配置</p>\n<pre><code class=\"js\">......\n\nconst getters = &#123;\n    bigSum(state)&#123;\n        return state.sum * 10\n    &#125;\n&#125;\n\n//创建并暴露store\nexport default new Vuex.Store(&#123;\n    ......\n    getters\n&#125;)\n</code></pre>\n</li>\n<li><p>组件中读取数据：<code>$store.getters.bigSum</code></p>\n</li>\n</ol>\n<h2 id=\"6-四个map方法的使用\"><a href=\"#6-四个map方法的使用\" class=\"headerlink\" title=\"6.四个map方法的使用\"></a>6.四个map方法的使用</h2><ol>\n<li><p><strong>mapState方法：</strong>用于帮助我们映射<code>state</code>中的数据为计算属性</p>\n<pre><code class=\"js\">computed: &#123;\n    //借助mapState生成计算属性：sum、school、subject（对象写法）\n     ...mapState(&#123;sum:&#39;sum&#39;,school:&#39;school&#39;,subject:&#39;subject&#39;&#125;),\n         \n    //借助mapState生成计算属性：sum、school、subject（数组写法）\n    ...mapState([&#39;sum&#39;,&#39;school&#39;,&#39;subject&#39;]),\n&#125;,\n</code></pre>\n</li>\n<li><p><strong>mapGetters方法：</strong>用于帮助我们映射<code>getters</code>中的数据为计算属性</p>\n<pre><code class=\"js\">computed: &#123;\n    //借助mapGetters生成计算属性：bigSum（对象写法）\n    ...mapGetters(&#123;bigSum:&#39;bigSum&#39;&#125;),\n\n    //借助mapGetters生成计算属性：bigSum（数组写法）\n    ...mapGetters([&#39;bigSum&#39;])\n&#125;,\n</code></pre>\n</li>\n<li><p><strong>mapActions方法：</strong>用于帮助我们生成与<code>actions</code>对话的方法，即：包含<code>$store.dispatch(xxx)</code>的函数</p>\n<pre><code class=\"js\">methods:&#123;\n    //靠mapActions生成：incrementOdd、incrementWait（对象形式）\n    ...mapActions(&#123;incrementOdd:&#39;jiaOdd&#39;,incrementWait:&#39;jiaWait&#39;&#125;)\n\n    //靠mapActions生成：incrementOdd、incrementWait（数组形式）\n    ...mapActions([&#39;jiaOdd&#39;,&#39;jiaWait&#39;])\n&#125;\n</code></pre>\n</li>\n<li><p><strong>mapMutations方法：</strong>用于帮助我们生成与<code>mutations</code>对话的方法，即：包含<code>$store.commit(xxx)</code>的函数</p>\n<pre><code class=\"js\">methods:&#123;\n    //靠mapActions生成：increment、decrement（对象形式）\n    ...mapMutations(&#123;increment:&#39;JIA&#39;,decrement:&#39;JIAN&#39;&#125;),\n    \n    //靠mapMutations生成：JIA、JIAN（对象形式）\n    ...mapMutations([&#39;JIA&#39;,&#39;JIAN&#39;]),\n&#125;\n</code></pre>\n</li>\n</ol>\n<blockquote>\n<p>备注：mapActions与mapMutations使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象。</p>\n</blockquote>\n<h2 id=\"7-模块化-命名空间\"><a href=\"#7-模块化-命名空间\" class=\"headerlink\" title=\"7.模块化+命名空间\"></a>7.模块化+命名空间</h2><ol>\n<li><p>目的：让代码更好维护，让多种数据分类更加明确。</p>\n</li>\n<li><p>修改<code>store.js</code></p>\n<pre><code class=\"javascript\">const countAbout = &#123;\n  namespaced:true,//开启命名空间\n  state:&#123;x:1&#125;,\n  mutations: &#123; ... &#125;,\n  actions: &#123; ... &#125;,\n  getters: &#123;\n    bigSum(state)&#123;\n       return state.sum * 10\n    &#125;\n  &#125;\n&#125;\n\nconst personAbout = &#123;\n  namespaced:true,//开启命名空间\n  state:&#123; ... &#125;,\n  mutations: &#123; ... &#125;,\n  actions: &#123; ... &#125;\n&#125;\n\nconst store = new Vuex.Store(&#123;\n  modules: &#123;\n    countAbout,\n    personAbout\n  &#125;\n&#125;)\n</code></pre>\n</li>\n<li><p>开启命名空间后，组件中读取state数据：</p>\n<pre><code class=\"js\">//方式一：自己直接读取\nthis.$store.state.personAbout.list\n//方式二：借助mapState读取：\n...mapState(&#39;countAbout&#39;,[&#39;sum&#39;,&#39;school&#39;,&#39;subject&#39;]),\n</code></pre>\n</li>\n<li><p>开启命名空间后，组件中读取getters数据：</p>\n<pre><code class=\"js\">//方式一：自己直接读取\nthis.$store.getters[&#39;personAbout/firstPersonName&#39;]\n//方式二：借助mapGetters读取：\n...mapGetters(&#39;countAbout&#39;,[&#39;bigSum&#39;])\n</code></pre>\n</li>\n<li><p>开启命名空间后，组件中调用dispatch</p>\n<pre><code class=\"js\">//方式一：自己直接dispatch\nthis.$store.dispatch(&#39;personAbout/addPersonWang&#39;,person)\n//方式二：借助mapActions：\n...mapActions(&#39;countAbout&#39;,&#123;incrementOdd:&#39;jiaOdd&#39;,incrementWait:&#39;jiaWait&#39;&#125;)\n</code></pre>\n</li>\n<li><p>开启命名空间后，组件中调用commit</p>\n<pre><code class=\"js\">//方式一：自己直接commit\nthis.$store.commit(&#39;personAbout/ADD_PERSON&#39;,person)\n//方式二：借助mapMutations：\n...mapMutations(&#39;countAbout&#39;,&#123;increment:&#39;JIA&#39;,decrement:&#39;JIAN&#39;&#125;),\n</code></pre>\n</li>\n</ol>\n<h2 id=\"8：Vuex-state数据的双向绑定\"><a href=\"#8：Vuex-state数据的双向绑定\" class=\"headerlink\" title=\"8：Vuex state数据的双向绑定\"></a>8：Vuex state数据的双向绑定</h2><pre><code class=\"javascript\">// 在从组件的computed中\ncomputed: &#123;\n    user: &#123;\n        get() &#123;\n          return this.$store.state.user\n        &#125;,\n        set(v) &#123;\n          // 使用vuex中的mutations中定义好的方法来改变\n          this.$store.commit(&#39;USER&#39;, v)\n        &#125;\n    &#125;&lt;br&gt;&#125;&lt;br&gt;// 在组件中就可以使用\n     \n        \n        \n&lt;input v-modle=&quot;user&quot; /&gt;        \n</code></pre>\n<h2 id=\"9-相关文档-写的比较好的文档\"><a href=\"#9-相关文档-写的比较好的文档\" class=\"headerlink\" title=\"9.相关文档(写的比较好的文档)\"></a>9.相关文档(写的比较好的文档)</h2><pre><code class=\"javascript\">https://zhuanlan.zhihu.com/p/78981485\n</code></pre>\n<h2 id=\"10-简要概括vuex\"><a href=\"#10-简要概括vuex\" class=\"headerlink\" title=\"10.简要概括vuex\"></a>10.简要概括vuex</h2><pre><code class=\"javascript\">主要包括以下几个模块：\n\nState =&gt; 基本数据，定义了应用状态的数据结构，可以在这里设置默认的初始状态。\nGetter =&gt; 从基本数据派生的数据，允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。\nMutation =&gt; 是唯一更改 store 中状态的方法，且必须是同步函数。\nAction =&gt; 像一个装饰器，包裹mutations，使之可以异步。用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。\nModule =&gt; 模块化Vuex，允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。\n</code></pre>\n<h1 id=\"四：Vue中的开发经验\"><a href=\"#四：Vue中的开发经验\" class=\"headerlink\" title=\"四：Vue中的开发经验\"></a>四：Vue中的开发经验</h1><h2 id=\"1：搭建Vue脚手架（vue-cli）并创建一个项目\"><a href=\"#1：搭建Vue脚手架（vue-cli）并创建一个项目\" class=\"headerlink\" title=\"1：搭建Vue脚手架（vue-cli）并创建一个项目\"></a>1：搭建Vue脚手架（vue-cli）并创建一个项目</h2><pre><code class=\"javascript\">1.安装node.js环境\n      [官网下载地址](https://nodejs.org/en/download/)\n               一路安装完成后 打开cmd  \n               输入 node -v\n               输入 npm -v\n               如果能看到node和npm的版本号了，说明已经安装成功\n\n               \n               \n2.安装vue-cli\n               有npm和cnpm两种方式，网上都说cnpm好些，所以我也用的cnpm安装，\n               首先利用淘宝镜像安装cnpm      \n               npm install cnpm -g --registry=https://registry.npm.taobao.org       \n               安装完成\n               输入 cnpm -v\n  \n               \n               \n3.然后全局安装 vue-cli\n               输入指令 cnpm install -g vue-cli\n               这个命令只需要运行一次就可以了。安装上之后，以后就不用安装了。\n               查看vue版本号\n               vue -V    //注：V是大写字母V\n\n               如果提示“无法识别 ‘vue’ ” ，有可能是 npm 版本过低，需要手动更新npm的版本号，这也是上面说的为什么要保证npm版本号高的原因，npm的版本可以手动升级更新，没记错的话应该是               \n               npm install -g npm\n               \n \n               \n               \n4.使用vue-cli来创建一个基于 webpack 模板的新项目               \n               创建\n               cmd利用cd指令进入到保存项目的文件夹下，然后输入命令           \n               输入 vue init webpack\n\n5.安装项目所需要的依赖               \n                   进入新建的项目文件夹下，就是上头有一些文件的里面，输入命令\n                输入 指令 cnpm install\n\n6.运行项目\n               根据你package.json里的配置里的指令\n               一般情况下都是 npm run dev\n               \n7.打包资源上线\n               根据你package.json里的配置里的指令\n               一般情况下都是 npm run build\n                   \n8.具体创建项目 博客地址\n               https://www.cnblogs.com/coober/p/10875647.html\n               \n</code></pre>\n<h2 id=\"2：关于不同版本的Vue\"><a href=\"#2：关于不同版本的Vue\" class=\"headerlink\" title=\"2：关于不同版本的Vue\"></a>2：关于不同版本的Vue</h2><ol>\n<li>vue.js与vue.runtime.xxx.js的区别：<ol>\n<li>vue.js是完整版的Vue，包含：核心功能 + 模板解析器。</li>\n<li>vue.runtime.xxx.js是运行版的Vue，只包含：核心功能；没有模板解析器。</li>\n</ol>\n</li>\n<li>因为vue.runtime.xxx.js没有模板解析器，所以不能使用template这个配置项，需要使用render函数接收到的createElement函数去指定具体内容。</li>\n</ol>\n<h2 id=\"3：vue-config-js配置文件\"><a href=\"#3：vue-config-js配置文件\" class=\"headerlink\" title=\"3：vue.config.js配置文件\"></a>3：vue.config.js配置文件</h2><ol>\n<li>使用vue inspect &gt; output.js可以查看到Vue脚手架的默认配置。</li>\n<li>使用vue.config.js可以对脚手架进行个性化定制，详情见：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbGkudnVlanMub3JnL3po\">https://cli.vuejs.org/zh</span></li>\n</ol>\n<h2 id=\"2：vue中如何编写可复用的组件？\"><a href=\"#2：vue中如何编写可复用的组件？\" class=\"headerlink\" title=\"2：vue中如何编写可复用的组件？\"></a>2：vue中如何编写可复用的组件？</h2><p>①创建组件页面eg Toast.vue；<br>②用Vue.extend()扩展一个组件构造器,再通过实例化组件构造器,就可创造出可复用的组件<br>③将toast组件挂载到新创建的div上；<br>④把toast组件的dom添加到body里；<br>⑤修改优化达到动态控制页面显示文字跟显示时间；</p>\n<pre><code class=\"javascript\">\nimport Vue from &#39;vue&#39;; \nimport Toast from &#39;@/components/Toast&#39;;     //引入组件\nlet ToastConstructor  = Vue.extend(Toast) // 返回一个“扩展实例构造器”\n \nlet myToast = (text,duration)=&gt;&#123;\n    let toastDom = new ToastConstructor(&#123;\n        el:document.createElement(&#39;div&#39;)    //将toast组件挂载到新创建的div上\n    &#125;)\n    document.body.appendChild( toastDom.$el )   //把toast组件的dom添加到body里\n    \n    toastDom.text = text;\n    toastDom.duration = duration;\n \n    // 在指定 duration 之后让 toast消失\n    setTimeout(()=&gt;&#123;\n        toastDom.isShow = false;  \n    &#125;, toastDom.duration);\n&#125;\nexport default myToast;\n</code></pre>\n<p>点击查看 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTYzODQ1L2FydGljbGUvZGV0YWlscy83NzUyNDkzNA==\">https://blog.csdn.net/qq_38563845/article/details/77524934</span> </p>\n<h2 id=\"3：vue父组件向子组件传对象，不实时更新解决\"><a href=\"#3：vue父组件向子组件传对象，不实时更新解决\" class=\"headerlink\" title=\"3：vue父组件向子组件传对象，不实时更新解决\"></a>3：vue父组件向子组件传对象，不实时更新解决</h2><pre><code class=\"javascript\">思路1：就是让利用v-if的重新渲染机制\n\n1.首先考虑的就是手动刷了，给组件加个v-if=”someShow“;\n\n//  这是组件上写法 ：&lt;my-component v-if=&quot;someShow&quot;&gt;&lt;/my-component&gt;\n \n// 下边写在父组件的methods里\nrefesh:function()&#123;\n    this.someShow=false;\n    var _this=this;\n    this.$nextTick(function()&#123;\n        _this.someShow = true;\n    &#125;)\n  \n&#125;\n// $nextTick\n// $nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM  这样重新渲染就会是最新数据了\n\n\n\n\n思路2：利用watch监听\n\n在子组件中监听你要的数据，当然别监听对象，监听了不一定好使。亲测不好使，测过好使的，可以给我留言。\n\n\ndata:function()&#123;\n    return &#123;\n        title:&quot;&quot;,\n        content:&quot;&quot;,\n        btn:&quot;&quot;\n    &#125;\n&#125;,   \nmethods:&#123;\n        changeTitle:function()&#123;\n            this.title=this.listTitle;\n            // 这里的每次变化了就复制给组件上的变量，视图也就更改了\t\t\t\n        &#125;,\n        changeList:function()&#123;\n            this.content=this.listList;\n        &#125;,\n        changeBtn:function()&#123;\n            this.btn=this.listBtn;\n        &#125;\n    &#125;,\nwatch:&#123;\n        listTitle:&quot;changeTitle&quot;,\n        listList:&quot;changeList&quot;,\n        listBtn:&quot;changeBtn&quot;\n        // 冒号前边这个就是从父组件传过来的，后边的就是变化了的监听函数\n&#125;\n</code></pre>\n<h2 id=\"4：is的用法（用于动态组件且基于-DOM-内模板的限制来工作。）\"><a href=\"#4：is的用法（用于动态组件且基于-DOM-内模板的限制来工作。）\" class=\"headerlink\" title=\"4：is的用法（用于动态组件且基于 DOM 内模板的限制来工作。）\"></a>4：is的用法（用于动态组件且基于 DOM 内模板的限制来工作。）</h2><p><strong>is用来动态切换组件，DOM模板解析</strong></p>\n<pre><code class=\"js\">&lt;table&gt; &lt;tr is=&quot;my-row&quot;&gt;&lt;/tr&gt; &lt;/table&gt;\n</code></pre>\n<h2 id=\"5：vue脚手架配置代理\"><a href=\"#5：vue脚手架配置代理\" class=\"headerlink\" title=\"5：vue脚手架配置代理\"></a>5：vue脚手架配置代理</h2><h3 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h3><p>​\t在vue.config.js中添加如下配置：</p>\n<pre><code class=\"js\">devServer:&#123;\n  proxy:&quot;http://localhost:5000&quot;\n&#125;\n</code></pre>\n<p>说明：</p>\n<ol>\n<li>优点：配置简单，请求资源时直接发给前端（8080）即可。</li>\n<li>缺点：不能配置多个代理，不能灵活的控制请求是否走代理。</li>\n<li>工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器 （优先匹配前端资源）</li>\n</ol>\n<h3 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h3><p>​\t编写vue.config.js配置具体代理规则：</p>\n<pre><code class=\"js\">module.exports = &#123;\n    devServer: &#123;\n      proxy: &#123;\n      &#39;/api1&#39;: &#123;// 匹配所有以 &#39;/api1&#39;开头的请求路径\n        target: &#39;http://localhost:5000&#39;,// 代理目标的基础路径\n        changeOrigin: true,\n        pathRewrite: &#123;&#39;^/api1&#39;: &#39;&#39;&#125;\n      &#125;,\n      &#39;/api2&#39;: &#123;// 匹配所有以 &#39;/api2&#39;开头的请求路径\n        target: &#39;http://localhost:5001&#39;,// 代理目标的基础路径\n        changeOrigin: true,\n        pathRewrite: &#123;&#39;^/api2&#39;: &#39;&#39;&#125;\n      &#125;\n    &#125;\n  &#125;\n&#125;\n/*\n   changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000\n   changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:8080\n   changeOrigin默认值为true\n*/\n</code></pre>\n<p>说明：</p>\n<ol>\n<li>优点：可以配置多个代理，且可以灵活的控制请求是否走代理。</li>\n<li>缺点：配置略微繁琐，请求资源时必须加前缀。</li>\n</ol>\n<h1 id=\"五：Vue源码原理\"><a href=\"#五：Vue源码原理\" class=\"headerlink\" title=\"五：Vue源码原理\"></a>五：Vue源码原理</h1><h2 id=\"1：vue-js2-x的两个核心是什么-数据驱动、组件系统。\"><a href=\"#1：vue-js2-x的两个核心是什么-数据驱动、组件系统。\" class=\"headerlink\" title=\"1：vue.js2.x的两个核心是什么(数据驱动、组件系统。)\"></a>1：vue.js2.x的两个核心是什么(数据驱动、组件系统。)</h2><p>数据驱动:Object.defineProperty和存储器属性: getter和setter（所以只兼容IE9及以上版本），可称为基于依赖收集的观测机制,核心是VM，即ViewModel，保证数据和视图的一致性。</p>\n<pre><code class=\"javascript\">            let number = 18\n            let person = &#123;\n                name : &#39;jack&#39;,\n                sex : &#39;男&#39;\n            &#125;\n\n            Object.defineProperty(person,&#39;age&#39;,&#123;\n                // value : 18,\n                // enumerable : true, //控制熟悉是否可以枚举，默认值是false\n                // writable : true, //控制熟悉是否可以被修改，默认值是false\n                // configurable : true, //控制属性是否可以被删除,默认值是false\n\n                //当有人读取person的age属性时，get函数(getter)就会被调用,且返回值就是age的值\n                get()&#123;\n                    console.log(&#39;有人读取了age&#39;)\n                    return number\n                &#125;,\n\n                //当有人修改person的age属性时，set函数(setter)就会被调用,且会收到修改的具体值\n                set(value)&#123;\n                    console.log(`有人修改了age，值为:$&#123;value&#125;`)\n                    number = value\n                &#125;\n\n            &#125;)\n</code></pre>\n<p>组件系统:</p>\n<h2 id=\"2：VUE数据代理的原理\"><a href=\"#2：VUE数据代理的原理\" class=\"headerlink\" title=\"2：VUE数据代理的原理\"></a>2：VUE数据代理的原理</h2><pre><code class=\"javascript\">通过一个对象代理对另一个对象中的属性的操作(读写)\nlet obj = &#123;x:100&#125;\nlet obj2 = &#123;y:200&#125;\n\nObject.defineProperty(obj2,&#39;x&#39;,&#123;\n    get()&#123;\n        return obj.x\n    &#125;,\n    set()&#123;\n        obj.x = value\n    &#125;\n&#125;)\n\n\n1.Vue中的数据代理：\n    通过vm对象代理data对象中的数据(读/写)\n2.Vue中数据代理的好处：\n    更加方便的操作data中的数据\n3.基本原理\n    通过Object.defineProperty()把data对象中所有属性添加到vm上\n    为每一个添加到vm上的属性，都指定一个getter/setter\n    在getter/setter内部去操作(读/写)data中对应的属性\n</code></pre>\n<h2 id=\"3：Vue-组件中-data-为什么必须是函数\"><a href=\"#3：Vue-组件中-data-为什么必须是函数\" class=\"headerlink\" title=\"3：Vue 组件中 data 为什么必须是函数\"></a>3：Vue 组件中 data 为什么必须是函数</h2><p>vue组件中data值不能为对象，因为对象是引用类型，组件可能会被多个实例同时引用。<br>如果data值为对象，将导致多个实例共享一个对象，其中一个组件改变data属性值，其它实例也会受到影响。</p>\n<h2 id=\"4：Vue双向绑定的原理\"><a href=\"#4：Vue双向绑定的原理\" class=\"headerlink\" title=\"4：Vue双向绑定的原理\"></a>4：Vue双向绑定的原理</h2><pre><code class=\"javascript\">如果被问到 Vue 怎么实现数据双向绑定，大家肯定都会回答 通过 Object.defineProperty() 对数据进行劫持，但是 Object.defineProperty() 只能对属性进行数据劫持，不能对整个对象进行劫持。\n同理无法对数组进行劫持，但是我们在使用 Vue 框架中都知道，Vue 能检测到对象和数组（部分方法的操作）的变化，那它是怎么实现的呢？我们查看相关代码如下：\n\n  /**\n   * Observe a list of Array items.\n   */\n  observeArray (items: Array&lt;any&gt;) &#123;\n    for (let i = 0, l = items.length; i &lt; l; i++) &#123;\n      observe(items[i])  // observe 功能为监测数据的变化\n    &#125;\n  &#125;\n\n  /**\n   * 对属性进行递归遍历\n   */\n  let childOb = !shallow &amp;&amp; observe(val) // observe 功能为监测数据的变化\n\n  通过以上 Vue 源码部分查看，我们就能知道 Vue 框架是通过遍历数组 和递归遍历对象，从而达到利用 Object.defineProperty() 也能对对象和数组（部分方法的操作）进行监听。\n  \n</code></pre>\n<h2 id=\"5：Vue的diff算法（列表渲染key的作用和原理）\"><a href=\"#5：Vue的diff算法（列表渲染key的作用和原理）\" class=\"headerlink\" title=\"5：Vue的diff算法（列表渲染key的作用和原理）\"></a>5：Vue的diff算法（列表渲染key的作用和原理）</h2><pre><code class=\"javascript\">1.虚拟DOM中key的作用:\nkey是虚拟DOM对象的标识，当状态中的数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】\n随后，Vue进行【新的虚拟DOM】与【旧的虚拟DOM】的差异比较，比较规则如下\n\n2.对比规则:\n(1).旧虚拟DOM中找到了与新虚拟DOM相同的key:\n    1.若虚拟DOM中的内容没变，直接使用之前的真实DOM！\n    2.若虚拟DOM中的内容变了，则生成新的真实DOM，随后替换掉页面中之前的真实DOM\n(2).旧虚拟DOM中未找到与新虚拟DOM相同的key\n    1.创建新的真实DOM，随后渲染到页面\n\n3.用index作为key可能会引发的问题:\n    1.若对数据进行，逆序添加，逆序删除等破坏顺寻操作：\n        会产生没有必要的真实DOM更新 =&gt; 界面效果没问题，但是效率低\n    2.如果结构中还有包含输入类的DOM：\n        会产生错误DOM更新 =&gt; 界面有问题\n\n4.开发中如何选择key?:\n    1.最好使用每条数据的唯一标识作为key,比如id,手机号，身份证号，学号等唯一值\n    2.如果不存在对数据的逆序添加，逆序删除等破坏性顺序操作，仅用于渲染列表展示，使用index作为key是没问题的\n</code></pre>\n<h2 id=\"6：Vue是怎么检测数据的改变的原理\"><a href=\"#6：Vue是怎么检测数据的改变的原理\" class=\"headerlink\" title=\"6：Vue是怎么检测数据的改变的原理\"></a>6：Vue是怎么检测数据的改变的原理</h2><pre><code class=\"javascript\">let data = &#123;\n    name :&#39;jack&#39;,\n    age : 18\n&#125;\n\n//创建一个监视的实例对象，用于监视data中属性的变化\nconst obs = new Observer(data)\n\n//准备一个vm实例对象\nlet vm = &#123;&#125;\nvm._data = data = obs\n\nfunction Observer(obj)&#123;\n    //汇总对象中所有属性形成的数组\n    const keys = Object.keys(obj)\n    //遍历\n    keys.forEach((k)=&gt;&#123;\n        Object.defineProperty(this,k,&#123;\n            get()&#123;\n                return obj[k]\n            &#125;,\n            set(val)&#123;\n                console.log(`$&#123;k&#125;被改了，我要去解析模板了，生成虚拟DOM`)\n                obj[k] = val\n            &#125;\n        &#125;)\n    &#125;)\n&#125;  \n//自己实现的基本的原理，只是对第一层的基本数据类型进行检测。无法检测到里面的\n\nVue的底层对data中的对象数据检测进行了递归，所以都能检测到，\n数组里的对象数据没有检测\n</code></pre>\n<h2 id=\"7-v-model-的原理？\"><a href=\"#7-v-model-的原理？\" class=\"headerlink\" title=\"7. v-model 的原理？\"></a>7. v-model 的原理？</h2><h2 id=\"8-使用过-Vue-SSR-吗？说说-SSR？\"><a href=\"#8-使用过-Vue-SSR-吗？说说-SSR？\" class=\"headerlink\" title=\"8.使用过 Vue SSR 吗？说说 SSR？\"></a>8.使用过 Vue SSR 吗？说说 SSR？</h2><pre><code class=\"javascript\">Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记&quot;激活&quot;为客户端上完全可交互的应用程序。\n即：SSR大致的意思就是vue在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的html 片段直接返回给客户端这个过程就叫做服务端渲染。\n服务端渲染 SSR 的优缺点如下：\n\n（1）服务端渲染的优点：\n更好的 SEO：因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；\n更快的内容到达时间（首屏加载更快）：SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间；\n（2) 服务端渲染的缺点：\n更多的开发条件限制：例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；\n更多的服务器负载：在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。\n</code></pre>\n<h2 id=\"9-Vue-框架怎么实现对象和数组的监听？\"><a href=\"#9-Vue-框架怎么实现对象和数组的监听？\" class=\"headerlink\" title=\"9. Vue 框架怎么实现对象和数组的监听？\"></a>9. Vue 框架怎么实现对象和数组的监听？</h2><pre><code class=\"javascript\">Vue 数据双向绑定主要是指：数据变化更新视图，视图变化更新数据。\n即：\n\n输入框内容变化时，Data 中的数据同步变化。即 View =&gt; Data 的变化。\nData 中的数据变化时，文本节点的内容同步变化。即 Data =&gt; View 的变化。\n其中，View 变化更新 Data ，可以通过事件监听的方式来实现，所以 Vue 的数据双向绑定的工作主要是如何根据 Data 变化更新 View。\nVue 主要通过以下 4 个步骤来实现数据双向绑定的：\n\n实现一个监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。\n实现一个解析器 Compile：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。\n实现一个订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。\n实现一个订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。\n</code></pre>\n<h2 id=\"10-Vue-怎么用-vm-set-解决对象新增属性不能响应的问题-？\"><a href=\"#10-Vue-怎么用-vm-set-解决对象新增属性不能响应的问题-？\" class=\"headerlink\" title=\"10. Vue 怎么用 vm.$set() 解决对象新增属性不能响应的问题 ？\"></a>10. Vue 怎么用 vm.$set() 解决对象新增属性不能响应的问题 ？</h2><pre><code class=\"javascript\">受现代 JavaScript 的限制 ，Vue 无法检测到对象属性的添加或删除。\n由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。\n但是 Vue 提供了 Vue.set (object, propertyName, value) / vm.$set (object, propertyName, value)来实现为对象添加响应式属性，那框架本身是如何实现的呢？\n\n我们查看对应的 Vue 源码：vue/src/core/instance/index.js\n\nexport function set (target: Array&lt;any&gt; | Object, key: any, val: any): any &#123;\n  // target 为数组\n  if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;\n    // 修改数组的长度, 避免索引&gt;数组长度导致splcie()执行有误\n    target.length = Math.max(target.length, key)\n    // 利用数组的splice变异方法触发响应式\n    target.splice(key, 1, val)\n    return val\n  &#125;\n  // key 已经存在，直接修改属性值\n  if (key in target &amp;&amp; !(key in Object.prototype)) &#123;\n    target[key] = val\n    return val\n  &#125;\n  const ob = (target: any).__ob__\n  // target 本身就不是响应式数据, 直接赋值\n  if (!ob) &#123;\n    target[key] = val\n    return val\n  &#125;\n  // 对属性进行响应式处理\n  defineReactive(ob.value, key, val)\n  ob.dep.notify()\n  return val\n&#125;\n\n\n我们阅读以上源码可知，vm.$set 的实现原理是：\n\n如果目标是数组，直接使用数组的 splice 方法触发相应式；\n如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 defineReactive 方法进行响应式处理（ defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法）\n</code></pre>\n<h2 id=\"11-虚拟-DOM-的优缺点？\"><a href=\"#11-虚拟-DOM-的优缺点？\" class=\"headerlink\" title=\"11. 虚拟 DOM 的优缺点？\"></a>11. 虚拟 DOM 的优缺点？</h2><pre><code class=\"javascript\">优点：\n\n保证性能下限： 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；\n无需手动操作 DOM： 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；\n跨平台： 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。\n\n缺点:\n\n无法进行极致优化： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。\n</code></pre>\n<h2 id=\"12-虚拟-DOM-实现原理？\"><a href=\"#12-虚拟-DOM-实现原理？\" class=\"headerlink\" title=\"12. 虚拟 DOM 实现原理？\"></a>12. 虚拟 DOM 实现原理？</h2><pre><code class=\"javascript\">虚拟 DOM 的实现原理主要包括以下 3 部分：\n\n用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；\ndiff 算法 — 比较两棵虚拟 DOM 树的差异；\npach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。\n</code></pre>\n<h2 id=\"13-Vue-中的-key-有什么作用？\"><a href=\"#13-Vue-中的-key-有什么作用？\" class=\"headerlink\" title=\"13. Vue 中的 key 有什么作用？\"></a>13. Vue 中的 key 有什么作用？</h2><pre><code class=\"javascript\">key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速。\nVue 的 diff 过程可以概括为：oldCh 和 newCh 各有两个头尾的变量 oldStartIndex、oldEndIndex 和 newStartIndex、newEndIndex，它们会新节点和旧节点会进行两两对比，即一共有4种比较方式：newStartIndex 和oldStartIndex 、newEndIndex 和 oldEndIndex 、newStartIndex 和 oldEndIndex 、newEndIndex 和 oldStartIndex，如果以上 4 种比较都没匹配，如果设置了key，就会用 key 再进行比较，在比较的过程中，遍历会往中间靠，一旦 StartIdx &gt; EndIdx 表明 oldCh 和 newCh 至少有一个已经遍历完了，就会结束比较。\n所以 Vue 中 key 的作用是：key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速!\n\n更准确：因为带 key 就不是就地复用了，在 sameNode 函数 a.key === b.key 对比中可以避免就地复用的情况。所以会更加准确。\n更快速：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快，源码如下：\n\n\nfunction createKeyToOldIdx (children, beginIdx, endIdx) &#123;\n  let i, key\n  const map = &#123;&#125;\n  for (i = beginIdx; i &lt;= endIdx; ++i) &#123;\n    key = children[i].key\n    if (isDef(key)) map[key] = i\n  &#125;\n  return map\n&#125;\n</code></pre>\n<h2 id=\"14-你有对-Vue-项目进行哪些优化？\"><a href=\"#14-你有对-Vue-项目进行哪些优化？\" class=\"headerlink\" title=\"14. 你有对 Vue 项目进行哪些优化？\"></a>14. 你有对 Vue 项目进行哪些优化？</h2><pre><code class=\"javascript\">（1）代码层面的优化\n\nv-if 和 v-show 区分使用场景\ncomputed 和 watch 区分使用场景\nv-for 遍历必须为 item 添加 key，且避免同时使用 v-if\n长列表性能优化\n事件的销毁\n图片资源懒加载\n路由懒加载\n第三方插件的按需引入\n优化无限列表性能\n服务端渲染 SSR or 预渲染\n（2）Webpack 层面的优化\n\nWebpack 对图片进行压缩\n减少 ES6 转为 ES5 的冗余代码\n提取公共代码\n模板预编译\n提取组件的 CSS\n优化 SourceMap\n构建结果输出分析\nVue 项目的编译优化\n\n（3）基础的 Web 技术的优化\n\n开启 gzip 压缩\n浏览器缓存\nCDN 的使用\n使用 Chrome Performance 查找性能瓶颈\n</code></pre>\n<h2 id=\"15-对于-vue3-0-特性你有什么了解的吗？\"><a href=\"#15-对于-vue3-0-特性你有什么了解的吗？\" class=\"headerlink\" title=\"15. 对于 vue3.0 特性你有什么了解的吗？\"></a>15. 对于 vue3.0 特性你有什么了解的吗？</h2><pre><code class=\"javascript\">Vue 3.0 的目标是让 Vue 核心变得更小、更快、更强大，因此 Vue 3.0 增加以下这些新特性：\n\n（1）监测机制的改变\n3.0 将带来基于代理 Proxy 的 observer 实现，提供全语言覆盖的反应性跟踪。这消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制：\n\n只能监测属性，不能监测对象\n检测属性的添加和删除；\n检测数组索引和长度的变更；\n支持 Map、Set、WeakMap 和 WeakSet。\n新的 observer 还提供了以下特性：\n\n用于创建 observable 的公开 API。这为中小规模场景提供了简单轻量级的跨组件状态管理解决方案。\n默认采用惰性观察。在 2.x 中，不管反应式数据有多大，都会在启动时被观察到。如果你的数据集很大，这可能会在应用启动时带来明显的开销。在 3.x 中，只观察用于渲染应用程序最初可见部分的数据。\n更精确的变更通知。在 2.x 中，通过 Vue.set 强制添加新属性将导致依赖于该对象的 watcher 收到变更通知。在 3.x 中，只有依赖于特定属性的 watcher 才会收到通知。\n不可变的 observable：我们可以创建值的“不可变”版本（即使是嵌套属性），除非系统在内部暂时将其“解禁”。这个机制可用于冻结 prop 传递或 Vuex 状态树以外的变化。\n更好的调试功能：我们可以使用新的 renderTracked 和 renderTriggered 钩子精确地跟踪组件在什么时候以及为什么重新渲染。\n（2）模板\n模板方面没有大的变更，只改了作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。\n同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。\n\n（3）对象式的组件声明方式\nvue2.x 中的组件是通过声明的方式传入一系列 option，和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。\n3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易。\n此外，vue 的源码也改用了 TypeScript 来写。其实当代码的功能复杂之后，必须有一个静态类型系统来做一些辅助管理。\n现在 vue3.0 也全面改用 TypeScript 来重写了，更是使得对外暴露的 api 更容易结合 TypeScript。静态类型系统对于复杂代码的维护确实很有必要。\n\n（4）其它方面的更改\nvue3.0 的改变是全面的，上面只涉及到主要的 3 个方面，还有一些其他的更改：\n\n支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。\n支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。\n基于 treeshaking 优化，提供了更多的内置功能。\n</code></pre>\n<h2 id=\"16-响应式原理（变化侦测）\"><a href=\"#16-响应式原理（变化侦测）\" class=\"headerlink\" title=\"16. 响应式原理（变化侦测）\"></a>16. 响应式原理（变化侦测）</h2><p><strong>使用发布订阅模式将数据劫持和模板编译结合，实现双向绑定</strong></p>\n<pre><code class=\"javascript\">1、observer: 封装 Object.defineProperty 方法用来劫持对象属性的getter和setter，以此来追踪数据变化。\n\n2、读取数据时触发getter来收集依赖(Watcher)到Dep。\n3、修改数据时触发setter，并遍历依赖列表，通知所有相关依赖（Watcher）\n4、Dep 类为依赖找一个存储依赖的地方，用来收集和管理依赖，在getter中收集，在setter中通知。\n5、Watcher 类就是收集的依赖，实际上是一个订阅器，Watcher会将自己的实例赋值给window.target（全局变量）上，然后去主动访问属性，触发属性的getter，getter中会将此Watcher收集到Dep中，Watcher的update方法会在Dep的通知方法中被调用，触发更新。\n6、Observer 类用来将一个对象的所有属性和子属性都变成响应式的，通过递归调用defineReactive来实现。\n7、由于无法侦测对象上新增/删除属性，所以提供 $set 和 $delete API5。\n\n28. Object.defineProperty怎么用， 三个参数？，有什么作用啊？\nObject.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。\n\n\n\n   obj：需要定义属性的对象\n     prop：需要定义的属性\n     &#123;&#125;：要定义或修改的属性描述符。\n         value: &quot;18&quot;,         // 设置默认值 （与 get() 互斥）\n         enumerable: true,    //这一句控制属性可以枚举 enumerable 改为true 就可以参与遍历了   默认值false\n         writable: true,      // 该属性是否可写   默认值false （与 set() 互斥）\n         configurable: true,  // 该属性是否可被删除   默认值false\n          get // 当有人读取 prop 的时候  get函数就会调用,并且返回就是 sss 的值\n          set // 当有人修改 prop 的时候  set函数就会调用, 有个参数这个参数就是修改后的值\n</code></pre>\n<h2 id=\"17-vue2和vue3的响应式原理都有什么区别呢？\"><a href=\"#17-vue2和vue3的响应式原理都有什么区别呢？\" class=\"headerlink\" title=\"17. vue2和vue3的响应式原理都有什么区别呢？\"></a>17. vue2和vue3的响应式原理都有什么区别呢？</h2><pre><code class=\"javascript\">vue2 用的是 Object.defindProperty 但是vue3用的是Proxy\n\nObject.defindProperty 缺点：\n\n一次只能对一个属性进行监听，需要遍历来对所有属性监听\n对于对象的新增属性，需要手动监听\n对于数组通过push、unshift方法增加的元素，也无法监听\nProxy就没有这个问题，可以监听整个对象的数据变化，所以用vue3.0会用Proxy代替definedProperty。\n</code></pre>\n<h2 id=\"18-Vue-模板编译原理\"><a href=\"#18-Vue-模板编译原理\" class=\"headerlink\" title=\"18. Vue 模板编译原理\"></a>18. Vue 模板编译原理</h2><pre><code class=\"javascript\">模板字符串 转换成 element AST（解析器）\nVue-loader 切割解析 .vue 文件（parseHTML按标签以出栈入栈形式切割（自闭合不入栈直接处理），出栈时维护父子关系）生成 AST（抽象语法树）\n\n使用大量正则匹配开始结束标签，while指针定位解析位置，\n\n对 AST 进行静态节点标记，主要用来做虚拟DOM的渲染优化（优化器）\n在dom更新时不需 diff 静态节点。\n\n使用 element AST 生成 render 函数代码字符串（代码生成器）\nVue-template-compiler再解析成render（可执行函数字符串-with(this)=&gt;&#123;return _c(‘div’)&#125;），new Function 生成函数，传递给组件的 render\n\n在组件渲染的时候直接调用 render 即可\n</code></pre>\n<h2 id=\"19-Vue原理总结\"><a href=\"#19-Vue原理总结\" class=\"headerlink\" title=\"19. Vue原理总结\"></a>19. Vue原理总结</h2><pre><code class=\"javascript\">【模板编译】将template模板，经过编译系统后生成VNode，（模板字符串→AST→Render函数）\n\n【渲染】然后再通过渲染系统来将VNode生成真实DOM（document.createElement &amp;&amp; Mount挂载到真实DOM节点上）\n\n【响应式】通过响应式系统对数据进行监听，当数据发生改变时，触发依赖项（组件）\n\n【Diff &amp; Patch】组件内收到通知后，会通过diff算法对比VNode的变化，尽可能复用代码，找出最小差异，保证性能消耗最小。\n\n【渲染】拿到需要新增/删除/修改的VNode后，逐一去操作真实DOM进行修改（通过选择器选择到对应真实DOM节点进行修改）\n</code></pre>\n<h1 id=\"六：对Vue的理解\"><a href=\"#六：对Vue的理解\" class=\"headerlink\" title=\"六：对Vue的理解\"></a>六：对Vue的理解</h1><h2 id=\"1：谈谈对MVVM的理解\"><a href=\"#1：谈谈对MVVM的理解\" class=\"headerlink\" title=\"1：谈谈对MVVM的理解\"></a>1：谈谈对MVVM的理解</h2><p>M-model，model代表数据模型，也可以在model中定义数据修改和操作的业务逻辑</p>\n<p>V-view,view代表UI组件，它负责将数据模型转化为UI展现出来</p>\n<p>VM-viewmodel,viewmodel监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步view和model的对象，连接model和view</p>\n<h2 id=\"2：vue是渐进式的框架的理解：-主张最少-没有多做职责之外的事\"><a href=\"#2：vue是渐进式的框架的理解：-主张最少-没有多做职责之外的事\" class=\"headerlink\" title=\"2：vue是渐进式的框架的理解：(主张最少,没有多做职责之外的事)\"></a>2：vue是渐进式的框架的理解：(主张最少,没有多做职责之外的事)</h2><p>Vue的核心的功能，是一个视图模板引擎，但这不是说Vue就不能成为一个框架。如下图所示，这里包含了Vue的所有部件，在声明式渲染（视图模板引擎）的基础上，我们可以通过添加组件系统、客户端路由、大规模状态管理来构建一个完整的框架。更重要的是，这些功能相互独立，你可以在核心功能的基础上任意选用其他的部件，不一定要全部整合在一起。可以看到，所说的“渐进式”，其实就是Vue的使用方式，同时也体现了Vue的设计的理念<br>在我看来，渐进式代表的含义是：主张最少。视图模板引擎<br>每个框架都不可避免会有自己的一些特点，从而会对使用者有一定的要求，这些要求就是主张，主张有强有弱，它的强势程度会影响在业务开发中的使用方式。<br>比如说，Angular，它两个版本都是强主张的，如果你用它，必须接受以下东西：<br>必须使用它的模块机制- 必须使用它的依赖注入- 必须使用它的特殊形式定义组件（这一点每个视图框架都有，难以避免）<br>所以Angular是带有比较强的排它性的，如果你的应用不是从头开始，而是要不断考虑是否跟其他东西集成，这些主张会带来一些困扰。<br>Vue可能有些方面是不如React，不如Angular，但它是渐进的，没有强主张，你可以在原有大系统的上面，把一两个组件改用它实现，当jQuery用；也可以整个用它全家桶开发，当Angular用；还可以用它的视图，搭配你自己设计的整个下层用。也可以函数式，都可以，它只是个轻量视图而已，只做了自己该做的事，没有做不该做的事，仅此而已。<br><strong>渐进式的含义，我的理解是：没有多做职责之外的事。</strong></p>\n<h2 id=\"3：SPA-单页面应用及其优缺点\"><a href=\"#3：SPA-单页面应用及其优缺点\" class=\"headerlink\" title=\"3：SPA 单页面应用及其优缺点\"></a>3：SPA 单页面应用及其优缺点</h2><p><strong>缺点：</strong></p>\n<p>不支持低版本的浏览器，最低只支持到IE9；<br>不利于SEO的优化（如果要支持SEO，建议通过服务端来进行渲染组件）；<br>第一次加载首页耗时相对长一些；<br>不可以使用浏览器的导航按钮需要自行实现前进、后退。</p>\n<p><strong>优点：</strong></p>\n<p>无刷新体验,提升了用户体验；<br>前端开发不再以页面为单位，更多地采用组件化的思想，代码结构和组织方式更加规范化，便于修改和调整；<br>API 共享，同一套后端程序代码不用修改就可以用于Web界面、手机、平板等多种客户端<br>用户体验好、快，内容的改变不需要重新加载整个页面。</p>\n<h2 id=\"4：怎样理解-Vue-的单向数据流？\"><a href=\"#4：怎样理解-Vue-的单向数据流？\" class=\"headerlink\" title=\"4：怎样理解 Vue 的单向数据流？\"></a>4：怎样理解 Vue 的单向数据流？</h2><pre><code class=\"javascript\">所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。\n这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。\n额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。\n这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。\n子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。\n</code></pre>\n<h1 id=\"七：Vue3扩展\"><a href=\"#七：Vue3扩展\" class=\"headerlink\" title=\"七：Vue3扩展\"></a>七：Vue3扩展</h1><h2 id=\"1-VUE3简介\"><a href=\"#1-VUE3简介\" class=\"headerlink\" title=\"1.VUE3简介\"></a>1.VUE3简介</h2><ul>\n<li>2020年9月18日，Vue.js发布3.0版本，代号 One Piece(海贼王)</li>\n</ul>\n<h2 id=\"2-Vue3带来了什么\"><a href=\"#2-Vue3带来了什么\" class=\"headerlink\" title=\"2.Vue3带来了什么\"></a>2.Vue3带来了什么</h2><p>1.性能的提升</p>\n<pre><code class=\"javascript\">1.打包大小减少41%\n2.初次渲染快55%,更新渲染快33%\n3.内存减少54%   \n...    \n</code></pre>\n<p>2.源码的升级</p>\n<pre><code class=\"javascript\">使用Proxy代替defineProperty实现响应式\n重写虚拟DOM的实现和Tree-Shaking\n...\n</code></pre>\n<p>3.拥抱TypeScript</p>\n<pre><code class=\"javascript\">Vue3可以更好的支持TypeScript\n</code></pre>\n<p>4.新的特性</p>\n<pre><code class=\"javascript\">1.Composition API(组合API)\n    steup配置\n    ref与reactive\n    watch与watchEffect\n    provide与inject\n    ...\n2.新的内置组件\n    Fragment\n    Teleport\n    Suspense\n3.其他改变\n    新的生命周期钩子\n    data选项应始终被声明为一个函数\n    移除keyCode支持作为v-on的修饰符\n    ...\n</code></pre>\n<h2 id=\"3-创建Vue3-0工程\"><a href=\"#3-创建Vue3-0工程\" class=\"headerlink\" title=\"3.创建Vue3.0工程\"></a>3.创建Vue3.0工程</h2><h3 id=\"1-使用vue-cli创建\"><a href=\"#1-使用vue-cli创建\" class=\"headerlink\" title=\"1.使用vue-cli创建\"></a>1.使用vue-cli创建</h3><pre><code class=\"javascript\">## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上\nvue --version  或者 vue -V\n## 安装或者升级你的@vue/cli\nnpm install -g @vue/cli\n## 创建\nvue create vue-text   /或者使用 node自带的(如果升级不了@vue/cli)    npx @vue/cli create my-app\n## 启动\ncd vue-text\nnpm run serve\n</code></pre>\n<h3 id=\"2-使用vite创建\"><a href=\"#2-使用vite创建\" class=\"headerlink\" title=\"2.使用vite创建\"></a>2.使用vite创建</h3><pre><code class=\"javascript\">## 什么是vite?   \n新一代前端构建工具\n## 优势\n1.开发环境中,无需打包操作，可快速的冷启动\n2.轻量快速的热重载(HMR)\n3.真正的按需编译，不再等待整个应用编译完成\n## 创建工程\nnpm init  vite-app &lt;project-name&gt;\n## 进入工程目录\ncd &lt;project-name&gt;\n## 安装依赖\nnpm install\n## 运行\nnpm run dev\n</code></pre>\n<h2 id=\"4-常用Composition-API\"><a href=\"#4-常用Composition-API\" class=\"headerlink\" title=\"4.常用Composition API\"></a>4.常用Composition API</h2><h3 id=\"1-拉开序幕的setup\"><a href=\"#1-拉开序幕的setup\" class=\"headerlink\" title=\"1.拉开序幕的setup\"></a>1.拉开序幕的setup</h3><pre><code class=\"javascript\">1.理解：vue3.0中的一个新的配置项。值为一个函数\n2.setups是所有Composition API(组合api) “表演的舞台”\n3.组件中所有用到的：数据，方法等等。均要配置在setup中\n4.setup函数的两种返回值：\n    1.若返回一个对象，则对象中的属性，方法，在模板中直接使用\n    2.若返回画一个渲染函数，则可以自定义渲染内容(了解即可)\n5.注意点\n    1.尽量不要与Vue2.x配置混用\n    2.但在setup中不能访问到Vue2.x配置(data,methsds,computed...)\n    3.如果重名，setup优先\n    \n</code></pre>\n<h3 id=\"2-ref函数\"><a href=\"#2-ref函数\" class=\"headerlink\" title=\"2.ref函数\"></a>2.ref函数</h3><pre><code class=\"javascript\">1.作用：定义一个响应式的数据\n2.语法 ： const xxx = ref(initValue)\n    1.创建一个响应式的数据的引用对象\n    2.js操作数据\n    3.模板中读取数据：不需要  .value  直接 &lt;div&gt;&#123;&#123;xxx&#125;&#125;&lt;div/&gt;\n3.备注：\n    1.接收数据可以是基本类型，也可以是对象类型\n    2.基本类型的数据：响应式依然是靠Object.defineProperty() 的get和set\n    3.对象类型的数据： 内部求助了Vue3.0中的一个新的函数  - reactive\n</code></pre>\n<h3 id=\"3-reactive\"><a href=\"#3-reactive\" class=\"headerlink\" title=\"3.reactive\"></a>3.reactive</h3><pre><code class=\"javascript\">1.作用：定义一个对象类型的响应式数据(基本类型别用它，用ref函数)\n2.语法 const 代理对象  = reactive(被代理对象)接收一个对象或者数组,返回一个代理器对象(proxy对象)\n3.reactive定义的响应数据是深层次的\n4.内部基于ES6的proxy，通过代理对象对原数据内部数据都是响应式的\n</code></pre>\n<h1 id=\"八：vue3-X脚手架相关\"><a href=\"#八：vue3-X脚手架相关\" class=\"headerlink\" title=\"八：vue3.X脚手架相关\"></a>八：vue3.X脚手架相关</h1><h3 id=\"1-shims-vue-d-ts-文件的作用\"><a href=\"#1-shims-vue-d-ts-文件的作用\" class=\"headerlink\" title=\"1.shims-vue.d.ts  文件的作用\"></a>1.shims-vue.d.ts  文件的作用</h3><pre><code class=\"javascript\">/**\n * shims-vue.d.ts的作用\n * 为了 typescript 做的适配定义文件，因为.vue 文件不是一个常规的文件类型，ts 是不能理解 vue 文件是干嘛的，\n * 加这一段是是告诉 ts，vue 文件是这种类型的。\n * 可以把这一段删除，会发现 import 的所有 vue 类型的文件都会报错。\n */\n\ndeclare module &#39;*.vue&#39; &#123; //declare声明宣告， 声明一个ambient module(即:没有内部实现的 module声明) \n  import Vue from &#39;vue&#39;\n  export default Vue\n&#125;\n\ndeclare module &#39;vue-echarts&#39;  // 引入vue-echarts\n\n&lt;script lang=&quot;ts&quot;&gt;\n    /* eslint-disable @typescript-eslint/camelcase */\n    import &#123; Vue, Component, Watch &#125; from &#39;vue-property-decorator&#39;\n    import ECharts from &#39;vue-echarts&#39; //报错,按上面的方法在shims-vue.d.ts文件中引入即可\n    import &#39;echarts/lib/chart/line&#39;\n    import &#39;echarts/lib/chart/pie&#39;\n    import &#39;echarts/lib/component/tooltip&#39;\n&lt;/script&gt;\n</code></pre>\n<h1 id=\"八：vue-性能优化\"><a href=\"#八：vue-性能优化\" class=\"headerlink\" title=\"八：vue 性能优化\"></a>八：vue 性能优化</h1><h2 id=\"1-SSR\"><a href=\"#1-SSR\" class=\"headerlink\" title=\"1.SSR\"></a>1.SSR</h2><h2 id=\"2-同构\"><a href=\"#2-同构\" class=\"headerlink\" title=\"2.同构\"></a>2.同构</h2><h2 id=\"3-常见性能优化策略\"><a href=\"#3-常见性能优化策略\" class=\"headerlink\" title=\"3.常见性能优化策略\"></a>3.常见性能优化策略</h2><h1 id=\"九：自动化测试\"><a href=\"#九：自动化测试\" class=\"headerlink\" title=\"九：自动化测试\"></a>九：自动化测试</h1><h2 id=\"1-单元测试\"><a href=\"#1-单元测试\" class=\"headerlink\" title=\"1.单元测试\"></a>1.单元测试</h2><h2 id=\"2-E2E测试\"><a href=\"#2-E2E测试\" class=\"headerlink\" title=\"2.E2E测试\"></a>2.E2E测试</h2>",
            "tags": [
                "前端开发",
                "Vue",
                "Vue"
            ]
        },
        {
            "id": "http://yoursite.com/front-end/web%E5%AE%89%E5%85%A8/",
            "url": "http://yoursite.com/front-end/web%E5%AE%89%E5%85%A8/",
            "title": "web安全",
            "date_published": "2021-06-25T08:43:00.000Z",
            "content_html": "<h1 id=\"XSS（跨站脚本攻击）：\"><a href=\"#XSS（跨站脚本攻击）：\" class=\"headerlink\" title=\"XSS（跨站脚本攻击）：\"></a>XSS（跨站脚本攻击）：</h1><pre><code class=\"text\">使用合适的编码和转义方式来处理输入和输出的数据。\n对用户输入进行验证和过滤，避免将恶意脚本插入到页面中。\n</code></pre>\n<h1 id=\"CSRF（跨站请求伪造）：\"><a href=\"#CSRF（跨站请求伪造）：\" class=\"headerlink\" title=\"CSRF（跨站请求伪造）：\"></a>CSRF（跨站请求伪造）：</h1><pre><code class=\"text\">在关键操作上使用随机生成的令牌（CSRF Token），并验证该令牌的合法性。\n设置合适的 SameSite Cookie 属性，限制跨站点访问。\n</code></pre>\n<h1 id=\"点击劫持（Clickjacking）：\"><a href=\"#点击劫持（Clickjacking）：\" class=\"headerlink\" title=\"点击劫持（Clickjacking）：\"></a>点击劫持（Clickjacking）：</h1><pre><code class=\"text\">使用 X-Frame-Options 或 Content-Security-Policy 来限制页面被嵌套到其他网站的情况。\n可以使用 JavaScript 检测页面是否在 iframe 中展示，并弹出警告或拒绝加载。\n</code></pre>\n<h1 id=\"密码安全：\"><a href=\"#密码安全：\" class=\"headerlink\" title=\"密码安全：\"></a>密码安全：</h1><pre><code class=\"text\">采用密码哈希算法（如 bcrypt）对用户密码进行加密存储，避免明文存储。\n强制要求用户设置强密码，并进行密码策略的验证（如长度、大小写字母、特殊字符等）。\n</code></pre>\n<h1 id=\"客户端数据验证和过滤：\"><a href=\"#客户端数据验证和过滤：\" class=\"headerlink\" title=\"客户端数据验证和过滤：\"></a>客户端数据验证和过滤：</h1><pre><code class=\"text\">不要依赖前端验证，一定要在后端进行数据验证和过滤。\n对客户端输入的数据进行严格验证，避免恶意输入和攻击。\n</code></pre>\n<h1 id=\"安全更新和依赖管理：\"><a href=\"#安全更新和依赖管理：\" class=\"headerlink\" title=\"安全更新和依赖管理：\"></a>安全更新和依赖管理：</h1><pre><code class=\"text\">及时更新和升级前端框架、库和依赖，以获取最新的安全修复和补丁。\n定期审查和监控项目的依赖项，确保没有包含已知的漏洞和安全问题。\n</code></pre>\n<h1 id=\"HTTPS-的使用：\"><a href=\"#HTTPS-的使用：\" class=\"headerlink\" title=\"HTTPS 的使用：\"></a>HTTPS 的使用：</h1><pre><code class=\"text\">在页面上使用 HTTPS 协议来加密数据传输，防止数据被窃取和篡改。\n配置合适的 TLS/SSL 加密套件和证书，确保通信的安全性。\n</code></pre>\n<h1 id=\"安全审计和日志记录：\"><a href=\"#安全审计和日志记录：\" class=\"headerlink\" title=\"安全审计和日志记录：\"></a>安全审计和日志记录：</h1><pre><code class=\"text\">记录用户操作日志，追溯异常行为和安全事件。\n定期进行安全审计，检查应用程序的漏洞和安全风险。\n</code></pre>\n<h1 id=\"输入验证与过滤：\"><a href=\"#输入验证与过滤：\" class=\"headerlink\" title=\"输入验证与过滤：\"></a>输入验证与过滤：</h1><pre><code class=\"text\">对用户输入进行验证和过滤，确保只接受预期的合法输入。\n使用白名单过滤，而不是黑名单过滤，避免遗漏恶意输入。\n</code></pre>\n<h1 id=\"安全的跨域资源共享（CORS）配置：\"><a href=\"#安全的跨域资源共享（CORS）配置：\" class=\"headerlink\" title=\"安全的跨域资源共享（CORS）配置：\"></a>安全的跨域资源共享（CORS）配置：</h1><pre><code class=\"text\">配置合适的 CORS 头信息，限制跨域请求的访问权限。\n设置合理的源和目标组合，防止未经授权的访问和信息泄露。\n</code></pre>\n<h1 id=\"客户端存储的安全性：\"><a href=\"#客户端存储的安全性：\" class=\"headerlink\" title=\"客户端存储的安全性：\"></a>客户端存储的安全性：</h1><pre><code class=\"text\">避免在客户端存储敏感信息，如密码、令牌等。\n使用合适的存储机制，如浏览器提供的 localStorage 或 sessionStorage，加密存储敏感数据。\n</code></pre>\n<h1 id=\"CDN-安全：\"><a href=\"#CDN-安全：\" class=\"headerlink\" title=\"CDN 安全：\"></a>CDN 安全：</h1><pre><code class=\"text\">如果使用内容分发网络（CDN），确保从可信任的来源获取资源并验证其完整性。\n配置适当的安全头部，如 Content Security Policy (CSP)。\n</code></pre>\n<h1 id=\"防御点击劫持：\"><a href=\"#防御点击劫持：\" class=\"headerlink\" title=\"防御点击劫持：\"></a>防御点击劫持：</h1><pre><code class=\"text\">通过在响应头中设置 X-Frame-Options 或 Content-Security-Policy，限制页面被嵌套到其他网站的情况。\n对于现代浏览器，可以使用 Frame-ancestors CSP 指令来进一步控制允许嵌套页面的来源。\n</code></pre>\n<h1 id=\"定期安全审查和漏洞扫描：\"><a href=\"#定期安全审查和漏洞扫描：\" class=\"headerlink\" title=\"定期安全审查和漏洞扫描：\"></a>定期安全审查和漏洞扫描：</h1><pre><code class=\"text\">定期进行安全审查，检查代码中的潜在漏洞和安全隐患。\n使用自动化工具进行漏洞扫描和代码静态分析，及时发现可能存在的安全问题。\n</code></pre>\n<h1 id=\"消息传递的安全性：\"><a href=\"#消息传递的安全性：\" class=\"headerlink\" title=\"消息传递的安全性：\"></a>消息传递的安全性：</h1><pre><code class=\"text\">对于敏感信息的传递，尽量使用加密算法加密数据。\n避免将敏感信息直接传递给前端，而是在后端进行敏感信息的处理和加密。\n</code></pre>\n<h1 id=\"防御代码注入攻击：\"><a href=\"#防御代码注入攻击：\" class=\"headerlink\" title=\"防御代码注入攻击：\"></a>防御代码注入攻击：</h1><pre><code class=\"text\">避免在前端中执行不受信任的代码。\n不要将用户输入直接拼接到代码字符串中，以防止代码注入攻击。\n</code></pre>\n<h1 id=\"防御文件上传漏洞：\"><a href=\"#防御文件上传漏洞：\" class=\"headerlink\" title=\"防御文件上传漏洞：\"></a>防御文件上传漏洞：</h1><pre><code class=\"text\">对用户上传的文件进行严格的验证和过滤，并使用独立的文件存储来避免安全问题。\n验证文件类型、大小和内容，确保只接受合法和安全的文件。\n</code></pre>\n<h1 id=\"安全的第三方组件和库：\"><a href=\"#安全的第三方组件和库：\" class=\"headerlink\" title=\"安全的第三方组件和库：\"></a>安全的第三方组件和库：</h1><pre><code class=\"text\">在使用第三方组件和库时，选择经过广泛审查和更新的可信来源。\n定期更新和升级第三方组件，以获取最新的安全修复和功能改进。\n</code></pre>\n<h1 id=\"保护敏感信息：\"><a href=\"#保护敏感信息：\" class=\"headerlink\" title=\"保护敏感信息：\"></a>保护敏感信息：</h1><pre><code class=\"text\">不要将敏感信息直接存储在前端，如密码、密钥等。\n使用加密算法对敏感信息进行加密，并在后端进行处理和存储。\n</code></pre>\n",
            "tags": [
                "前端开发",
                "web安全",
                "web安全"
            ]
        },
        {
            "id": "http://yoursite.com/front-end/webpack%E9%9D%A2%E8%AF%95/",
            "url": "http://yoursite.com/front-end/webpack%E9%9D%A2%E8%AF%95/",
            "title": "webpack面试",
            "date_published": "2021-06-25T08:43:00.000Z",
            "content_html": "<h1 id=\"谈谈你对Webpack的理解（Webpack是什么？）\"><a href=\"#谈谈你对Webpack的理解（Webpack是什么？）\" class=\"headerlink\" title=\"谈谈你对Webpack的理解（Webpack是什么？）\"></a>谈谈你对Webpack的理解（Webpack是什么？）</h1><pre><code class=\"text\">Webpack 是一个 静态模块打包器，可以分析各个模块的依赖关系，项目中的所有资源皆为模块，通过分析模块间的依赖关系，在其内部递归构建出一个依赖关系图，其中包含应用程序需要的每个模块，然后将这些模块打包成一个或多个 bundle。最终编绎输出模块为 HTML、JavaScript、CSS 以及各种静态文件（图片、字体等）。\n\nwebpack 就像一条生产线,要经过一系列处理流程(loader)后才能将源文件转换成输出结果。 这条生产线上的每个处理流程的职责都是单一的,多个流程之间有存在依赖关系,只有完成当前处理后才能交给下一个流程去处理。\n插件就像是一个插入到生产线中的一个功能,在特定的时机对生产线上的资源做处理。 webpack 在运行过程中会广播事件,插件只需要监听它所关心的事件,就能加入到这条生产线中,去改变生产线的运作。\n\nwebpack的主要作用如下：\n模块打包 可以将不同模块的文件打包整合在一起，并且保证它们之间的引用正确，执行有序。利用打包我们就可以在开发的时候根据我们自己的业务自由划分文件模块，保证项目结构的清晰和可读性。\n编译兼容 在前端的“上古时期”，手写一堆浏览器兼容代码一直是令前端工程师头皮发麻的事情，而在今天这个问题被大大的弱化了，通过webpack的Loader机制，不仅仅可以帮助我们对代码做polyfill，还可以编译转换诸如.less，.vue，.jsx这类在浏览器无法识别的格式文件，让我们在开发的时候可以使用新特性和新语法做开发，提高开发效率。\n能力扩展 通过webpack的Plugin机制，我们在实现模块化打包和编译兼容的基础上，可以进一步实现诸如按需加载，代码压缩等一系列功能，帮助我们进一步提高自动化程度，工程效率以及打包输出的质量。\n</code></pre>\n<h1 id=\"Webpack的打包过程-x2F-打包原理-x2F-构建流程？\"><a href=\"#Webpack的打包过程-x2F-打包原理-x2F-构建流程？\" class=\"headerlink\" title=\"Webpack的打包过程&#x2F;打包原理&#x2F;构建流程？\"></a>Webpack的打包过程&#x2F;打包原理&#x2F;构建流程？</h1><pre><code class=\"text\">初始化：启动构建，读取与合并配置参数，加载plugin,实例化Compiler\n编译：从Entry出发，针对每个Module串行调用对应的Loader去翻译文件中的内容，再找到该Module依赖的Module，递归的进行编译处理\n输出：将编译后的Module组合成Chunk,将Chunk转换成文件，输出到文件系统中\n\n\n\n细节：\n\nWebpack CLI 通过 yargs模块解析 CLI 参数，并转化为配置对象option（单入口：Object，多入口：Array），调用 webpack(option) 创建 compiler 对象。\n\n如果有 option.plugin，则遍历调用plugin.apply()来注册 plugin，\n\n判断是否开启了 watch，如果开启则调用 compiler.watch，否则调用 compiler.run，开始构建。\n\n创建 Compilation 对象来收集全部资源和信息，然后触发 make 钩子。\n\nmake阶段从入口开始递归所有依赖，\n\n每次遍历时调用对应Loader翻译文件中内容，然后生成AST，遍历AST找到下个依赖继续递归，\n\n根据入口和模块之间关系组装chunk，输出到dist中的一个文件内。\n\n在以上过程中，webpack会在特定的时间点（使用tapable模块）广播特定的事件，插件监听事件并执行相应的逻辑，并且插件可以调用webpack提供的api改变webpack的运行结果\n</code></pre>\n<h1 id=\"loader的作用\"><a href=\"#loader的作用\" class=\"headerlink\" title=\"loader的作用\"></a>loader的作用</h1><pre><code class=\"text\">webpack中的loader是一个函数，主要为了实现源码的转换，所以loader函数会以源码作为参数，比如，将ES6转换为ES5，将less转换为css，然后再将css转换为js，以便能嵌入到html文件中。\n\n默认情况下，webpack只支持对js和json文件进行打包，但是像css、html、png等其他类型的文件，webpack则无能为力。因此，就需要配置相应的loader进行文件内容的解析转换。\n</code></pre>\n<h1 id=\"有哪些常见的Loader？他们是解决什么问题的？\"><a href=\"#有哪些常见的Loader？他们是解决什么问题的？\" class=\"headerlink\" title=\"有哪些常见的Loader？他们是解决什么问题的？\"></a>有哪些常见的Loader？他们是解决什么问题的？</h1><pre><code class=\"text\">image-loader：加载并且压缩图片文件。\nless-loader：加载并编译 LESS 文件。\nsass-loader：加载并编译 SASS/SCSS 文件。\ncss-loader：加载 CSS，支持模块化、压缩、文件导入等特性，使用css-loader必须要配合使用style-loader。\nstyle-loader：用于将 CSS 编译完成的样式，挂载到页面的 style 标签上。需要注意 loader 执行顺序，style-loader 要放在第一位，loader 都是从后往前执行。\nbabel-loader：把 ES6 转换成 ES5\npostcss-loader：扩展 CSS 语法，使用下一代 CSS，可以配合 autoprefixer 插件自动补齐 CSS3 前缀。\neslint-loader：通过 ESLint 检查 JavaScript 代码。\nvue-loader：加载并编译 Vue 组件。\nfile-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件 (处理图片和字体)\nurl-loader：与 file-loader 类似，区别是用户可以设置一个阈值，大于阈值会交给 file-loader 处理，小于阈值时返回文件 base64 形式编码 (处理图片和字体)。\nsource-map-loader：加载额外的 Source Map 文件，以方便断点调试。\n</code></pre>\n<h1 id=\"plugin的作用\"><a href=\"#plugin的作用\" class=\"headerlink\" title=\"plugin的作用\"></a>plugin的作用</h1><pre><code class=\"text\">plugin是一个类，类中有一个apply()方法，主要用于Plugin的安装，可以在其中监听一些来自编译器发出的事件，在合适的时机做一些事情。\n\nwebpack中的plugin赋予其各种灵活的功能，例如打包优化、资源管理、环境变量注入等，它们会运行在webpack的不同阶段（钩子 / 生命周期），贯穿了webpack整个编译周期。目的在于「解决 loader 无法实现的其他事」。\n</code></pre>\n<h1 id=\"有哪些常见的Plugin？他们是解决什么问题的？\"><a href=\"#有哪些常见的Plugin？他们是解决什么问题的？\" class=\"headerlink\" title=\"有哪些常见的Plugin？他们是解决什么问题的？\"></a>有哪些常见的Plugin？他们是解决什么问题的？</h1><pre><code class=\"text\">html-webpack-plugin：可以复制一个有结构的html文件，并自动引入打包输出的所有资源（JS/CSS）\nclean-webpack-plugin：重新打包自动清空 dist 目录\nmini-css-extract-plugin：提取 js 中的 css 成单独文件\noptimize-css-assets-webpack-plugin：压缩css\nuglifyjs-webpack-plugin：压缩js\ncommons-chunk-plugin：提取公共代码\ndefine-plugin：定义环境变量\n</code></pre>\n<h1 id=\"Webpack中Loader和Plugin的区别\"><a href=\"#Webpack中Loader和Plugin的区别\" class=\"headerlink\" title=\"Webpack中Loader和Plugin的区别\"></a>Webpack中Loader和Plugin的区别</h1><pre><code class=\"text\">\n运行时机\n1.loader运行在编译阶段\n2.plugins 在整个周期都起作用\n\n使用方式\nLoader:1.下载 2.使用\nPlugin:1.下载 2.引用 3.使用\n\nloader是文件加载器，能够加载资源文件，并对这些文件进行一些处理，诸如编译、压缩等，最终一起打包到指定的文件中；plugin赋予了webpack各种灵活的功能，例如打包优化、资源管理、环境变量注入等，目的是解决 loader无法实现的其他事。\n\n在运行时机上，loader 运行在打包文件之前；plugin则是在整个编译周期都起作用。\n\n在配置上，loader在module.rules中配置，作为模块的解析规则，类型为数组。每一项都是一个 Object，内部包含了 test(类型文件)、loader、options (参数)等属性；plugin在 plugins中单独配置，类型为数组，每一项是一个 plugin 的实例，参数都通过构造函数传入。\n</code></pre>\n<h1 id=\"webpack的热更新是如何做到的？说明其原理？\"><a href=\"#webpack的热更新是如何做到的？说明其原理？\" class=\"headerlink\" title=\"webpack的热更新是如何做到的？说明其原理？\"></a>webpack的热更新是如何做到的？说明其原理？</h1><pre><code class=\"text\">热更新的核心就是客户端从服务端拉去更新后的文件，准确的说是 chunk diff (chunk 需要更新的部分)，实际上webpack-dev-server与浏览器之间维护了一个websocket，当本地资源发生变化时，webpack-dev-server会向浏览器推送更新，并带上构建时的hash，让客户端与上一次资源进行对比。客户端对比出差异后会向webpack-dev-server发起 Ajax 请求来获取更改内容(文件列表、hash)，这样客户端就可以再借助这些信息继续向webpack-dev-server发起 jsonp 请求获取该chunk的增量更新。\n\n后续的部分(拿到增量更新之后如何处理？哪些状态该保留？哪些又需要更新？)由HotModulePlugin 来完成，提供了相关 API 以供开发者针对自身场景进行处理，像react-hot-loader和vue-loader都是借助这些 API 实现热更新。\n\n详细：\n1、在 webpack 的 watch 模式下，文件系统中某一个文件发生修改，webpack 监听到文件变化，根据配置文件对模块重新编译打包，并将打包后的代码通过简单的 JavaScript 对象保存在内存中。\n2、webpack-dev-server 和 webpack 之间的接口交互，而在这一步，主要是 dev-server 的中间件webpack-dev-middleware 和 webpack 之间的交互，webpack-dev-middleware 调用 webpack 暴露的 API对代码变化进行监控，并且告诉 webpack，将代码打包到内存中。\n3、webpack-dev-server 对文件变化的一个监控，这一步不同于第一步，并不是监控代码变化重新打包。当我们在配置文件中配置了devServer.watchContentBase 为 true 的时候，Server 会监听这些配置文件夹中静态文件的变化，变化后会通知浏览器端对应用进行 live reload。注意，这儿是浏览器刷新，和 HMR 是两个概念\n4、webpack-dev-server 代码的工作，该步骤主要是通过 sockjs（webpack-dev-server 的依赖）在浏览器端和服务端之间建立一个 websocket 长连接，将 webpack 编译打包的各个阶段的状态信息告知浏览器端，\n同时也包括第三步中 Server 监听静态文件变化的信息。浏览器端根据这些 socket 消息进行不同的操作。当然服务端传递的最主要信息还是新模块的 hash 值，后面的步骤根据这一 hash 值来进行模块热替换。\nwebpack-dev-server/client 端并不能够请求更新的代码，也不会执行热更模块操作，而把这些工作又交回给了 webpack，webpack/hot/dev-server 的工作就是根据 webpack-dev-server/client 传给它的信息以及 dev-server 的配置决定是刷新浏览器呢还是进行模块热更新。当然如果仅仅是刷新浏览器，也就没有后面那些步骤了。HotModuleReplacement.runtime 是客户端 HMR 的中枢，它接收到上一步传递给他的新模块的 hash 值，它通过 JsonpMainTemplate.runtime 向 server 端发送 Ajax 请求，服务端返回一个 json，该 json 包含了所有要更新的模块的 hash 值，获取到更新列表后，该模块再次通过 jsonp 请求，获取到最新的模块代码。\n5、决定 HMR 成功与否的关键步骤，在该步骤中，HotModulePlugin 将会对新旧模块进行对比，决定是否更新模块，在决定更新模块后，检查模块之间的依赖关系，更新模块的同时更新模块间的依赖引用。最后一步，当 HMR 失败后，回退到 live reload 操作，也就是进行浏览器刷新来获取最新打包代码。\n</code></pre>\n<h1 id=\"如何解决循环依赖问题\"><a href=\"#如何解决循环依赖问题\" class=\"headerlink\" title=\"如何解决循环依赖问题\"></a>如何解决循环依赖问题</h1><pre><code class=\"text\">\nWebpack 中将 require 替换为 webpack_require，会根据 moduleId 到 installedModules 找是否加载过，加载过则直接返回之前的 export，不会重复加载。\n</code></pre>\n<h1 id=\"如何提高Webpack构建速度\"><a href=\"#如何提高Webpack构建速度\" class=\"headerlink\" title=\"如何提高Webpack构建速度\"></a>如何提高Webpack构建速度</h1><pre><code class=\"javascript\">1. 代码压缩\n\nJS 压缩\nwebpack 4.0默认在生产环境的时候是支持代码压缩的，即mode=production模式下。实际上webpack 4.0默认是使用terser-webpack-plugin这个压缩插件，在此之前是使用 uglifyjs-webpack-plugin，两者的区别是后者对 ES6 的压缩不是很好，同时我们可以开启 parallel参数，使用多进程压缩，加快压缩。\nCSS 压缩\nCSS 压缩通常是去除无用的空格等，因为很难去修改选择器、属性的名称、值等。可以使用另外一个插件：css-minimizer-webpack-plugin。\nHTML 压缩\n使用HtmlWebpackPlugin插件来生成 HTML 的模板时候，通过配置属性minify进行 html 优化。\n\nmodule.exports = &#123;\nplugin:[\n  new HtmlwebpackPlugin(&#123;\n    minify:&#123;\n      minifyCSS: false, // 是否压缩css\n      collapseWhitespace: false, // 是否折叠空格\n      removeComments: true // 是否移除注释\n    &#125;\n  &#125;)\n  ]\n&#125;\n\n2. 图片压缩\n\n配置image-webpack-loader\n\n3. Tree Shaking\n\nTree Shaking是一个术语，在计算机中表示消除死代码，依赖于 ES Module 的静态语法分析（不执行任何的代码，可以明确知道模块的依赖关系）。在webpack实现Tree shaking有两种方案：\n\nusedExports：通过标记某些函数是否被使用，之后通过 Terser 来进行优化的\nmodule.exports = &#123;\n    ...\n    \n    optimization:&#123;\n        usedExports\n    &#125;\n  &#125;\n使用之后，没被用上的代码在webpack打包中会加入unused harmony export mul注释，用来告知Terser在优化时，可以删除掉这段代码。\n\nsideEffects：跳过整个模块/文件，直接查看该文件是否有副作用\n\nsideEffects用于告知webpack compiler哪些模块时有副作用，配置方法是在package.json中设置sideEffects属性。如果sideEffects设置为false，就是告知webpack可以安全的删除未用到的exports。如果有些文件需要保留，可以设置为数组的形式，如：\n\n&quot;sideEffecis&quot;:[\n    &quot;./src/util/format.js&quot;,\n    &quot;*.css&quot; // 所有的css文件\n]\n\n4. 缩小打包域\n排除webpack不需要解析的模块，即在使用loader的时候，在尽量少的模块中去使用。可以借助 include和exclude这两个参数，规定loader只在那些模块应用和在哪些模块不应用。\n\n5. 减少 ES6 转为 ES5 的冗余代码\n使用bable-plugin-transform-runtime插件\n\n6. 提取公共代码\n通过配置CommonsChunkPlugin插件，将多个页面的公共代码抽离成单独的文件\n\n7. 其他\n组件懒加载、路由懒加载、开启gzip、公共的第三方包上cdn、配置cache缓存Loader对文件的编译副本、配置resolve提高文件的搜索速度（@: src）\n\n</code></pre>\n<h1 id=\"webpack和vite的区别\"><a href=\"#webpack和vite的区别\" class=\"headerlink\" title=\"webpack和vite的区别\"></a>webpack和vite的区别</h1><p>工具本身定位不同<br>webpack是底层的东西，vite则是更上层的工具。webpack是配置化，灵活度极高的工具，vite是开箱即用，使用更简单的工具<br>原理不同<br>webpack是bundle，自己实现了一套模块导入导出机制。vite是利用浏览器的esm能力，是bundless。<br>优缺点<br>vite开箱即用，更加简单，基于浏览器esm，使得hmr更加优秀，达到极速的效果；webpack更加灵活，api以及插件生态更加丰富。<br>webpack先打包，再启动服务器，请求服务器时直接给予打包后的结果；vite直接启动服务器，请求哪个模块再对哪个模块进行实时编译。</p>\n<p>1.webpack常见配置</p>\n<p>2.webpack性能优化</p>\n<p>3.手写webpack</p>\n<p>4.实现自己地vue-cli</p>\n<p>5.剖析vue-cli</p>\n<h1 id=\"webpack性能优化\"><a href=\"#webpack性能优化\" class=\"headerlink\" title=\"webpack性能优化\"></a>webpack性能优化</h1><p>* 开发环境性能优化</p>\n<p>* 生产环境性能优化</p>\n<h1 id=\"开发环境性能优化\"><a href=\"#开发环境性能优化\" class=\"headerlink\" title=\"开发环境性能优化\"></a>开发环境性能优化</h1><p>* 优化打包构建速度</p>\n<p> * HMR</p>\n<p>* 优化代码调试</p>\n<p> * source-map</p>\n<h1 id=\"生产环境性能优化\"><a href=\"#生产环境性能优化\" class=\"headerlink\" title=\"生产环境性能优化\"></a>生产环境性能优化</h1><p>* 优化打包构建速度</p>\n<p> * oneOf</p>\n<p> * babel缓存</p>\n<p> * 多进程打包</p>\n<p> * externals</p>\n<p> * dll</p>\n<p>* 优化代码运行的性能</p>\n<p> * 缓存(hash-chunkhash-contenthash)</p>\n<p> * tree shaking</p>\n<p> * code split</p>\n<p> * 懒加载&#x2F;预加载</p>\n<p> * pwa</p>\n",
            "tags": [
                "前端开发",
                "前端工程化",
                "webpack"
            ]
        },
        {
            "id": "http://yoursite.com/front-end/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%A6%96%E5%B1%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/",
            "url": "http://yoursite.com/front-end/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%A6%96%E5%B1%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/",
            "title": "小程序首屏性能优化",
            "date_published": "2021-06-25T08:43:00.000Z",
            "content_html": "<h1 id=\"一：优化的核心\"><a href=\"#一：优化的核心\" class=\"headerlink\" title=\"一：优化的核心\"></a>一：优化的核心</h1><h2 id=\"一：关于耗时\"><a href=\"#一：关于耗时\" class=\"headerlink\" title=\"一：关于耗时\"></a>一：关于耗时</h2><pre><code class=\"javascript\">1. 首屏耗时与用户设备、所在网络环境、程序代码有很大关系。线上环境有2/3的运气成分。\n\n2. 理论上相同地域访问 https 比访问 ip 慢，但小程序要求必须使用 https。\n\n3. 小程序启动时由微信加载代码包，与服务域名无关，进入页面后才会发起首次网络请求，某些用户环境出现 ERR_CONNECTION_RESET，导致上报的 API 接口及首屏耗时因网络不通畅爆表\n</code></pre>\n<h2 id=\"二：前端性能监控（RUM）-接入\"><a href=\"#二：前端性能监控（RUM）-接入\" class=\"headerlink\" title=\"二：前端性能监控（RUM） 接入\"></a>二：前端性能监控（RUM） 接入</h2><pre><code class=\"javascript\">RUM 是腾讯提供的一款前端监控方案，只需在控制台上创建业务系统和应用，获取上报 ID；通过安装 npm 依赖配置 JSON 就可以实现测速和日志的收集。\n\n注意：在小程序中，要按照小程序规则开启 NPM 构建。\n必须将  https://aegis.qq.com  添加到 request 合法域名中，否则 RUM 控制台中没有正式版本的数据。一般会在 devTools 中开启忽略合法域名校验，为了方便开发调试调用开发环境，而忽略这个配置。\n</code></pre>\n<h2 id=\"三：图片资源\"><a href=\"#三：图片资源\" class=\"headerlink\" title=\"三：图片资源\"></a>三：图片资源</h2><pre><code class=\"javascript\">常见图片可以采用JPG、PNG、WEBP、雪碧图或字体图标实现，可搜索到的描述大概都是不同格式适用的不同场景，以及从占用带宽上的描述。\n\n1.首先要选择合适的图片格式\n1.1照片图片使用 webP。\n1.2复杂的图形使用 PNG 或 JPG，看哪个格式的文件小。\n1.3有透明度的图形使用 PNG 或 webP。\n1.4可能缩放的图形、图标等使用 SVG。\n1.5动态图尽量不使用 GIF，无法使用 CSS 的用视频替代。\n\n2.在小程序中，只有网络图片且在基础库高于 2.9.0 的微信上可以使用 webp ，目前绝大多数的微信用户基础库以及高于 2.16.0版本库，因此\n可以对互联网图片转换为 webp  格式，减小网络加载耗时。\n\n3.目前没有查到关于这几种方式显示图片资源的页面渲染耗时分析。\n</code></pre>\n<h2 id=\"四：JS-优化\"><a href=\"#四：JS-优化\" class=\"headerlink\" title=\"四：JS 优化\"></a>四：JS 优化</h2><pre><code class=\"javascript\">1.首先排查在主线程上不要使用同步方法，减小主线程阻塞。\n2.开启小程序中的代码按需注入，避免没有使用的代码注入到小程序运行环境中，影响注入耗时和内存占用。\n3.生产环境去掉不必要的日志打印\n</code></pre>\n<h2 id=\"五：CSS-优化\"><a href=\"#五：CSS-优化\" class=\"headerlink\" title=\"五：CSS 优化\"></a>五：CSS 优化</h2><pre><code class=\"javascript\">因为构建 CSSOM 树时会阻塞页面的解析，因此需要：\n\n1.删除没有使用的 CSS 代码\n2.减小 CSS 文件大小，如 #FFFFFF -&gt; #FFF ， 0px -&gt; 0，不要使用 Base64 编码的图片。\n</code></pre>\n<h1 id=\"二：具体的优化方法\"><a href=\"#二：具体的优化方法\" class=\"headerlink\" title=\"二：具体的优化方法\"></a>二：具体的优化方法</h1><h2 id=\"一：资源优化\"><a href=\"#一：资源优化\" class=\"headerlink\" title=\"一：资源优化\"></a>一：资源优化</h2><pre><code class=\"javascript\">资源优化\n1. 按照页面访问的频次，将图片资源分成常用的和不常用的，将常用的放入小程序代码包通过本地加载，将不常用的转换成 webp 放到服务器。\n\n2. 减小代码包体积：压缩代码包中的图片资源，对 PNG 格式的透明图设置更少的颜色数；通过依赖分析，更换体积更小的 markdown 渲染依赖。从 1M+下降到280K+。\n</code></pre>\n<h2 id=\"二：网络优化\"><a href=\"#二：网络优化\" class=\"headerlink\" title=\"二：网络优化\"></a>二：网络优化</h2><pre><code class=\"javascript\">\n 网络优化\n1. 由于只有一台华北地区的服务器，为解决不同地域和运营商的访问速度，开启全站动态加速。通过某测速网站看到可解析到70+个独立 IP，并且不同地区的用户会访问到同运营商较近的 IP，然后由 DCDN 通过内部线路转发用户到服务器的请求。\n\n2. 通过分析，首次请求时需要进行域名的解析和建连，后续的请求会复用该链路，解析和 SSL 等时间为0。通过某测速网站可看到平均响应时间在 0.3s，考虑到链路复用，网络请求时间会在 60ms 左右。\n\n3. 对不经常变更且频繁访问的接口，在 DCDN 中设置静态缓存，并触发接口预热，将接口的响应缓存到 DCDN 的二级节点上。这样用户发起这些请求时，直接由 DCDN 做出应答而不回源到真实服务器处理。\n\n4. 在服务端和客户端开启 http/2 协议支持。由于小程序中无高并发请求，自测没有明显改善。\n\n5. 对超过 1kb 的响应体开启 gzip 压缩。\n\n6. 对服务端的图片等静态资源设置浏览器缓存。\n\n7. 由于小程序不像 BAT 这么大用户量和高频的访问，根据 DNS 的解析机制，各地运营商如果有缓存 DNS的解析结果就不会向跟 DNS 进行解析，利用网站测速提供的服务，发送 GET 测速，让各地运营商缓存 DNS 结果。\n\n8. 开启 OCSP Stapling，提高证书的校验性能。\n\n9. 小程序使用中，服务端会调用 api.weixin.qq.com 换取用户的 openid，通过调用微信公众平台接口获取该域名的各个 ip 地址，在服务器执行 ping 命令，找到最快的一个ip，写入host文件。从 40ms 降低到 28.8ms。\n</code></pre>\n<h2 id=\"三：代码编写\"><a href=\"#三：代码编写\" class=\"headerlink\" title=\"三：代码编写\"></a>三：代码编写</h2><pre><code class=\"javascript\">代码编写\n1. 代码中对图片标签开启懒加载。\n\n2. 减小冗余的 &lt;view&gt; 层次嵌套。\n\n3. 为 data 赋初始值，避免在网络请求结束后赋值引起页面元素的位置变动。\n\n4. 开启代码的按需注入\n\n5. 采用 DCDN 后，各地域各运营商的绝大部分网络请求会在 0.3s 内到达，因此删除了网络请求起止的 loading 浮层动画。\n\n6. 原来为了真机调试方便，把网络请求、自定义组件的响应等打印到了 vConsole 中。目前线上生产环境删除了所有的日志打印。\n\n7. 删除了部分无用的 css 代码。优化的部分 css 样式的选择器。\n\n8. 亲测使用骨架屏只会让人感觉页面非白屏了，但会增加首屏的时间。\n</code></pre>\n<h2 id=\"四：业务逻辑\"><a href=\"#四：业务逻辑\" class=\"headerlink\" title=\"四：业务逻辑\"></a>四：业务逻辑</h2><pre><code class=\"javascript\">1. 所有新用户（首次访问）最初进入小程序时，页面和 data 中的数据都是一样的。将这些数据作为 data 的默认值（这里是把请求数据放在vue(cteated) uniapp(onLoad) ），直接显示出来，网络请求到达后，由于 data 内容不变，不会发生页面的重新渲染。\n\n2. 用户使用程序后，将从网络请求中获取的用户数据存储到 storage 中。\n\n3. 对于长列表改为数据分页加载。\n</code></pre>\n<h1 id=\"支付宝小程序\"><a href=\"#支付宝小程序\" class=\"headerlink\" title=\"支付宝小程序\"></a>支付宝小程序</h1><pre><code class=\"javascript\">\n核心要优化的东西：\n\n1.由于网络问题存在，所以这点应该去减少包的加载大小\n 1.1 图片等一些文件的大小\n 1.2 最后是分包 ,但是2M以内，其实分包没有实际的意义\n \n2.js 和 css 的优化 \n \n更多的优化渠道：\n    \n3.支付宝小程序内有相关的检测能力工具\n\n4.支付宝有性能研究群对接\n\n可以研究的方向：\n\n5.有些机型是存在打不开的情况的，并非所有的都是网络造成的问题\n\n6.每个机型的启动首屏加载时间都是不同的， 可以认为中高端手机启动时间就是小于低端手机\n\n7.小程序打开就涉及内存，平均每个页面需要的内存在250 - 450之间\n当前页面内存的大小，直接影响下一个页面打开的时间\n 7.1 某些手机的打开内存固定超过某个值 就会显示过高的\n \n</code></pre>\n<h1 id=\"小程序性能\"><a href=\"#小程序性能\" class=\"headerlink\" title=\"小程序性能\"></a>小程序性能</h1><pre><code class=\"javascript\">1.vuex 对启动耗时的影响\n2.mixins 对启动耗时的影响\n    vuex mixins 对启动耗时的影响和业务代码一致；比如：业务侧，在小程序启动阶段执行了大量、繁重的业务逻辑 会造成启动耗时过长，如果这部分业务逻辑是在 vuex mixins 也会造成启动耗时增长。\n\n3.子组件中的请求是从onReady 加载完再去调用请求的，所以是否组件中不要使用请求?  \n  \n4.挂载到原型上的东西 ,每次生成的页面都会执行这个数据 , 这里的影响多大?\n   \n5.有没有根据包大小计算出来的 平均启动时间/加载耗时   \n    1.计算最佳收益点\n    2.其实这里想表达的是否2M 和 1.5M的包下载时间的差距是否几乎不计?\n\n6.从小程序加载流程上来讲，对于首次打开小程序用户，会去下载包，包大会造成下载时间变长（在相同网络条件下）；影响启动耗时的直接因素：\n● 平台：不同的平台下（安卓、IOS）设备性能、操作系统、框架实现、优化方案存在较大的差异，启动耗时也存在较大的差异。只有分平台比较启动耗时（包括各阶段耗时）才有意义；\n    1.怎么做到只是针对某个机型去判断?\n    2.是不是要去处理慢的机型呢? 怎么处理是个问题\n● 下载比例及大小：代码包下载和更新都会显著影响小程序启动耗时，在其他流程耗时稳定的情况下，下载比例升高会影响大盘启动耗时。\n● 入口页面：不同页面启动时，根据所在分包的不同，需要下载的代码包数量和大小和代码注入量都存在差异。不同页面渲染耗时也存在差异。\n● 机型分布：启动耗时和设备性能有较强关联，不同小程序或使用场景用户群体的差异可能导致机型分布的差异，进而影响大盘启动耗时。\n● 网络环境：网络环境主要影响网络请求的耗时，如小程序信息获取、代码包下载等。\n间接因素：\n● 场景/访问来源：不同场景下，用户访问的页面不同，新用户比例也有差异，对启动耗时会有一定影响。此外，用户访问的目的性和自身的等待意愿也有差异，也会影响打开率。\n    1.这里可能存在有些页面分享进来的，但是这个页面其实是不允许直接进入的，可能会造成某些问题导致的耗时\n    2.进入的页面不是首页，这是一种什么场景?\n● 首次访问用户比例：用户首次访问小程序时，需要完整的进行小程序信息准备、代码包下载的流程，代码缓存也需要重新生成，启动耗时会比非首次访问高。\n● 小程序版本更新：小程序版本更新时，用户需要更新小程序信息和代码包，代码缓存也需要重新生成，启动耗时会出现上涨。\n    1.这个其实就是每次更新版本对启动时长的影响，特别是发布灰度的时候\n    2.一段时间不发新版本,启动时间会降低。这里其实说明我们登报的人，他存在多次进来看的情况（这个是肯定的）\n\n\n    \n</code></pre>\n",
            "tags": [
                "前端开发",
                "小程序",
                "小程序"
            ]
        },
        {
            "id": "http://yoursite.com/front-end/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7vue%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95/",
            "url": "http://yoursite.com/front-end/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7vue%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95/",
            "title": "微信公众号vue实现登录",
            "date_published": "2021-06-25T08:43:00.000Z",
            "content_html": "<pre><code class=\"javascript\">\n1. 在Vue项目中安装并引入微信 JS-SDK库（jweixin.js）。\nnpm install weixin-js-sdk\n引入 import wx from &#39;weixin-js-sdk&#39;;\n\n2. 在Vue的组件中，创建一个用于授权登录的按钮，并定义触发登录的方法。\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;button @click=&quot;wechatLogin&quot;&gt;微信登录&lt;/button&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\nmethods: &#123;\n  wechatLogin() &#123;\n    // 微信公众号授权登录的逻辑\n  &#125;\n&#125;\n\n3. 在微信授权登录的方法内部，进行微信 JS-SDK的初始化和授权登录操作。\n// 引入后端提供的获取微信 JS-SDK配置的接口\nimport &#123; getWechatConfig &#125; from &#39;@/api/wechat&#39;; // 替换成实际的接口路径\n\nmethods: &#123;\n  async wechatLogin() &#123;\n    const config = await getWechatConfig(); // 调用后端接口获取微信 JS-SDK的配置信息\n    wx.config(&#123;\n      debug: false,\n      appId: config.appId,\n      timestamp: config.timestamp,\n      nonceStr: config.nonceStr,\n      signature: config.signature,\n      jsApiList: [&#39;checkJsApi&#39;, &#39;authorize&#39;] // 需要使用的微信 API 列表\n    &#125;);\n\n    wx.error(function(res) &#123;\n      // 初始化失败的处理逻辑\n      console.error(&#39;微信 JS-SDK初始化失败:&#39;, res);\n    &#125;);\n\n    const vm = this;\n    wx.ready(function() &#123;\n      // 在这里执行授权登录操作\n      wx.authorize(&#123;\n        scope: &#39;snsapi_base&#39;,\n        success: function(res) &#123;\n          // 用户同意授权，可以获取到用户的基本信息\n          const code = res.code; // 获取到授权登录的code\n          // 在这里可以将code发送到服务器进行进一步处理\n          console.log(&#39;授权登录成功，code:&#39;, code);\n        &#125;,\n        fail: function(res) &#123;\n          // 用户拒绝授权或授权失败\n          console.log(&#39;授权登录失败:&#39;, res);\n        &#125;\n      &#125;);\n    &#125;);\n  &#125;\n&#125;\n\n</code></pre>\n",
            "tags": [
                "前端开发",
                "微信公众号",
                "微信公众号"
            ]
        },
        {
            "id": "http://yoursite.com/front-end/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7html%20js%20%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95/",
            "url": "http://yoursite.com/front-end/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7html%20js%20%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95/",
            "title": "微信公众号html js 实现登录",
            "date_published": "2021-06-25T08:43:00.000Z",
            "content_html": "<pre><code class=\"JavaScript\">1. 在微信公众平台上创建并配置好您的公众号，获取到相应的开发者ID（AppID）和密钥（AppSecret）。\n\n2. 在您的网页中引入微信 JS-SDK，以便与微信进行交互。可以使用以下 JS 代码进行引入：\nscript src=&quot;http://res.wx.qq.com/open/js/jweixin-1.6.0.js&quot;&gt;&lt;/script&gt;\n\n\n3. 初始化微信 JS-SDK，设置相关配置信息，并在初始化完成后执行授权登录操作。可以使用以下 JS 代码进行初始化和授权登录操作：\nwx.config(&#123;\n    appId: &#39;YOUR_APP_ID&#39;,\n    timestamp: &#39;TIMESTAMP&#39;,\n    nonceStr: &#39;NONCE_STR&#39;,\n    signature: &#39;SIGNATURE&#39;,\n    jsApiList: [&#39;checkJsApi&#39;, &#39;chooseWXPay&#39;, &#39;openLocation&#39;, &#39;scanQRCode&#39;, &#39;authorize&#39;] // 需要使用的微信 API 列表\n&#125;);\n\nwx.ready(function() &#123;\n    // 在这里执行授权登录操作\n    wx.authorize(&#123;\n        scope: &#39;snsapi_base&#39;,\n        success: function(res) &#123;\n            // 用户同意授权，可以获取到用户的基本信息\n            var code = res.code; // 获取到授权登录的code\n            // 在这里可以将code发送到服务器进行进一步处理\n        &#125;,\n        fail: function(res) &#123;\n            // 用户拒绝授权或授权失败\n            console.log(res);\n        &#125;\n    &#125;);\n&#125;);\n\n请将 YOUR_APP_ID 替换为您的公众号的开发者ID，TIMESTAMP、NONCE_STR 和 SIGNATURE 替换为相应的值，这些信息可以通过后台服务器签名获取。\n\n\n4. 根据需要进行进一步的处理。在获得用户授权登录的code后，您可以将其发送到后台服务器，通过调用微信提供的接口来获取用户的详细信息或执行其他操作。\n\n</code></pre>\n",
            "tags": [
                "前端开发",
                "微信公众号",
                "微信公众号"
            ]
        },
        {
            "id": "http://yoursite.com/front-end/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/",
            "url": "http://yoursite.com/front-end/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/",
            "title": "前端性能优化",
            "date_published": "2021-06-25T08:43:00.000Z",
            "content_html": "<h2 id=\"一：前端性能优化方向\"><a href=\"#一：前端性能优化方向\" class=\"headerlink\" title=\"一：前端性能优化方向\"></a>一：前端性能优化方向</h2><pre><code class=\"javascript\">1.加载性能:如何更快地把资源从服务器中拉到浏览器，如 http 与资源体积的各种优化，都是旨在加载性能的提升。\n2.渲染性能:如何更快的把资源在浏览器上进行渲染。如减少重排重绘，rIC 等都是旨在渲染性能的提升。\n</code></pre>\n<h2 id=\"二：核心性能指标与-Performance-API\"><a href=\"#二：核心性能指标与-Performance-API\" class=\"headerlink\" title=\"二：核心性能指标与 Performance API\"></a>二：核心性能指标与 Performance API</h2><pre><code class=\"javascript\">LCP: 加载性能。最大内容绘制应在 2.5s 内完成。\nFID: 交互性能。首次输入延迟应在 100ms 内完成。\nCLS: 页面稳定性。累积布局偏移，需手动计算，CLS 应保持在 0.1 以下。\n</code></pre>\n<h2 id=\"三：计算与收集\"><a href=\"#三：计算与收集\" class=\"headerlink\" title=\"三：计算与收集\"></a>三：计算与收集</h2><pre><code class=\"javascript\">当收集浏览器端每个用户核心性能指标时，可通过 web-vitals 收集并通过 sendBeacon (opens new window)上报到打点系统。\n\nimport &#123; getCLS, getFID, getLCP &#125; from &#39;web-vitals&#39;\n\nfunction sendToAnalytics(metric) &#123;\n  const body = JSON.stringify(metric);\n  navigator.sendBeacon(&#39;/analytics&#39;, body))\n&#125;\n\ngetCLS(sendToAnalytics);\ngetFID(sendToAnalytics);\ngetLCP(sendToAnalytics);\n</code></pre>\n<h2 id=\"四：更快的传输\"><a href=\"#四：更快的传输\" class=\"headerlink\" title=\"四：更快的传输\"></a>四：更快的传输</h2><h3 id=\"1：CDN\"><a href=\"#1：CDN\" class=\"headerlink\" title=\"1：CDN\"></a>1：CDN</h3><pre><code class=\"javascript\">将资源分发到 CDN 的边缘网络节点，使用户可就近获取所需内容，大幅减小了光纤传输距离，使全球各地用户打开网站都拥有良好的网络体验。\n</code></pre>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9pbWcuYWxpY2RuLmNvbS9pbWdleHRyYS9pNC9PMUNOMDFaRTNQdEcyMkVvTU55QXY5TF8hITYwMDAwMDAwMDcwODktMi10cHMtMTUzMC0xMTQwLnBuZw==\">图片演示链接</span></p>\n<h3 id=\"2：http2\"><a href=\"#2：http2\" class=\"headerlink\" title=\"2：http2\"></a>2：http2</h3><pre><code class=\"javascript\">http2 的诸多特性决定了它更快的传输速度。\n\n1.多路复用，在浏览器可并行发送 N 条请求。\n2.首部压缩，更小的负载体积。\n3.请求优先级，更快的关键请求\n目前，网站已大多上了 http2，可在控制台面板进行查看。\n\n\n由于 http2 可并行请求，解决了 http1.1 线头阻塞的问题，以下几个性能优化点将会过时\n\n资源合并。如 https://shanyue.tech/assets??index.js,interview.js,report.js\n域名分片。\n雪碧图。将无数小图片合并成单个大图片。\n</code></pre>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3NoZnNoYW55dWUvYXNzZXRzQG1hc3Rlci9zcmMvaDIuNzU4MmE0ZnZ0eDAwLnBuZw==\">图片演示链接</span></p>\n<h3 id=\"3：充分利用-HTTP-缓存\"><a href=\"#3：充分利用-HTTP-缓存\" class=\"headerlink\" title=\"3：充分利用 HTTP 缓存\"></a>3：充分利用 HTTP 缓存</h3><pre><code class=\"javascript\">更好的资源缓存策略，对于 CDN 来讲可减少回源次数，对于浏览器而言可减少请求发送次数。无论哪一点，对于二次网站访问都具有更好的访问体验。\n\n一:缓存策略\n  1.强缓存: 打包后带有 hash 值的资源 (如 /build/a3b4c8a8.js)\n  2.协商缓存: 打包后不带有 hash 值的资源 (如 /index.html)\n二:分包加载 (Bundle Spliting)\n  1.避免一行代码修改导致整个 bundle 的缓存失效\n</code></pre>\n<h3 id=\"4：减少-HTTP-请求及负载\"><a href=\"#4：减少-HTTP-请求及负载\" class=\"headerlink\" title=\"4：减少 HTTP 请求及负载\"></a>4：减少 HTTP 请求及负载</h3><pre><code class=\"javascript\">对一个网站的资源进行压缩优化，从而达到减少 HTTP 负载的目的。\n\njs/css/image 等常规资源体积优化，这是一个大话题，再以下分别讨论\n1.小图片优化，将小图片内联为 Data URI，减小请求数量\n2.图片懒加载\n3.新的 API: IntersectionObserver API\n4.新的属性: loading=lazy\n</code></pre>\n<h2 id=\"五：更小的体积\"><a href=\"#五：更小的体积\" class=\"headerlink\" title=\"五：更小的体积\"></a>五：更小的体积</h2><h3 id=\"1：gzip-x2F-brotli\"><a href=\"#1：gzip-x2F-brotli\" class=\"headerlink\" title=\"1：gzip&#x2F;brotli\"></a>1：gzip&#x2F;brotli</h3><pre><code class=\"javascript\">对 JS、CSS、HTML 等文本资源均有效，但是对图片效果不大。\n\ngzip 通过 LZ77 算法与 Huffman 编码来压缩文件，重复度越高的文件可压缩的空间就越大。\nbrotli 通过变种的 LZ77 算法、Huffman 编码及二阶文本建模来压缩文件，更先进的压缩算法，比 gzip 有更高的性能及压缩率\n可在浏览器的 Content-Encoding 响应头查看该网站是否开启了压缩算法，目前知乎、掘金等已全面开启了 brotli 压缩。\n\n\n\n# Request Header\nAccept-Encoding: gzip, deflate, br\n\n# gzip\nContent-Encoding: gzip\n\n# gzip\nContent-Encoding: br\n</code></pre>\n<h3 id=\"2：压缩混淆工具\"><a href=\"#2：压缩混淆工具\" class=\"headerlink\" title=\"2：压缩混淆工具\"></a>2：压缩混淆工具</h3><pre><code class=\"javascript\">1.Terser (opens new window)是 Javascript 资源压缩混淆的神器。\n\n它可以根据以下策略进行压缩处理:\n\n长变量名替换短变量\n删除空格换行符\n预计算: const a = 24 * 60 * 60 * 1000 -&gt; const a = 86400000\n移除无法被执行的代码·\n移除无用的变量及函数\n可在 Terser Repl (opens new window)在线查看代码压缩效果。\n\n\n2.swc (opens new window)是另外一个用以压缩 Javascript 的工具，它拥有与 terser 相同的 API，由于它是由 rust 所写，因此它拥有更高的性能。\n\n\n3.html-minifier-terser (opens new window)用以压缩 HTML 的工具\n</code></pre>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3NoZnNoYW55dWUvYXNzZXRzQG1hc3Rlci9zcmMvdGVyc2VyLjFiYjFzNXYzdHQ0dy5wbmc=\">图片演示链接</span></p>\n<h3 id=\"3：更小的-Javascript\"><a href=\"#3：更小的-Javascript\" class=\"headerlink\" title=\"3：更小的 Javascript\"></a>3：更小的 Javascript</h3><pre><code class=\"javascript\">关于更小的 Javascript，上边已总结了两条:\n\ngzip/brotli\nterser (minify)\n还有以下几点可以考虑考虑:\n\n路由懒加载，无需加载整个应用的资源\nTree Shaking: 无用导出将在生产环境进行删除\nbrowserlist/babel: 及时更新 browserlist，将会产生更小的垫片体积\n再补充一个问题:\n\n如何分析并优化当前项目的 Javascript 体积？如果使用 webpack 那就简单很多。\n\n使用 webpack-bundle-analyze 分析打包体积\n对一些库替换为更小体积的库，如 moment -&gt; dayjs\n对一些库进行按需加载，如 import lodash -&gt; import lodash/get\n对一些库使用支持 Tree Shaking，如 import lodash -&gt; import lodash-es\n</code></pre>\n<h3 id=\"4：更小的图片\"><a href=\"#4：更小的图片\" class=\"headerlink\" title=\"4：更小的图片\"></a>4：更小的图片</h3><pre><code class=\"javascript\">在前端发展的现在，webp 普遍比 jpeg/png 更小，而 avif 又比 webp 小一个级别\n\n为了无缝兼容，可选择 picture/source 进行回退处理\n&lt;picture&gt;\n  &lt;source srcset=&quot;img/photo.avif&quot; type=&quot;image/avif&quot;&gt;\n  &lt;source srcset=&quot;img/photo.webp&quot; type=&quot;image/webp&quot;&gt;\n  &lt;img src=&quot;img/photo.jpg&quot; width=&quot;360&quot; height=&quot;240&quot;&gt;\n&lt;/picture&gt;\n\n1.更合适的尺寸: 当页面仅需显示 100px/100px 大小图片时，对图片进行压缩到 100px/100px\n2.更合适的压缩: 可对前端图片进行适当压缩，如通过 sharp 等\n</code></pre>\n<h2 id=\"六：渲染优化\"><a href=\"#六：渲染优化\" class=\"headerlink\" title=\"六：渲染优化\"></a>六：渲染优化</h2><h3 id=\"1：关键渲染路径\"><a href=\"#1：关键渲染路径\" class=\"headerlink\" title=\"1：关键渲染路径\"></a>1：关键渲染路径</h3><pre><code class=\"javascript\">以下五个步骤为关键渲染路径\n\n1.HTML -&gt; DOM，将 html 解析为 DOM\n2.CSS -&gt; CSSOM，将 CSS 解析为 CSSOM\n3.DOM/CSSOM -&gt; Render Tree，将 DOM 与 CSSOM 合并成渲染树\n4.RenderTree -&gt; Layout，确定渲染树中每个节点的位置信息\n5.Layout -&gt; Paint，将每个节点渲染在浏览器中\n渲染的优化很大程度上是对关键渲染路径进行优化。\n</code></pre>\n<h3 id=\"2：preload-x2F-prefetch\"><a href=\"#2：preload-x2F-prefetch\" class=\"headerlink\" title=\"2：preload&#x2F;prefetch\"></a>2：preload&#x2F;prefetch</h3><pre><code class=\"javascript\">preload/prefetch 可控制 HTTP 优先级，从而达到关键请求更快响应的目的。\n\n&lt;link rel=&quot;prefetch&quot; href=&quot;style.css&quot; as=&quot;style&quot;&gt;\n&lt;link rel=&quot;preload&quot; href=&quot;main.js&quot; as=&quot;script&quot;&gt;\n1.preload 加载当前路由必需资源，优先级高。一般对于 Bundle Spliting 资源与 Code Spliting 资源做 preload\n2.prefetch 优先级低，在浏览器 idle 状态时加载资源。一般用以加载其它路由资源，如当页面出现 Link，可 prefetch 当前 Link 的路由资源。（next.js 默认会对 link 做懒加载+prefetch，即当某条 Link 出现页面中，即自动 prefetch 该 Link 指向的路由资源\n捎带说一下 dns-prefetch，可对主机地址的 DNS 进行预解析。\n\n&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//shanyue.tech&quot;&gt;\n</code></pre>\n<h3 id=\"3：防抖与节流\"><a href=\"#3：防抖与节流\" class=\"headerlink\" title=\"3：防抖与节流\"></a>3：防抖与节流</h3><pre><code class=\"javascript\">1.防抖：防止抖动，单位时间内事件触发会被重置，避免事件被误伤触发多次。代码实现重在清零 clearTimeout。防抖可以比作等电梯，只要有一个人进来，就需要再等一会儿。业务场景有避免登录按钮多次点击的重复提交。\n\n2.节流：控制流量，单位时间内事件只能触发一次，与服务器端的限流 (Rate Limit) 类似。代码实现重在开锁关锁 timer=timeout; timer=null。节流可以比作过红绿灯，每等一个红灯时间就可以过一批。\n\n\n无论是防抖还是节流都可以大幅度减少渲染次数，在 React 中还可以使用 use-debounce 之类的 hooks 避免重新渲染。\n\nimport React, &#123; useState &#125; from &#39;react&#39;;\nimport &#123; useDebounce &#125; from &#39;use-debounce&#39;;\n\nexport default function Input() &#123;\n  const [text, setText] = useState(&#39;Hello&#39;);\n  // 一秒钟渲染一次，大大降低了重新渲染的频率\n  const [value] = useDebounce(text, 1000);\n\n  return (\n    &lt;div&gt;\n      &lt;input\n        defaultValue=&#123;&#39;Hello&#39;&#125;\n        onChange=&#123;(e) =&gt; &#123;\n          setText(e.target.value);\n        &#125;&#125;\n      /&gt;\n      &lt;p&gt;Actual value: &#123;text&#125;&lt;/p&gt;\n      &lt;p&gt;Debounce value: &#123;value&#125;&lt;/p&gt;\n    &lt;/div&gt;\n  );\n&#125;\n</code></pre>\n<h3 id=\"4：虚拟列表优化\"><a href=\"#4：虚拟列表优化\" class=\"headerlink\" title=\"4：虚拟列表优化\"></a>4：虚拟列表优化</h3><pre><code class=\"javascript\">这又是一个老生常谈的话题，一般在视口内维护一个虚拟列表(仅渲染十几条条数据左右)，监听视口位置变化，从而对视口内的虚拟列表进行控制。\n\n在 React 中可采用以下库:\n\nreact-virtualized(opens new window)\nreact-window\n</code></pre>\n<h3 id=\"5：请求及资源缓存\"><a href=\"#5：请求及资源缓存\" class=\"headerlink\" title=\"5：请求及资源缓存\"></a>5：请求及资源缓存</h3><pre><code class=\"javascript\">在一些前端系统中，当加载页面时会发送请求，路由切换出去再切换回来时又会重新发送请求，每次请求完成后会对页面重新渲染。\n\n然而这些重新请求再大多数时是没有必要的，合理地对 API 进行缓存将达到优化渲染的目的。\n\n1.对每一条 GET API 添加 key\n2.根据 key 控制该 API 缓存，重复发生请求时将从缓存中取得\n\nfunction Example() &#123;\n  // 设置缓存的 Key 为 Users:10086\n  const &#123; isLoading, data &#125; = useQuery([&#39;users&#39;, userId], () =&gt; fetchUserById(userId))\n&#125;\n</code></pre>\n<h2 id=\"七：Web-Worker\"><a href=\"#七：Web-Worker\" class=\"headerlink\" title=\"七：Web Worker\"></a>七：Web Worker</h2><pre><code class=\"javascript\">试举一例:\n\n在纯浏览器中，如何实现高性能的实时代码编译及转换？\n\n1.Babel Repl(opens new window)\n如果纯碎使用传统的 Javascript 实现，将会耗时过多阻塞主线程，有可能导致页面卡顿。\n\n如果使用 Web Worker 交由额外的线程来做这件事，将会高效很多，基本上所有在浏览器端进行代码编译的功能都由 Web Worker 实现。\n</code></pre>\n<h2 id=\"八：WASM\"><a href=\"#八：WASM\" class=\"headerlink\" title=\"八：WASM\"></a>八：WASM</h2><pre><code class=\"javascript\">1.JS 性能低下\n2.C++/Rust 高性能\n3.使用 C++/Rust 编写代码，然后在 Javascript 环境运行\n试举一例:\n\n在纯浏览器中，如何实现高性能的图片压缩？\n\n基本上很难做到，Javascript 的性能与生态决定了实现图片压缩的艰难。\n\n而借助于 WASM 就相当于借用了其它语言的生态。\n\n1.libavif (opens new window): C语言写的 avif 解码编码库\n2.libwebp (opens new window): C语言写的 webp 解码编码库\n3.mozjpeg (opens new window): C语言写的 jpeg 解码编码库\n4.oxipng (opens new window): Rust语言写的 png 优化库\n而由于 WASM，完全可以把这些其它语言的生态移植到浏览器中，从而实现一个高性能的离线式的图片压缩工具。\n\n如果想了解这种的工具，请看看 squoosh\n</code></pre>\n",
            "tags": [
                "前端开发",
                "前端性能优化",
                "前端性能优化"
            ]
        },
        {
            "id": "http://yoursite.com/front-end/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E9%9D%A2%E8%AF%95/",
            "url": "http://yoursite.com/front-end/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E9%9D%A2%E8%AF%95/",
            "title": "前端性能优化三大方向",
            "date_published": "2021-06-25T08:43:00.000Z",
            "content_html": "<h1 id=\"浏览器缓存优化\"><a href=\"#浏览器缓存优化\" class=\"headerlink\" title=\"浏览器缓存优化\"></a>浏览器缓存优化</h1><p>为了让浏览器缓存发挥最大作用，该策略尽量遵循以下五点就能发挥浏览器缓存最大作用。</p>\n<p>「考虑拒绝一切缓存策略」：Cache-Control:no-store<br>「考虑资源是否每次向服务器请求」：Cache-Control:no-cache<br>「考虑资源是否被代理服务器缓存」：Cache-Control:public&#x2F;private<br>「考虑资源过期时间」：Expires:t&#x2F;Cache-Control:max-age&#x3D;t,s-maxage&#x3D;t<br>「考虑协商缓存」：Last-Modified&#x2F;Etag<br>缓存策略通过设置HTTP报文实现，在形式上分为<strong>「强缓存&#x2F;强制缓存」和「协商缓存&#x2F;对比缓存」</strong>。为了方便对比，笔者将某些细节使用图例展示，相信你有更好的理解。</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/80c0b755bd4f4b7f8cc4f9447f1a1bde.png#pic_center\"></p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/0bfe2b2f1ea54e1aa6bf08d2c932ca0a.png#pic_center\"></p>\n<p>整个缓存策略机制很明了，先走强缓存，若命中失败才走协商缓存。若命中强缓存，直接使用强缓存；若未命中强缓存，发送请求到服务器检查是否命中协商缓存；若命中协商缓存，服务器返回304通知浏览器使用本地缓存，否则返回最新资源。</p>\n<p>有两种较常用的应用场景值得使用缓存策略一试，当然更多应用场景都可根据项目需求制定。</p>\n<p>「频繁变动资源」：设置Cache-Control:no-cache，使浏览器每次都发送请求到服务器，配合Last-Modified&#x2F;ETag验证资源是否有效<br>「不常变化资源」：设置Cache-Control:max-age&#x3D;31536000，对文件名哈希处理，当代码修改后生成新的文件名，当HTML文件引入文件名发生改变才会下载最新文件</p>\n<h1 id=\"渲染层面性能优化\"><a href=\"#渲染层面性能优化\" class=\"headerlink\" title=\"渲染层面性能优化\"></a>渲染层面性能优化</h1><p><strong>「渲染层面」</strong>的性能优化，无疑是如何让代码解析更好执行更快。因此笔者从以下五方面做出建议。</p>\n<p>「CSS策略」：基于CSS规则<br>「DOM策略」：基于DOM操作<br>「阻塞策略」：基于脚本加载<br>「回流重绘策略」：基于回流重绘<br>「异步更新策略」：基于异步更新<br>上述五方面都是编写代码时完成，充满在整个项目流程的开发阶段里。因此在开发阶段需时刻注意以下涉及到的每一点，养成良好的开发习惯，性能优化也自然而然被使用上了。</p>\n<p>渲染层面的性能优化更多表现在编码细节上，而并非实体代码。简单来说就是遵循某些编码规则，才能将渲染层面的性能优化发挥到最大作用。</p>\n<p><strong>「回流重绘策略」</strong>在渲染层面的性能优化里占比较重，也是最常规的性能优化之一。上年笔者发布的掘金小册《玩转CSS的艺术之美》使用一整章讲解回流重绘，本章已开通试读，更多细节请戳这里。</p>\n<p>CSS策略<br>避免出现超过三层的嵌套规则<br>避免为ID选择器添加多余选择器<br>避免使用标签选择器代替类选择器<br>避免使用通配选择器，只对目标节点声明规则<br>避免重复匹配重复定义，关注可继承属性<br>DOM策略<br>缓存DOM计算属性<br>避免过多DOM操作<br>使用DOMFragment缓存批量化DOM操作<br>阻塞策略<br>脚本与DOM&#x2F;其它脚本的依赖关系很强：对<script>设置defer<br>脚本与DOM/其它脚本的依赖关系不强：对<script>设置async<br>回流重绘策略<br>缓存DOM计算属性<br>使用类合并样式，避免逐条改变样式<br>使用display控制DOM显隐，将DOM离线化<br>异步更新策略<br>在异步任务中修改DOM时把其包装成微任务</p>\n<h1 id=\"性能优化六大指标\"><a href=\"#性能优化六大指标\" class=\"headerlink\" title=\"性能优化六大指标\"></a>性能优化六大指标</h1><p>六大指标基本囊括大部分性能优化细节，可作为九大策略的补充。笔者根据每条性能优化建议的特征将指标划分为以下六方面。</p>\n<p>「加载优化」：资源在加载时可做的性能优化<br>「执行优化」：资源在执行时可做的性能优化<br>「渲染优化」：资源在渲染时可做的性能优化<br>「样式优化」：样式在编码时可做的性能优化<br>「脚本优化」：脚本在编码时可做的性能优化<br>「V8引擎优化」：针对V8引擎特征可做的性能优化</p>\n",
            "tags": [
                "前端开发",
                "前端性能优化",
                "前端性能优化"
            ]
        },
        {
            "id": "http://yoursite.com/front-end/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3/",
            "url": "http://yoursite.com/front-end/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3/",
            "title": "浏览器相关知识",
            "date_published": "2021-06-25T08:43:00.000Z",
            "content_html": "<h1 id=\"常见的浏览器内核有哪些？\"><a href=\"#常见的浏览器内核有哪些？\" class=\"headerlink\" title=\"常见的浏览器内核有哪些？\"></a>常见的浏览器内核有哪些？</h1><p>主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。<br>渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。<br>JS引擎则：解析和执行javascript来实现网页的动态效果。<br>最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。<br>常见内核<br>Trident 内核：IE, MaxThon, TT, The World, 360, 搜狗浏览器等。[又称 MSHTML]<br>Gecko 内核：Netscape6 及以上版本，FF, MozillaSuite &#x2F; SeaMonkey 等<br>Presto 内核：Opera7 及以上。 [Opera内核原为：Presto，现为：Blink;]<br>Webkit 内核：Safari, Chrome等。 [ Chrome的：Blink（WebKit 的分支）]</p>\n<h1 id=\"网页前端性能优化的方式有哪些？\"><a href=\"#网页前端性能优化的方式有哪些？\" class=\"headerlink\" title=\"网页前端性能优化的方式有哪些？\"></a>网页前端性能优化的方式有哪些？</h1><p>1.压缩 css, js, 图片<br>2.减少 http 请求次数， 合并 css、js 、合并图片（雪碧图）<br>3.使用 CDN<br>4.减少 dom 元素数量<br>5.图片懒加载<br>6.静态资源另外用无 cookie 的域名<br>7.减少 dom 的访问（缓存 dom）<br>8.巧用事件委托<br>9.样式表置顶、脚本置低</p>\n<h1 id=\"网页从输入网址到渲染完成经历了哪些过程？\"><a href=\"#网页从输入网址到渲染完成经历了哪些过程？\" class=\"headerlink\" title=\"网页从输入网址到渲染完成经历了哪些过程？\"></a>网页从输入网址到渲染完成经历了哪些过程？</h1><p>大致可以分为如下7步：</p>\n<p>输入网址；<br>发送到DNS服务器，并获取域名对应的web服务器对应的ip地址；<br>与web服务器建立TCP连接；<br>浏览器向web服务器发送http请求；<br>web服务器响应请求，并返回指定url的数据（或错误信息，或重定向的新的url地址）；<br>浏览器下载web服务器返回的数据及解析html源文件；<br>生成DOM树，解析css和js，渲染页面，直至显示完成；</p>\n<h1 id=\"线程与进程的区别？\"><a href=\"#线程与进程的区别？\" class=\"headerlink\" title=\"线程与进程的区别？\"></a>线程与进程的区别？</h1><p>一个程序至少有一个进程,一个进程至少有一个线程.<br>线程的划分尺度小于进程，使得多线程程序的并发性高。<br>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。<br>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。<br>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</p>\n<h1 id=\"HTTP常见的状态码？\"><a href=\"#HTTP常见的状态码？\" class=\"headerlink\" title=\"HTTP常见的状态码？\"></a>HTTP常见的状态码？</h1><p>100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息<br>200 OK 正常返回信息<br>201 Created 请求成功并且服务器创建了新的资源<br>202 Accepted 服务器已接受请求，但尚未处理<br>301 Moved Permanently 请求的网页已永久移动到新位置。<br>302 Found 临时性重定向。<br>303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。<br>304 Not Modified 自从上次请求后，请求的网页未修改过。<br>400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。<br>401 Unauthorized 请求未授权。<br>403 Forbidden 禁止访问。<br>404 Not Found 找不到如何与 URI 相匹配的资源。<br>500 Internal Server Error 最常见的服务器端错误。<br>503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。</p>\n<h1 id=\"图片懒加载？\"><a href=\"#图片懒加载？\" class=\"headerlink\" title=\"图片懒加载？\"></a>图片懒加载？</h1><p>当页面滚动的时间被触发 -&gt; 执行加载图片操作 -&gt; 判断图片是否在可视区域内 -&gt; 在，则动态将data-src的值赋予该图片</p>\n<h1 id=\"移动端性能优化？\"><a href=\"#移动端性能优化？\" class=\"headerlink\" title=\"移动端性能优化？\"></a>移动端性能优化？</h1><p>尽量使用css3动画，开启硬件加速<br>适当使用touch时间代替click时间<br>避免使用css3渐变阴影效果<br>可以用transform: translateZ(0) 来开启硬件加速<br>不滥用float。float在渲染时计算量比较大，尽量减少使用<br>不滥用web字体。web字体需要下载，解析，重绘当前页面<br>合理使用requestAnimationFrame动画代替setTimeout<br>css中的属性（css3 transitions、css3 3D transforms、opacity、webGL、video）会触发GUP渲染，耗电</p>\n<h1 id=\"TCP-传输的三次握手、四次挥手策略\"><a href=\"#TCP-传输的三次握手、四次挥手策略\" class=\"headerlink\" title=\"TCP 传输的三次握手、四次挥手策略\"></a>TCP 传输的三次握手、四次挥手策略</h1><p>三次握手：<br>为了准确无误地吧数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送出去后，TCP不会对传送后的情况置之不理，他一定会向对方确认是否送达，握手过程中使用TCP的标志：SYN和ACK<br>发送端首先发送一个带SYN的标志的数据包给对方<br>接收端收到后，回传一个带有SYN&#x2F;ACK标志的数据包以示传达确认信息<br>最后，发送端再回传一个带ACK的标志的数据包，代表“握手”结束<br>如在握手过程中某个阶段莫明中断，TCP协议会再次以相同的顺序发送相同的数据包</p>\n<p>断开一个TCP连接需要“四次挥手”<br>第一次挥手：主动关闭方发送一个FIN，用来关注主动方到被动关闭方的数据传送，也即是主动关闭方告诫被动关闭方：我已经不会再给你发数据了（在FIN包之前发送的数据，如果没有收到对应的ACK确认报文，主动关闭方依然会重发这些数据）。但是，此时主动关闭方还可以接受数据<br>第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号收到序号 +1（与SYN相同，一个 FIN占用一个序号）<br>第三次挥手：被动关闭方发送一个 FIN。用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会给你发送数据了<br>第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手</p>\n<h1 id=\"HTTP-和-HTTPS，为什么HTTPS安全？\"><a href=\"#HTTP-和-HTTPS，为什么HTTPS安全？\" class=\"headerlink\" title=\"HTTP 和 HTTPS，为什么HTTPS安全？\"></a>HTTP 和 HTTPS，为什么HTTPS安全？</h1><p>HTTP协议通常承载与 TCP协议之上，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的HTTPS<br>默认HTTP的端口号为80，HTTPS的端口号为443<br>因为网络请求需要中间有很多的服务器路由的转发，中间的节点都可能篡改信息，而如果使用HTTPS，密钥在你和终点站才有，https之所有说比http安全，是因为他利用ssl&#x2F;tls协议传输。包含证书，流量转发，负载均衡，页面适配，浏览器适配，refer传递等，保障了传输过程的安全性</p>\n<h1 id=\"axios和fetch区别对比\"><a href=\"#axios和fetch区别对比\" class=\"headerlink\" title=\"axios和fetch区别对比\"></a>axios和fetch区别对比</h1><p>axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，本质上也是对原生XHR的封装，只不过它是Promise的实现版本，符合最新的ES规范，它本身具有以下特征</p>\n<p>从浏览器中创建 XMLHttpRequest<br>支持 Promise API<br>客户端支持防止CSRF<br>提供了一些并发请求的接口（重要，方便了很多的操作）<br>从 node.js 创建 http 请求<br>拦截请求和响应<br>转换请求和响应数据<br>取消请求<br>自动转换JSON数据<br>fetch优势：</p>\n<p>语法简洁，更加语义化<br>基于标准 Promise 实现，支持 async&#x2F;await<br>同构方便，使用 isomorphic-fetch<br>更加底层，提供的API丰富（request, response）<br>脱离了XHR，是ES规范里新的实现方式<br>fetch存在问题</p>\n<p>fetch是一个低层次的API，你可以把它考虑成原生的XHR，所以使用起来并不是那么舒服，需要进行封装。<br>fetch只对网络请求报错，对400，500都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。<br>fetch默认不会带cookie，需要添加配置项： fetch(url, {credentials: ‘include’})<br>fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费<br>fetch没有办法原生监测请求的进度，而XHR可以</p>\n",
            "tags": [
                "前端开发",
                "浏览器",
                "浏览器"
            ]
        },
        {
            "id": "http://yoursite.com/front-end/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/",
            "url": "http://yoursite.com/front-end/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/",
            "title": "移动端相关适配方案",
            "date_published": "2021-06-25T08:43:00.000Z",
            "content_html": "<h1 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h1><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM0MDAzMTQvYXJ0aWNsZS9kZXRhaWxzLzEyNTQ4ODM3Ng==\">https://blog.csdn.net/u013400314/article/details/125488376</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81MjU1NTIyNDg=\">https://zhuanlan.zhihu.com/p/525552248</span></p>\n",
            "tags": [
                "前端开发",
                "移动端适配",
                "移动端适配"
            ]
        },
        {
            "id": "http://yoursite.com/front-end/%E8%AE%B0%E4%B8%80%E6%AC%A1vue%E8%BD%ACuniapp/",
            "url": "http://yoursite.com/front-end/%E8%AE%B0%E4%B8%80%E6%AC%A1vue%E8%BD%ACuniapp/",
            "title": "记一次vue转uniapp",
            "date_published": "2021-06-25T08:43:00.000Z",
            "content_html": "<h1 id=\"vue的相关标签怎么转\"><a href=\"#vue的相关标签怎么转\" class=\"headerlink\" title=\"vue的相关标签怎么转?\"></a>vue的相关标签怎么转?</h1><pre><code class=\"text\">div  header main section -&gt; view\nspan -&gt; text\nul li -&gt; view ?  这个还不太确定，这个只要有样式类的情况下直接改\nimg -&gt; image   这里注意的是转成uniapp的image标签要把宽高都设置一下  \n    \n总结为只要有class类的情况下，基本上都是用的view\n</code></pre>\n<p>#字体处理： px 转 rpx  2倍化怎么处理？ 全局样式怎么转化?</p>\n<pre><code class=\"text\">uniapp有个&lt;page-meta :root-font-size=&quot;&#39;12px&#39;&quot;/&gt;\n1rem 就是12px\n\n现在某个页面盒子得大小是22px  但是实际我需要得大小是44px  \nso  在不改变前面数字得情况下，\n\n1rem = 2px\n\n\n但是这个是有一定缺陷的，浏览器里最小的字体是12px ,如果字体大小已经写死的情况下就不能用了   \nso  其实还有一个办法，直接全局替换px 为 px * 2  \n</code></pre>\n<h1 id=\"对于已经使用axios写得api接口，怎么快速转化成uniapp的请求方式\"><a href=\"#对于已经使用axios写得api接口，怎么快速转化成uniapp的请求方式\" class=\"headerlink\" title=\"对于已经使用axios写得api接口，怎么快速转化成uniapp的请求方式\"></a>对于已经使用axios写得api接口，怎么快速转化成uniapp的请求方式</h1><pre><code class=\"javascript\">针对当前的项目，进行对函数导出和数据传入进行分布封装\n\nimport config from &quot;@/config/index.js&quot;\nimport store from &#39;@/store/index.js&#39;;\n\nexport const requestApi = (options) =&gt; &#123;\n\n    const ppsessid = store.state.user.ppSessId\n    const sessid = store.state.user.sessId\n    const cid = store.state.env.cid\n\n    const publicHeaders = &#123;\n        &quot;Content-Type&quot;: &quot;application/json&quot;,\n        &#39;Accept&#39;: &#39;application/json&#39;,\n        &#39;X-Yf-CID&#39;: cid,\n        &#39;X-Yf-PPSessid&#39; : ppsessid,\n        &#39;X-Yf-Sessid&#39; : sessid\n    &#125;\n    return (function() &#123;\n        let &#123;\n            url,\n            method,\n            params,\n            data\n        &#125; = options\n        // console.log(&#39;options&#39;, options)\n        return new Promise((resolve, reject) =&gt; &#123;\n            uni.request(&#123;\n                url: config.url.devServer + url,\n                method: method || &#39;GET&#39;,\n                header: publicHeaders,\n                data: data || params,\n                success: (res) =&gt; &#123;\n                    resolve(res);\n                &#125;,\n                fail: (err) =&gt; &#123;\n                    reject(err);\n                &#125;\n            &#125;)\n        &#125;);\n    &#125;)(options)\n&#125;\n</code></pre>\n<h1 id=\"vue中的good-storage-unaiapp的替代方案\"><a href=\"#vue中的good-storage-unaiapp的替代方案\" class=\"headerlink\" title=\"vue中的good-storage    unaiapp的替代方案\"></a>vue中的good-storage    unaiapp的替代方案</h1><pre><code class=\"javascript\">这个js库其实就是一个操作缓存的库\n\n自己封装一个简单的对象即可解决\n\nlet storage = &#123;&#125;\nstorage.get = function(options) &#123;\n    uni.getStorageSync(options)\n&#125;\nstorage.set = function(options) &#123;\n    uni.setStorageSync(options)\n&#125;\nstorage.remove = function(options) &#123;\n    uni.removeStorageSync(options)\n&#125;\n</code></pre>\n<h1 id=\"vue中的相关跳转\"><a href=\"#vue中的相关跳转\" class=\"headerlink\" title=\"vue中的相关跳转\"></a>vue中的相关跳转</h1><pre><code class=\"javascript\">1.封装vue的原型对象。这个是最方便的，但是需要适配一些东西，? 可以试一下。\n\n2.\npush -&gt; navigateTo  \nreplace -&gt; redirectTo\n\n\nback  -&gt; \n    \n    let pages = getCurrentPages(); // 当前页面\n                    let beforePage = pages[pages.length - 2]; // 上一页\n                    uni.navigateBack(&#123;\n                        success: function() &#123;\n                            beforePage.onLoad(); // 执行上一页的onLoad方法\n                        &#125;\n                    &#125;);\n</code></pre>\n<h1 id=\"怎么快速的处理css样式完成转化\"><a href=\"#怎么快速的处理css样式完成转化\" class=\"headerlink\" title=\"怎么快速的处理css样式完成转化\"></a>怎么快速的处理css样式完成转化</h1><pre><code class=\"javascript\">采取   \n1.就地取材\n2.转vue标签为类\n\n举个例子。 比如当前的页面p 标签哟样式，就直接，吧类名变成p ,然后p标签改为view\n</code></pre>\n<h1 id=\"路由相关\"><a href=\"#路由相关\" class=\"headerlink\" title=\"路由相关\"></a>路由相关</h1><pre><code class=\"java\">this.$route.query.canshu1  \n    就是在 onload 里接收 options 里接收canshu1  \n</code></pre>\n<h1 id=\"记一次ui-li-scss-转化的过程\"><a href=\"#记一次ui-li-scss-转化的过程\" class=\"headerlink\" title=\"记一次ui li  scss 转化的过程\"></a>记一次ui li  scss 转化的过程</h1><pre><code class=\"javascript\">\n*****转化之前\n\n&lt;ul&gt;\n    &lt;template v-if=&quot;currentSku.coupon &amp;&amp; currentSku.coupon.length&quot;&gt;\n        &lt;li class=&quot;has-coupon&quot; v-for=&quot;(item, index) in currentSku.coupon.slice(0, 2)&quot;\n        :key=&quot;index&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/li&gt;\n    &lt;/template&gt;\n    &lt;li v-else&gt;暂无优惠券&lt;/li&gt;\n&lt;/ul&gt;\n\n.goods-tickets &#123;\n        ul &#123;\n          display: flex;\n          li &#123;\n            color: #378BF7;\n            &amp;.has-coupon &#123;\n              display: flex;\n              align-items: center;\n              height: 20px * 2;\n              font-size: 12px * 2;\n              padding: 0 9px * 2;\n              margin-right: 6px * 2;\n              background-color: #378BF7;\n              background-repeat: no-repeat;\n              position: relative;\n              overflow: hidden;\n              color: #FFFFFF;\n              &amp;:last-child &#123;\n                margin-right: 0;\n              &#125;\n              &amp;:before, &amp;:after &#123;\n                content: &#39;&#39;;\n                display: block;\n                position: absolute;\n                width: 8px * 2;\n                height: 8px * 2;\n                background-color: #FFF;\n                border-radius: 50%;\n                top: 50%;\n                transform: translateY(-50%);\n              &#125;\n              &amp;:before &#123;\n                left: -4px * 2;\n              &#125;\n              &amp;:after &#123;\n                right: -4px * 2;\n              &#125;\n            &#125;\n          &#125;\n        &#125;\n      &#125;\n\n\n *****转化过后\n\n&lt;view class=&quot;ul222&quot;&gt;\n    &lt;template v-if=&quot;currentSku.coupon &amp;&amp; currentSku.coupon.length&quot;&gt;\n        &lt;view class=&quot;has-coupon&quot; v-for=&quot;(item, index) in currentSku.coupon.slice(0, 2)&quot;\n        :key=&quot;index&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/view&gt;\n    &lt;/template&gt;\n    &lt;view v-else&gt;暂无优惠券&lt;/view&gt;\n&lt;/view&gt;\n\n\n .goods-tickets &#123;\n        .ul222 &#123;\n          display: flex;\n          view &#123;\n            color: #378BF7;\n            &amp;.has-coupon &#123;\n              display: flex;\n              align-items: center;\n              height: 20px * 2;\n              font-size: 12px * 2;\n              padding: 0 9px * 2;\n              margin-right: 6px * 2;\n              background-color: #378BF7;\n              background-repeat: no-repeat;\n              position: relative;\n              overflow: hidden;\n              color: #FFFFFF;\n              &amp;:last-child &#123;\n                margin-right: 0;\n              &#125;\n              &amp;:before, &amp;:after &#123;\n                content: &#39;&#39;;\n                display: block;\n                position: absolute;\n                width: 8px * 2;\n                height: 8px * 2;\n                background-color: #FFF;\n                border-radius: 50%;\n                top: 50%;\n                transform: translateY(-50%);\n              &#125;\n              &amp;:before &#123;\n                left: -4px * 2;\n              &#125;\n              &amp;:after &#123;\n                right: -4px * 2;\n              &#125;\n            &#125;\n          &#125;\n        &#125;\n      &#125;\n</code></pre>\n<h1 id=\"uniapp的图片路径相关问题\"><a href=\"#uniapp的图片路径相关问题\" class=\"headerlink\" title=\"uniapp的图片路径相关问题\"></a>uniapp的图片路径相关问题</h1><p>编译成H5 的时候图片在哪里都无所谓</p>\n<p>编译成小程序 的时候图片必须要在 static 下</p>\n<h1 id=\"分包应该在项目改写之前\"><a href=\"#分包应该在项目改写之前\" class=\"headerlink\" title=\"分包应该在项目改写之前\"></a>分包应该在项目改写之前</h1><p>不然后面又得改写跳转路径</p>\n",
            "tags": [
                "前端开发",
                "大前端",
                "uniapp"
            ]
        }
    ]
}