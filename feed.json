{
    "version": "https://jsonfeed.org/version/1",
    "title": "死肥宅",
    "subtitle": "肥宅快乐水",
    "icon": "https://pink-png.github.io/images/favicon.ico",
    "description": "编程 & 生活",
    "home_page_url": "https://pink-png.github.io",
    "items": [
        {
            "id": "https://pink-png.github.io/Version-management-tools/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB/",
            "url": "https://pink-png.github.io/Version-management-tools/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB/",
            "title": "版本管理工具汇总",
            "date_published": "2024-05-11T02:20:00.000Z",
            "content_html": "<table>\n<thead>\n<tr>\n<th>工具名称</th>\n<th>描述</th>\n<th>类型</th>\n<th>适用场景</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Git</td>\n<td>目前最流行的版本管理工具之一，分布式版本控制系统，快速、高效和强大</td>\n<td>分布式</td>\n<td>大型项目、并发开发和团队协作</td>\n</tr>\n<tr>\n<td>Subversion (SVN)</td>\n<td>集中式版本控制系统，略显陈旧但易于使用</td>\n<td>集中式</td>\n<td>小型团队管理</td>\n</tr>\n<tr>\n<td>Mercurial</td>\n<td>分布式版本管理工具，注重简洁和易用性</td>\n<td>分布式</td>\n<td>中小型项目和开发团队</td>\n</tr>\n<tr>\n<td>Perforce</td>\n<td>商业版本管理工具，高性能和可扩展性</td>\n<td>集中式</td>\n<td>大规模项目和复杂的代码管理</td>\n</tr>\n<tr>\n<td>Microsoft Team Foundation Server (TFS)</td>\n<td>微软开发的团队软件开发工具，包含版本控制、项目管理等功能</td>\n<td>集中式</td>\n<td>团队协作、项目管理、测试管理和持续集成</td>\n</tr>\n<tr>\n<td>Apache Subversion (ASF)</td>\n<td>Apache基金会开发的开源版本控制系统，基于Subversion但增加扩展和改进</td>\n<td>集中式</td>\n<td>开源项目和大型团队</td>\n</tr>\n<tr>\n<td>Source Gear Vault</td>\n<td>Windows平台的商业版本管理工具，易用性和稳定性</td>\n<td>集中式</td>\n<td>小型到中型项目</td>\n</tr>\n<tr>\n<td>Beanstalk</td>\n<td>基于云的版本管理工具，提供简单界面和易用功能</td>\n<td>分布式（云）</td>\n<td>小型项目和个人开发者</td>\n</tr>\n</tbody></table>\n",
            "tags": [
                "版本管理",
                "版本管理工具汇总",
                "版本管理"
            ]
        },
        {
            "id": "https://pink-png.github.io/performance-optimization/35%E6%9D%A1%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96%E5%86%9B%E8%A7%84/",
            "url": "https://pink-png.github.io/performance-optimization/35%E6%9D%A1%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96%E5%86%9B%E8%A7%84/",
            "title": "35条前端优化军规",
            "date_published": "2023-12-04T03:41:00.000Z",
            "content_html": "<h1 id=\"减少-HTTP-请求数\"><a href=\"#减少-HTTP-请求数\" class=\"headerlink\" title=\"减少 HTTP 请求数\"></a>减少 HTTP 请求数</h1><p>Web 前端 80% 的响应时间花在图片、样式、脚本等资源下载上。最直接的方式是减少页面所需资源，但并不现实。所以，减少 HTTP 请求数主要的途径是：</p>\n<h2 id=\"合并-JS-x2F-CSS-文件\"><a href=\"#合并-JS-x2F-CSS-文件\" class=\"headerlink\" title=\"合并 JS&#x2F;CSS 文件\"></a>合并 JS&#x2F;CSS 文件</h2><p>服务器端（CDN）自动合并，基于 Node.js 的文件合并工具，通过把所有脚本放在一个文件中的方式来减少请求数。</p>\n<p>最好的优化是做到页面只加载一个 CSS 和一个 JS。</p>\n<h2 id=\"使用-CSS-Sprite\"><a href=\"#使用-CSS-Sprite\" class=\"headerlink\" title=\"使用 CSS Sprite\"></a>使用 CSS Sprite</h2><p>将背景图片合并成一个文件，通过 background-image 和 background-position 控制显示</p>\n<h2 id=\"行内图片（Base64-编码）\"><a href=\"#行内图片（Base64-编码）\" class=\"headerlink\" title=\"行内图片（Base64 编码）\"></a>行内图片（Base64 编码）</h2><p>使用 Data URI scheme 将图片嵌入 HTML 或者 CSS 中；或者将 CSS、JS、图片直接嵌入 HTML 中，会增加文件大小，也可能产生浏览器兼容及其他性能问题。</p>\n<p>减少页面的 HTTP 请求数是个起点，这是提升站点首次访问速度的重要指导原则。</p>\n<h1 id=\"使用-CDN（内容分发网络）\"><a href=\"#使用-CDN（内容分发网络）\" class=\"headerlink\" title=\"使用 CDN（内容分发网络）\"></a>使用 CDN（内容分发网络）</h1><p>用户与服务器的物理距离对响应时间也有影响。把内容部署在多个地理位置分散的服务器上能让用户更快地载入页面。但具体要怎么做呢？</p>\n<p>实现内容在地理位置上分散的第一步是：不要尝试去重新设计你的 Web 应用程序来适应分布式结构。这取决于应用程序，改变结构可能包括一些让人望而生畏的任务，比如同步会话状态和跨服务器复制数据库等事务。缩短用户和内容之间距离的提议可能被推迟，或者根本不可能通过，就是因为这个难题。</p>\n<p>网站 80-90% 响应时间消耗在资源下载上，减少资源下载时间是性能优化的黄金法则。相比分布式架构的复杂和巨大投入，静态内容分发网络（CDN）可以以较低的投入，获得加载速度有效提升。</p>\n<p>内容分发网络（CDN）是一组分散在不同地理位置的 web 服务器，用来给用户更高效地发送内容。典型地，选择用来发送内容的服务器是基于网络距离的衡量标准的。例如：选跳数（hop）最少的或者响应时间最快的服务器。</p>\n<h1 id=\"Expires-或-Cache-Control-响应头\"><a href=\"#Expires-或-Cache-Control-响应头\" class=\"headerlink\" title=\"Expires 或 Cache-Control 响应头\"></a>Expires 或 Cache-Control 响应头</h1><p>这条规则有两个方面：</p>\n<p>对于静态组件：通过设置一个遥远的将来时间作为 Expires 来实现永不失效<br>多余动态组件：用合适的 Cache-Control HTTP 头来让浏览器进行条件性的请求</p>\n<p>网页设计越来越丰富，这意味着页面里有更多的脚本，图片。站点的新访客可能还是不得不提交几个 HTTP 请求，但通过使用有效期能让组件变得可缓存，这避免了在接下来的浏览过程中不必要的 HTTP 请求。有效期 HTTP 头通常被用在图片上，但它们也应该被用在所有组件上，包括脚本、样式等静态文件中。</p>\n<p>一般来讲，浏览器等客户端都会有缓存机制来减少 HTTP 请求的数目和大小，让页面能够更快加载。Web 服务器通过有效期 HTTP 响应头来告诉客户端，页面的各个组件应该被缓存多久。用一个遥远的将来时间做有效期，告诉浏览器这个响应在 2022 年 4 月 15 日前不会改变。</p>\n<pre><code class=\"javascript\">Expires: Thu, 15 Apr 2022 20:00:00 GMT\n</code></pre>\n<p>如果你用的是 Apache 服务器，用 ExpiresDefault 指令来设置相对于当前日期的有效期。下面的例子设置了从请求时间起 10 年的有效期：</p>\n<pre><code class=\"javascript\">ExpiresDefault &quot;access plus 10 years&quot;\n</code></pre>\n<p>因为 Expires 头使用一个特定的时间，它要求服务端和客户端的时钟严格同步；另外，过期日期需要经常检查，一旦过期日期到了，需要在服务器中配置提供一个新的日期。所以，HTTP1.1 引入了 Cache-Control 头来克服 Exipres 头的限制。</p>\n<p>Cache-Control 使用 max-age 指令指定组件被缓存多久，它以秒为单位定义了一个更新期限。使用带有 max-age 的 Cache-Control 可以消除 Expires 的限制，但对于不支持 HTTP1.1 的应用（在 2019 的现在很少很少了），仍希望使用 Expires 头。可以同时制定这两个响应头，如果两者同时出现时，HTTP 规范规定 max-age 指令将重写 Expires 头。</p>\n<p>当出现了 Expires 头时，直到过期时间为止一直会使用缓存的版本，浏览器不会检查任何更新，直到过了过期时间。为了确保用户能够获取组件的最新版本，需要在所有的 HTML 页面中修改组件的文件名。Yahoo 在此使用了将版本号嵌入在组件的文件名中的方法，简而言之就是通过修改文件名的方式来重置缓存。</p>\n<h1 id=\"使用-Gzip-压缩\"><a href=\"#使用-Gzip-压缩\" class=\"headerlink\" title=\"使用 Gzip 压缩\"></a>使用 Gzip 压缩</h1><p>压缩组件通过减少 HTTP 请求产生的响应包的大小，从而降低传输时间的方式来提高性能。从 HTTP1.1 开始，Web 客户端可以通过 HTTP 请求中的 Accept-Encoding 头来标识对压缩的支持：</p>\n<pre><code class=\"javascript\">Accept-Encoding: gzip,deflate   \n</code></pre>\n<p>服务器看到请求中的这个头，就会使用客户端列出的方法中的一种来压缩响应。Web 服务器通过响应中的 Content-Encoding 头来告知 Web 客户端：</p>\n<pre><code class=\"javascript\">Content-Encoding: gzip\n</code></pre>\n<p>目前许多网站通常会压缩 HTML 文档，脚本和样式表的压缩也是值得的（包括 XML 和 JSON 在内的任何文本响应理论上都值得被压缩）。但是，图片和 PDF 文件不应该被压缩，因为它们本来已经被压缩了。</p>\n<p>压缩通常能将响应的数据量减少近 70%，但是压缩通常情况下会带来服务端和客户端的 CPU 开销，要检测受益是否大于开销，需要综合考虑响应大小、带宽和客户端服务端物理距离等因素。通常需要对大于 1KB 或 2KB 的文件进行压缩。</p>\n<p>当浏览器通过代理来发送请求时，有可能出现浏览器期望接受的压缩后内容和实际接收到的不一致的情况。解决这一问题的方法是在 Web 服务器的响应中添加 Vary 头。Web 服务器可以告诉代理根据一个或多个请求头来改变缓存的响应。由于压缩的决定是基于 Accept-Encoding 请求头的，因此需要在服务器的 Vary 响应头中包含 Accept-Encoding:</p>\n<pre><code class=\"javascript\">Vary: Accept-Encoding\n</code></pre>\n<p>目前大约 90% 的通过浏览器进行的网络通信都需要使用 gzip，这使得服务端和客户端的对等性变得额外重要。无论是客户端还是服务端发送错误，都会造成页面被破坏。避免错误的一种方式是采用『浏览器白名单』方式，即只为经过证实支持压缩的浏览器提供压缩内容，但是当代理缓存加进来以后，处理边缘情形浏览器将变得更加复杂。另一种方式是使用 Vary: * 或 Cache-Control: private 头来禁用代理缓存。此种方式会为所有浏览器禁用代理缓存，从而增加带宽开销。如何平衡压缩和代理支持需要在加快响应时间、减小带宽开销和边缘情形浏览器缺陷之间进行权衡：</p>\n<ol>\n<li>如果网站的用户很少，并且他们处于一个小圈子中，边缘情形浏览器不需要太多关注，可以压缩内容并使用 Vary: Accept-Encoding。</li>\n<li>如果更注重带宽开销，可以和前一种情形一样，压缩内容并使用 Vary: Accept-Encoding。</li>\n<li>如果网站拥有大量的、多变的用户群，能够应付较高的带宽开销，并且享有高质量的声誉，需要压缩内容并使用 Cache-Control: Private。（ Google 和 Yahoo 都使用这种方式）</li>\n</ol>\n<h1 id=\"将-CSS-放在页面顶部\"><a href=\"#将-CSS-放在页面顶部\" class=\"headerlink\" title=\"将 CSS 放在页面顶部\"></a>将 CSS 放在页面顶部</h1><p>我们研究雅虎网页性能时发现把样式表移到 <head> 里会让页面更快。这是因为把样式表移到 <head> 里允许页面逐步渲染。</p>\n<p>关注性能的前端工程师希望页面被逐步渲染，这时因为，我们希望浏览器尽早渲染获取到的任何内容。这对大页面和网速慢的用户很重要。给用户视觉反馈，比如进度条的重要性已经被大量研究和记录。在我们的情况中，HTML 页面就是进度条。当浏览器逐步加载页面头部，导航条，logo 等等，这些都是给等待页面的用户的视觉反馈。这优化了整体用户体验。</p>\n<p>把样式表放在文档底部的问题是它阻止了许多浏览器的逐步渲染，包括 IE。这些浏览器阻止渲染来避免在样式更改时需要重绘页面元素。所以用户会卡在白屏。</p>\n<p>HTML<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw0L3N0cnVjdC9saW5rcy5odG1sI2gtMTIuMw==\">https://www.w3.org/TR/html4/struct/links.html#h-12.3</span> 规范 清楚表明样式应该在 <head> 里。</p>\n<h1 id=\"将-JavaScript-放在页面底部\"><a href=\"#将-JavaScript-放在页面底部\" class=\"headerlink\" title=\"将 JavaScript 放在页面底部\"></a>将 JavaScript 放在页面底部</h1><p>脚本会阻塞并行下载，HTTP&#x2F;1.1 官方文档建议浏览器每个主机名下并行下载的组件数不要超过两个，如果图片来自多个域名，并行下载的数量就可以超过两个。如果脚本正在下载，浏览器就不开始任何其它下载任务，即使是在不同域名下的。</p>\n<p>有时候，并不容易把脚本移动到底部。举个例子，如果脚本是用 document.write 插入到页面内容中的，就没办法再往下移了。还可能存在作用域问题，在多数情况下，这些问题都是可以解决的。</p>\n<p>一个常见的建议是用推迟（deferred）脚本，有 DEFER 属性的脚本意味着不能含有 document.write，并且提示浏览器告诉他们可以继续渲染。不幸的是，Firefox 不支持 DEFER 属性。在 IE 中，脚本可能被推迟，但不尽如人意。如果脚本可以推迟，我们就可以把它放到页面底部，页面就可以更快地载入。</p>\n<h1 id=\"避免使用-CSS-表达式\"><a href=\"#避免使用-CSS-表达式\" class=\"headerlink\" title=\"避免使用 CSS 表达式\"></a>避免使用 CSS 表达式</h1><p>CSS 表达式是强大的（可能也是危险的）设置动态 CSS 属性的方法。IE5 开始支持，IE8 开始不赞成使用。例如，背景颜色可以设置成每小时轮换：</p>\n<pre><code class=\"css\">background-color: expression( (new Date()).getHours()%2 ? &quot;#B8D4FF&quot; : &quot;#F08A00&quot; );\n</code></pre>\n<p>表达式的问题在于它们的评估频率高于大多数人的预期。它们不仅在页面呈现和调整大小时进行重新计算，而且在页面滚动时甚至在用户将鼠标移动到页面上时进行计算。在 CSS 表达式中添加计数器可以让我们跟踪 CSS 表达式的计算时间和频率。在页面上移动鼠标可以轻松计算超过 10,000 次。</p>\n<h1 id=\"使用外部-JavaScript-和-CSS\"><a href=\"#使用外部-JavaScript-和-CSS\" class=\"headerlink\" title=\"使用外部 JavaScript 和 CSS\"></a>使用外部 JavaScript 和 CSS</h1><p>在现实环境中使用外部文件通常会产生较快的页面，因为 JavaScript 和 CSS 有机会被浏览器缓存起来。对于内联的情况，由于 HTML 文档通常不会被配置为可以进行缓存的，所以每次请求 HTML 文档都要下载 JavaScript 和 CSS。所以，如果 JavaScript 和 CSS 在外部文件中，浏览器可以缓存它们，HTML 文档的大小会被减少而不必增加 HTTP 请求数量。</p>\n<p>决定是否使用外部文件的关键在于被缓存的外部文件占请求的 HTML 文档数的比重。如果网站用户在每次会话中进行多次页面访问，同时页面重用了多个脚本和样式表，使用外部文件时很好的选择。</p>\n<p>对于大多数网站而言，难以精确度量以判断是否使用内联或外部文件，此时建议是使用外部文件的方式。对于这个问题的一个例外是网站主页，由于主页对于响应时间要求更高，因此更加倾向于内联而不是外部文件。</p>\n<p>对于内联文件而言，由于无法利用浏览器缓存，因此给人感觉依然比较低效。我们可以通过加载后下载和动态内联的方式来使得网站主页既可以获得内联的优势，同时也能缓存外部文件。</p>\n<h1 id=\"减少-DNS-查询\"><a href=\"#减少-DNS-查询\" class=\"headerlink\" title=\"减少 DNS 查询\"></a>减少 DNS 查询</h1><p>用户输入 URL 以后，浏览器首先要查询域名（example.com）对应服务器的 IP 地址，这个操作一般需要耗费 20-120 毫秒时间。DNS 查询完成之前，浏览器无法从服务器下载任何数据。</p>\n<p>基于性能考虑，ISP、局域网、操作系统、浏览器都会有相应的 DNS 缓存机制。</p>\n<p>IE 缓存 30 分钟，可以通过注册表中 DnsCacheTimeout 项设置；<br>Firefox 缓存 1 分钟，通过 network.dnsCacheExpiration 配置；<br>Chrome 缓存 1 分钟，通过 chrome:&#x2F;&#x2F;net-internals&#x2F;#dns 配置。<br>另外需要注意的是这里有一个矛盾，减少不同的域名可减少 DNS 查找，同时也减少了页面下载资源文件的并发量。也就是说，虽然避免 DNS 查找削减了响应时间，但是减少并行下载数量却增加了响应时间。原则是把组件分散在 2~4 个域名下，控制好数量，这是同时减少 DNS 查找和允许并发下载的折中方案。</p>\n<h1 id=\"压缩-JavaScript-和-CSS\"><a href=\"#压缩-JavaScript-和-CSS\" class=\"headerlink\" title=\"压缩 JavaScript 和 CSS\"></a>压缩 JavaScript 和 CSS</h1><p>压缩具体来说就是从代码中去除不必要的字符以减少大小，从而提升加载速度。代码最小化就是去掉所有注释和不必要的空白字符（空格，换行和 tab）。</p>\n<p>在 JavaScript 中这样做能够提高响应性能，因为要下载的文件变小了。两个最常用的 JavaScript 代码压缩工具是 JSMin 和 YUI Compressor，YUI compressor 还可以压缩 CSS。</p>\n<p>混淆 是一种可选的源码优化措施，要比压缩更复杂，所以混淆过程也更容易产生 Bug。在对美国前十的网站调查中，压缩可以缩小 21%，而混淆能缩小 25%。虽然混淆的缩小程度更高，但比压缩风险更大。</p>\n<p>除了压缩外部脚本和样式，行内的和块也可以压缩。即使启用了 gzip 模块，先进行压缩也能够缩小 5% 或者更多的大小。JavaScript 和 CSS 的用处越来越多，所以压缩代码会有不错的效果。</p>\n<p>译者注：得益于 Node.js 的流行，开源社区涌现出许多高效、易用的前端优化工具，JavaScript 和 CSS 压缩类如 UglifyJS 2、csso、cssnano 等都是很成熟的工具。<br>对于内嵌的 CSS 和 JavaScript，也可以通过 htmlmin 等工具压缩。<br>这些项目都有 Gulp、Webpack 等流行构建工具的配套版本。</p>\n<h1 id=\"避免-301-x2F-302-重定向\"><a href=\"#避免-301-x2F-302-重定向\" class=\"headerlink\" title=\"避免 301&#x2F;302 重定向\"></a>避免 301&#x2F;302 重定向</h1><p>HTTP 重定向通过 301&#x2F;302 状态码实现。下面是一个 301 状态码的 HTTP 头：</p>\n<pre><code> HTTP/1.1 301 Moved Permanently \n Location: http://example.com/newuri\n Content-Type: text/html\n</code></pre>\n<p>浏览器会自动跳转到 Location 域指明的 URL。重定向需要的所有信息都在 HTTP 头部，而响应体一般是空的。其实额外的 HTTP 头，比如 Expires 和 Cache-Control 也表示重定向。除此之外还有别的跳转方式：refresh 元标签和 JavaScript，但如果你必须得做重定向，最好用标准的 3xx HTTP 状态码，主要是为了让返回按钮能正常使用。</p>\n<h2 id=\"影响\"><a href=\"#影响\" class=\"headerlink\" title=\"影响\"></a>影响</h2><p>客户端收到服务器的重定向响应后，会根据响应头中 Location 的地址再次发送请求。重定向会影响用户体验，尤其是多次重定向时，用户在一段时间内看不到任何内容，只看到浏览器进度条一直在刷新。</p>\n<h2 id=\"常见错误\"><a href=\"#常见错误\" class=\"headerlink\" title=\"常见错误\"></a>常见错误</h2><p>有一种常见的极其浪费资源的重定向，而且 Web 开发人员一般都意识不到这一点：URL 末尾应该添加 &#x2F; 但未添加。比如，访问 <span class=\"exturl\" data-url=\"aHR0cDovL2FzdHJvbG9neS55YWhvby5jb20vYXN0cm9sb2d5\">http://astrology.yahoo.com/astrology</span> 将被 301 重定向到 <span class=\"exturl\" data-url=\"aHR0cDovL2FzdHJvbG9neS55YWhvby5jb20vYXN0cm9sb2d5LyVFRiVCQyU4OCVFNiVCMyVBOCVFNiU4NCU4RiVFNiU5QyVBQiVFNSVCMCVCRSVFNyU5QSU4NA==\">http://astrology.yahoo.com/astrology/（注意末尾的</span> &#x2F;）。如果使用 Apache，可以通过 Alias 或 mod_rewrite 或 DirectorySlash 解决这个问题。</p>\n<p>另一种常见用途是从旧站点跳转到新站点，有时是跳转到同一站点的不同部分，或者针对用户的不同情况（浏览器类型，用户帐号类型等等）做一些处理。用重定向来连接两个网站是最简单的，只需要少量的额外代码。虽然在这些时候使用重定向减少了开发人员的开发复杂度，但降低了用户体验。一种替代方案是用 Alias 和 mod_rewrite，前提是两个代码都在相同的服务器上。如果是因为域名变化而使用了重定向，就可以创建一条 CNAME（创建一个指向另一个域名的 DNS 记录作为别名）结合 Alias 或者 mod_rewrite 指令。</p>\n<h1 id=\"移除重复的-JavaScript-脚本\"><a href=\"#移除重复的-JavaScript-脚本\" class=\"headerlink\" title=\"移除重复的 JavaScript 脚本\"></a>移除重复的 JavaScript 脚本</h1><p>页面含有重复的脚本文件会影响性能，这可能和你想象的不一样。在对美国前 10 大 Web 站点的评审中，发现只有 2 个站点含有重复脚本。两个主要原因增加了在单一页面中出现重复脚本的几率：团队大小和脚本数量。在这种情况下，重复脚本会创建不必要的 HTTP 请求，执行无用的 JavaScript 代码，而影响页面性能。</p>\n<p>IE 会产生不必要的 HTTP 请求，而 Firefox 不会。在 IE 中，如果一个不可缓存的外部脚本被页面引入了两次，它会在页面加载时产生两个 HTTP 请求。即使脚本是可缓存的，在用户重新加载页面时也会产生额外的 HTTP 请求。</p>\n<p>除了产生没有意义的 HTTP 请求之外，多次执行脚本也会浪费时间。因为无论脚本是否可缓存，在主流浏览器中都会执行冗余的 JavaScript 代码。</p>\n<p>避免不小心把相同脚本引入两次的一种方法就是在模板系统中实现脚本管理模块。典型的脚本引入方法就是在 HTML 页面中用 SCRIPT 标签：</p>\n<pre><code class=\"javascript\">&lt;script type=&quot;text/javascript&quot; src=&quot;menu_1.0.17.js&quot;&gt;&lt;/script&gt;\n</code></pre>\n<p>升级为以下这种 PHP 动态函数 insertScript() 进行加载：</p>\n<pre><code class=\"php\"> &lt;?php insertScript(&quot;menu.js&quot;) ?&gt;\n</code></pre>\n<p>这样在 insertScript() 里执行确保加载的唯一性，或者设置好文件版本等操作。</p>\n<h1 id=\"设置-ETags-来控制缓存\"><a href=\"#设置-ETags-来控制缓存\" class=\"headerlink\" title=\"设置 ETags 来控制缓存\"></a>设置 ETags 来控制缓存</h1><p>实体标记（Entity tags，ETag）是服务器和浏览器之间判断浏览器缓存中某个文件是否匹配服务器端原文件的一种机制。实体就是资源文件，如图片，脚本，样式等等。ETag 是比验证 last-modified 日期更高效的机制。</p>\n<p>服务器这样设置组件的 ETag：</p>\n<pre><code>HTTP/1.1 200 OK\nLast-Modified: Tue, 12 Dec 2006 03:03:59 GMT\nETag: &quot;10c24bc-4ab-457e1c1f&quot;\nContent-Length: 12195\n</code></pre>\n<p>之后，如果浏览器要验证文件，它用 If-None-Match 头部来传 ETag 给服务器。如果 ETag 匹配，服务器返回 304（文件未变化），就不下载内容。这样就减少了 12195 个字节的响应体。Etag 通过文件版本标识，方便服务器判断请求的内容是否有更新，如果没有就响应 304，避免重新下载：</p>\n<pre><code>GET /i/yahoo.gif HTTP/1.1\nHost: us.yimg.com\nIf-Modified-Since: Tue, 12 Dec 2006 03:03:59 GMT\nIf-None-Match: &quot;10c24bc-4ab-457e1c1f&quot;\nHTTP/1.1 304 Not Modified\n</code></pre>\n<p>ETag 的问题在于，通常使用文件的某些属性来构造它，这些属性对于特定的网站服务器来说是唯一的。在集群的情况下，当浏览器从一台服务器上获取了原始文件之后又尝试向另一台服务器来验证文件时，ETag 是不匹配的。这种情况是使用服务器集群的网站经常会遇到的问题。默认情况下，Apache 和 IIS 向 ETag 中嵌入的数据都会大大降低有效性验证的成功率。</p>\n<p>Apache1.3 和 2.x 的 ETag 格式是 inode-size-timestamp。文件系统使用 inode 来存储诸如文件类型、所有者、组和访问模式等信息。尽管在多台服务器上一个给定的文件可能位于相同的目录、具有相同的文件大小、权限、时间戳等，从一台服务器到另一台服务器的 inode 仍然是不同的。</p>\n<p>IIS5.0 和 6.0 在 ETag 上有着类似的问题。IIS 上 ETag 的格式是 Filetimestamp:ChangeNumber。ChangeNumber 适用于跟踪 IIS 配置变化的计数器。对于一个网站背后的所有 IIS 服务器来说，ChangeNumber 不大可能相同。</p>\n<p>最终的结果是，对于完全相同的组件，从一台服务器到另一台，Apache 和 IIS 产生的 ETag 是不会匹配的。如果 ETag 不匹配，用户就不会按照 ETag 的设计那样接收到更小更快的 304 响应；相反，它们会收到普通的 200 响应以及组件的所有数据。</p>\n<p>如果只在一台服务器上部署网站，这通常不会产生问题；但如果使用了服务器集群，同时使用 Apache 或者 IIS 默认的 ETag 配置，用户响应将变慢，服务器负载将变高，将消耗更多的带宽，同时代理缓存的效率也会下降。即使组件具有长久的 Expires 头，一旦用户单击了 Reload 或 Refresh 按钮，依然会产生条件 GET 请求。</p>\n<p>如果组件必须通过最新修改日期之外的一些东西来进行验证，则 ETag 是一种强大的方法；如果无须自定义 ETag，则最好将其移除。 last-modified 头基于文件的时间戳进行验证，可以提供完全等价的信息，而且移除 ETag 可以减少响应和后续请求的 HTTP 头的大小。在 Apache 中，只要向 Apache 配置文件中简单地添加下面一行配置就能移除 ETag：</p>\n<pre><code>FileETag none\n</code></pre>\n",
            "tags": [
                "前端开发",
                "前端性能优化",
                "前端性能优化"
            ]
        },
        {
            "id": "https://pink-png.github.io/performance-optimization/%E5%89%8D%E7%AB%AF%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/",
            "url": "https://pink-png.github.io/performance-optimization/%E5%89%8D%E7%AB%AF%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/",
            "title": "前端调试技巧",
            "date_published": "2023-12-04T03:41:00.000Z",
            "content_html": "<pre><code class=\"javascript\">1、网络 请求重新发送xhr \n2、修改请求参数： 复制-&gt;以fetch格式复制\n3、复制JavaScript变量：右键复制object、将object存储为全局变量\n4、$0 输出选中的第一个元素\n5、截屏：Ctrl+shift+p screen\n6、同时展开多级节点 选中元素，按住alt再点击7、$_ 上一个输出结果\n8、Ctrl +shift +p switch切换主题\n9、$$()选中所有匹配元素\n10、debugger\n</code></pre>\n",
            "tags": [
                "前端开发",
                "前端调试",
                "前端调试"
            ]
        },
        {
            "id": "https://pink-png.github.io/tool/%E4%B8%8B%E8%BD%BD%E7%B1%BB/",
            "url": "https://pink-png.github.io/tool/%E4%B8%8B%E8%BD%BD%E7%B1%BB/",
            "title": "下载",
            "date_published": "2023-12-01T08:43:00.000Z",
            "content_html": "<h2 id=\"xshell-下载地址\"><a href=\"#xshell-下载地址\" class=\"headerlink\" title=\"xshell 下载地址\"></a>xshell 下载地址</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueHNoZWxsLmNvbS96aC9mcmVlLWZvci1ob21lLXNjaG9vbC8=\">https://www.xshell.com/zh/free-for-home-school/</span></p>\n",
            "tags": [
                "下载",
                "xshell",
                "xshell"
            ]
        },
        {
            "id": "https://pink-png.github.io/Version-management-tools/git%E5%91%BD%E4%BB%A4%E5%92%8C%E6%A6%82%E5%BF%B5/",
            "url": "https://pink-png.github.io/Version-management-tools/git%E5%91%BD%E4%BB%A4%E5%92%8C%E6%A6%82%E5%BF%B5/",
            "title": "git学习清单",
            "date_published": "2023-12-01T08:43:00.000Z",
            "content_html": "<h1 id=\"Git-命令和概念\"><a href=\"#Git-命令和概念\" class=\"headerlink\" title=\"Git 命令和概念\"></a>Git 命令和概念</h1><h2 id=\"Git-概念\"><a href=\"#Git-概念\" class=\"headerlink\" title=\"Git 概念\"></a>Git 概念</h2><table>\n<thead>\n<tr>\n<th>序号</th>\n<th>概念</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>默认分支名称</td>\n<td>通常是 <code>main</code>，但也有可能是 <code>master</code> 或其他自定义名称</td>\n</tr>\n<tr>\n<td>2</td>\n<td>默认远程名称</td>\n<td>通常是 <code>origin</code></td>\n</tr>\n<tr>\n<td>3</td>\n<td>当前分支参考</td>\n<td><code>HEAD</code></td>\n</tr>\n<tr>\n<td>4</td>\n<td>HEAD 的父级</td>\n<td><code>HEAD^</code> 或 <code>HEAD~1</code></td>\n</tr>\n<tr>\n<td>5</td>\n<td>HEAD 的祖父母</td>\n<td><code>HEAD^^</code> 或 <code>HEAD~2</code></td>\n</tr>\n</tbody></table>\n<h2 id=\"Git-命令\"><a href=\"#Git-命令\" class=\"headerlink\" title=\"Git 命令\"></a>Git 命令</h2><table>\n<thead>\n<tr>\n<th>序号</th>\n<th>命令</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td><code>git init</code></td>\n<td>初始化一个新的 Git 仓库在当前目录（注意：<code>git init &lt;directory&gt;</code> 是不正确的，应该先在目标目录中使用 <code>cd</code> 命令，然后执行 <code>git init</code>）</td>\n</tr>\n<tr>\n<td>2</td>\n<td><code>git clone &lt;url&gt;</code></td>\n<td>克隆一个远程 Git 仓库到本地</td>\n</tr>\n<tr>\n<td>3</td>\n<td><code>git add &lt;file&gt;</code> 或 <code>git add .</code></td>\n<td>添加文件到暂存区（准备提交）。使用 <code>.</code> 代替 <code>&lt;file&gt;</code> 可添加当前目录中的所有文件</td>\n</tr>\n<tr>\n<td>4</td>\n<td><code>git commit -m &quot;&lt;message&gt;&quot;</code> 或 <code>git commit -a -m &quot;&lt;message&gt;&quot;</code></td>\n<td>提交更改到本地仓库。<code>-a</code> 标志用于自动添加所有已跟踪文件的更改</td>\n</tr>\n<tr>\n<td>5</td>\n<td><code>git reset &lt;file&gt;</code></td>\n<td>从暂存区移除文件</td>\n</tr>\n<tr>\n<td>6</td>\n<td><code>git mv &lt;current path&gt; &lt;new path&gt;</code></td>\n<td>移动或重命名文件</td>\n</tr>\n<tr>\n<td>7</td>\n<td><code>git rm &lt;file&gt;</code> 或 <code>git rm --cached &lt;file&gt;</code></td>\n<td>从存储库中删除文件或仅从暂存区中删除文件</td>\n</tr>\n<tr>\n<td>8</td>\n<td><code>git branch</code></td>\n<td>显示分支列表。可配合 <code>-a</code>、<code>-r</code>、<code>-v</code> 标志使用</td>\n</tr>\n<tr>\n<td>9</td>\n<td><code>git branch &lt;branch&gt;</code> 或 <code>git checkout -b &lt;branch&gt;</code></td>\n<td>创建一个新分支或切换到一个新分支并创建它</td>\n</tr>\n<tr>\n<td>10</td>\n<td><code>git checkout &lt;branch&gt;</code></td>\n<td>切换到指定分支</td>\n</tr>\n<tr>\n<td>11</td>\n<td><code>git branch -d &lt;branch&gt;</code> 或 <code>git branch -D &lt;branch&gt;</code></td>\n<td>删除一个分支。<code>-D</code> 强制删除</td>\n</tr>\n<tr>\n<td>12</td>\n<td><code>git merge &lt;branch to merge into HEAD&gt;</code></td>\n<td>合并指定分支到当前分支</td>\n</tr>\n<tr>\n<td>13</td>\n<td><code>git rebase &lt;branch to rebase from&gt;</code></td>\n<td>变基操作，将当前分支的提交移动到另一个分支上</td>\n</tr>\n<tr>\n<td>14</td>\n<td><code>git checkout &lt;commit id&gt;</code></td>\n<td>切换到指定提交</td>\n</tr>\n<tr>\n<td>15</td>\n<td><code>git revert &lt;commit id&gt;</code></td>\n<td>创建一个新的提交来撤销指定提交的更改</td>\n</tr>\n<tr>\n<td>16</td>\n<td><code>git reset &lt;commit id&gt;</code> 或 <code>git reset --hard &lt;commit id&gt;</code></td>\n<td>重置当前分支的 HEAD 到指定提交。<code>--hard</code> 标志会丢弃所有未提交的更改</td>\n</tr>\n<tr>\n<td>17</td>\n<td><code>git status</code></td>\n<td>显示存储库的状态</td>\n</tr>\n<tr>\n<td>18</td>\n<td><code>git log</code></td>\n<td>显示提交历史</td>\n</tr>\n<tr>\n<td>19</td>\n<td><code>git diff</code> 或 <code>git diff --staged</code></td>\n<td>显示对未暂存文件的更改或显示对暂存文件的更改</td>\n</tr>\n<tr>\n<td>20</td>\n<td><code>git diff &lt;commit id 01&gt; &lt;commit id 02&gt;</code></td>\n<td>显示两次提交之间的变化</td>\n</tr>\n<tr>\n<td>21</td>\n<td><code>git stash</code> 或 <code>git stash save &quot;&lt;message&gt;&quot;</code></td>\n<td>临时存储更改而不提交</td>\n</tr>\n<tr>\n<td>22</td>\n<td><code>git stash list</code></td>\n<td>列出所有存储的更改</td>\n</tr>\n<tr>\n<td>23</td>\n<td><code>git stash apply &lt;stash id&gt;</code> 或 <code>git stash apply stash@&#123;0&#125;</code></td>\n<td>应用一个存储的更改</td>\n</tr>\n<tr>\n<td>24</td>\n<td><code>git stash drop &lt;stash id&gt;</code></td>\n<td>删除一个存储的更改</td>\n</tr>\n<tr>\n<td>25</td>\n<td><code>git stash clear</code></td>\n<td>删除所有存储的更改</td>\n</tr>\n<tr>\n<td>26</td>\n<td><code>git stash pop &lt;stash id&gt;</code></td>\n<td>应用并删除一个存储的更改</td>\n</tr>\n<tr>\n<td>27</td>\n<td><code>git stash show &lt;stash id&gt;</code></td>\n<td>显示存储中的更改</td>\n</tr>\n<tr>\n<td>28</td>\n<td><code>git remote add &lt;remote name&gt; &lt;url&gt;</code></td>\n<td>添加一个远程仓库</td>\n</tr>\n<tr>\n<td>29</td>\n<td><code>git remote -v</code></td>\n<td>显示远程仓库的 URL，以及它们分别用于推送和拉取的别名（fetch 和 push）</td>\n</tr>\n<tr>\n<td>30</td>\n<td><code>git remote remove &lt;remote name&gt;</code></td>\n<td>删除名为 <code>&lt;remote name&gt;</code> 的远程仓库</td>\n</tr>\n<tr>\n<td>31</td>\n<td><code>git remote rename &lt;old name&gt; &lt;new name&gt;</code></td>\n<td>将远程仓库的别名从 <code>&lt;old name&gt;</code> 重命名为 <code>&lt;new name&gt;</code></td>\n</tr>\n<tr>\n<td>32</td>\n<td><code>git fetch &lt;remote name&gt;</code></td>\n<td>从名为 <code>&lt;remote name&gt;</code> 的远程仓库获取所有分支的最新更改，但不合并到当前分支</td>\n</tr>\n<tr>\n<td>33</td>\n<td><code>git fetch &lt;remote name&gt; &lt;branch&gt;</code></td>\n<td>从名为 <code>&lt;remote name&gt;</code> 的远程仓库的 <code>&lt;branch&gt;</code> 分支获取最新更改，但不合并到当前分支</td>\n</tr>\n<tr>\n<td>34</td>\n<td><code>git pull &lt;remote name&gt; &lt;branch&gt;</code></td>\n<td>从名为 <code>&lt;remote name&gt;</code> 的远程仓库的 <code>&lt;branch&gt;</code> 分支拉取更改，并自动合并到当前分支</td>\n</tr>\n<tr>\n<td>35</td>\n<td><code>git push &lt;remote name&gt;</code></td>\n<td>将当前分支的更改推送到名为 <code>&lt;remote name&gt;</code> 的远程仓库的对应分支（默认推送当前分支）</td>\n</tr>\n<tr>\n<td>36</td>\n<td><code>git push &lt;remote name&gt; &lt;branch&gt;</code></td>\n<td>将 <code>&lt;branch&gt;</code> 分支的更改推送到名为 <code>&lt;remote name&gt;</code> 的远程仓库的 <code>&lt;branch&gt;</code> 分支</td>\n</tr>\n</tbody></table>\n",
            "tags": [
                "版本管理",
                "git",
                "版本管理"
            ]
        },
        {
            "id": "https://pink-png.github.io/js-base/jsES6-ES13%E6%96%B0%E5%A2%9E%E7%9A%84%E5%8A%9F%E8%83%BD/",
            "url": "https://pink-png.github.io/js-base/jsES6-ES13%E6%96%B0%E5%A2%9E%E7%9A%84%E5%8A%9F%E8%83%BD/",
            "title": "ES6-ES13新增的特性",
            "date_published": "2022-10-25T08:43:00.000Z",
            "content_html": "<h1 id=\"ES6（ES2015）\"><a href=\"#ES6（ES2015）\" class=\"headerlink\" title=\"ES6（ES2015）\"></a>ES6（ES2015）</h1><pre><code class=\"text\">块级作用域变量声明（let和const）\n箭头函数\n模板字面量\n解构赋值\n默认参数值\n扩展运算符和剩余参数\n类和模块化（class和import/export）\nPromise 对象\n迭代器和生成器（Iterator和Generator）\n新的集合类型（Map、Set、WeakMap、WeakSet）\n</code></pre>\n<h1 id=\"ES7（ES2016）\"><a href=\"#ES7（ES2016）\" class=\"headerlink\" title=\"ES7（ES2016）\"></a>ES7（ES2016）</h1><pre><code class=\"text\">Array.prototype.includes 方法\n指数操作符（**）\n</code></pre>\n<h1 id=\"ES8-ES2017\"><a href=\"#ES8-ES2017\" class=\"headerlink\" title=\"ES8 (ES2017)\"></a>ES8 (ES2017)</h1><pre><code class=\"text\">异步函数（async/await）\nObject.values 和 Object.entries 方法\n字符串填充方法（padStart和padEnd）\n</code></pre>\n<h1 id=\"ES9-ES2018\"><a href=\"#ES9-ES2018\" class=\"headerlink\" title=\"ES9 (ES2018)\"></a>ES9 (ES2018)</h1><pre><code class=\"text\">异步迭代器\nPromise.prototype.finally 方法\nRest/Spread 属性\n</code></pre>\n<h1 id=\"ES10-ES2019\"><a href=\"#ES10-ES2019\" class=\"headerlink\" title=\"ES10 (ES2019)\"></a>ES10 (ES2019)</h1><pre><code class=\"text\">Array.prototype.flat 和 Array.prototype.flatMap 方法\nOptional Chaining （可选链操作符 ?.）\n空值合并运算符（??）\n</code></pre>\n<h1 id=\"ES11-ES2020\"><a href=\"#ES11-ES2020\" class=\"headerlink\" title=\"ES11 (ES2020)\"></a>ES11 (ES2020)</h1><pre><code class=\"text\">BigInt 类型\n动态导入（import()）\n可选的捕获绑定（Optional catch binding）\nPromise.allSettled 方法\nString.prototype.matchAll 方法\n全局对象 globalThis\n</code></pre>\n<h1 id=\"ES12-ES2021\"><a href=\"#ES12-ES2021\" class=\"headerlink\" title=\"ES12 (ES2021)\"></a>ES12 (ES2021)</h1><pre><code class=\"text\">逻辑赋值运算符（||=、&amp;&amp;=、??=）\nString.prototype.replaceAll 方法\nPromise.any 方法\n私有字段和方法（# 开头）\n数字分隔符（Number separator）\n</code></pre>\n<h1 id=\"ES13-ES2022\"><a href=\"#ES13-ES2022\" class=\"headerlink\" title=\"ES13 (ES2022)\"></a>ES13 (ES2022)</h1><pre><code class=\"text\">导入.meta对象\n字符串实例方法String.prototype.&#123;trimLeft, trimRight&#125;\n异步迭代器的for-await-of支持\nimport()的顶级动态引入\n更宽松的模板字面量转义\n</code></pre>\n",
            "tags": [
                "前端开发",
                "Javascript",
                "Javascript"
            ]
        },
        {
            "id": "https://pink-png.github.io/js-base/js%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/",
            "url": "https://pink-png.github.io/js-base/js%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/",
            "title": "javascript全局函数和全局变量",
            "date_published": "2022-10-25T08:43:00.000Z",
            "content_html": "<ol>\n<li>全局变量</li>\n</ol>\n<ul>\n<li>Infinity 代表正的⽆穷⼤的数值。</li>\n<li>NaN 指示某个值是不是数字值。</li>\n<li>undefined 指示未定义的值。</li>\n</ul>\n<ol start=\"2\">\n<li>全局函数</li>\n</ol>\n<ul>\n<li>decodeURI() 解码某个编码的 URI 。</li>\n<li>decodeURIComponent() 解码⼀个编码的 URI 组件。</li>\n<li>encodeURI() 把字符串编码为 URI。</li>\n<li>encodeURIComponent() 把字符串编码为 URI 组件。</li>\n<li>escape() 对字符串进⾏编码。</li>\n<li>eval() 计算 JavaScript 字符串，并把它作为脚本代码来执⾏。</li>\n<li>isFinite() 检查某个值是否为有穷⼤的数。</li>\n<li>isNaN() 检查某个值是否是数字。</li>\n<li>Number() 把对象的值转换为数字。</li>\n<li>parseFloat() 解析⼀个字符串并返回⼀个浮点数。</li>\n<li>parseInt() 解析⼀个字符串并返回⼀个整数。</li>\n<li>String() 把对象的值转换为字符串。</li>\n<li>unescape() 对由 escape() 编码的字符串进⾏解码</li>\n</ul>\n",
            "tags": [
                "前端开发",
                "Javascript",
                "Javascript"
            ]
        },
        {
            "id": "https://pink-png.github.io/js-base/js%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F/",
            "url": "https://pink-png.github.io/js-base/js%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F/",
            "title": "js创建对象的多种方式",
            "date_published": "2022-10-25T08:43:00.000Z",
            "content_html": "<pre><code class=\"javascript\">1. 对象字面量（Object Literal）：使用对象字面量可以直接创建一个简单的对象。对象字面量使用花括号 &#123;&#125; 包裹，并在其中定义键值对。\n\nconst person = &#123;\n  name: &#39;John&#39;,\n  age: 30,\n  sayHello: function() &#123;\n    console.log(&#39;Hello!&#39;);\n  &#125;\n&#125;;\n\n\n优点：简洁、直观，适合创建简单的对象。\n缺点：无法实现对象的复用，每次创建对象时都需要重新定义属性和方法。\n</code></pre>\n<pre><code class=\"javascript\">2. 构造函数（Constructor）：通过构造函数可以创建一个对象的实例。构造函数使用 new 操作符来调用，并在内部使用 this 关键字来引用新创建的对象。\nfunction Person(name, age) &#123;\n  this.name = name;\n  this.age = age;\n  this.sayHello = function() &#123;\n    console.log(&#39;Hello!&#39;);\n  &#125;;\n&#125;\n\nconst person = new Person(&#39;John&#39;, 30);\n\n优点：可以通过 new 操作符创建对象的实例，适合创建多个相似的对象。\n缺点：每个对象实例都会拥有独立的方法，占用额外的内存空间。创建大量对象时可能造成内存浪费。\n</code></pre>\n<pre><code class=\"javascript\">3. 原型链继承（Prototype Chain Inheritance）：使用原型链可以实现对象的继承。可以通过给构造函数的原型对象添加属性和方法，使所有通过该构造函数创建的对象都可以共享这些属性和方法。\nfunction Person(name, age) &#123;\n  this.name = name;\n  this.age = age;\n&#125;\n\nPerson.prototype.sayHello = function() &#123;\n  console.log(&#39;Hello!&#39;);\n&#125;;\n\nconst person = new Person(&#39;John&#39;, 30);\n\n优点：可以实现对象的属性和方法的共享，减少内存占用。适合创建多个具有相同属性和方法的对象。\n缺点：所有实例共享原型对象上的属性和方法，如果对原型对象进行修改，会影响所有实例。不能传递参数给构造函数。\n</code></pre>\n<pre><code class=\"javascript\">4. ES6 的类（Class）：ES6 引入了类的概念，可以使用 class 关键字来定义一个类，并通过 new 操作符创建类的实例。\nclass Person &#123;\n  constructor(name, age) &#123;\n    this.name = name;\n    this.age = age;\n  &#125;\n  \n  sayHello() &#123;\n    console.log(&#39;Hello!&#39;);\n  &#125;\n&#125;\n\nconst person = new Person(&#39;John&#39;, 30);\n\n优点：语法更加直观、易读，符合面向对象的编程习惯。支持继承、封装和多态等特性。\n缺点：在底层仍然使用原型链来实现，因此也存在原型链继承的一些问题，如共享方法造成的潜在风险。\n</code></pre>\n",
            "tags": [
                "前端开发",
                "Javascript",
                "Javascript"
            ]
        },
        {
            "id": "https://pink-png.github.io/js-base/js%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/",
            "url": "https://pink-png.github.io/js-base/js%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/",
            "title": "js 实现异步编程",
            "date_published": "2022-10-25T08:43:00.000Z",
            "content_html": "<ol>\n<li>回调函数（Callbacks）：在异步操作完成后，通过传递一个回调函数作为参数，在异步操作结束时调用该回调函数来处理结果。</li>\n</ol>\n<pre><code class=\"Javascript\">function asyncOperation(callback) &#123;\n  // 模拟异步操作\n  setTimeout(function() &#123;\n    const result = &#39;Async operation completed&#39;;\n    callback(result);\n  &#125;, 1000);\n&#125;\n\nasyncOperation(function(result) &#123;\n  console.log(result);\n&#125;);\n\n优点：简单、容易理解\n缺点：不利于维护，代码耦合⾼\n</code></pre>\n<ol start=\"2\">\n<li>Promise：Promise 是一种在 ES6 中引入的异步编程模式。它代表一个异步操作最终的完成或失败，并提供了处理结果的方法。</li>\n</ol>\n<pre><code class=\"Javascript\">function asyncOperation() &#123;\n  return new Promise(function(resolve, reject) &#123;\n    // 模拟异步操作\n    setTimeout(function() &#123;\n      const result = &#39;Async operation completed&#39;;\n      resolve(result); // 异步操作成功\n      // 或者使用 reject(new Error(&#39;Async operation failed&#39;)); 处理异步操作失败\n    &#125;, 1000);\n  &#125;);\n&#125;\n\nasyncOperation()\n  .then(function(result) &#123;\n    console.log(result);\n  &#125;)\n  .catch(function(error) &#123;\n    console.error(error);\n  &#125;);\n\n优点：可以利⽤then⽅法，进⾏链式写法；可以书写错误时的回调函数；\n缺点：编写和理解，相对⽐较难\n</code></pre>\n<ol start=\"3\">\n<li>async&#x2F;await：async&#x2F;await 是在 ES2017 中引入的异步编程语法糖，基于 Promise，让异步代码看起来像同步代码一样。</li>\n</ol>\n<pre><code class=\"Javascript\">function asyncOperation() &#123;\n  return new Promise(function(resolve, reject) &#123;\n    // 模拟异步操作\n    setTimeout(function() &#123;\n      const result = &#39;Async operation completed&#39;;\n      resolve(result); // 异步操作成功\n      // 或者使用 reject(new Error(&#39;Async operation failed&#39;)); 处理异步操作失败\n    &#125;, 1000);\n  &#125;);\n&#125;\nasync function processData() &#123;\n  try &#123;\n    const result = await asyncOperation();\n    console.log(result);\n  &#125; catch (error) &#123;\n    console.error(error);\n  &#125;\n&#125;\n\nprocessData();\n优点：内置执⾏器、更好的语义、更⼴的适⽤性、返回的是Promise、结构清晰。\n缺点：错误处理机制\n</code></pre>\n<ol start=\"4\">\n<li>事件监听（Event Listening）：事件监听是一种基于观察者模式的编程方式。通过注册事件监听器，当特定事件发生时，会触发相应的回调函数。</li>\n</ol>\n<pre><code class=\"Javascript\">// 定义一个事件触发器\nconst eventEmitter = new EventEmitter();\n\n// 注册事件监听器\neventEmitter.on(&#39;event&#39;, function(data) &#123;\n  console.log(&#39;Event triggered:&#39;, data);\n&#125;);\n\n// 触发事件\neventEmitter.emit(&#39;event&#39;, &#39;Some data&#39;);\n\n优点：容易理解，可以绑定多个事件，每个事件可以指定多个回调函数\n缺点：事件驱动型，流程不够清晰\n</code></pre>\n<ol start=\"5\">\n<li>发布&#x2F;订阅（Publish&#x2F;Subscribe）：发布&#x2F;订阅也是一种基于观察者模式的编程方式，其中发布者（发布消息的对象）和订阅者（接收消息的对象）之间是松耦合的关系。</li>\n</ol>\n<pre><code class=\"Javascript\">// 创建一个发布者\nconst publisher = new Publisher();\n\n// 创建一个订阅者并订阅消息\nconst subscriber1 = new Subscriber(&#39;Subscriber 1&#39;);\npublisher.subscribe(subscriber1);\n\n// 创建另一个订阅者并订阅消息\nconst subscriber2 = new Subscriber(&#39;Subscriber 2&#39;);\npublisher.subscribe(subscriber2);\n\n// 发布消息\npublisher.publish(&#39;Some message&#39;);\n\n类似于事件监听，但是可以通过‘消息中⼼ʼ，了解现在有多少发布者，多少订阅者\n</code></pre>\n<ol start=\"5\">\n<li>Generator函数</li>\n</ol>\n<pre><code class=\"javascript\">function* myGeneratorFunction() &#123;\n  try &#123;\n    const result = yield new Promise((resolve, reject) =&gt; &#123;\n      setTimeout(() =&gt; &#123;\n        resolve(&#39;Async operation completed.&#39;);\n      &#125;, 2000);\n    &#125;);\n    console.log(result);\n  &#125; catch (error) &#123;\n    console.error(error);\n  &#125;\n&#125;\n\nfunction runGenerator(generator) &#123;\n  const iterator = generator();\n\n  function iterate(&#123; value, done &#125;) &#123;\n    if (done) &#123;\n      return;\n    &#125;\n\n    if (value instanceof Promise) &#123;\n      value.then(\n        (result) =&gt; &#123;\n          iterate(iterator.next(result));\n        &#125;,\n        (error) =&gt; &#123;\n          iterate(iterator.throw(error));\n        &#125;\n      );\n    &#125; else &#123;\n      iterate(iterator.next(value));\n    &#125;\n  &#125;\n\n  iterate(iterator.next());\n&#125;\n\nrunGenerator(myGeneratorFunction);\n\n\n优点：函数体内外的数据交换、错误处理机制\n缺点：流程管理不⽅便\n</code></pre>\n",
            "tags": [
                "前端开发",
                "Javascript",
                "Javascript"
            ]
        },
        {
            "id": "https://pink-png.github.io/js-base/js%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/",
            "url": "https://pink-png.github.io/js-base/js%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/",
            "title": "数组去重方法总结",
            "date_published": "2022-10-25T08:43:00.000Z",
            "content_html": "<h1 id=\"借助ES6提供的Set结构-new-Set-简单好用-强烈推荐\"><a href=\"#借助ES6提供的Set结构-new-Set-简单好用-强烈推荐\" class=\"headerlink\" title=\"借助ES6提供的Set结构 new Set() 简单好用 强烈推荐\"></a>借助ES6提供的Set结构 new Set() 简单好用 强烈推荐</h1><pre><code class=\"javascript\">使用 Set 数据结构：将数组转换为 Set，然后再将 Set 转回数组。\n var arr = [1,9,8,8,7,7];\n  function noRepeat(arr)&#123;\n    var newArr = [...new Set(arr)]; //利用了Set结构不能接收重复数据的特点\n    return newArr\n  &#125;\n  var arr2 = noRepeat(arr) \n</code></pre>\n<h1 id=\"利用-filter-indexOf-去重\"><a href=\"#利用-filter-indexOf-去重\" class=\"headerlink\" title=\"利用 filter() +  indexOf() 去重\"></a>利用 filter() +  indexOf() 去重</h1><pre><code class=\"javascript\">filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。item是当前元素的值，index是当前元素的索引值。indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。利用indexOf() 查询到数组的下标，看是否等于当前的下标，相等的话就返回，否则不返回值\n\nvar arr = [&#39;apple&#39;,&#39;apps&#39;,&#39;pear&#39;,&#39;apple&#39;,&#39;orange&#39;,&#39;apps&#39;];  \n  var newArr = arr.filter(function(item,index)&#123;\n     return arr.indexOf(item) === index;  // 因为indexOf 只能查找到第一个  \n  &#125;);\n</code></pre>\n<h1 id=\"利用for-循环-搭配-indexOf-去重\"><a href=\"#利用for-循环-搭配-indexOf-去重\" class=\"headerlink\" title=\"利用for 循环 搭配 indexOf 去重\"></a>利用for 循环 搭配 indexOf 去重</h1><pre><code class=\"javascript\"> var arr = [1,9,8,8,7,7];\n function noRepeat(arr) &#123;\n        var newArr=[]; \n        for(var i=0;i&lt;arr.length;i++) &#123;\n          if(newArr.indexOf(arr[i]) === -1) &#123;\n             newArr.push(arr[i]);\n          &#125;\n        &#125;\n    return newArr\n  &#125;\n  var arr2 = noRepeat(arr);\n</code></pre>\n<h1 id=\"将数组的每一个元素依次与其他元素做比较，发现重复元素，删除-比较繁琐-不推荐\"><a href=\"#将数组的每一个元素依次与其他元素做比较，发现重复元素，删除-比较繁琐-不推荐\" class=\"headerlink\" title=\"将数组的每一个元素依次与其他元素做比较，发现重复元素，删除 比较繁琐 不推荐\"></a>将数组的每一个元素依次与其他元素做比较，发现重复元素，删除 比较繁琐 不推荐</h1><pre><code class=\"javascript\">var arr = [1,9,8,8,7,7];\n function noRepeat(arr) &#123;\n        for(var i = 0; i &lt; arr.length-1; i++)&#123;\n            for(var j = i+1; j &lt; arr.length; j++)&#123;\n                if(arr[i]===arr[j])&#123;\n                    arr.splice(j,1);\n                    j--;\n                &#125;\n            &#125;\n        &#125;\n        return arr;\n &#125;\n var arr2 = noRepeat(arr);\n</code></pre>\n<h1 id=\"借助新数组-通过-indexOf-方法判断当前元素在数组中的索引，如果与循环的下标相等则添加到新数组中\"><a href=\"#借助新数组-通过-indexOf-方法判断当前元素在数组中的索引，如果与循环的下标相等则添加到新数组中\" class=\"headerlink\" title=\"借助新数组 通过 indexOf 方法判断当前元素在数组中的索引，如果与循环的下标相等则添加到新数组中\"></a>借助新数组 通过 indexOf 方法判断当前元素在数组中的索引，如果与循环的下标相等则添加到新数组中</h1><pre><code class=\"javascript\"> var arr = [1,9,8,8,7,7];\n    function noRepeat(arr) &#123;\n        var newArr = [];\n        for (var i = 0; i &lt; arr.length; i++) &#123;\n            if (arr.indexOf(arr[i]) == i) &#123;\n              newArr.push(arr[i]);\n            &#125;\n        &#125;\n        return newArr;\n    &#125;\n   var arr2 = noRepeat(arr); \n</code></pre>\n<h1 id=\"利用双重for循环\"><a href=\"#利用双重for循环\" class=\"headerlink\" title=\"利用双重for循环\"></a>利用双重for循环</h1><pre><code class=\"javascript\">var arr = [1,9,8,8,7,7];  \nfunction noRepeat(arr)&#123;\n   for (var i = 0; i &lt; arr.length; i++) &#123;\n       for (var j = 0; j &lt; arr.length; j++) &#123;\n           if (arr[i] == arr[j] &amp;&amp; i != j) &#123;\n              arr.splice(j, 1);\n            &#125;\n       &#125;\n    &#125;\n    return arr;\n&#125;\nvar arr2  = noRepeat(arr);\n</code></pre>\n<h1 id=\"利用includes实现数组去重\"><a href=\"#利用includes实现数组去重\" class=\"headerlink\" title=\"利用includes实现数组去重\"></a>利用includes实现数组去重</h1><pre><code class=\"javascript\"> var arr = [1,9,8,8,7,7];\n    function noRepeat(arr) &#123;\n      let newArr = [];\n      for(i=0; i&lt;arr.length; i++)&#123;\n        if(!newArr.includes(arr[i]))&#123;\n            newArr.push(arr[i])\n        &#125;\n      &#125;\n     return newArr\n   &#125;\n</code></pre>\n<h1 id=\"利⽤-reduce-includes\"><a href=\"#利⽤-reduce-includes\" class=\"headerlink\" title=\"利⽤ reduce + includes\"></a>利⽤ reduce + includes</h1><pre><code class=\"javascript\">  const res = arr.reduce((prev, cur) =&gt; &#123;\n      if(!prev.includes(cur))&#123;\n          prev.push(cur)\n      &#125;\n      return prev\n  &#125;, [])\n\n  优化后\n function unique(arr) &#123;\n    return arr.reduce((prev, cur) =&gt; prev.includes(cur) ? prev : [...prev, cur])\n  &#125;\n</code></pre>\n<h1 id=\"利⽤Map数据结构去重\"><a href=\"#利⽤Map数据结构去重\" class=\"headerlink\" title=\"利⽤Map数据结构去重\"></a>利⽤Map数据结构去重</h1><pre><code class=\"javascript\"> function arrayNonRepeatfy(arr) &#123;\n    let map = new Map();\n    let array = new Array(); // 数组⽤于返回结果\n    for (let i = 0; i &lt; arr.length; i++) &#123;\n        if (map.has(arr[i])) &#123; // 如果有该key值\n            map.set(arr[i], true);\n        &#125; else &#123;\n            map.set(arr[i], false); // 如果没有该key值\n            array.push(arr[i]);\n        &#125;\n    &#125;\n    return array;\n&#125;\n</code></pre>\n<h1 id=\"利⽤递归去重\"><a href=\"#利⽤递归去重\" class=\"headerlink\" title=\"利⽤递归去重\"></a>利⽤递归去重</h1><pre><code class=\"javascript\"> function unique(arr) &#123;\n      var array = arr;\n      var len = array.length;\n      array.sort(function (a, b) &#123; //排序后更加⽅便去重\n          return a - b;\n      &#125;)\n      function loop(index) &#123;\n          if (index &gt;= 1) &#123;\n              if (array[index] === array[index - 1]) &#123;\n                  array.splice(index, 1);\n              &#125;\n              loop(index - 1); //递归loop，然后数组去重\n          &#125;\n      &#125;\n      loop(len - 1);\n      return array;\n  &#125;\n</code></pre>\n<h1 id=\"利⽤hasOwnProperty-filter\"><a href=\"#利⽤hasOwnProperty-filter\" class=\"headerlink\" title=\"利⽤hasOwnProperty + filter\"></a>利⽤hasOwnProperty + filter</h1><pre><code class=\"javascript\">function unique(arr) &#123;\n    var obj = &#123;&#125;;\n    return arr.filter(function (item, index, arr) &#123;\n        return obj.hasOwnProperty(typeof item + item) ? false : (obj[typeof item + item] = true);\n    &#125;);\n&#125;\n</code></pre>\n<h1 id=\"利⽤对象的属性不能相同的特点进⾏去重\"><a href=\"#利⽤对象的属性不能相同的特点进⾏去重\" class=\"headerlink\" title=\"利⽤对象的属性不能相同的特点进⾏去重\"></a>利⽤对象的属性不能相同的特点进⾏去重</h1><pre><code class=\"javascript\">function unique(arr) &#123;\n      if (!Array.isArray(arr)) &#123;\n          console.log(&#39;type error!&#39;)\n          return\n      &#125;\n      var arrry = [];\n      var obj = &#123;&#125;;\n      for (var i = 0; i &lt; arr.length; i++) &#123;\n          if (!obj[arr[i]]) &#123;\n              arrry.push(arr[i])\n              obj[arr[i]] = 1\n          &#125; else &#123;\n              obj[arr[i]]++\n          &#125;\n      &#125;\n      return arrry;\n  &#125;\n</code></pre>\n",
            "tags": [
                "前端开发",
                "Javascript",
                "Javascript"
            ]
        },
        {
            "id": "https://pink-png.github.io/js-base/js%E6%B5%85%E8%B0%88new%20this/",
            "url": "https://pink-png.github.io/js-base/js%E6%B5%85%E8%B0%88new%20this/",
            "title": "浅谈js中new this 关键字",
            "date_published": "2022-10-25T08:43:00.000Z",
            "content_html": "<h1 id=\"new操作符具体干了什么\"><a href=\"#new操作符具体干了什么\" class=\"headerlink\" title=\"new操作符具体干了什么\"></a>new操作符具体干了什么</h1><pre><code class=\"text\">1. 创建一个新的空对象。\n2. 将新对象的原型链（[[Prototype]]）链接到构造函数的 prototype 属性上，使新对象能够访问构造函数原型中定义的属性和方法。\n3. 将构造函数的作用域赋值给新对象，即将新对象的 this 绑定到构造函数上，使构造函数内部的代码能够访问和操作新对象的属性。\n4. 执行构造函数内部的代码，初始化新对象的属性和方法。\n5. 如果构造函数返回了一个非空对象，则返回该对象；否则，返回新创建的对象。\n</code></pre>\n<h1 id=\"new的模拟实现\"><a href=\"#new的模拟实现\" class=\"headerlink\" title=\"new的模拟实现\"></a>new的模拟实现</h1><pre><code class=\"javascript\">function myNew(constructor, ...args) &#123;\n  // 1. 在内存中创建一个新对象\n  const obj = &#123;&#125;;\n\n  // 2. 将新对象的原型设置为构造函数的 prototype 属性\n  Object.setPrototypeOf(obj, constructor.prototype);\n\n  // 3. 将构造函数内部的 this 绑定到新对象\n  const result = constructor.apply(obj, args);\n\n  // 4. 执行构造函数内部的代码后，如果返回非空对象则返回该对象，否则返回新对象\n  return result instanceof Object ? result : obj;\n&#125;\n</code></pre>\n<p>上述代码中，myNew 函数接受构造函数和参数，模拟了 new 操作符的行为。它会创建一个新对象 obj，将该对象的原型设置为构造函数的 prototype 属性，然后将构造函数内部的 this 绑定到新对象 obj 上，最后根据构造函数的返回结果决定返回值。</p>\n<p>需要注意的是，这只是一个简化的实现，并没有考虑 new 操作符的所有细节和复杂性，如原型链继承、构造函数返回非对象值时的处理等。在实际开发中，建议优先使用原生的 new 操作符。</p>\n<h1 id=\"this-对象的理解\"><a href=\"#this-对象的理解\" class=\"headerlink\" title=\"this 对象的理解\"></a>this 对象的理解</h1><p>&#96;&#96;text<br>在 JavaScript 中，this 是一个特殊的关键字，它指向当前执行代码的上下文对象。具体来说，this 引用的是调用函数的对象，根据函数的调用方式不同，this 会有不同的值。</p>\n<pre><code>\n```text\nthis 的值可以根据以下几种情况进行判断\n</code></pre>\n<pre><code class=\"javascript\">1. 作为普通函数调用：当函数作为独立函数调用时，this 的值指向全局对象（在浏览器中为 window）。\nfunction greet() &#123;\n  console.log(`Hello, $&#123;this.name&#125;`);\n&#125;\n\nconst obj = &#123;\n  name: &#39;Alice&#39;,\n  sayHello: greet\n&#125;;\n\ngreet(); // 输出：Hello, undefined\nobj.sayHello(); // 输出：Hello, Alice\n</code></pre>\n<pre><code class=\"javascript\">2. 作为对象方法调用：当函数作为对象的方法调用时，this 的值指向调用该方法的对象。\nconst person = &#123;\n  name: &#39;Alice&#39;,\n  sayHello() &#123;\n    console.log(`Hello, $&#123;this.name&#125;`);\n  &#125;\n&#125;;\n\nperson.sayHello(); // 输出：Hello, Alice\n</code></pre>\n<pre><code class=\"javascript\">3. 作为构造函数调用：当函数被用作构造函数调用时（使用 new 关键字），this 的值指向新创建的对象。\nfunction Person(name) &#123;\n  this.name = name;\n  this.sayHello = function() &#123;\n    console.log(`Hello, $&#123;this.name&#125;`);\n  &#125;;\n&#125;\n\nconst john = new Person(&#39;John&#39;);\njohn.sayHello(); // 输出：Hello, John\n</code></pre>\n<pre><code class=\"javascript\">4. 使用 call、apply 或 bind 方法显式指定 this 的值。\nfunction greet(greeting) &#123;\n  console.log(`$&#123;greeting&#125;, $&#123;this.name&#125;`);\n&#125;\n\nconst person = &#123;\n  name: &#39;Alice&#39;\n&#125;;\n\ngreet.call(person, &#39;Hi&#39;); // 输出：Hi, Alice\ngreet.apply(person, [&#39;Hi&#39;]); // 输出：Hi, Alice\n\nconst boundGreet = greet.bind(person);\nboundGreet(&#39;Hi&#39;); // 输出：Hi, Alice\n</code></pre>\n",
            "tags": [
                "前端开发",
                "Javascript",
                "Javascript"
            ]
        },
        {
            "id": "https://pink-png.github.io/js-base/js%E6%B5%85%E8%B0%88%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%BB%A5%E5%8F%8A%E5%8F%98%E9%87%8F%E4%BB%A5%E5%8F%8A%E9%97%AD%E5%8C%85/",
            "url": "https://pink-png.github.io/js-base/js%E6%B5%85%E8%B0%88%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%BB%A5%E5%8F%8A%E5%8F%98%E9%87%8F%E4%BB%A5%E5%8F%8A%E9%97%AD%E5%8C%85/",
            "title": "js浅谈作用域 - 变量 - 闭包",
            "date_published": "2022-10-25T08:43:00.000Z",
            "content_html": "<h1 id=\"什么是作用域\"><a href=\"#什么是作用域\" class=\"headerlink\" title=\"什么是作用域\"></a>什么是作用域</h1><pre><code class=\"text\">在 JavaScript 中，作用域是指变量的可访问范围，它控制了变量在代码中的可见性和生命周期。JavaScript 有以下几种类型的作用域和变量：\n</code></pre>\n<pre><code class=\"javascript\">1. 全局作用域（Global Scope）：全局作用域是在代码中任何地方都能访问到的最外层作用域。在浏览器环境中，全局作用域通常指的是 window 对象。在全局作用域中声明的变量在整个程序中都是可访问的。 \n\nvar globalVariable = &#39;I am a global variable&#39;;\n\nfunction foo() &#123;\n  console.log(globalVariable); // 输出：I am a global variable\n&#125;\n\nconsole.log(globalVariable); // 输出：I am a global variable\n</code></pre>\n<pre><code class=\"javascript\">2. 函数作用域（Function Scope）：函数作用域是在函数内部声明的变量所拥有的作用域。这意味着函数内部可以访问函数外部的变量，但函数外部无法访问函数内部的变量。\n\nfunction foo() &#123;\n  var functionVariable = &#39;I am a function variable&#39;;\n  console.log(functionVariable); // 输出：I am a function variable\n&#125;\n\nconsole.log(functionVariable); // 报错：functionVariable is not defined\n</code></pre>\n<pre><code class=\"javascript\">3. 块级作用域（Block Scope）：在 ES6（ECMAScript 2015）之前，JavaScript 只有全局作用域和函数作用域，没有块级作用域。块级作用域由一对花括号（&#123;&#125;）创建，在块级作用域内声明的变量只在该块级作用域内部可见。\n\nfunction foo() &#123;\n  if (true) &#123;\n    var blockVariable = &#39;I am a block variable&#39;;\n    let blockScopedVariable = &#39;I am a block-scoped variable&#39;;\n    console.log(blockVariable); // 输出：I am a block variable\n    console.log(blockScopedVariable); // 输出：I am a block-scoped variable\n  &#125;\n\n  console.log(blockVariable); // 输出：I am a block variable\n  console.log(blockScopedVariable); // 报错：blockScopedVariable is not defined\n&#125;\n</code></pre>\n<pre><code class=\"javascript\">4. 词法作用域（Lexical Scope）：JavaScript 使用的是词法作用域，也称为静态作用域。词法作用域是在代码编写时确定的，它基于变量在代码中的位置来确定其可访问范围，而不是运行时的调用栈。\n\nvar globalVariable = &#39;I am a global variable&#39;;\n\nfunction foo() &#123;\n  var functionVariable = &#39;I am a function variable&#39;;\n  console.log(globalVariable); // 输出：I am a global variable\n  console.log(functionVariable); // 输出：I am a function variable\n&#125;\n\nfoo();\n</code></pre>\n<pre><code class=\"text\">在 JavaScript 中，变量有三种声明方式：var、let 和 const。其中 var 声明的变量具有函数作用域或全局作用域，let 和 const 声明的变量具有块级作用域。\n\n请注意，函数声明本身也遵循词法作用域，可以在函数内部定义函数，并在函数内部访问和调用。这就是 JavaScript 中的闭包机制。\n</code></pre>\n<h1 id=\"作用域的理解\"><a href=\"#作用域的理解\" class=\"headerlink\" title=\"作用域的理解\"></a>作用域的理解</h1><ol>\n<li>作⽤域链的作⽤是保证执⾏环境⾥有权访问的变量和函数是有序的，作⽤域链的变量只能向上访问，变量访问到 window 对象即被终⽌，作⽤域链向下访问变量是不被允许的</li>\n<li>简单的说，作⽤域就是变量与函数的可访问范围，即作⽤域控制着变量与函数的可⻅性和⽣命周期</li>\n</ol>\n<h1 id=\"什么是闭包？\"><a href=\"#什么是闭包？\" class=\"headerlink\" title=\"什么是闭包？\"></a>什么是闭包？</h1><ol>\n<li><p>闭包就是能够读取其他函数内部变量的函数</p>\n</li>\n<li><p>闭包是指有权访问另⼀个函数作⽤域中变量的函数，创建闭包的最常⻅的⽅式就是在⼀个函数内创建另⼀个函数，通过另⼀个函数访问这个函数的局部变量,利⽤闭包可以突破作⽤链域</p>\n</li>\n<li><p>闭包的特性：<br>函数内再嵌套函数<br>内部函数可以引⽤外层的参数和变量<br>参数和变量不会被垃圾回收机制回收</p>\n</li>\n</ol>\n<h1 id=\"闭包的理解\"><a href=\"#闭包的理解\" class=\"headerlink\" title=\"闭包的理解\"></a>闭包的理解</h1><ol>\n<li>使⽤闭包主要是为了设计私有的⽅法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增⼤内存使⽤量，使⽤不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产⽣作⽤域的概念</li>\n<li>闭包 的最⼤⽤处有两个，⼀个是可以读取函数内部的变量，另⼀个就是让这些变量始终保持在内存中</li>\n<li>闭包的另⼀个⽤处，是封装对象的私有属性和私有⽅法</li>\n<li>好处：能够实现封装和缓存等；</li>\n<li>坏处：就是消耗内存、不正当使⽤会造成内存溢出的问题</li>\n</ol>\n<h1 id=\"使⽤闭包的注意点\"><a href=\"#使⽤闭包的注意点\" class=\"headerlink\" title=\"使⽤闭包的注意点\"></a>使⽤闭包的注意点</h1><ol>\n<li>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很⼤，所以不能滥⽤闭包，否则会造成⽹⻚的性能问题，在IE中可能导致内存泄露</li>\n<li>解决⽅法是，在退出函数之前，将不使⽤的局部变量全部删除</li>\n</ol>\n<pre><code class=\"javascript\">function outer() &#123;\n  var outerVariable = &#39;I am an outer variable&#39;;\n\n  function inner() &#123;\n    console.log(outerVariable); // 闭包，内部函数可以访问外部函数的变量\n  &#125;\n\n  return inner;\n&#125;\n\nvar closureFunction = outer(); \nclosureFunction(); // 输出：I am an outer variable\n</code></pre>\n<h1 id=\"什么情况下会造成内存泄漏\"><a href=\"#什么情况下会造成内存泄漏\" class=\"headerlink\" title=\"什么情况下会造成内存泄漏\"></a>什么情况下会造成内存泄漏</h1><ol>\n<li>未及时释放闭包：如果闭包被保留在内存中，并且不再需要使用，但没有手动解除对闭包的引用，这将导致闭包及其所引用的变量无法被垃圾回收，从而造成内存泄漏。</li>\n<li>循环引用：如果闭包持有对其他对象的引用，而这些对象又持有对闭包的引用，形成了循环引用，那么这些对象以及闭包本身都无法被垃圾回收，导致内存泄漏。</li>\n<li>事件监听器未移除：当页面中的元素绑定了事件监听器，而这些监听器是在闭包中定义的，如果没有正确地解除对元素的引用，这会导致闭包无法释放，从而造成内存泄漏。</li>\n<li>全局变量引用：如果闭包中引用了全局变量，即使函数执行结束，闭包仍然可以访问和持有对全局变量的引用，阻止了对全局变量的释放，导致内存泄漏。</li>\n</ol>\n<h1 id=\"为避免闭包导致的内存泄漏，可以采取以下措施：\"><a href=\"#为避免闭包导致的内存泄漏，可以采取以下措施：\" class=\"headerlink\" title=\"为避免闭包导致的内存泄漏，可以采取以下措施：\"></a>为避免闭包导致的内存泄漏，可以采取以下措施：</h1><ol>\n<li>及时释放闭包：在不需要使用闭包时，手动解除对闭包的引用，让垃圾回收机制能够回收闭包及其引用的变量。</li>\n<li>移除事件监听器：在不再需要使用的情况下，确保移除元素上的事件监听器，以免闭包继续持有对元素的引用。</li>\n<li>避免不必要的全局变量：减少对全局作用域的依赖，限制闭包对全局变量的引用，使得相关变量能够在不需要时被回收。</li>\n</ol>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><pre><code class=\"text\">在上面的例子中，outer 函数返回了一个内部函数 inner，该内部函数引用了 outer 函数的变量 outerVariable。即使 outer 函数执行完毕后，inner 函数依然可以访问和操作 outerVariable 变量，这就是闭包的特性。\n\n通过使用作用域和闭包，我们可以实现封装、数据私有化和模块化等编程概念。闭包还可以用于创建函数工厂和实现函数柯里化等高级编程技巧。\n</code></pre>\n",
            "tags": [
                "前端开发",
                "Javascript",
                "Javascript"
            ]
        },
        {
            "id": "https://pink-png.github.io/performance-optimization/%E6%8F%90%E9%AB%98Webpack%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/",
            "url": "https://pink-png.github.io/performance-optimization/%E6%8F%90%E9%AB%98Webpack%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/",
            "title": "webpack性能优化",
            "date_published": "2022-07-25T08:43:00.000Z",
            "content_html": "<h1 id=\"如何提高Webpack构建速度\"><a href=\"#如何提高Webpack构建速度\" class=\"headerlink\" title=\"如何提高Webpack构建速度\"></a>如何提高Webpack构建速度</h1><pre><code class=\"javascript\">1. 代码压缩\n\nJS 压缩\nwebpack 4.0默认在生产环境的时候是支持代码压缩的，即mode=production模式下。实际上webpack 4.0默认是使用terser-webpack-plugin这个压缩插件，在此之前是使用 uglifyjs-webpack-plugin，两者的区别是后者对 ES6 的压缩不是很好，同时我们可以开启 parallel参数，使用多进程压缩，加快压缩。\nCSS 压缩\nCSS 压缩通常是去除无用的空格等，因为很难去修改选择器、属性的名称、值等。可以使用另外一个插件：css-minimizer-webpack-plugin。\nHTML 压缩\n使用HtmlWebpackPlugin插件来生成 HTML 的模板时候，通过配置属性minify进行 html 优化。\n\nmodule.exports = &#123;\nplugin:[\n  new HtmlwebpackPlugin(&#123;\n    minify:&#123;\n      minifyCSS: false, // 是否压缩css\n      collapseWhitespace: false, // 是否折叠空格\n      removeComments: true // 是否移除注释\n    &#125;\n  &#125;)\n  ]\n&#125;\n\n2. 图片压缩\n\n配置image-webpack-loader\n\n3. Tree Shaking\nTree Shaking是一个术语，在计算机中表示消除死代码，依赖于 ES Module 的静态语法分析（不执行任何的代码，可以明确知道模块的依赖关系）。在webpack实现Tree shaking有两种方案：\n\nusedExports：通过标记某些函数是否被使用，之后通过 Terser 来进行优化的\nmodule.exports = &#123;\n    ...\n    optimization:&#123;\n        usedExports\n    &#125;\n  &#125;\n使用之后，没被用上的代码在webpack打包中会加入unused harmony export mul注释，用来告知Terser在优化时，可以删除掉这段代码。\n\nsideEffects：跳过整个模块/文件，直接查看该文件是否有副作用\n\nsideEffects用于告知webpack compiler哪些模块时有副作用，配置方法是在package.json中设置sideEffects属性。如果sideEffects设置为false，就是告知webpack可以安全的删除未用到的exports。如果有些文件需要保留，可以设置为数组的形式，如：\n\n&quot;sideEffecis&quot;:[\n    &quot;./src/util/format.js&quot;,\n    &quot;*.css&quot; // 所有的css文件\n]\n\n4. 缩小打包域\n排除webpack不需要解析的模块，即在使用loader的时候，在尽量少的模块中去使用。可以借助 include和exclude这两个参数，规定loader只在那些模块应用和在哪些模块不应用。\n\n5. 减少 ES6 转为 ES5 的冗余代码\n使用bable-plugin-transform-runtime插件\n\n6. 提取公共代码\n通过配置CommonsChunkPlugin插件，将多个页面的公共代码抽离成单独的文件\n\n7. 其他\n组件懒加载、路由懒加载、开启gzip、公共的第三方包上cdn、配置cache缓存Loader对文件的编译副本、配置resolve提高文件的搜索速度\n</code></pre>\n<h1 id=\"webpack性能优化\"><a href=\"#webpack性能优化\" class=\"headerlink\" title=\"webpack性能优化\"></a>webpack性能优化</h1><h2 id=\"开发环境性能优化\"><a href=\"#开发环境性能优化\" class=\"headerlink\" title=\"开发环境性能优化\"></a>开发环境性能优化</h2><ol>\n<li>优化打包构建速度</li>\n<li>HMR</li>\n<li>优化代码调试</li>\n<li>source-map</li>\n</ol>\n<h2 id=\"生产环境性能优化\"><a href=\"#生产环境性能优化\" class=\"headerlink\" title=\"生产环境性能优化\"></a>生产环境性能优化</h2><ol>\n<li>优化打包构建速度</li>\n<li>oneOf(可以按照一组优先级顺序来定义不同类型或特定条件下的模块处理方式)</li>\n</ol>\n<pre><code class=\"javascript\">module.exports = &#123;\n  // ...其他的Webpack配置\n  module: &#123;\n    rules: [\n      // ...其他规则\n      &#123;\n        oneOf: [\n          &#123;\n            test: /\\.css$/,\n            use: [&#39;style-loader&#39;, &#39;css-loader&#39;]\n          &#125;,\n          &#123;\n            test: /\\.less$/,\n            use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;less-loader&#39;]\n          &#125;,\n          &#123;\n            test: /\\.js$/,\n            exclude: /node_modules/,\n            use: &#39;babel-loader&#39;\n          &#125;,\n          // ...其他的规则\n        ]\n      &#125;\n    ]\n  &#125;\n&#125;;\n</code></pre>\n<ol start=\"3\">\n<li>babel缓存</li>\n<li>多进程打包</li>\n<li>externals(拒绝某些包被打包进来)</li>\n<li>dll(独立打包第三方库,减少构建时间)</li>\n<li>优化代码运行的性能</li>\n<li>缓存(hash-chunkhash-contenthash)</li>\n<li>tree shaking</li>\n</ol>\n<pre><code class=\"text\">tree shaking：去除无用代码\n  前提：1. 必须使用ES6模块化  2. 开启production环境\n  作用: 减少代码体积\n\n在package.json中配置 \n  &quot;sideEffects&quot;: false 所有代码都没有副作用（都可以进行tree shaking）\n    问题：可能会把css / @babel/polyfill （副作用）文件干掉\n  &quot;sideEffects&quot;: [&quot;*.css&quot;, &quot;*.less&quot;]\n</code></pre>\n<ol start=\"10\">\n<li>code split</li>\n<li>懒加载&#x2F;预加载</li>\n<li>pwa(PWA 提供了一种融合了网页和原生应用优点的解决方案，能够提供离线访问、快速加载、类似原生应用的体验以及跨平台兼容性等优势)</li>\n</ol>\n",
            "tags": [
                "前端开发",
                "前端性能优化",
                "前端性能优化"
            ]
        },
        {
            "id": "https://pink-png.github.io/performance-optimization/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%A4%A7%E7%BA%B2/",
            "url": "https://pink-png.github.io/performance-optimization/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%A4%A7%E7%BA%B2/",
            "title": "前端性能优化大纲",
            "date_published": "2022-06-25T08:43:00.000Z",
            "content_html": "<h1 id=\"性能优化六大指标\"><a href=\"#性能优化六大指标\" class=\"headerlink\" title=\"性能优化六大指标\"></a>性能优化六大指标</h1><p><strong>六大指标基本囊括大部分性能优化细节，可作为优化策略的补充。</strong></p>\n<ol>\n<li>「加载优化」：资源在加载时可做的性能优化</li>\n<li>「执行优化」：资源在执行时可做的性能优化</li>\n<li>「渲染优化」：资源在渲染时可做的性能优化</li>\n<li>「样式优化」：样式在编码时可做的性能优化</li>\n<li>「脚本优化」：脚本在编码时可做的性能优化</li>\n<li>「V8引擎优化」：针对V8引擎特征可做的性能优化</li>\n</ol>\n<h2 id=\"加载优化\"><a href=\"#加载优化\" class=\"headerlink\" title=\"加载优化\"></a>加载优化</h2><ol>\n<li>优化HTTP请求：减少请求次数、合并与压缩静态资源、使用CDN、http2、preload&#x2F;prefetch,HTTP 缓存等</li>\n</ol>\n<pre><code class=\"text\"> 1.1 CDN：将资源分发到 CDN 的边缘网络节点，使用户可就近获取所需内容，大幅减小了光纤传输距离，使全球各地用户打开网站都拥有良好的网络体验。\n\n 1.2 http2：http2 的诸多特性决定了它更快的传输速度(多路复用，在浏览器可并行发送 N 条请求,首部压缩，更小的负载体积,请求优先级，更快的关键请求)。\n目前，网站已大多上了 http2，可在控制台面板进行查看。\n由于 http2 可并行请求，解决了 http1.1 线头阻塞的问题，以下几个性能优化点将会过时\n资源合并。如 https://shanyue.tech/assets??index.js,interview.js,report.js\n域名分片。\n雪碧图(CSS Sprite)。将无数小图片合并成单个大图片。\n \n 1.3 充分利用 HTTP 缓存\n更好的资源缓存策略，对于 CDN 来讲可减少回源次数，对于浏览器而言可减少请求发送次数。无论哪一点，对于二次网站访问都具有更好的访问体验。\n一:缓存策略\n  1. 强缓存: 打包后带有 hash 值的资源 (如 /build/a3b4c8a8.js)\n  2. 协商缓存: 打包后不带有 hash 值的资源 (如 /index.html)\n二:分包加载 (Bundle Spliting)\n  1. 避免一行代码修改导致整个 bundle 的缓存失效 \n\n1.4 减少 HTTP 请求及负载\n对一个网站的资源进行压缩优化，从而达到减少 HTTP 负载的目的。\njavascript/css/image 等常规资源（图片等...）体积优化，这是一个大话题，再以下分别讨论\n\n一：image     \n    1. 小图片优化，将小图片内联为 Data URI，减小请求数量 \n    2. 选择合适的图片格式、响应式图片或按需加载图片\n    3. 在前端发展的现在，webp 普遍比 jpeg/png 更小，而 avif 又比 webp 小一个级别\n    为了无缝兼容，可选择 picture/source 进行回退处理\n&lt;picture&gt;\n  &lt;source srcset=&quot;img/photo.avif&quot; type=&quot;image/avif&quot;&gt;\n  &lt;source srcset=&quot;img/photo.webp&quot; type=&quot;image/webp&quot;&gt;\n  &lt;img src=&quot;img/photo.jpg&quot; width=&quot;360&quot; height=&quot;240&quot;&gt;\n&lt;/picture&gt;\n    4. 更合适的尺寸: 当页面仅需显示 100px/100px 大小图片时，对图片进行压缩到 100px/100px\n    5. 更合适的压缩: 可对前端图片进行适当压缩，如通过 sharp 等\n    6. 新的 API: IntersectionObserver API\n    7. 新的属性: loading=lazy \n\n二：javascript\n    1. 更小的 Javascript\n      gzip/brotli\n      terser (minify)\n\n    还有以下几点可以考虑考虑:\n路由懒加载，无需加载整个应用的资源\nTree Shaking: 无用导出将在生产环境进行删除\nbrowserlist/babel: 及时更新 browserlist，将会产生更小的垫片体积\n再补充一个问题:\n\n如何分析并优化当前项目的 Javascript 体积？如果使用 webpack 那就简单很多。\n\n使用 webpack-bundle-analyze 分析打包体积\n对一些库替换为更小体积的库，如 moment -&gt; dayjs\n对一些库进行按需加载，如 import lodash -&gt; import lodash/get\n对一些库使用支持 Tree Shaking，如 import lodash -&gt; import lodash-es\n\n三：字体\n    1.使用字体图标和矢量图形：替代大量图片的使用\n\n\n四：css\n  1. 把样式表放在顶部\n  2. 选择&lt;link&gt;舍弃@import\n  3. 避免使用滤镜\n  4. 避免使用CSS表达式\n    用CSS表达式动态设置CSS属性，是一种强大又危险的方式。从IE5开始支持，但从IE8起就不推荐使用了。例如，可以用CSS表达式把背景颜色设置成按小时交替的：\n    background-color: expression( (new Date()).getHours()%2 ? &quot;#B8D4FF&quot; : &quot;#F08A00&quot; );\n  \n\n\n五：压缩工具\n1.Terser (opens new window)是 Javascript 资源压缩混淆的神器。\n\n2.swc (opens new window)是另外一个用以压缩 Javascript 的工具，它拥有与 terser 相同的 API，由于它是由 rust 所写，因此它拥有更高的性能。\n\n3.html-minifier-terser (opens new window)用以压缩 HTML 的工具\n\n4. gzip/brotli\n对 JS、CSS、HTML 等文本资源均有效，但是对图片效果不大。\n\ngzip 通过 LZ77 算法与 Huffman 编码来压缩文件，重复度越高的文件可压缩的空间就越大。\nbrotli 通过变种的 LZ77 算法、Huffman 编码及二阶文本建模来压缩文件，更先进的压缩算法，比 gzip 有更高的性能及压缩率\n可在浏览器的 Content-Encoding 响应头查看该网站是否开启了压缩算法，目前知乎、掘金等已全面开启了 brotli 压缩。\n\nRequest Header\nAccept-Encoding: gzip, deflate, br\n\ngzip\nContent-Encoding: gzip\n\ngzip\nContent-Encoding: br \n\n\n5. preload/prefetch : preload/prefetch 可控制 HTTP 优先级，从而达到关键请求更快响应的目的。(延迟加载：将非关键资源延迟加载，如图片、视频、第三方插件等)\n \n&lt;link rel=&quot;prefetch&quot; href=&quot;style.css&quot; as=&quot;style&quot;&gt;\n&lt;link rel=&quot;preload&quot; href=&quot;main.js&quot; as=&quot;script&quot;&gt;\n5.1 preload 加载当前路由必需资源，优先级高。一般对于 Bundle Spliting 资源与 Code Spliting 资源做 preload\n5.2. prefetch 优先级低，在浏览器 idle 状态时加载资源。一般用以加载其它路由资源，如当页面出现 Link，可 prefetch 当前 Link 的路由资源。（next.js 默认会对 link 做懒加载+prefetch，即当某条 Link 出现页面中，即自动 prefetch 该 Link 指向的路由资源\n捎带说一下 dns-prefetch，可对主机地址的 DNS 进行预解析。\n\n&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//shanyue.tech&quot;&gt;\n</code></pre>\n<h2 id=\"执行优化\"><a href=\"#执行优化\" class=\"headerlink\" title=\"执行优化\"></a>执行优化</h2><ol>\n<li>代码优化：精简html，css，js代码，避免重复代码</li>\n<li>异步加载：将JavaScript放在底部，使用async,defer属性</li>\n<li>代码分割和懒加载：拆分大型应用程序为小模块，按需加载模块，减少初始加载时间</li>\n<li>前端代码压缩混淆：对前端代码进行压缩和混淆，减小文件大小，提高加载速度</li>\n</ol>\n<h2 id=\"渲染优化\"><a href=\"#渲染优化\" class=\"headerlink\" title=\"渲染优化\"></a>渲染优化</h2><p><strong>「渲染层面」</strong>的性能优化，无疑是如何让代码解析更好执行更快。</p>\n<ol>\n<li>「CSS策略」：基于CSS规则</li>\n<li>「DOM策略」：基于DOM操作</li>\n<li>「阻塞策略」：基于脚本加载</li>\n<li>「回流重绘策略」：基于回流重绘</li>\n<li>「异步更新策略」：基于异步更新</li>\n<li>「缓存策略」</li>\n</ol>\n<p><strong>CSS策略</strong><br>避免出现超过三层的嵌套规则<br>避免为ID选择器添加多余选择器<br>避免使用标签选择器代替类选择器<br>避免使用通配选择器，只对目标节点声明规则<br>避免重复匹配重复定义，关注可继承属性 </p>\n<p><strong>DOM策略</strong><br>缓存DOM计算属性<br>避免过多DOM操作<br>使用DOMFragment缓存批量化DOM操作<br>虚拟列表优化</p>\n<p><strong>阻塞策略</strong><br>脚本与DOM&#x2F;其它脚本的依赖关系很强：对<script>设置defer<br>脚本与DOM/其它脚本的依赖关系不强：对<script>设置async</p>\n<p><strong>「回流重绘策略」</strong>在渲染层面的性能优化里占比较重，也是最常规的性能优化之一。<br>缓存DOM计算属性<br>使用类合并样式，避免逐条改变样式<br>使用display控制DOM显隐，将DOM离线化</p>\n<p><strong>异步更新策略</strong><br>在异步任务中修改DOM时把其包装成微任务</p>\n<p><strong>缓存策略</strong></p>\n<pre><code class=\"javascript\">在一些前端系统中，当加载页面时会发送请求，路由切换出去再切换回来时又会重新发送请求，每次请求完成后会对页面重新渲染。\n\n然而这些重新请求再大多数时是没有必要的，合理地对 API 进行缓存将达到优化渲染的目的。\n\n1.对每一条 GET API 添加 key\n2.根据 key 控制该 API 缓存，重复发生请求时将从缓存中取得\n\nfunction Example() &#123;\n  // 设置缓存的 Key 为 Users:10086\n  const &#123; isLoading, data &#125; = useQuery([&#39;users&#39;, userId], () =&gt; fetchUserById(userId))\n&#125;\n</code></pre>\n<h2 id=\"样式优化\"><a href=\"#样式优化\" class=\"headerlink\" title=\"样式优化\"></a>样式优化</h2><ol>\n<li>响应式设计：使用响应式布局和媒体查询适应不同设备和屏幕大小</li>\n<li>使用CSS预处理器：如Less、Sass等，提高样式编写的效率</li>\n</ol>\n<h2 id=\"脚本优化\"><a href=\"#脚本优化\" class=\"headerlink\" title=\"脚本优化\"></a>脚本优化</h2><ol>\n<li>使用模块化开发：使用模块化/组件化的方式组织JavaScript代码</li>\n<li>优化DOM操作：减少DOM操作的次数，对多次操作进行批量处理</li>\n</ol>\n<pre><code class=\"javascript\">1. 批量更新：将多个 DOM 操作合并为一个操作，以减少重排和重绘的次数。例如，如果要对一个元素进行多次样式修改，可以先使用 CSS 类来添加或删除样式，最后再应用一次类，而不是每次修改都直接操作样式属性。\n\n// 不优化的写法\nelement.style.width = &#39;100px&#39;;\nelement.style.height = &#39;200px&#39;;\nelement.style.backgroundColor = &#39;red&#39;;\n\n// 优化的写法\nelement.classList.add(&#39;my-class&#39;);\nelement.classList.remove(&#39;my-class&#39;);\n\n\n2. 使用文档片段（DocumentFragment）：将多个 DOM 节点先添加到文档片段中，然后再一次性插入文档中，这样只会触发一次重排和重绘。这在需要动态添加大量元素时特别有效。\n\n// 不优化的写法\nfor (let i = 0; i &lt; 1000; i++) &#123;\n  const element = document.createElement(&#39;div&#39;);\n  document.body.appendChild(element);\n&#125;\n\n// 优化的写法\nconst fragment = document.createDocumentFragment();\nfor (let i = 0; i &lt; 1000; i++) &#123;\n  const element = document.createElement(&#39;div&#39;);\n  fragment.appendChild(element);\n&#125;\ndocument.body.appendChild(fragment);\n\n3. 缓存 DOM 查询结果：当需要多次访问同一个 DOM 元素时，将查询结果缓存在变量中，避免重复查询。\n// 不优化的写法\nfor (let i = 0; i &lt; 100; i++) &#123;\n  document.getElementById(&#39;myElement&#39;).innerHTML += &#39;new content&#39;;\n&#125;\n\n// 优化的写法\nconst element = document.getElementById(&#39;myElement&#39;);\nfor (let i = 0; i &lt; 100; i++) &#123;\n  element.innerHTML += &#39;new content&#39;;\n&#125;\n\n4. 使用虚拟 DOM：在涉及大量数据变动和复杂视图更新的情况下，可以使用虚拟 DOM 技术，通过比对虚拟 DOM 树来最小化实际 DOM 操作的次数。\n这些是一些常见的优化 DOM 操作的方法。请根据具体场景选择合适的方法进行优化。记住，减少 DOM 操作次数会显著提高性能和用户体验。\n</code></pre>\n<h2 id=\"V8引擎优化\"><a href=\"#V8引擎优化\" class=\"headerlink\" title=\"V8引擎优化\"></a>V8引擎优化</h2><ol>\n<li>避免不必要的闭包：过多的闭包会导致内存消耗增加</li>\n<li>使用高性能API和方法：如使用map而不是for循环等</li>\n<li>优化循环和递归：尽量减少循环和递归的层数和次数，避免性能问题</li>\n</ol>\n<h1 id=\"性能评测指标\"><a href=\"#性能评测指标\" class=\"headerlink\" title=\"性能评测指标\"></a>性能评测指标</h1><p><strong>三大指标</strong> 使用工具 lighthouse，web-vitals 等<br>LCP: 加载性能。最大内容绘制应在 2.5s 内完成。<br>FID: 交互性能。首次输入延迟应在 100ms 内完成。<br>CLS: 页面稳定性。累积布局偏移，需手动计算，CLS 应保持在 0.1 以下。</p>\n<h1 id=\"浏览器缓存优化\"><a href=\"#浏览器缓存优化\" class=\"headerlink\" title=\"浏览器缓存优化\"></a>浏览器缓存优化</h1><p>为了让浏览器缓存发挥最大作用，该策略尽量遵循以下五点就能发挥浏览器缓存最大作用。</p>\n<p>「考虑拒绝一切缓存策略」：Cache-Control:no-store<br>「考虑资源是否每次向服务器请求」：Cache-Control:no-cache<br>「考虑资源是否被代理服务器缓存」：Cache-Control:public/private<br>「考虑资源过期时间」：Expires:t/Cache-Control:max-age=t,s-maxage=t<br>「考虑协商缓存」：Last-Modified/Etag<br>缓存策略通过设置HTTP报文实现，在形式上分为<strong>「强缓存/强制缓存」和「协商缓存/对比缓存」</strong>。</p>\n<p><img data-src=\"/images/xn/%E5%BC%BA%E7%BC%93%E5%AD%98.png\"><br><img data-src=\"/images/xn/%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98.png\"></p>\n<p>整个缓存策略机制很明了，先走强缓存，若命中失败才走协商缓存。若命中强缓存，直接使用强缓存；若未命中强缓存，发送请求到服务器检查是否命中协商缓存；若命中协商缓存，服务器返回304通知浏览器使用本地缓存，否则返回最新资源。</p>\n<p>有两种较常用的应用场景值得使用缓存策略一试，当然更多应用场景都可根据项目需求制定。</p>\n<p>「频繁变动资源」：设置Cache-Control:no-cache，使浏览器每次都发送请求到服务器，配合Last-Modified/ETag验证资源是否有效<br>「不常变化资源」：设置Cache-Control:max-age=31536000，对文件名哈希处理，当代码修改后生成新的文件名，当HTML文件引入文件名发生改变才会下载最新文件</p>\n<h1 id=\"Web-Worker\"><a href=\"#Web-Worker\" class=\"headerlink\" title=\"Web Worker\"></a>Web Worker</h1><p>在纯浏览器中，如何实现高性能的实时代码编译及转换？</p>\n<p>Babel Repl(opens new window)<br>如果纯碎使用传统的 Javascript 实现，将会耗时过多阻塞主线程，有可能导致页面卡顿。</p>\n<p>如果使用 Web Worker 交由额外的线程来做这件事，将会高效很多，基本上所有在浏览器端进行代码编译的功能都由 Web Worker 实现。</p>\n<h1 id=\"WASM-WebAssembly\"><a href=\"#WASM-WebAssembly\" class=\"headerlink\" title=\"WASM(WebAssembly)\"></a>WASM(WebAssembly)</h1><ol>\n<li>JS 性能低下</li>\n<li>C++/Rust 高性能</li>\n<li>使用 C++/Rust 编写代码，然后在 Javascript 环境运行<br>试举一例:</li>\n</ol>\n<p>在纯浏览器中，如何实现高性能的图片压缩？</p>\n<p>基本上很难做到，Javascript 的性能与生态决定了实现图片压缩的艰难。</p>\n<p>而借助于 WASM 就相当于借用了其它语言的生态。</p>\n<p>1.libavif (opens new window): C语言写的 avif 解码编码库<br>2.libwebp (opens new window): C语言写的 webp 解码编码库<br>3.mozjpeg (opens new window): C语言写的 jpeg 解码编码库<br>4.oxipng (opens new window): Rust语言写的 png 优化库<br>而由于 WASM，完全可以把这些其它语言的生态移植到浏览器中，从而实现一个高性能的离线式的图片压缩工具。</p>\n",
            "tags": [
                "前端开发",
                "前端性能优化",
                "前端性能优化"
            ]
        },
        {
            "id": "https://pink-png.github.io/performance-optimization/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BC%98%E5%8C%96%E6%80%9D%E8%80%83(uniapp)/",
            "url": "https://pink-png.github.io/performance-optimization/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BC%98%E5%8C%96%E6%80%9D%E8%80%83(uniapp)/",
            "title": "在某某企业小程序优化思考(uniapp)",
            "date_published": "2022-06-25T08:43:00.000Z",
            "content_html": "<ol>\n<li><p>vuex 对启动耗时的影响<br>Vuex 是一个状态管理库，在启动阶段如果存在大量的业务逻辑，会使启动耗时增加。这是因为在启动过程中，需要初始化 Vuex 的状态和相关的模块，可能会触发一些异步操作和计算，导致启动时间延长。因此，在设计和使用 Vuex 时，需要注意避免在启动阶段执行过多的繁重操作，以减少启动耗时。</p>\n</li>\n<li><p>mixins 对启动耗时的影响<br>Mixins 是一种在组件中复用代码的机制，通过将相同的逻辑和功能抽离到 Mixins 中，可以在多个组件中共享使用。在启动阶段，如果组件使用了 Mixins，会在组件实例化时执行 Mixins 中的代码逻辑，因此会增加启动耗时。如果 Mixins 中存在大量或复杂的业务逻辑，会进一步增加启动耗时。因此，使用 Mixins 时需要注意控制逻辑的复杂度，避免影响启动性能。</p>\n</li>\n<li><p>子组件中的请求是从onReady 加载完再去调用请求的，所以是否组件中不要使用请求?<br>在小程序中，子组件的请求通常是在组件的 onReady 生命周期钩子函数中进行调用。由于 onReady 是在页面的渲染准备完成后调用的，此时页面已经可见，用户可以看到页面内容。因此，在 onReady 钩子中进行请求可能会导致页面加载完成后才开始请求数据，从而延长了页面加载时间。</p>\n</li>\n<li><p>挂载到原型上的东西 ,每次生成的页面都会执行这个数据 , 这里的影响多大?<br>当一些数据或方法挂载到小程序的原型对象上时，每次生成的页面都可以通过原型链访问到这些数据或方法。这样做的好处是可以实现数据和方法的全局共享和复用。</p>\n</li>\n<li><p>有没有根据包大小计算出来的 平均启动时间&#x2F;加载耗时<br>通常情况下，并没有一个直接根据包大小计算出来的平均启动时间或加载耗时的公式或算法。因为启动时间和加载耗时受到多个因素的影响，如网络环境、设备性能、代码复杂度等。<br>包大小的增加可能会导致下载时间变长，从而影响启动时间。然而，仅仅根据包大小无法准确预测启动时间的增加，还需要考虑其他因素的综合影响。因此，对于不同的小程序和具体场景，需要进行实际测试和评估来得出准确的启动时间和加载耗时。</p>\n</li>\n</ol>\n<ul>\n<li>计算最佳收益点</li>\n<li>其实这里想表达的是否2M 和 1.5M的包下载时间的差距是否几乎不计?</li>\n</ul>\n<ol start=\"6\">\n<li>从小程序加载流程上来讲，对于首次打开小程序用户，会去下载包，包大会造成下载时间变长（在相同网络条件下）；影响启动耗时的直接因素：<br>● 平台：不同的平台下（安卓、IOS）设备性能、操作系统、框架实现、优化方案存在较大的差异，启动耗时也存在较大的差异。只有分平台比较启动耗时（包括各阶段耗时）才有意义；<br> 1.怎么做到只是针对某个机型去判断?<br> 2.是不是要去处理慢的机型呢? 怎么处理是个问题<br>● 下载比例及大小：代码包下载和更新都会显著影响小程序启动耗时，在其他流程耗时稳定的情况下，下载比例升高会影响大盘启动耗时。<br>● 入口页面：不同页面启动时，根据所在分包的不同，需要下载的代码包数量和大小和代码注入量都存在差异。不同页面渲染耗时也存在差异。<br>● 机型分布：启动耗时和设备性能有较强关联，不同小程序或使用场景用户群体的差异可能导致机型分布的差异，进而影响大盘启动耗时。<br>● 网络环境：网络环境主要影响网络请求的耗时，如小程序信息获取、代码包下载等。<br>间接因素：<br>● 场景&#x2F;访问来源：不同场景下，用户访问的页面不同，新用户比例也有差异，对启动耗时会有一定影响。此外，用户访问的目的性和自身的等待意愿也有差异，也会影响打开率。<br> 1.这里可能存在有些页面分享进来的，但是这个页面其实是不允许直接进入的，可能会造成某些问题导致的耗时<br> 2.进入的页面不是首页，这是一种什么场景?<br>● 首次访问用户比例：用户首次访问小程序时，需要完整的进行小程序信息准备、代码包下载的流程，代码缓存也需要重新生成，启动耗时会比非首次访问高。<br>● 小程序版本更新：小程序版本更新时，用户需要更新小程序信息和代码包，代码缓存也需要重新生成，启动耗时会出现上涨。<br> 1.这个其实就是每次更新版本对启动时长的影响，特别是发布灰度的时候<br> 2.一段时间不发新版本,启动时间会降低。这里其实说明我们登报的人，他存在多次进来看的情况（这个是肯定的）</li>\n</ol>\n",
            "tags": [
                "前端开发",
                "前端性能优化",
                "前端性能优化"
            ]
        },
        {
            "id": "https://pink-png.github.io/Web-Integration/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/",
            "url": "https://pink-png.github.io/Web-Integration/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/",
            "title": "浏览器渲染原理以及优化思路",
            "date_published": "2021-06-25T08:43:00.000Z",
            "content_html": "<h1 id=\"浏览器渲染原理\"><a href=\"#浏览器渲染原理\" class=\"headerlink\" title=\"浏览器渲染原理\"></a>浏览器渲染原理</h1><pre><code class=\"text\">1. 渲染过程：\n解析HTML：浏览器解析HTML代码，构建DOM树。\n解析CSS：浏览器解析CSS样式表，构建CSSOM树。\n构建渲染树：将DOM树和CSSOM树合并成渲染树，该树只包含需要显示元素的信息。\n布局（Layout）：计算每个元素的大小和位置。\n绘制（Paint）：根据计算好的布局信息，将每个元素绘制成屏幕上的像素。\n合成（Composite）：将绘制好的元素按正确的顺序合成到最终的图像上。\n\n2. 阻塞过程：\n脚本阻塞：当浏览器遇到&lt;script&gt;标签或执行JavaScript代码时，会暂停HTML解析和渲染，直到脚本执行完毕。\n样式加载阻塞：如果浏览器遇到外部CSS文件，会等待该文件下载和解析完毕后再继续渲染。\n资源加载阻塞：当浏览器遇到资源文件如图片、字体或其他媒体时，会等待资源下载和加载完毕后再继续渲染。\n\n3. 重绘与汇流：\n重绘（Repaint）：当元素的样式改变，但不影响布局时，浏览器只需要重新绘制元素的可视部分。\n汇流（Reflow）：当布局发生改变，例如改变元素的大小或位置时，浏览器需要重新计算并调整元素的布局和相关元素的位置。\n</code></pre>\n<h1 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h1><pre><code class=\"text\">1. 减少阻塞时间：\n脚本加载优化：将JavaScript脚本放在页面底部，或者使用defer属性将其延迟执行，以免阻塞HTML解析和渲染过程。\n样式加载优化：将CSS样式表放在&lt;head&gt;标签中，避免样式表的加载阻塞页面渲染。\n资源加载优化：使用合适的缓存策略、减小资源文件的大小，以及使用CDN等方式来提高资源加载速度。\n\n2. 最小化重绘与汇流：\n批量修改样式：避免频繁读取和修改单个元素的样式属性，最好使用CSS类进行批量修改，这样可以减少重绘和汇流的次数。\n避免强制同步布局：在修改多个元素的样式时，避免强制同步布局，即尽量将布局相关的修改集中在一起，减少不必要的重绘和汇流。\n\n3.使用现代CSS特性：\n使用CSS动画代替JavaScript动画：CSS动画借助浏览器的硬件加速，性能更高，并且不会阻塞JavaScript主线程。\n使用CSS Grid 和 Flexbox 布局：这些现代的布局方式能够更有效地处理布局，减少重绘和汇流的次数。\n\n4.图片优化：\n使用适当的图片格式：根据图片特性选择合适的图片格式，例如JPEG、PNG、WebP等，以尽量减小文件大小。\n图片懒加载：只在视口范围内加载可见区域的图片，延迟加载其他图片，以提高页面加载速度。\n\n5. 代码优化：\n避免频繁操作DOM：减少对DOM的修改和查询次数，可以使用文档片段（DocumentFragment）来进行批量操作。\n压缩和合并代码：对CSS和JavaScript文件进行压缩和合并，减小文件体积，加快加载速度。\n</code></pre>\n",
            "tags": [
                "前端开发",
                "浏览器",
                "web综合问题"
            ]
        },
        {
            "id": "https://pink-png.github.io/Web-Integration/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/",
            "url": "https://pink-png.github.io/Web-Integration/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/",
            "title": "浏览器缓存机制",
            "date_published": "2021-06-25T08:43:00.000Z",
            "content_html": "<h1 id=\"浏览器缓存机制\"><a href=\"#浏览器缓存机制\" class=\"headerlink\" title=\"浏览器缓存机制\"></a>浏览器缓存机制</h1><p>浏览器缓存机制是指浏览器在处理网页资源时，将一部分资源保存在本地存储中，以便下次请求相同资源时可以快速获取，从而提高网页加载速度和用户体验。以下是常见的浏览器缓存机制：</p>\n<h1 id=\"强缓存\"><a href=\"#强缓存\" class=\"headerlink\" title=\"强缓存\"></a>强缓存</h1><ol>\n<li>浏览器在第一次请求资源时，服务器通过响应头中的Cache-Control或Expires字段返回资源，并将这些信息保存在浏览器缓存中。在下一次请求相同资源时，浏览器会直接从缓存中读取，而不发起请求</li>\n<li>常用的Cache-Control值有：</li>\n</ol>\n<ul>\n<li>public：表示资源可以被所有用户及代理服务器缓存。</li>\n<li>private：表示资源只能被单个用户缓存，不允许代理服务器缓存。</li>\n<li>max-age：表示资源在缓存中的有效期，单位为秒。</li>\n</ul>\n<h1 id=\"协商缓存\"><a href=\"#协商缓存\" class=\"headerlink\" title=\"协商缓存\"></a>协商缓存</h1><ol>\n<li>在资源过期后，浏览器会发送一个带有If-Modified-Since（Last-Modified）或If-None-Match（ETag）字段的请求到服务器，询问该资源是否有更新。如果服务器返回304 Not Modified状态码，则表示资源未发生变化，浏览器会直接从缓存中读取。</li>\n<li>常用的响应头字段有：</li>\n</ol>\n<ul>\n<li>Last-Modified：表示资源的最后修改时间。</li>\n<li>ETag：表示资源的唯一标识符。</li>\n</ul>\n<h1 id=\"离线缓存\"><a href=\"#离线缓存\" class=\"headerlink\" title=\"离线缓存\"></a>离线缓存</h1><ol>\n<li>HTML5提供了离线缓存机制，使用manifest文件来定义需要缓存的资源。浏览器在第一次访问网页时会下载manifest文件并根据文件中的信息缓存相应资源。在之后的访问中，即使处于离线状态，浏览器仍然能够加载并显示已缓存的页面。离线缓存可以提高网页的可访问性和性能。</li>\n</ol>\n<h1 id=\"缓存位置\"><a href=\"#缓存位置\" class=\"headerlink\" title=\"缓存位置\"></a>缓存位置</h1><ol>\n<li><p>内存缓存（Memory Cache）：<br>内存缓存是最快的缓存位置，将资源直接保存在浏览器内存中。<br>内存缓存的读取速度非常快，可以快速响应请求，适用于频繁请求和临时性资源。<br>但是，内存缓存的容量有限，并且在浏览器关闭时会被清空。</p>\n</li>\n<li><p>硬盘缓存（Disk Cache）：<br>硬盘缓存将资源保存在硬盘上，相对于内存缓存来说读取速度较慢，但比重新请求资源要快得多。<br>硬盘缓存可以持久保存资源，并且在浏览器关闭后仍然可用。<br>硬盘缓存的容量相对较大，可以保存更多的资源。</p>\n</li>\n<li><p>服务端缓存：<br>服务端缓存是指将资源保存在服务器端，由服务器返回缓存的资源给浏览器。<br>服务端缓存可以利用类似缓存代理、CDN等方式来提升资源获取速度，减轻服务器的压力。<br>服务端缓存可以根据资源的过期时间或版本号来判断是否返回缓存资源。</p>\n</li>\n<li><p>Service Worker 缓存：<br>Service Worker 是运行在浏览器后台的脚本，可以拦截网络请求并自定义响应。<br>Service Worker 可以将资源保存在本地缓存中，实现离线访问或快速加载。<br>Service Worker 缓存具有灵活性和高度可自定义的特性，适用于离线应用、推送通知等场景。</p>\n</li>\n</ol>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>通过合理设置缓存策略，可以减少对服务器的请求次数，加快网页加载速度，降低网络流量消耗。同时，如果网页内容有更新，通过修改资源的版本号或过期时间等方式来使浏览器重新请求新的资源版本。</p>\n",
            "tags": [
                "前端开发",
                "浏览器",
                "web综合问题"
            ]
        },
        {
            "id": "https://pink-png.github.io/Web-Integration/%E6%B5%8F%E8%A7%88%E5%99%A8%E9%9D%A2%E8%AF%95/",
            "url": "https://pink-png.github.io/Web-Integration/%E6%B5%8F%E8%A7%88%E5%99%A8%E9%9D%A2%E8%AF%95/",
            "title": "web综合问题",
            "date_published": "2021-06-25T08:43:00.000Z",
            "content_html": "<h1 id=\"常见的浏览器内核有哪些？\"><a href=\"#常见的浏览器内核有哪些？\" class=\"headerlink\" title=\"常见的浏览器内核有哪些？\"></a>常见的浏览器内核有哪些？</h1><p>主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。<br>渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。<br>JS引擎则：解析和执行javascript来实现网页的动态效果。<br>最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。<br>常见内核<br>Trident 内核：IE, MaxThon, TT, The World, 360, 搜狗浏览器等。[又称 MSHTML]<br>Gecko 内核：Netscape6 及以上版本，FF, MozillaSuite &#x2F; SeaMonkey 等<br>Presto 内核：Opera7 及以上。 [Opera内核原为：Presto，现为：Blink;]<br>Webkit 内核：Safari, Chrome等。 [ Chrome的：Blink（WebKit 的分支）]</p>\n<h1 id=\"网页前端性能优化的方式有哪些？\"><a href=\"#网页前端性能优化的方式有哪些？\" class=\"headerlink\" title=\"网页前端性能优化的方式有哪些？\"></a>网页前端性能优化的方式有哪些？</h1><p>1.压缩 css, js, 图片<br>2.减少 http 请求次数， 合并 css、js 、合并图片（雪碧图）<br>3.使用 CDN<br>4.减少 dom 元素数量<br>5.图片懒加载<br>6.静态资源另外用无 cookie 的域名<br>7.减少 dom 的访问（缓存 dom）<br>8.巧用事件委托<br>9.样式表置顶、脚本置低</p>\n<h1 id=\"网页从输入网址到渲染完成经历了哪些过程？\"><a href=\"#网页从输入网址到渲染完成经历了哪些过程？\" class=\"headerlink\" title=\"网页从输入网址到渲染完成经历了哪些过程？\"></a>网页从输入网址到渲染完成经历了哪些过程？</h1><p>大致可以分为如下7步：</p>\n<p>输入网址；<br>发送到DNS服务器，并获取域名对应的web服务器对应的ip地址；<br>与web服务器建立TCP连接；<br>浏览器向web服务器发送http请求；<br>web服务器响应请求，并返回指定url的数据（或错误信息，或重定向的新的url地址）；<br>浏览器下载web服务器返回的数据及解析html源文件；<br>生成DOM树，解析css和js，渲染页面，直至显示完成；</p>\n<h1 id=\"线程与进程的区别？\"><a href=\"#线程与进程的区别？\" class=\"headerlink\" title=\"线程与进程的区别？\"></a>线程与进程的区别？</h1><p>一个程序至少有一个进程,一个进程至少有一个线程.<br>线程的划分尺度小于进程，使得多线程程序的并发性高。<br>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。<br>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。<br>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</p>\n<h1 id=\"HTTP常见的状态码？\"><a href=\"#HTTP常见的状态码？\" class=\"headerlink\" title=\"HTTP常见的状态码？\"></a>HTTP常见的状态码？</h1><p>100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息<br>200 OK 正常返回信息<br>201 Created 请求成功并且服务器创建了新的资源<br>202 Accepted 服务器已接受请求，但尚未处理<br>301 Moved Permanently 请求的网页已永久移动到新位置。<br>302 Found 临时性重定向。<br>303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。<br>304 Not Modified 自从上次请求后，请求的网页未修改过。<br>400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。<br>401 Unauthorized 请求未授权。<br>403 Forbidden 禁止访问。<br>404 Not Found 找不到如何与 URI 相匹配的资源。<br>500 Internal Server Error 最常见的服务器端错误。<br>503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。</p>\n<h1 id=\"图片懒加载？\"><a href=\"#图片懒加载？\" class=\"headerlink\" title=\"图片懒加载？\"></a>图片懒加载？</h1><p>当页面滚动的时间被触发 -&gt; 执行加载图片操作 -&gt; 判断图片是否在可视区域内 -&gt; 在，则动态将data-src的值赋予该图片</p>\n<h1 id=\"移动端性能优化？\"><a href=\"#移动端性能优化？\" class=\"headerlink\" title=\"移动端性能优化？\"></a>移动端性能优化？</h1><p>尽量使用css3动画，开启硬件加速<br>适当使用touch时间代替click时间<br>避免使用css3渐变阴影效果<br>可以用transform: translateZ(0) 来开启硬件加速<br>不滥用float。float在渲染时计算量比较大，尽量减少使用<br>不滥用web字体。web字体需要下载，解析，重绘当前页面<br>合理使用requestAnimationFrame动画代替setTimeout<br>css中的属性（css3 transitions、css3 3D transforms、opacity、webGL、video）会触发GUP渲染，耗电</p>\n<h1 id=\"TCP-传输的三次握手、四次挥手策略\"><a href=\"#TCP-传输的三次握手、四次挥手策略\" class=\"headerlink\" title=\"TCP 传输的三次握手、四次挥手策略\"></a>TCP 传输的三次握手、四次挥手策略</h1><p>三次握手：<br>为了准确无误地吧数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送出去后，TCP不会对传送后的情况置之不理，他一定会向对方确认是否送达，握手过程中使用TCP的标志：SYN和ACK<br>发送端首先发送一个带SYN的标志的数据包给对方<br>接收端收到后，回传一个带有SYN&#x2F;ACK标志的数据包以示传达确认信息<br>最后，发送端再回传一个带ACK的标志的数据包，代表“握手”结束<br>如在握手过程中某个阶段莫明中断，TCP协议会再次以相同的顺序发送相同的数据包</p>\n<p>断开一个TCP连接需要“四次挥手”<br>第一次挥手：主动关闭方发送一个FIN，用来关注主动方到被动关闭方的数据传送，也即是主动关闭方告诫被动关闭方：我已经不会再给你发数据了（在FIN包之前发送的数据，如果没有收到对应的ACK确认报文，主动关闭方依然会重发这些数据）。但是，此时主动关闭方还可以接受数据<br>第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号收到序号 +1（与SYN相同，一个 FIN占用一个序号）<br>第三次挥手：被动关闭方发送一个 FIN。用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会给你发送数据了<br>第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手</p>\n<h1 id=\"HTTP-和-HTTPS，为什么HTTPS安全？\"><a href=\"#HTTP-和-HTTPS，为什么HTTPS安全？\" class=\"headerlink\" title=\"HTTP 和 HTTPS，为什么HTTPS安全？\"></a>HTTP 和 HTTPS，为什么HTTPS安全？</h1><p>HTTP协议通常承载与 TCP协议之上，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的HTTPS<br>默认HTTP的端口号为80，HTTPS的端口号为443<br>因为网络请求需要中间有很多的服务器路由的转发，中间的节点都可能篡改信息，而如果使用HTTPS，密钥在你和终点站才有，https之所有说比http安全，是因为他利用ssl&#x2F;tls协议传输。包含证书，流量转发，负载均衡，页面适配，浏览器适配，refer传递等，保障了传输过程的安全性</p>\n<h1 id=\"axios和fetch区别对比\"><a href=\"#axios和fetch区别对比\" class=\"headerlink\" title=\"axios和fetch区别对比\"></a>axios和fetch区别对比</h1><p>axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，本质上也是对原生XHR的封装，只不过它是Promise的实现版本，符合最新的ES规范，它本身具有以下特征</p>\n<p>从浏览器中创建 XMLHttpRequest<br>支持 Promise API<br>客户端支持防止CSRF<br>提供了一些并发请求的接口（重要，方便了很多的操作）<br>从 node.js 创建 http 请求<br>拦截请求和响应<br>转换请求和响应数据<br>取消请求<br>自动转换JSON数据<br>fetch优势：</p>\n<p>语法简洁，更加语义化<br>基于标准 Promise 实现，支持 async&#x2F;await<br>同构方便，使用 isomorphic-fetch<br>更加底层，提供的API丰富（request, response）<br>脱离了XHR，是ES规范里新的实现方式<br>fetch存在问题</p>\n<p>fetch是一个低层次的API，你可以把它考虑成原生的XHR，所以使用起来并不是那么舒服，需要进行封装。<br>fetch只对网络请求报错，对400，500都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。<br>fetch默认不会带cookie，需要添加配置项： fetch(url, {credentials: ‘include’})<br>fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费<br>fetch没有办法原生监测请求的进度，而XHR可以</p>\n",
            "tags": [
                "前端开发",
                "浏览器",
                "web综合问题"
            ]
        },
        {
            "id": "https://pink-png.github.io/Web-Integration/%E8%AF%A6%E8%A7%A3%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E2%BC%8Aurl%E5%88%B0%E6%98%BE%E7%A4%BA%E2%BB%9A%E2%BE%AF/",
            "url": "https://pink-png.github.io/Web-Integration/%E8%AF%A6%E8%A7%A3%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E2%BC%8Aurl%E5%88%B0%E6%98%BE%E7%A4%BA%E2%BB%9A%E2%BE%AF/",
            "title": "从浏览器地址栏输⼊url到显示⻚⾯的步骤",
            "date_published": "2021-06-25T08:43:00.000Z",
            "content_html": "<ol>\n<li>在浏览器地址栏输⼊URL</li>\n<li>浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤</li>\n</ol>\n<ul>\n<li>如果资源未缓存，发起新请求</li>\n<li>如果已缓存，检验是否⾜够新鲜，⾜够新鲜直接提供给客户端，否则与服务器进⾏验证。</li>\n<li>检验新鲜通常有两个HTTP头进⾏控制 Expires 和 Cache-Control ：(  HTTP1.0提供Expires，值为⼀个绝对时间表示缓存新鲜⽇期<br>  HTTP1.1增加了Cache-Control: max-age&#x3D;,值为以秒为单位的最⼤新鲜时间)</li>\n</ul>\n<ol start=\"3\">\n<li>浏览器解析URL获取协议，主机，端⼝，path</li>\n<li>浏览器组装⼀个HTTP（GET）请求报⽂</li>\n<li>浏览器获取主机ip地址，过程如下：</li>\n</ol>\n<ul>\n<li>浏览器缓存:(浏览器会在本地进行DNS缓存，将之前解析过的域名和其对应的IP地址保存起来。当再次请求相同的域名时，浏览器会首先检查本地缓存中是否存在对应的记录)</li>\n<li>本机缓存:(如果在浏览器缓存中找不到域名的IP地址，浏览器将查找操作系统（如Windows、Mac等）的本机DNS缓存。操作系统也会对DNS查询结果进行缓存，以提高性能和减少网络请求)</li>\n<li>hosts⽂件:(如果在本机缓存中没有找到域名的IP地址，系统将查找操作系统的Hosts文件。Hosts文件是一个文本文件，可以手动配置域名和对应的IP地址映射关系)</li>\n<li>路由器缓存:(如果在Hosts文件中找不到域名的IP地址，系统将向路由器发送DNS查询请求。某些路由器会在自身进行DNS缓存，以便快速响应本地网络设备的DNS查询)</li>\n<li>ISP DNS缓存:(如果在路由器缓存中没有找到域名的IP地址，系统将向互联网服务提供商（ISP）的DNS服务器发送DNS查询请求。ISP的DNS服务器也会进行缓存，以提高DNS解析速度和网络访问效率)</li>\n<li>DNS递归查询:(如果在ISP DNS缓存中找不到域名的IP地址，ISP的DNS服务器将发起递归查询。递归查询是指DNS服务器按照一定的顺序向上级DNS服务器发出查询请求，直到找到所需的IP地址或者查询失败。在递归查询过程中，可能会经过多个DNS服务器，这可能导致负载均衡使得每次获得的IP地址可能不一样)（可能存在负载均衡导致每次IP不⼀样）</li>\n</ul>\n<ol start=\"6\">\n<li>打开⼀个socket与⽬标IP地址，端⼝建⽴TCP链接，三次握⼿如下：</li>\n</ol>\n<ul>\n<li>客户端发送⼀个TCP的SYN&#x3D;1，Seq&#x3D;X的包到服务器端⼝</li>\n<li>服务器发回SYN&#x3D;1， ACK&#x3D;X+1， Seq&#x3D;Y的响应包</li>\n<li>客户端发送ACK&#x3D;Y+1， Seq&#x3D;Z</li>\n</ul>\n<ol start=\"7\">\n<li>TCP链接建⽴后发送HTTP请求</li>\n<li>服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使⽤HTTP Host头部判断请求的服务程序</li>\n<li>服务器检查HTTP请求头是否包含缓存验证信息如果验证缓存新鲜，返回304等对应状态码</li>\n<li>处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作</li>\n<li>服务器将响应报⽂通过TCP连接发送回浏览器</li>\n<li>浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重⽤，关闭TCP连接的四<br>次握⼿如下：</li>\n</ol>\n<ul>\n<li>主动⽅发送Fin&#x3D;1， Ack&#x3D;Z， Seq&#x3D; X报⽂</li>\n<li>被动⽅发送ACK&#x3D;X+1， Seq&#x3D;Z报⽂</li>\n<li>被动⽅发送Fin&#x3D;1， ACK&#x3D;X， Seq&#x3D;Y报⽂</li>\n<li>主动⽅发送ACK&#x3D;Y， Seq&#x3D;X报⽂</li>\n</ul>\n<ol start=\"13\">\n<li>浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同</li>\n<li>如果资源可缓存，进⾏缓存</li>\n<li>对响应进⾏解码（例如gzip压缩）</li>\n<li>根据资源类型决定如何处理（假设资源为HTML⽂档）</li>\n<li>解析HTML⽂档，构件DOM树，下载资源，构造CSSOM树，执⾏js脚本，这些操作没有严格的先后顺序，以下分别解释</li>\n<li>构建DOM树：</li>\n</ol>\n<ul>\n<li>Tokenizing：根据HTML规范将字符流解析为标记</li>\n<li>Lexing：词法分析将标记转换为对象并定义属性和规则</li>\n<li>DOM construction：根据HTML标记关系将对象组成DOM树</li>\n</ul>\n<ol start=\"19\">\n<li>解析过程中遇到图⽚、样式表、js⽂件，启动下载</li>\n<li>构建CSSOM树：</li>\n</ol>\n<ul>\n<li>Tokenizing：字符流转换为标记流</li>\n<li>Node：根据标记创建节点</li>\n<li>CSSOM：节点创建CSSOM树</li>\n</ul>\n<ol start=\"21\">\n<li>根据DOM树和CSSOM树构建渲染树 :</li>\n</ol>\n<ul>\n<li>从DOM树的根节点遍历所有可⻅节点，不可⻅节点包括：1） script , meta 这样本身<br>不可⻅的标签。2)被css隐藏的节点，如 display: none</li>\n<li>对每⼀个可⻅节点，找到恰当的CSSOM规则并应⽤</li>\n<li>发布可视节点的内容和计算样式</li>\n</ul>\n<ol start=\"22\">\n<li>js解析如下：</li>\n</ol>\n<ul>\n<li>浏览器创建Document对象并解析HTML，将解析到的元素和⽂本节点添加到⽂档中，此<br>时document.readystate为loading</li>\n<li>HTML解析器遇到没有async和defer的script时，将他们添加到⽂档中，然后执⾏⾏内<br>或外部脚本。这些脚本会同步执⾏，并且在脚本下载和执⾏时解析器会暂停。这样就可<br>以⽤document.write()把⽂本插⼊到输⼊流中。同步脚本经常简单定义函数和注册事件<br>处理程序，他们可以遍历和操作script和他们之前的⽂档内容</li>\n<li>当解析器遇到设置了async属性的script时，开始下载脚本并继续解析⽂档。脚本会在它下载完成后尽快执⾏，但是解析器不会停下来等它下载。异步脚本禁使⽤document.write()，它们可以访问⾃⼰script和之前的⽂档元素</li>\n<li>当⽂档完成解析，document.readState变成interactive</li>\n<li>所有defer脚本会按照在⽂档出现的顺序执⾏，延迟脚本能访问完整⽂档树，禁⽌使⽤document.write()</li>\n<li>浏览器在Document对象上触发DOMContentLoaded事件</li>\n<li>此时⽂档完全解析完成，浏览器可能还在等待如图⽚等内容加载，等这些内容完成载⼊并且所有异步脚本完成载⼊和执⾏，document.readState变complete，window触发load事件</li>\n</ul>\n<ol start=\"23\">\n<li>显示⻚⾯（HTML解析过程中会逐步显示⻚⾯）</li>\n</ol>\n",
            "tags": [
                "前端开发",
                "浏览器",
                "web综合问题"
            ]
        },
        {
            "id": "https://pink-png.github.io/Web-Integration/%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/",
            "url": "https://pink-png.github.io/Web-Integration/%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/",
            "title": "跨域解决方案",
            "date_published": "2021-06-25T08:43:00.000Z",
            "content_html": "<h1 id=\"什么是跨域？\"><a href=\"#什么是跨域？\" class=\"headerlink\" title=\"什么是跨域？\"></a>什么是跨域？</h1><pre><code class=\"text\">在前端领域中，跨域是指浏览器允许向服务器发送跨域请求，从而克服Ajax只能**同源**使用的限制。\n\n什么是同源策略？\n\n**同源策略**是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指&quot;协议+域名+端口&quot;三者相同，即便两个不同的域名指向同一个ip地址，也非同源\n\n同源策略限制以下几种行为：\n\n- Cookie、LocalStorage 和 IndexDB 无法读取\n- DOM和JS对象无法获得\n- AJAX 请求不能发送\n\n举例说明：⽐如⼀个⿊客程序，他利⽤ Iframe 把真正的银⾏登录⻚⾯嵌到他的⻚⾯上，\n当你使⽤真实的⽤户名，密码登录时，他的⻚⾯就可以通过 Javascript 读取到你的表单\n中 input 中的内容，这样⽤户名，密码就轻松到⼿了。\n</code></pre>\n<h1 id=\"JSONP跨域\"><a href=\"#JSONP跨域\" class=\"headerlink\" title=\"JSONP跨域\"></a>JSONP跨域</h1><p><strong>jsonp</strong>的原理就是利用<code>&lt;script&gt;</code>标签没有跨域限制，通过<code>&lt;script&gt;</code>标签src属性，发送带有callback参数的GET请求，服务端将接口返回数据拼凑到callback函数中，返回给浏览器，浏览器解析执行，从而前端拿到callback函数返回的数据。</p>\n<p>1）原生JS实现：</p>\n<pre><code class=\"text\">&lt;script&gt;\n    var script = document.createElement(&#39;script&#39;);\n    script.type = &#39;text/javascript&#39;;\n\n    // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数\n    script.src = &#39;http://www.domain2.com:8080/login?user=admin&amp;callback=handleCallback&#39;;\n    document.head.appendChild(script);\n\n    // 回调执行函数\n    function handleCallback(res) &#123;\n        alert(JSON.stringify(res));\n    &#125;\n &lt;/script&gt;\n</code></pre>\n<p>服务端返回如下（返回时即执行全局函数）：</p>\n<pre><code class=\"text\">handleCallback(&#123;&quot;success&quot;: true, &quot;user&quot;: &quot;admin&quot;&#125;)\n</code></pre>\n<p>2）jquery Ajax实现：</p>\n<pre><code class=\"text\">$.ajax(&#123;\n    url: &#39;http://www.domain2.com:8080/login&#39;,\n    type: &#39;get&#39;,\n    dataType: &#39;jsonp&#39;,  // 请求方式为jsonp\n    jsonpCallback: &quot;handleCallback&quot;,  // 自定义回调函数名\n    data: &#123;&#125;\n&#125;);\n</code></pre>\n<p>3）Vue axios实现：</p>\n<pre><code class=\"text\">this.$http = axios;\nthis.$http.jsonp(&#39;http://www.domain2.com:8080/login&#39;, &#123;\n    params: &#123;&#125;,\n    jsonp: &#39;handleCallback&#39;\n&#125;).then((res) =&gt; &#123;\n    console.log(res); \n&#125;)\n</code></pre>\n<p>后端node.js代码：</p>\n<pre><code class=\"text\">var querystring = require(&#39;querystring&#39;);\nvar http = require(&#39;http&#39;);\nvar server = http.createServer();\n\nserver.on(&#39;request&#39;, function(req, res) &#123;\n    var params = querystring.parse(req.url.split(&#39;?&#39;)[1]);\n    var fn = params.callback;\n\n    // jsonp返回设置\n    res.writeHead(200, &#123; &#39;Content-Type&#39;: &#39;text/javascript&#39; &#125;);\n    res.write(fn + &#39;(&#39; + JSON.stringify(params) + &#39;)&#39;);\n\n    res.end();\n&#125;);\n\nserver.listen(&#39;8080&#39;);\nconsole.log(&#39;Server is running at port 8080...&#39;);\n</code></pre>\n<p>jsonp的缺点：只能发送get一种请求。</p>\n<h1 id=\"跨域资源共享（CORS）（后端配置跨域）\"><a href=\"#跨域资源共享（CORS）（后端配置跨域）\" class=\"headerlink\" title=\"跨域资源共享（CORS）（后端配置跨域）\"></a>跨域资源共享（CORS）（后端配置跨域）</h1><p><strong>CORS</strong>是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。<br>它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。<br>CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。</p>\n<p>浏览器将CORS跨域请求分为简单请求和非简单请求。</p>\n<p>只要同时满足一下两个条件，就属于简单请求</p>\n<p>(1)使用下列方法之一：</p>\n<ul>\n<li>head</li>\n<li>get</li>\n<li>post</li>\n</ul>\n<p>(2)请求的Heder是</p>\n<ul>\n<li>Accept</li>\n<li>Accept-Language</li>\n<li>Content-Language</li>\n<li>Content-Type: 只限于三个值：application&#x2F;x-www-form-urlencoded、multipart&#x2F;form-data、text&#x2F;plain</li>\n</ul>\n<p>不同时满足上面的两个条件，就属于非简单请求。浏览器对这两种的处理，是不一样的。</p>\n<p>简单请求</p>\n<p>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。</p>\n<pre><code class=\"text\">GET /cors HTTP/1.1\nOrigin: http://api.bob.com\nHost: api.alice.com\nAccept-Language: en-US\nConnection: keep-alive\nUser-Agent: Mozilla/5.0...\n</code></pre>\n<p>上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</p>\n<p>CORS请求设置的响应头字段，都以 Access-Control-开头:</p>\n<p><strong>1）Access-Control-Allow-Origin</strong>：必选</p>\n<p>它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。</p>\n<p><strong>2）Access-Control-Allow-Credentials</strong>：可选</p>\n<p>它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。</p>\n<p><strong>3）Access-Control-Expose-Headers</strong>：可选</p>\n<p>CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。</p>\n<p>非简单请求</p>\n<p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application&#x2F;json。非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。</p>\n<p>预检请求</p>\n<p>预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。请求头信息里面，关键字段是Origin，表示请求来自哪个源。除了Origin字段，”预检”请求的头信息包括两个特殊字段。</p>\n<pre><code class=\"text\">OPTIONS /cors HTTP/1.1\nOrigin: http://api.bob.com\nAccess-Control-Request-Method: PUT\nAccess-Control-Request-Headers: X-Custom-Header\nHost: api.alice.com\nAccept-Language: en-US\nConnection: keep-alive\nUser-Agent: Mozilla/5.0..\n</code></pre>\n<p><strong>1）Access-Control-Request-Method</strong>：必选</p>\n<p>用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。</p>\n<p><strong>2）Access-Control-Request-Headers</strong>：可选</p>\n<p>该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。</p>\n<p>预检请求的回应</p>\n<p>服务器收到”预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。</p>\n<p>HTTP回应中，除了关键的是Access-Control-Allow-Origin字段，其他CORS相关字段如下：</p>\n<p><strong>1）Access-Control-Allow-Methods</strong>：必选</p>\n<p>它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。</p>\n<p><strong>2）Access-Control-Allow-Headers</strong></p>\n<p>如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。</p>\n<p><strong>3）Access-Control-Allow-Credentials</strong>：可选</p>\n<p>该字段与简单请求时的含义相同。</p>\n<p><strong>4）Access-Control-Max-Age</strong>：可选</p>\n<p>用来指定本次预检请求的有效期，单位为秒。</p>\n<p>CORS跨域示例</p>\n<p><strong>1）前端设置</strong>：</p>\n<ul>\n<li>原生ajax：</li>\n</ul>\n<pre><code class=\"text\">var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容\n\n// 前端设置是否带cookie\nxhr.withCredentials = true;\n\nxhr.open(&#39;post&#39;, &#39;http://www.domain2.com:8080/login&#39;, true);\nxhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application/x-www-form-urlencoded&#39;);\nxhr.send(&#39;user=admin&#39;);\n\nxhr.onreadystatechange = function() &#123;\n    if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123;\n        alert(xhr.responseText);\n    &#125;\n&#125;;\n</code></pre>\n<ul>\n<li>jquery ajax：</li>\n</ul>\n<pre><code class=\"text\">$.ajax(&#123;\n    ...\n   xhrFields: &#123;\n       withCredentials: true    // 前端设置是否带cookie\n   &#125;,\n   crossDomain: true,   // 会让请求头中包含跨域的额外信息，但不会含cookie\n    ...\n&#125;);\n</code></pre>\n<p><strong>2）服务端设置</strong>：</p>\n<ul>\n<li>nodejs代码</li>\n</ul>\n<pre><code class=\"text\">var http = require(&#39;http&#39;);\nvar server = http.createServer();\nvar qs = require(&#39;querystring&#39;);\n\nserver.on(&#39;request&#39;, function(req, res) &#123;\n    var postData = &#39;&#39;;\n\n    // 数据块接收中\n    req.addListener(&#39;data&#39;, function(chunk) &#123;\n        postData += chunk;\n    &#125;);\n\n    // 数据接收完毕\n    req.addListener(&#39;end&#39;, function() &#123;\n        postData = qs.parse(postData);\n\n        // 跨域后台设置\n        res.writeHead(200, &#123;\n            &#39;Access-Control-Allow-Credentials&#39;: &#39;true&#39;,     // 后端允许发送Cookie\n            &#39;Access-Control-Allow-Origin&#39;: &#39;http://www.domain1.com&#39;,    // 允许访问的域（协议+域名+端口）\n            /* \n             * 此处设置的cookie还是domain2的而非domain1，因为后端也不能跨域写cookie(nginx反向代理可以实现)，\n             * 但只要domain2中写入一次cookie认证，后面的跨域接口都能从domain2中获取cookie，从而实现所有的接口都能跨域访问\n             */\n            &#39;Set-Cookie&#39;: &#39;l=a123456;Path=/;Domain=www.domain2.com;HttpOnly&#39;  // HttpOnly的作用是让js无法读取cookie\n        &#125;);\n\n        res.write(JSON.stringify(postData));\n        res.end();\n    &#125;);\n&#125;);\n\nserver.listen(&#39;8080&#39;);\nconsole.log(&#39;Server is running at port 8080...&#39;);\n</code></pre>\n<h1 id=\"nginx代理跨域\"><a href=\"#nginx代理跨域\" class=\"headerlink\" title=\"nginx代理跨域\"></a>nginx代理跨域</h1><p>nginx代理跨域，实质和CORS跨域原理一样，通过配置文件设置请求响应头Access-Control-Allow-Origin…等字段。</p>\n<p>1）nginx配置解决iconfont跨域</p>\n<p>浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。</p>\n<pre><code class=\"text\">location / &#123;\n  add_header Access-Control-Allow-Origin *;\n&#125;\n</code></pre>\n<p>2）nginx反向代理接口跨域</p>\n<p>跨域问题：同源策略仅是针对浏览器的安全策略。服务器端调用HTTP接口只是使用HTTP协议，不需要同源策略，也就不存在跨域问题。</p>\n<p>实现思路：通过Nginx配置一个代理服务器域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域访问。</p>\n<p>nginx具体配置：</p>\n<pre><code class=\"text\">#proxy服务器\nserver &#123;\n    listen       81;\n    server_name  www.domain1.com;\n\n    location / &#123;\n        proxy_pass   http://www.domain2.com:8080;  #反向代理\n        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名\n        index  index.html index.htm;\n\n        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用\n        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*\n        add_header Access-Control-Allow-Credentials true;\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"nodejs中间件代理跨域\"><a href=\"#nodejs中间件代理跨域\" class=\"headerlink\" title=\"nodejs中间件代理跨域\"></a>nodejs中间件代理跨域</h1><p>node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。</p>\n<p><strong>1）非vue框架的跨域</strong></p>\n<p>使用node + express + http-proxy-middleware搭建一个proxy服务器。</p>\n<ul>\n<li>前端代码：</li>\n</ul>\n<pre><code class=\"text\">var xhr = new XMLHttpRequest();\n\n// 前端开关：浏览器是否读写cookie\nxhr.withCredentials = true;\n\n// 访问http-proxy-middleware代理服务器\nxhr.open(&#39;get&#39;, &#39;http://www.domain1.com:3000/login?user=admin&#39;, true);\nxhr.send();\n</code></pre>\n<ul>\n<li>中间件服务器代码：</li>\n</ul>\n<pre><code class=\"text\">var express = require(&#39;express&#39;);\nvar proxy = require(&#39;http-proxy-middleware&#39;);\nvar app = express();\n\napp.use(&#39;/&#39;, proxy(&#123;\n    // 代理跨域目标接口\n    target: &#39;http://www.domain2.com:8080&#39;,\n    changeOrigin: true,\n\n    // 修改响应头信息，实现跨域并允许带cookie\n    onProxyRes: function(proxyRes, req, res) &#123;\n        res.header(&#39;Access-Control-Allow-Origin&#39;, &#39;http://www.domain1.com&#39;);\n        res.header(&#39;Access-Control-Allow-Credentials&#39;, &#39;true&#39;);\n    &#125;,\n\n    // 修改响应信息中的cookie域名\n    cookieDomainRewrite: &#39;www.domain1.com&#39;  // 可以为false，表示不修改\n&#125;));\n\napp.listen(3000);\nconsole.log(&#39;Proxy server is listen at port 3000...&#39;);\n</code></pre>\n<p><strong>2）vue框架的跨域</strong></p>\n<p>node + vue + webpack + webpack-dev-server搭建的项目，跨域请求接口，直接修改webpack.config.js配置。开发环境下，vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域。</p>\n<p>webpack.config.js部分配置：</p>\n<pre><code class=\"text\">module.exports = &#123;\n    entry: &#123;&#125;,\n    module: &#123;&#125;,\n    ...\n    devServer: &#123;\n        historyApiFallback: true,\n        proxy: [&#123;\n            context: &#39;/login&#39;,\n            target: &#39;http://www.domain2.com:8080&#39;,  // 代理跨域目标接口\n            changeOrigin: true,\n            secure: false,  // 当代理某些https服务报错时用\n            cookieDomainRewrite: &#39;www.domain1.com&#39;  // 可以为false，表示不修改\n        &#125;],\n        noInfo: true\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"document-domain-iframe跨域\"><a href=\"#document-domain-iframe跨域\" class=\"headerlink\" title=\"document.domain + iframe跨域\"></a>document.domain + iframe跨域</h1><p>此方案仅限主域相同，子域不同的跨域应用场景。实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。</p>\n<p>1）父窗口：(<span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHA6Ly93d3cuZG9tYWluLmNvbS9hLmh0bWw=\">http://www.domain.com/a.html</span>)</p>\n<pre><code class=\"text\">&lt;iframe id=&quot;iframe&quot; src=&quot;http://child.domain.com/b.html&quot;&gt;&lt;/iframe&gt;\n&lt;script&gt;\n    document.domain = &#39;domain.com&#39;;\n    var user = &#39;admin&#39;;\n&lt;/script&gt;\n</code></pre>\n<p>1）子窗口：(<span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHA6Ly9jaGlsZC5kb21haW4uY29tL2EuaHRtbA==\">http://child.domain.com/a.html</span>)</p>\n<pre><code class=\"text\">&lt;script&gt;\n    document.domain = &#39;domain.com&#39;;\n    // 获取父窗口中变量\n    console.log(&#39;get js data from parent ---&gt; &#39; + window.parent.user);\n&lt;/script&gt;\n</code></pre>\n<h1 id=\"location-hash-iframe跨域\"><a href=\"#location-hash-iframe跨域\" class=\"headerlink\" title=\"location.hash + iframe跨域\"></a>location.hash + iframe跨域</h1><p>实现原理： a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。</p>\n<p>具体实现：A域：a.html -&gt; B域：b.html -&gt; A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。</p>\n<p>1）a.html：(<span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHA6Ly93d3cuZG9tYWluMS5jb20vYS5odG1s\">http://www.domain1.com/a.html</span>)</p>\n<pre><code class=\"text\">&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain2.com/b.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;\n&lt;script&gt;\n    var iframe = document.getElementById(&#39;iframe&#39;);\n\n    // 向b.html传hash值\n    setTimeout(function() &#123;\n        iframe.src = iframe.src + &#39;#user=admin&#39;;\n    &#125;, 1000);\n    \n    // 开放给同域c.html的回调方法\n    function onCallback(res) &#123;\n        alert(&#39;data from c.html ---&gt; &#39; + res);\n    &#125;\n&lt;/script&gt;\n</code></pre>\n<p>2）b.html：(<span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHA6Ly93d3cuZG9tYWluMi5jb20vYi5odG1s\">http://www.domain2.com/b.html</span>)</p>\n<pre><code class=\"text\">&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain1.com/c.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;\n&lt;script&gt;\n    var iframe = document.getElementById(&#39;iframe&#39;);\n\n    // 监听a.html传来的hash值，再传给c.html\n    window.onhashchange = function () &#123;\n        iframe.src = iframe.src + location.hash;\n    &#125;;\n&lt;/script&gt;\n</code></pre>\n<p>3）c.html：(<span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHA6Ly93d3cuZG9tYWluMS5jb20vYy5odG1s\">http://www.domain1.com/c.html</span>)</p>\n<pre><code class=\"text\">&lt;script&gt;\n    // 监听b.html传来的hash值\n    window.onhashchange = function () &#123;\n        // 再通过操作同域a.html的js回调，将结果传回\n        window.parent.parent.onCallback(&#39;hello: &#39; + location.hash.replace(&#39;#user=&#39;, &#39;&#39;));\n    &#125;;\n&lt;/script&gt;\n</code></pre>\n<h1 id=\"window-name-iframe跨域\"><a href=\"#window-name-iframe跨域\" class=\"headerlink\" title=\"window.name + iframe跨域\"></a>window.name + iframe跨域</h1><p>window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。</p>\n<p>1）a.html：(<span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHA6Ly93d3cuZG9tYWluMS5jb20vYS5odG1s\">http://www.domain1.com/a.html</span>)</p>\n<pre><code class=\"text\">var proxy = function(url, callback) &#123;\n    var state = 0;\n    var iframe = document.createElement(&#39;iframe&#39;);\n\n    // 加载跨域页面\n    iframe.src = url;\n\n    // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name\n    iframe.onload = function() &#123;\n        if (state === 1) &#123;\n            // 第2次onload(同域proxy页)成功后，读取同域window.name中数据\n            callback(iframe.contentWindow.name);\n            destoryFrame();\n\n        &#125; else if (state === 0) &#123;\n            // 第1次onload(跨域页)成功后，切换到同域代理页面\n            iframe.contentWindow.location = &#39;http://www.domain1.com/proxy.html&#39;;\n            state = 1;\n        &#125;\n    &#125;;\n\n    document.body.appendChild(iframe);\n\n    // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）\n    function destoryFrame() &#123;\n        iframe.contentWindow.document.write(&#39;&#39;);\n        iframe.contentWindow.close();\n        document.body.removeChild(iframe);\n    &#125;\n&#125;;\n\n// 请求跨域b页面数据\nproxy(&#39;http://www.domain2.com/b.html&#39;, function(data)&#123;\n    alert(data);\n&#125;);\n</code></pre>\n<p>2）proxy.html：(<span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHA6Ly93d3cuZG9tYWluMS5jb20vcHJveHkuaHRtbA==\">http://www.domain1.com/proxy.html</span>)</p>\n<p>中间代理页，与a.html同域，内容为空即可。</p>\n<p>3）b.html：(<span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHA6Ly93d3cuZG9tYWluMi5jb20vYi5odG1s\">http://www.domain2.com/b.html</span>)</p>\n<pre><code class=\"text\">&lt;script&gt;\n    window.name = &#39;This is domain2 data!&#39;;\n&lt;/script&gt;\n</code></pre>\n<p>通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p>\n<h1 id=\"postMessage跨域\"><a href=\"#postMessage跨域\" class=\"headerlink\" title=\"postMessage跨域\"></a>postMessage跨域</h1><p>postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：</p>\n<ul>\n<li>页面和其打开的新窗口的数据传递</li>\n<li>多窗口之间消息传递</li>\n<li>页面与嵌套的iframe消息传递</li>\n<li>上面三个场景的跨域数据传递</li>\n</ul>\n<p>用法：postMessage(data,origin)方法接受两个参数：</p>\n<ul>\n<li><strong>data</strong>： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。</li>\n<li><strong>origin</strong>： 协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”&#x2F;“。</li>\n</ul>\n<p>1）a.html：(<span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHA6Ly93d3cuZG9tYWluMS5jb20vYS5odG1s\">http://www.domain1.com/a.html</span>)</p>\n<pre><code class=\"text\">&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain2.com/b.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;\n&lt;script&gt;       \n    var iframe = document.getElementById(&#39;iframe&#39;);\n    iframe.onload = function() &#123;\n        var data = &#123;\n            name: &#39;aym&#39;\n        &#125;;\n        // 向domain2传送跨域数据\n        iframe.contentWindow.postMessage(JSON.stringify(data), &#39;http://www.domain2.com&#39;);\n    &#125;;\n\n    // 接受domain2返回数据\n    window.addEventListener(&#39;message&#39;, function(e) &#123;\n        alert(&#39;data from domain2 ---&gt; &#39; + e.data);\n    &#125;, false);\n&lt;/script&gt;\n</code></pre>\n<p>2）b.html：(<span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHA6Ly93d3cuZG9tYWluMi5jb20vYi5odG1s\">http://www.domain2.com/b.html</span>)</p>\n<pre><code class=\"text\">&lt;script&gt;\n    // 接收domain1的数据\n    window.addEventListener(&#39;message&#39;, function(e) &#123;\n        alert(&#39;data from domain1 ---&gt; &#39; + e.data);\n\n        var data = JSON.parse(e.data);\n        if (data) &#123;\n            data.number = 16;\n\n            // 处理后再发回domain1\n            window.parent.postMessage(JSON.stringify(data), &#39;http://www.domain1.com&#39;);\n        &#125;\n    &#125;, false);\n&lt;/script&gt;\n</code></pre>\n<h1 id=\"WebSocket协议跨域\"><a href=\"#WebSocket协议跨域\" class=\"headerlink\" title=\"WebSocket协议跨域\"></a>WebSocket协议跨域</h1><p>WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。<br>原生WebSocket API使用起来不太方便，我们使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHA6Ly9Tb2NrZXQuaW8=\">http://Socket.io</span>，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。</p>\n<p>1）前端代码：</p>\n<pre><code class=\"text\">&lt;div&gt;user input：&lt;input type=&quot;text&quot;&gt;&lt;/div&gt;\n&lt;script src=&quot;https://cdn.bootcss.com/socket.io/2.2.0/socket.io.js&quot;&gt;&lt;/script&gt;\n&lt;script&gt;\nvar socket = io(&#39;http://www.domain2.com:8080&#39;);\n\n// 连接成功处理\nsocket.on(&#39;connect&#39;, function() &#123;\n    // 监听服务端消息\n    socket.on(&#39;message&#39;, function(msg) &#123;\n        console.log(&#39;data from server: ---&gt; &#39; + msg); \n    &#125;);\n\n    // 监听服务端关闭\n    socket.on(&#39;disconnect&#39;, function() &#123; \n        console.log(&#39;Server socket has closed.&#39;); \n    &#125;);\n&#125;);\n\ndocument.getElementsByTagName(&#39;input&#39;)[0].onblur = function() &#123;\n    socket.send(this.value);\n&#125;;\n&lt;/script&gt;\n</code></pre>\n<p>2）Nodejs socket后台：</p>\n<pre><code class=\"text\">var http = require(&#39;http&#39;);\nvar socket = require(&#39;socket.io&#39;);\n\n// 启http服务\nvar server = http.createServer(function(req, res) &#123;\n    res.writeHead(200, &#123;\n        &#39;Content-type&#39;: &#39;text/html&#39;\n    &#125;);\n    res.end();\n&#125;);\n\nserver.listen(&#39;8080&#39;);\nconsole.log(&#39;Server is running at port 8080...&#39;);\n\n// 监听socket连接\nsocket.listen(server).on(&#39;connection&#39;, function(client) &#123;\n    // 接收信息\n    client.on(&#39;message&#39;, function(msg) &#123;\n        client.send(&#39;hello：&#39; + msg);\n        console.log(&#39;data from client: ---&gt; &#39; + msg);\n    &#125;);\n\n    // 断开处理\n    client.on(&#39;disconnect&#39;, function() &#123;\n        console.log(&#39;Client socket has closed.&#39;); \n    &#125;);\n&#125;);\n</code></pre>\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><pre><code class=\"text\">以上就是9种常见的跨域解决方案，jsonp（只支持get请求，支持老的IE浏览器）适合加载不同域名的js、css，img等静态资源；CORS（支持所有类型的HTTP请求，但浏览器IE10以下不支持）适合做ajax各种跨域请求；Nginx代理跨域和nodejs中间件跨域原理都相似，都是搭建一个服务器，直接在服务器端请求HTTP接口，这适合前后端分离的前端项目调后端接口。document.domain+iframe适合主域名相同，子域名不同的跨域请求。postMessage、websocket都是HTML5新特性，兼容性不是很好，只适用于主流浏览器和IE10+\n</code></pre>\n",
            "tags": [
                "前端开发",
                "跨域",
                "web综合问题"
            ]
        }
    ]
}